head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	95.10.13.22.57.15;	author jbev;	state Exp;
branches;
next	;


desc
@initial file check in.
@


1.1
log
@Initial revision
@
text
@*MPX-32 NBCAT (3.4.0.05)         MPX-32 NBC 1.2.0       HEADER  CATL.S
*MPX-32 NBCAT (3.4.0.05)         MPX-32 NBC 1.1.0       HEADER  CATL.S
************************************************************************
*                                                                      *
*                       RESTRICTED RIGHTS                              *
*                       -----------------                              *
*   INFORMATION CONTAINED HEREIN IS PROPRIETERY TO ENCORE COMPUTER     *
*   CORPORATION AND/OR ITS SUPPLIERS, AND ITS USE,                     *
*   DISCLOSURE, OR DUPLICATION IS SUBJECT TO THE RESTRICTIONS STATED   *
*   IN THE ENCORE COMPUTER CORPORATION LICENSE AGREEMENT               *
*   OR THE APPROPRIATE THIRD-PARTY SUBLICENSE AGREEMENT.  INFORMATION  *
*   IS PROVIDED TO GOVERNMENT CUSTOMERS WITH RESTRICTED RIGHTS AS      *
*   DESCRIBED IN DAR 7-104.9A.                                         *
*                                                                      *
************************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
************************************************************************
*        PROGRAM   CATALOG         CATALOG.R3.4.0.04               CAID
         PROGRAM   NBCAT           CATALOG.R3.4.0.05               CAID
         M.VRSION
* NOTE!! THE PROGRAM DIRECTIVE SHOULD BE UPDATED FOR EACH VERSION/CUT.
*        THE 'R' NUMBER FOR THE OUTPUT SHOULD ALSO BE UPDATED.
*
*********************************************************************
         LIST      NODATA,NOREP,NONG,NOMAC
         M.EQUS
         M.TBLS
*                                                               ELFC-31
*        MACROS FOR BUILDING LFC TABLE USED IN LFC SUBSTITUTION ELFC-31
*                                                               ELFC-31
*        UTL:LFC - BUILDS LFC SUBSECTIONS OF TABLE ENTRIES      ELFC-31
*                                                               ELFC-31
UTL:LFC  DEFM      1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16       ELFC-31
UTL:LCT  SET       0                                            ELFC-31
         IFP       %1,N2           DETERMINE NUMBER OF LFC'S    ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N2       IFP       %2,N3                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N3       IFP       %3,N4                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N4       IFP       %4,N5                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N5       IFP       %5,N6                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N6       IFP       %6,N7                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N7       IFP       %7,N8                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N8       IFP       %8,N9                                        ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N9       IFP       %9,N10                                       ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N10      IFP       %10,N11                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N11      IFP       %11,N12                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N12      IFP       %12,N13                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N13      IFP       %13,N14                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N14      IFP       %14,N15                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N15      IFP       %15,N16                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N16      IFP       %16,N17                                      ELFC-31
UTL:LCT  SET       UTL:LCT+1                                    ELFC-31
N17      ANOP                                                   ELFC-31
*                                                               ELFC-31
*   GENERATE TABLE DATA - NUMBER OF LFC'S FOLLOWED BY THE LFC   ELFC-31
*   STRINGS.                                                    ELFC-31
*                                                               ELFC-31
         GEN       24/0,8/UTL:LCT*1W                            ELFC-31
         IFP       %1,G2                                        ELFC-31
         GEN       8/0,24/C'%1'                                 ELFC-31
G2       IFP       %2,G3                                        ELFC-31
         GEN       8/0,24/C'%2'                                 ELFC-31
G3       IFP       %3,G4                                        ELFC-31
         GEN       8/0,24/C'%3'                                 ELFC-31
G4       IFP       %4,G5                                        ELFC-31
         GEN       8/0,24/C'%4'                                 ELFC-31
G5       IFP       %5,G6                                        ELFC-31
         GEN       8/0,24/C'%5'                                 ELFC-31
G6       IFP       %6,G7                                        ELFC-31
         GEN       8/0,24/C'%6'                                 ELFC-31
G7       IFP       %7,G8                                        ELFC-31
         GEN       8/0,24/C'%7'                                 ELFC-31
G8       IFP       %8,G9                                        ELFC-31
         GEN       8/0,24/C'%8'                                 ELFC-31
G9       IFP       %9,G10                                       ELFC-31
         GEN       8/0,24/C'%9'                                 ELFC-31
G10      IFP       %10,G11                                      ELFC-31
         GEN       8/0,24/C'%10'                                ELFC-31
G11      IFP       %11,G12                                      ELFC-31
         GEN       8/0,24/C'%11'                                ELFC-31
G12      IFP       %12,G13                                      ELFC-31
         GEN       8/0,24/C'%12'                                ELFC-31
G13      IFP       %13,G14                                      ELFC-31
         GEN       8/0,24/C'%13'                                ELFC-31
G14      IFP       %14,G15                                      ELFC-31
         GEN       8/0,24/C'%14'                                ELFC-31
G15      IFP       %15,G16                                      ELFC-31
         GEN       8/0,24/C'%15'                                ELFC-31
G16      IFP       %16,G17                                      ELFC-31
         GEN       8/0,24/C'%16'                                ELFC-31
G17      ANOP                                                   ELFC-31
         ENDM                                                   ELFC-31
*                                                               ELFC-31
*        UTL:REF1 - BUILDS LFC REFERENCE SUBSECTION OF TABLE    ELFC-31
*                   ENTRIES.                                    ELFC-31
*                                                               ELFC-31
UTL:REF1 DEFM      1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16       ELFC-31
UTL:RCT1 SET       0                                            ELFC-31
         IFP       %1,N2           DETERMINE NUM. OF REFERENCES ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N2       IFP       %2,N3                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N3       IFP       %3,N4                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N4       IFP       %4,N5                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N5       IFP       %5,N6                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N6       IFP       %6,N7                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N7       IFP       %7,N8                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N8       IFP       %8,N9                                        ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N9       IFP       %9,N10                                       ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N10      IFP       %10,N11                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N11      IFP       %11,N12                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N12      IFP       %12,N13                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N13      IFP       %13,N14                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N14      IFP       %14,N15                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N15      IFP       %15,N16                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N16      IFP       %16,N17                                      ELFC-31
UTL:RCT1 SET       UTL:RCT1+1                                   ELFC-31
N17      ANOP                                                   ELFC-31
*                                                               ELFC-31
*   GENERATE TABLE DATA - NUMBER OF REFERENCE ADDRESSES         ELFC-31
*   FOLLOWED BY REFERENCE ADDRESSES.                            ELFC-31
*                                                               ELFC-31
         GEN       24/0,8/UTL:RCT1*1W                           ELFC-31
         IFP       %1,G2                                        ELFC-31
         ACW       %1                                           ELFC-31
G2       IFP       %2,G3                                        ELFC-31
         ACW       %2                                           ELFC-31
G3       IFP       %3,G4                                        ELFC-31
         ACW       %3                                           ELFC-31
G4       IFP       %4,G5                                        ELFC-31
         ACW       %4                                           ELFC-31
G5       IFP       %5,G6                                        ELFC-31
         ACW       %5                                           ELFC-31
G6       IFP       %6,G7                                        ELFC-31
         ACW       %6                                           ELFC-31
G7       IFP       %7,G8                                        ELFC-31
         ACW       %7                                           ELFC-31
G8       IFP       %8,G9                                        ELFC-31
         ACW       %8                                           ELFC-31
G9       IFP       %9,G10                                       ELFC-31
         ACW       %9                                           ELFC-31
G10      IFP       %10,G11                                      ELFC-31
         ACW       %10                                          ELFC-31
G11      IFP       %11,G12                                      ELFC-31
         ACW       %11                                          ELFC-31
G12      IFP       %12,G13                                      ELFC-31
         ACW       %12                                          ELFC-31
G13      IFP       %13,G14                                      ELFC-31
         ACW       %13                                          ELFC-31
G14      IFP       %14,G15                                      ELFC-31
         ACW       %14                                          ELFC-31
G15      IFP       %15,G16                                      ELFC-31
         ACW       %15                                          ELFC-31
G16      IFP       %16,G17                                      ELFC-31
         ACW       %16                                          ELFC-31
G17      ANOP                                                   ELFC-31
         ENDM                                                   ELFC-31
*                                                               ELFC-31
*        UTL:REF2 - BUILDS LFC 'C' STRING REFERENCE SUBSECTION  ELFC-31
*                   OF LFC TABLE ENTRIES                        ELFC-31
*                                                               ELFC-31
UTL:REF2 DEFM      1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16       ELFC-31
UTL:RCT2 SET       0                                            ELFC-31
         IFP       %1,N2           DETERMINE NUM. OF REFERENCES ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N2       IFP       %2,N3                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N3       IFP       %3,N4                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N4       IFP       %4,N5                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N5       IFP       %5,N6                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N6       IFP       %6,N7                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N7       IFP       %7,N8                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N8       IFP       %8,N9                                        ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N9       IFP       %9,N10                                       ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N10      IFP       %10,N11                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N11      IFP       %11,N12                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N12      IFP       %12,N13                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N13      IFP       %13,N14                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N14      IFP       %14,N15                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N15      IFP       %15,N16                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N16      IFP       %16,N17                                      ELFC-31
UTL:RCT2 SET       UTL:RCT2+1                                   ELFC-31
N17      ANOP                                                   ELFC-31
*                                                               ELFC-31
*   GENERATE TABLE DATA - NUMBER OF REFERENCE ADDRESSES         ELFC-31
*   FOLLOWED BY REFERENCE ADDRESSES.                            ELFC-31
*                                                               ELFC-31
         GEN       24/0,8/UTL:RCT2*1W                           ELFC-31
         IFP       %1,G2                                        ELFC-31
         ACW       %1                                           ELFC-31
G2       IFP       %2,G3                                        ELFC-31
         ACW       %2                                           ELFC-31
G3       IFP       %3,G4                                        ELFC-31
         ACW       %3                                           ELFC-31
G4       IFP       %4,G5                                        ELFC-31
         ACW       %4                                           ELFC-31
G5       IFP       %5,G6                                        ELFC-31
         ACW       %5                                           ELFC-31
G6       IFP       %6,G7                                        ELFC-31
         ACW       %6                                           ELFC-31
G7       IFP       %7,G8                                        ELFC-31
         ACW       %7                                           ELFC-31
G8       IFP       %8,G9                                        ELFC-31
         ACW       %8                                           ELFC-31
G9       IFP       %9,G10                                       ELFC-31
         ACW       %9                                           ELFC-31
G10      IFP       %10,G11                                      ELFC-31
         ACW       %10                                          ELFC-31
G11      IFP       %11,G12                                      ELFC-31
         ACW       %11                                          ELFC-31
G12      IFP       %12,G13                                      ELFC-31
         ACW       %12                                          ELFC-31
G13      IFP       %13,G14                                      ELFC-31
         ACW       %13                                          ELFC-31
G14      IFP       %14,G15                                      ELFC-31
         ACW       %14                                          ELFC-31
G15      IFP       %15,G16                                      ELFC-31
         ACW       %15                                          ELFC-31
G16      IFP       %16,G17                                      ELFC-31
         ACW       %16                                          ELFC-31
G17      ANOP                                                   ELFC-31
         ENDM                                                   ELFC-31
*                                                               ELFC-31
         SPACE     3
         DEF       CATSTART        TRANSFER ADDRESS
*
*-----------------------------------------------------------------------
         TITLE     REVISION HISTORY
*
* MARKER  |1.3.21A
*
*   MODIFY SIZE TABLE FOR COMPLEX*16 DBUG SYMBOLS FROM X'16'
*   PER COMMENTS FROM DATAMAX.
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.0  CHANGE HISTORY (SUSTAINING)
*
************************************************************************
*
*        VERSION   3.0.01
*
*        S8700640  04/22/87  5199  ADDED CODE TO CORRECT A      S8700640
*                                  PROBLEM WITH BOUNDING THE    S8700640
*                                  GLOBAL SYMBOL TABLE WHEN IT  S8700640
*                                  IS EXACTLY A SECTOR MULTIPLE S8700640
*                                  IN SIZE. INCLUDING ZERO      S8700640
*                                  ENTRIES.                     S8700640
*
*        S8501481  04/22/87  10032 ADDED CODE TO SUPRESS        S8501481
*                                  FORMATION OF RELOCATION      S8501481
*                                  MATRICES FOR ABSOLUTE        S8501481
*                                  LOAD MODULES.                S8501481
*
*        VERSION   3.0.02
*
*        S8600944  05/12/87  10032 ADDED CODE TO CHECK FOR      S8600944
*                                  VARYING SIZE DECLARATIONS    S8600944
*                                  FOR COMMON BLOCKS. THE       S8600944
*                                  LARGEST DECLARED SIZE IS THE S8600944
*                                  SIZE ALLOCATED. A MESSAGE IS S8600944
*                                  PUT OUT TO THE USER TO MAKE  S8600944
*                                  THEM AWARE OF THIS SITUATION S8600944
*
*        VERSION   3.0.03
*
*        S8700870  06/24/87  10032 CORRECTS PROBLEM WITH        S8700870
*                                  ALLOCATION OF SPACE FOR      S8700870
*                                  INITIALIZED COMMON AS THE    S8700870
*                                  FIRST PIECE OF THE FIRST     S8700870
*                                  PROGRAM ELEMENT OF THE LOAD  S8700870
*                                  MODULE.                      S8700870
*
*        VERSION   3.0.04
*
*        S8701186  07/09/87  5199  CORRECTS PROBLEM WITH        S8701186
*                                  EXCLUDE/INCLUDE/REF TABLE    S8701186
*                                  BOUNDING WHEN THE BUILD/     S8701186
*                                  CATALOG DIRECTIVE IS         S8701186
*                                  FOLLOWED BY "NO" DIRECTIVES  S8701186
*
*        C002-30   07/10/87  10032 COMMENTED OUT CODE ASSOCIATEDC002-30
*                                  WITH THE TSBB AND KEEPNAME   C002-30
*                                  DIRECTIVES. THE PREAMBLE     C002-30
*                                  BITS THAT THESE DIRECTIVES   C002-30
*                                  SET HAVE BEEN REASSIGNED.    C002-30
*                                  THESE DIRECTIVES WERE NEVER  C002-30
*                                  FULLY IMPLEMENTED.           C002-30
*
*        VERSION   3.0.05
*
*        C004-30   07/20/87  10032 CHANGED THE DEFAULT MAP BLOCKC004-30
*                                  SIZE TO 2048 WORDS CONSISTENTC004-30
*                                  WITH CONCEPT/32 USAGE.
*
*        VERSION   3.0.06
*
*        Q003-30   07/28/87  10032 MODIFIED CODE ADDED FOR SPR  Q003-30
*                                  8600944. MESSAGE IS NOW PUT  Q003-30
*                                  OUT USING XST2 ROUTINE WHICH Q003-30
*                                  ELIMINATES NULL (X'00')      Q003-30
*                                  CHARACTERS FROM THE SLO FILE Q003-30
*
*        VERSION   3.0.U01
*
*        C002-U01  09/28/87  10032 FIXED CODE THAT WAS ADDED    C002-U01
*                                  FOR SPR FIX S8600944. COMMON C002-U01
*                                  SIZE DISCREPANCIES WERE NOT  C002-U01
*                                  REPORTED CORRECTLY FOR LOAD  C002-U01
*                                  MODULES WITH OVERLAYS. THIS  C002-U01
*                                  ALSO CAUSED PROBLEMS WITH    C002-U01
*                                  ALLOCATING CERTAIN COMMON    C002-U01
*                                  BLOCKS.                      C002-U01
*
*        C003-U01  09/28/87  10032 ADDED CODE TO CORRECTLY      C003-U01
*                                  BOUND THE LOCAL SYMBOL TABLE C003-U01
*
*        VERSION   3.0.08
*
*        ECSW-30   12/4/87  10032  ADDED ONRA AND OFRA          ECSW-30
*                                  ENVIRONMENT DIRECTIVES. THEY ECSW-30
*                                  ALLOW REALTIME ACCOUNTING    ECSW-30
*                                  TO BE TURNED ON OR OFF AT    ECSW-30
*                                  THE TASK LEVEL. THIS CODE IS ECSW-30
*                                  ASSOCIATED WITH THE IMPROVED ECSW-30
*                                  CONTEXT SWITCH LOGIC IN      ECSW-30
*                                  H.EXEC AND H.TAMM.           ECSW-30
*
*        C008-30   12/11/87 10032  RE-ENABLED TSBB AND KEEPNAME C008-30
*                                  ENVIRONMENT DIRECTIVE OPTIONSC008-30
*                                  NEW BITS IN THE PREAMBLE     C008-30
*                                  WERE ASSIGNED AND THESE      C008-30
*                                  OPTIONS ARE NOW FULLY        C008-30
*                                  IMPLEMENTED.                 C008-30
*
*        VERSION   3.0.09
*
*        EOBJ-30                   OBJECT CODE PROCESSING FOR   EOBJ-30
*                                  NEW OBJECT FORMAT. THIS      EOBJ-30
*                                  MODIFICATION ALSO FIXES SPR  EOBJ-30
*                                  88000022.                    EOBJ-30
*
*
*        S8702103  02/05/88  10032 COMMENTED OUT CODE ASSOCIATEDS8702103
*                                  WITH PROCESSING THE PASSWORD S8702103
*                                  FIELD IN THE ASSIGN1 DIRECT- S8702103
*                                  IVE. THE PASSWORD FIELD IS   S8702103
*                                  NOW TRULY IGNORED AS THE     S8702103
*                                  UTILITIES REFERENCE MANUAL   S8702103
*                                  STATES.                      S8702103
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.1 CHANGE HISTORY (SUSTAINING)
*
************************************************************************
*
*        VERSION   3.1.01
*
*        S880337   06/28/88  10032 ADDED CODE TO THE XDIRLD     S880337
*                                  ROUTINE TO DETERMINE IF AN   S880337
*                                  INITIALIZED SUBROUTINE       S880337
*                                  LIBRARY IS EMPTY OR NOT.     S880337
*                                  THE "EMPTY DIRECTORY"        S880337
*                                  WARNING MESSAGE IS NOW PUT   S880337
*                                  OUT FOR INITIALIZED BUT      S880337
*                                  EMPTY DIRECTORIES.           S880337
*
*        S880176   08/04/88  10032 CODE ADDED TO XGETDP ROUTINE S880176
*                                  TO ENSURE VALID LFC'S ARE    S880176
*                                  BEING USED WHEN READS ARE    S880176
*                                  PERFORMED ON DATAPOOL        S880176
*                                  DICTIONARIES.                S880176
*
*        VERSION   3.1.02
*
*        ELFC-31   09/07/88  10032 CODE ADDED TO SUPPORT        ELFC-31
*                                  CONSISTENT LFC'S.            ELFC-31
*
*        VERSION   3.1.03
*
*        S881693   10/03/88  10032 CODE ADDED TO M2SYMB ROUTINE S881693
*                                  TO CORRECTLY GENERATE SYMBOL S881693
*                                  ADDRESSES FOR CHARACTER TYPE S881693
*                                  VARIABLES.                   S881693
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.2 CHANGE HISTORY (SUSTAINING)
*
************************************************************************
*
*        VERSION   3.2.01
*
*        ELST-32   05/02/89  10032 CODE ADDED TO GENERATE 2.5MB ELST-32
*                                  SEGMENTED TASKS.             ELST-32
*
*        VERSION   3.2.02
*
*        EAID-32   05/31/89        CODE ADDED TO SUPPORT THE    EAID-32
*                                  AID DEBUGGER.                EAID-32
*
*        ETSA-32   06/07/89  10032 ADDED TSA AND NOTSA KEYWORDS ETSA-32
*                                  TO EXTDMPX DIRECTIVE TO      ETSA-32
*                                  ALLOW PLACEMENT OF TSA IN    ETSA-32
*                                  EXTENDED MEMORY.             ETSA-32
*
*        EOUT-32   06/07/89  10032 ADDED MAPOUT AND NOMAPOUT    EOUT-32
*                                  KEYWORDS TO THE ENVIRONMENT  EOUT-32
*                                  DIRECTIVE TO ALLOW TASK      EOUT-32
*                                  CONTROL OVER THE MAPPING IN  EOUT-32
*                                  OF MPX-32.                   EOUT-32
*
*        EAID-32B  06/08/89  10032 ADDITIONAL CODE ADDED FOR    EAID-32B
*                                  AID COMPATABILITY. FOR       EAID-32B
*                                  SECTIONED TASKS, TWO PROGRAM EAID-32B
*                                  DEFINITION SYMBOL TABLE RECS EAID-32B
*                                  ARE PRODUCED. ONE FOR THE    EAID-32B
*                                  DSECT ORIGIN AND ONE FOR THE EAID-32B
*                                  CSECT ORIGIN. ALSO, THE FLAG EAID-32B
*                                  BITS ARE NO LONGER CLEARED   EAID-32B
*                                  WHEN THE SOURCE SECTOR ADDR. EAID-32B
*                                  IS SAVED INTO THE DEBUG      EAID-32B
*                                  SYMBOL TABLE RECORD.         EAID-32B
*
*        VERSION   3.2.03
*
*        EAID-32C  07/03/89  10032 CORRECTIONS MADE TO CODE     EAID-32C
*                                  ADDED FOR AID DEBUGGER       EAID-32C
*                                  SUPPORT. THE CSECT ORIGIN    EAID-32C
*                                  RECORD IS NO LONGER PUT OUT  EAID-32C
*                                  AS A PROGRAM ENTRY RECORD.   EAID-32C
*                                  THE ORIGIN ADDRESS IS NO     EAID-32C
*                                  LONGER DOUBLE BIASED WHEN    EAID-32C
*                                  USING EXPLICITLY SECTIONED   EAID-32C
*                                  OBJECT CODE.                 EAID-32C
*
*        PR10651   07/05/89  10032 THE .5 MB WARNING MESSAGE IS PR10651
*                                  ONLY OUTPUT WHEN THERE IS A  PR10651
*                                  MIXTURE OF PURELY AND NON-   PR10651
*                                  PURELY SECTIONED OBJECT AND  PR10651
*                                  OPTION 6 (SET SIZE) IS NOT   PR10651
*                                  SPECIFIED.                   PR10651
*
*        VERSION   3.2.04
*
*        ENCD-32   06/21/89  10032 IMPLEMENTATION OF NEW        ENCD-32
*                                  CATALOG DIRECTIVES : SET,    ENCD-32
*                                  OBJECT,LIBRARY,DIRECTORY     ENCD-32
*                                  AND PROGRAM XXX FROM FILENAM ENCD-32
*                                  ALL OBJECT CODE READ IN      ENCD-32
*                                  DURING PASS A IS NOW WRITTEN ENCD-32
*                                  TO AN OBJECT CODE TEMPORARY  ENCD-32
*                                  FILE. DURING PASS B THE OBJ  ENCD-32
*                                  CODE IS READ FROM THIS TEMP  ENCD-32
*                                  FILE.                        ENCD-32
*
*        VERSION   3.2.05
*
*        PR10705   08/04/89  10032 CORRECTIONS MADE TO CODE     PR10705
*                                  FOR TEMPORARY OBJECT CODE    PR10705
*                                  FILE SUPPORT.                PR10705
*
*        VERSION   3.2.06
*
*        PR10746   08/09/89  10032 MOVED CODE TO REWIND OBJECT  PR10746
*                                  CODE TEMP FILE. PREVIOUS     PR10746
*                                  POSITION CAUSED ERRORS WHEN  PR10746
*                                  CATALOGING A LOAD MODULE     PR10746
*                                  WITH OVERLAYS.               PR10746
*
*        ELST-32B  08/09/89  10032 CORRECTIONS MADE TO          ELST-32B
*                                  STINGBACK LIST ROUTINE FOR   ELST-32B
*                                  PROCESSING 2.5 MB TASKS      ELST-32B
*
*        PR10768   08/15/89  10032 CORRECTIONS MADE TO SET      PR10768
*                                  DIRECTIVE PROCESSOR. OPTION  PR10768
*                                  KEYWORDS SIZE AND NOSIZE     PR10768
*                                  WERE REVERSED.               PR10768
*
*        PR10774   08/15/89  10032 CORRECTIONS MADE TO THE      PR10774
*                                  DIRECTORY DIRECTIVE ROUTINE. PR10774
*                                  PREVIOUSLY, THE LFC TABLE    PR10774
*                                  ENTRIES FOR DIRECTORIES WERE PR10774
*                                  NOT SET UP PROPERLY.         PR10774
*
*        PR10775   08/15/89  10032 ADDED CODE TO CLEAR THE OBJ  PR10775
*                                  FILE OPEN FLAG AFTER THE     PR10775
*                                  FILE ASSIGNED TO OBJ IS      PR10775
*                                  DEASSIGNED.                  PR10775
*
*        PR10790   08/17/89  10032 CORRECTIONS MADE TO CODE FOR PR10790
*                                  NEW CATALOG DIRECTIVES TO    PR10790
*                                  PROPERLY CONTROL READING IN  PR10790
*                                  OF OBJECT CODE FROM SGO.     PR10790
*
*        VERSION   3.2.07
*
*        ETSA-32B  08/28/89  10032 CORRECTIONS MADE TO CODE FOR ETSA-32B
*                                  PROCESSING TSA,NOTSA OPTIONS ETSA-32B
*                                  OF THE EXTDMPX DIRECTIVE.    ETSA-32B
*
*        PR10824   08/28/89  10032 CORRECTIONS MADE TO LIBRARY  PR10824
*                                  AND DIRECTORY DIRECTIVE      PR10824
*                                  PROCESSING ROUTINES TO       PR10824
*                                  ASSIGN LIBRARIES AND         PR10824
*                                  DIRECTORIES AS EXPLICITLY    PR10824
*                                  UNBLOCKED.                   PR10824
*
*        PR10808   09/01/89  10032 CODE ADDED TO PROPERLY       PR10808
*                                  REWIND THE SGO FILE WHEN     PR10808
*                                  EXITING OR ABORTING.         PR10808
*
*        ELST-32C  09/05/89  10032 IMPLEMENTATION OF DOUBLE     ELST-32C
*                                  OPTION (6,7) CONTROL OF      ELST-32C
*                                  2.5 MB TASK GENERATION.      ELST-32C
*
*        VERSION   3.2.08
*
*        ETCM-32   09/05/89  10032 IMPLEMENTATION OF TASK CODE  ETCM-32
*                                  MANGEMENT SYSTEM.            ETCM-32
*
*        EXL-32    09/10/89  10032 CODE ADDED TO SUPPORT        EXL-32
*                                  CROSS LINKED LIBRARIES AND   EXL-32
*                                  DIRECTORIES.                 EXL-32
*
*        ELST-32D  09/12/89  10032 ADDED PREAMBLE FLAG BIT TO   ELST-32D
*                                  INDICATE THAT A LOAD MODULE  ELST-32D
*                                  IS A 2.5 MB TASK             ELST-32D
*
*        VERSION   3.2.09
*
*        ETCM-32   09/24/89  10032 FURTHER IMPLEMENTATION OF    ETCM-32
*                                  TASK CODE MANAGEMENT SYSTEM  ETCM-32
*
*        PR10874   10/30/89  10032 CODE ADDED TO INCLUDE THE    PR10874
*                                  NUMBER OF PAGES OF MEMORY    PR10874
*                                  REQUIRED FOR OVERLAY CSECTS  PR10874
*                                  IN THE TOTAL CSECT PAGE      PR10874
*                                  REQUIREMENT IN THE PREAMBLE  PR10874
*
*        EOPT-32   10/30/89  10032 THE OPTION DIRECTIVE         EOPT-32
*                                  PROCESSING ROUTINE WAS       EOPT-32
*                                  MODIFIED TO ACCEPT OPTION    EOPT-32
*                                  NUMBERS 33-64 FOR THE SECOND EOPT-32
*                                  TASK OPTION WORD.            EOPT-32
*
*        S890747   10/31/89  10032 CODE ADDED TO CORRECTLY      S890747
*                                  GET DATAPOOL SYMBOL OFFSETS  S890747
*                                  WHEN THE SYMBOL IS CONTAINED S890747
*                                  IN MULTIPLE DATAPOOLS.       S890747
*
*        VERSION   3.2.10
*
*        PR10988   11/03/89  10032 CODE ADDED TO THE BB.OPNR    PR10988
*                                  ROUTINE TO DETERMINE IF THE  PR10988
*                                  FILE TO BE OPENED IS A       PR10988
*                                  VOLUME RESOURCE AND IF NOT   PR10988
*                                  TO ONLY ALLOCATE 1 BLOCKING  PR10988
*                                  BUFFER FOR IT.               PR10988
*
*        ETSA-32C  11/10/89  10032 ADDED SYSTSA OPTION TO THE   ETSA-32C
*                                  EXTDMPX DIRECTIVE. ALSO      ETSA-32C
*                                  ADDED ABBREVIATIONS FOR      ETSA-32C
*                                  KEYWORDS                     ETSA-32C
*
*        EOUT-32B  11/10/89 10032  ADDED SYSMAP ENVIRONMENT     EOUT-32B
*                                  OPTION.                      EOUT-32B
*
*        VERSION   3.2.11
*
*        EDMP-32   11/17/89  10032 ADDED DEMAND/NODEMAND        EDMP-32
*                                  KEYWORDS TO THE ENVIRONMENT  EDMP-32
*                                  DIRECTIVE.                   EDMP-32
*
*        VERSION   3.2.12
*
*        PR11085   11/30/89  10032 CORRECTIONS MADE TO TEXT     PR11085
*                                  OPTION PROCESSING            PR11085
*
*        PR11084   11/30/89  10032 SET DIRECTIVE KEYWORDS CAN   PR11084
*                                  BE SEPERATED BY COMMAS OR    PR11084
*                                  SPACES.                      PR11084
*
*        PR11086   11/30/89  10032 COMMAND LINE PROCESSING      PR11086
*                                  MODIFIED TO ALLOW COMMANDS   PR11086
*                                  FROM MACROS                  PR11086
*
*        PR11088   11/30/89  10032 STATIC ASSIGNMENTS TO LIS    PR11088
*                                  AND LID CAN BE OVERRIDDEN    PR11088
*
*        PR11094   11/30/89  10032 IF EITHER THE LIBRARY OR     PR11094
*                                  DIRECTORY OF A LIB/DIR PAIR  PR11094
*                                  IS NOT ASSIGNED, THE LIBRARY PR11094
*                                  WILL NOT BE SEARCHED WHEN    PR11094
*                                  RESOLVING EXTERNAL REFS.     PR11094
*
*        PR11087   11/30/89  10032 ENHANCED ERROR MESSAGES FOR  PR11087
*                                  NEW FEATURES.                PR11087
*
*        C010-32   12/01/89  10032 MODIFIED TCM TIME/DATE       C010-32
*                                  CHECKING ROUTINE TO PROCESS  C010-32
*                                  ALL 3 TIME/DATE FORMATS.     C010-32
*
*        EAID-32D  12/07/89  10032 ADDED M2SXDF ROUTINE TO      EAID-32D
*                                  PROCESS SECTION EXTERNAL DEF EAID-32D
*                                  RECORDS DURING PASS B AND    EAID-32D
*                                  PRODUCE TYPE 'F' DEBUG       EAID-32D
*                                  SYMBOL TABLE RECORDS.        EAID-32D
*
*        VERSION   3.2.13
*
*        PR11086A  12/12/8  10032  COMMAND LINES ARE TERMINATED PR11086A
*                                  AT COLUMN 72.                PR11086A
*
*        VERSION   3.2.14
*
*        PR11197   12/28/89  5199  THE SYI FILE IS NOW          PR11197
*                                  PROPERLY PROCESSED WHEN      PR11197
*                                  RECATALOGING.                PR11197
*
*        C011-32   12/28/89  5199  ADDED OPTION 8 (AUDIT/       C011-32
*                                  NOAUDIT) TO CONTROL OUTPUT   C011-32
*                                  OF TCM WARNING MESSAGES.     C011-32
*
*        C012-32   12/28/89  5199  LOOK IN @@SYSTEM(SYSTEM) FOR  C012-32
*                                  LIBED IF NOT IN THE WORKING  C012-32
*                                  DIRECTORY.                   C012-32
*
*        C013-32   12/28/89  5199  CAHNGED XTYPEF CALLS TO      C013-32
*                                  XTYPE CALLS FOR WARNING      C013-32
*                                  MESSAGES.                    C013-32
*
*        C014-32   12/28/89  5199  CORRECTED PROBLEM WITH       C014-32
*                                  RE-ASSIGNING UPDATED OBJECT  C014-32
*                                  LIBRARIES.                   C014-32
*
*        VERSION   3.2.15
*
*        PR11209   01/10/90  10032 CORRECTLY BOUND RRS ENTRIES  PR11209
*                                  IN TCM ACTIVATION BLOCKS.    PR11209
*
*        VERSION   3.2.16
*
*        C015-32   01/15/90  10032 CORRECTED PROBLEM ASSIGNING  C015-32
*                                  CROSS-LINKED LIBRARY FROM    C015-32
*                                  DIRECTORY DIRECTIVE.         C015-32
*
*        C016-32   01/15/90  10032 SAVED DIRECTIVES ARE NO      C016-32
*                                  LONGER TRUNCATED WHEN A NEW  C016-32
*                                  SECTOR IS STARTED.           C016-32
*
*        VERSION   3.2.17
*
*        C017-32   01/23/90  10032 CORRECTED PROBLEM WITH       C017-32
*                                  SAVING DIRECTIVES WHEN NO    C017-32
*                                  EXIT DIRECTIVE IS READ       C017-32
*
*        VERSION   3.2.18
*
*        S890747B  02/14/90  10032 FURTHER CORRECTIONS MADE TO  S890747B
*                                  XGETDP ROUTINE TO HANDLE     S890747B
*                                  DUPLICATE SYMBOLS IN         S890747B
*                                  MULTIPLE DATAPOOLS.          S890747B
*
*        VERSION   3.2.19
*
*        C018-32   02/22/90  10032 CORRECTED BB.RWND ROUTINE    C018-32
*                                  TO WAIT FOR ALL I/O TO BE    C018-32
*                                  COMPLETED ON A FILE BEFORE   C018-32
*                                  REWINDING IT.                C018-32
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.2U01 CHANGE HISTORY
*
************************************************************************
*
*        VERSION   3.2.20
*
*        ELST-32E  03/08/90  10032 CORRECTED PROBLEM IN THE     ELST-32E
*                                  STRINGBACK LIST PROCESSING   ELST-32E
*                                  ROUTINE THAT CAUSED ABORTS   ELST-32E
*                                  WHEN CATALOGING 2.5 MB TASKS ELST-32E
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.2U02 CHANGE HISTORY
*
************************************************************************
*
*        VERSION   3.2.21
*
*        PR11370   05/29/90  10032 ADDITIONAL CORRECTIONS TO    PR11370
*                                  DIRECTIVE SAVING CODE TO     PR11370
*                                  TRUNCATE DIRECTIVE LINES TO  PR11370
*                                  72 CHARACTERS.               PR11370
*
*        C019-32   05/29/90  10032 CORRECTED PROBLEM WITH       C019-32
*                                  INCORRECT FILES AND BUFFERS  C019-32
*                                  COUNTS IN LOAD MODULES WITH  C019-32
*                                  OVERLAYS.                    C019-32
*
*        EAID-32E  05/29/90  10032 THE NUMBER OF SECTORS FOR    EAID-32E
*                                  DEBUG SYMBOL INFORMATION IS  EAID-32E
*                                  NO LONGER COMPUTED FROM THE  EAID-32E
*                                  TOTAL (ROOT + OVERLAYS)      EAID-32E
*                                  SYMBOL COUNT. THE NUMBER OF  EAID-32E
*                                  SECTORS FOR EACH OVERLAY'S   EAID-32E
*                                  SYMBOLS ARE COMPUTED AND     EAID-32E
*                                  ADDED TO THE NUMBER OF       EAID-32E
*                                  SECTORS REQUIRED FOR THE     EAID-32E
*                                  ROOT'S SYMBOLS.              EAID-32E
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.2U03 CHANGE HISTORY
*
************************************************************************
*
*        VERSION   3.2.22
*
*        S900452   07/18/90  10032 MODIFIED ENVIRONMENT COMMAND S900452
*                                  PROCESSOR TO RECOGNIZE NODEM S900452
*                                  AS ABBREVIATION FOR NODEMAND S900452
*                                  KEYWORD. CORRECTS CONFLICT   S900452
*                                  WITH NODEBUG (NODE) KEYWORD  S900452
*
*        VERSION   3.2.23
*
*        PR11750   08/16/90  10032 CORRECTED SOURCE COMPUTATION PR11750
*                                  FOR AID DEBUGGER SUPPORT.    PR11750
*                                  NOW BOTH TYPES OF FORTRAN    PR11750
*                                  DEBUG SYMBOL OBJECT RECORDS  PR11750
*                                  ARE HANDLED CORRECTLY.       PR11750
*
*        PR11735  08/16/90  10032  ADDED CODE TO CAUSE MAPPED   PR11735
*                                  OUT LOAD MODULES' DSECT TO   PR11735
*                                  BEGIN AT LOCATION 8 INSTEAD  PR11735
*                                  OF LOCATION 0. CORRECTS      PR11735
*                                  PROBLEM WITH FORTRAN PROGRAM PR11735
*                                  DATA BEING AT LOCATION 0 FOR PR11735
*                                  MAPPED OUT PROGRAMS.         PR11735
*
*        VERSION  3.2.24
*
*        C020-32   8/30/90   5199  CHANGE WRITE ACTIVE TEST IN  C020-32
*                                  BIG BUFFER ROUTINES FROM     C020-32
*                                  IOACT OF FCB.GLF TO AVOID    C020-32
*                                  PROBLEM IN TXPM.             C020-32
*
*        C021-32   8/31/90  5199  CONVERT REFERENCES TO C.TSAD  C021-32
*                                 TO M.GTSAD MACRO TO ALLOW TSA C021-32
*                                 TO BE MOVED TO MAXADDR.       C021-32
*
*        VERSION   3.2.25
*
*        EAID-32F  09/17/90  5199  ADDED CODE TO PROHIBIT TYPE  EAID-32F
*                                  D00E SYMBOL RECORDS WITH NO  EAID-32F
*                                  SOURCE FROM BRANCHING INTO   EAID-32F
*                                  AID_SREC ROUTINE. ALLOWING   EAID-32F
*                                  THESE RECORDS TO BE PASSED   EAID-32F
*                                  TO AID_SREC CAUSED BOGUS     EAID-32F
*                                  SOURCE TO BE PLACED INTO THE EAID-32F
*                                  LOAD MODULE.                 EAID-32F
*
*        VERSION   3.2.26
*
*        EAID-32G  09/24/90  10032 CORRECTED COMPUTATION OF     EAID-32G
*                                  NUMBER OF SECTORS NEEDED IN  EAID-32G
*                                  LOAD MODULE FOR DEBUG        EAID-32G
*                                  SYMBOLS.                     EAID-32G
*
*        PR11735B  09/24/90  10032 THE DSECT FOR MAPPED OUT     PR11735B
*                                  PROGRAMS NOW STARTS AT       PR11735B
*                                  LOCATION 20 INSTEAD OF       PR11735B
*                                  LOCATION 8 TO PRESERVE FILE  PR11735B
*                                  BOUNDED DATA STRUCTURES.     PR11735B
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.2U04 CHANGE HISTORY
*
************************************************************************
*
*        VERSION   3.2.27
*
*        C021-32B  10/11/90  10032 ADDED CODE TO RETAIN VALUE   C021-32B
*                                  IN R1 IN XLFCCHK ROUTINE.    C021-32B
*
*        PR11735C  10/18/90  10032 MODIFIED MAPPED OUT PROGRAM  PR11735C
*                                  ADJUSTMENT TO PLACE 8 ZEROED PR11735C
*                                  WORDS IN THE BEGINNING OF    PR11735C
*                                  THE DSECT. THIS OFFSETS THE  PR11735C
*                                  PROGRAM AND ALLOWS IT TO BE  PR11735C
*                                  DEMAND PAGEABLE BECAUSE NO   PR11735C
*                                  FURTHER RELOCATION IS NEEDED PR11735C
*
*        VERSION   3.2.28
*
*        PR11860   10/30/90  10032 ADDED MAPOUT/SYSMAP CHECK    PR11860
*                                  TO MAPPED OUT ADJUSTMENT     PR11860
*                                  MODIFICATION.                PR11860
*
*        S900698   11/05/90  10032 ADDED CODE TO PROPERLY       S900698
*                                  SEPERATE DEBUG SYMBOL OBJECT S900698
*                                  RECORDS INTO THOSE WITH NO   S900698
*                                  SOURCE, THOSE WITH SOURCE,   S900698
*                                  AND THOSE WITH A CARET       S900698
*                                  POINTING TO THE SOURCE.      S900698
*
*        VERSION   3.2.29
*
*        S900745   11/29/90  10032 CORRECTED PROBLEM WITH INFO  S900745
*                                  OBJECT RECORD PROCESSING     S900745
*                                  DURING TCM OBJECT CODE       S900745
*                                  VERIFICATION.                S900745
*
*        EUIC-32   11/29/90  10032 ADDED CODE TO ALLOCATE SPACE EUIC-32
*                                  IN THE LOAD MODULE FILE FOR  EUIC-32
*                                  UNINITIALIZED COMMON BLOCKS. EUIC-32
*                                  THIS ALLOWS TASKS WITH       EUIC-32
*                                  UNINITIALIZED COMMONS TO BE  EUIC-32
*                                  DEMAND PAGED. LOAD MODULES   EUIC-32
*                                  WITH OVERLAYS ARE UNEFFECTED.EUIC-32
*                                  THIS MODE OF OPERATION CAN   EUIC-32
*                                  BE OVERRIDDEN BY SETTING     EUIC-32
*                                  OPTION 9 (SET NOZERO).       EUIC-32
*
*        C022-32   11/29/90  10032 ADDED CODE TO FORCE LOAD     C022-32
*                                  MODULES WITH OVERLAYS TO     C022-32
*                                  BE NON-DEMAND PAGEABLE.      C022-32
*
*        VERSION   3.2.30
*
*        S900575   12/11/90  10032 MODIFIED ASSIGNMENT OF LO    S900575
*                                  FILE FOR SECONDARY TCM       S900575
*                                  PROCESSORS. IN BATCH MODE,   S900575
*                                  LO IS ASSIGNED TO UT AND UT  S900575
*                                  IS ASSIGNED TO NULL. IN      S900575
*                                  INTERACTIVE MODE, LO IS      S900575
*                                  ASSIGNED TO UT AND UT IS     S900575
*                                  ASSIGNED TO THE USERS        S900575
*                                  TERMINAL.                    S900575
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.3 CHANGE HISTORY
*
************************************************************************
*
*        VERSION   3.3.01
*
*        EIEE-33   06/06/91  10032 CODE ADDED TO SUPPORT        EIEE-33
*                                  IEEE-754 FLOATING POINT      EIEE-33
*                                  FORMAT NUMBERS.              EIEE-33
*
*        PR12009   06/12/91  10032 MODIFICATIONS MADE TO        PR12009
*                                  SEGMENT MODE BRANCH ADJUST-  PR12009
*                                  MENT CODE TO CORRECT DSECT   PR12009
*                                  BRANCH PROBLEM.              PR12009
*
*        EAGE-33   06/12/91  10032 ADDED AGE KEYWORD TO THE     EAGE-33
*                                  ENVIRONMENT DIRECTIVE. THIS  EAGE-33
*                                  IS USED IN CONJUNCTION WITH  EAGE-33
*                                  THE DEMAND KEYWORD.          EAGE-33
*
*        VERSION   3.3.02
*
*        EPSR-33   10/03/91  10032 ADDED CODE TO GENERATE       EPSR-33
*                                  DEBUG SYMBOL TABLE RECORDS   EPSR-33
*                                  FOR FORTRAN PARAMETER        EPSR-33
*                                  SYMBOLS.                     EPSR-33
*
*        ELST-33F  10/15/91  10032 FURTHER CORRECTIONS MADE TO  ELST-33F
*                                  2.5MB TASK GENERATION CODE.  ELST-33F
*                                  CSECT ADDRESSES IN THE DSECT ELST-33F
*                                  ARE NO LONGER 24 BIT BIASED. ELST-33F
*                                  EXM INSTRUCTIONS TARGET THE  ELST-33F
*                                  CSECT, INSTRUCTION ADDRESS   ELST-33F
*                                  IS SHIFTED. CHANGES MADE TO  ELST-33F
*                                  INDIRECT BRANCH DETECTION    ELST-33F
*                                  AND ERROR MESSAGE.           ELST-33F
*
*        VERSION   3.3.03
*
*        EBAC-33   11/05/91  10032 CODE ADDED TO PROCESS OBJECT EBAC-33
*                                  RECORDS FOR 24 BIT BIASED    EBAC-33
*                                  ADDRESS CONSTANTS.           EBAC-33
*
*        VERSION   3.3.04
*
*        EBAC-33B  11/12/91  10032 CHANGES MADE TO BACX         EBAC-33B
*                                  PROCESSING TO CHECK SECTION  EBAC-33B
*                                  NUMBER OF ADDRESS AND TO     EBAC-33B
*                                  RELOCATE IT WITHIN THE       EBAC-33B
*                                  PROPER SECTION.              EBAC-33B
*
*        VERSION   3.3.05
*
*        EBAC-33C  12/03/91  10032 CHANGES MADE TO STRINGBACK   EBAC-33C
*                                  PROCESSING TO DETECT THE     EBAC-33C
*                                  SPECIAL BACX LIST TERMINATOR EBAC-33C
*                                  VALUE 8FFFF. THIS ALLOWS THE EBAC-33C
*                                  REPLACEMENT ADDRESS TO BE    EBAC-33C
*                                  BIASED.                      EBAC-33C
*
*
*        VERSION   3.3.06
*
*        ELST-33G  12/05/91  10032 FURTHER SEGMENT MODE CHANGES ELST-33G
*                                  - RELOCATION ABOVE 1 MB IS   ELST-33G
*                                    CORRECTED.                 ELST-33G
*                                  - CORRECTED STRINGBACK MASK  ELST-33G
*                                    VALUE TO ALLOW 21 BIT      ELST-33G
*                                    ADDRESSES.                 ELST-33G
*                                  - CORRECTED BRANCH DETECTION ELST-33G
*                                    IN ABSOLUTE DATA PROCESSOR ELST-33G
*
*        VERSION   3.3.07
*
*        ELST-33H  12/06/91  10032 FURTHER CORRECTIONS MADE TO  ELST-33H
*                                  BRANCH DETECTION IN ABSOLUTE ELST-33H
*                                  DATA PROCESSOR.              ELST-33H
*
*        VERSION   3.3.08
*
*        EFLM-33   01/27/92  10032 IMPLEMENTATION OF FLOATMODE  EFLM-33
*                                  DIRECTIVE. ALLOWS SETTING    EFLM-33
*                                  AND RESETTING OF BITS        EFLM-33
*                                  WITHIN FLOATING POINT        EFLM-33
*                                  CONTEXT WORD IN PREAMBLE.    EFLM-33
*
*        VERSION   3.3.09
*
*        PR12226   02/10/92  10032 CORRECTED ADDR. COMPUTATION  PR12226
*                                  FOR GLOBAL DEBUG SYMBOLS FOR PR12226
*                                  SEGMENT REGISTER TASKS.      PR12226
*
*        EPSR-33B  02/10/92  10032 ADDED CODE TO TRUNCATE THE   EPSR-33B
*                                  LENGTH OF CHARACTER          EPSR-33B
*                                  PARAMETER SYMBOLS THAT ARE   EPSR-33B
*                                  GREATER THAN 16 BYTES IN     EPSR-33B
*                                  LENGTH. MAX LENGTH IS 16     EPSR-33B
*                                  BYTES.                       EPSR-33B
*
*        PR12230   02/13/92  10032 ADDED CODE TO CLEAR ABSOLUTE PR12230
*                                  SYMBOL FLAG BIT IN DEBUG     PR12230
*                                  SYMBOL RECORDS. THIS BIT IS  PR12230
*                                  USED TO FLAG PARAMETER       PR12230
*                                  SYMBOL RECORDS.              PR12230
*
************************************************************************
*
*        CATALOG REVISION 3 RELEASE 3.4.0 CHANGE HISTORY
*
************************************************************************
*
*        VERSION   3.4.0.01
*
*        PR11085B  05/05/92  10032 FURTHER CHANGES MADE TO      PR11085B
*                                  CORRECT TEXT OPTION COMMAND  PR11085B
*                                  LINE ECHOING.                PR11085B
*
*        S910662   05/05/92  10032 ADDED CODE TO DETECT IF THE  S910662
*                                  CURRENT WORKING DIRECTORY    S910662
*                                  HAS AVAILABLE ENTRIES FOR    S910662
*                                  TASK CODE MANAGEMENT         S910662
*                                  OBJECT FILES. IF NO ENTRIES  S910662
*                                  ARE AVAILABLE, A MESSAGE IS  S910662
*                                  OUTPUT AND OBJECT CODE       S910662
*                                  VERIFICATION IS DISABLED.    S910662
*
*        PR12264   05/05/92  10032 ADDED CODE TO DETECT         PR12264
*                                  MULTIPLE TRANSFER ADDRESSES  PR12264
*                                  IN SECTIONED TASKS.          PR12264
*
*        PR11483   05/05/92  10032 ADDED CODE TO DETERMINE IF   PR11483
*                                  SGO IS ASSIGNED TO A VOLUME  PR11483
*                                  RESOURCE. IF NOT, NO END OF  PR11483
*                                  FILE CHECK IS MADE BEFORE    PR11483
*                                  PROCESSING SGO. THIS ALLOWS  PR11483
*                                  PROCESSING OF OBJECT FROM    PR11483
*                                  TAPE.                        PR11483
*
*        PR12271   05/05/92  10032 ADDED CODE TO CORRECTLY      PR12271
*                                  OUTPUT THE TRANSFER ADDRESS  PR12271
*                                  IN THE LOAD MODULE MAP FOR   PR12271
*                                  SEGMENT REGISTER TASKS.      PR12271
*
*        VERSION   3.4.0.02
*
*        S920275   07/08/92  10032 CHANGES MADE SO THAT WHEN    S920275
*                                  OPTION 2 IS SET (OVERLAYS IN S920275
*                                  SEPERATE FILES) DEBUG        S920275
*                                  SYMBOLS ARE NOT COUNTED FOR  S920275
*                                  THE OVERLAYS. THE ARRAY FOR  S920275
*                                  THE COUNTS OVERFLOWED FOR    S920275
*                                  LARGE NUMBER OF OVERLAYS.    S920275
*
*        S900707   07/09/92  10032 CODE ADDED TO CONNECT        S900707
*                                  DIRECTIVE PROCESSOR TO       S900707
*                                  DETECT IF THE DATAPOOL       S900707
*                                  DICTIONARY SPECIFIED IS      S900707
*                                  EMPTY. CORRECTS INFINITE     S900707
*                                  LOOP WHEN EMPTY DICTIONARY   S900707
*                                  IS SPECIFIED.                S900707
*
*        PR12302   07/09/92  10032 MORE CODE ADDED TO SGO VOL.  PR12302
*                                  RESOURCE CHECK TO CHECK IF   PR12302
*                                  SGO IS ASSIGNED TO NULL      PR12302
*                                  DEVICE.                      PR12302
*
*        VERSION   3.4.0.03
*
*        PR12352   07/31/92  10032 FURTHER CHANGE MADE TO ALLOW PR12352
*                                  SGO TO BE READ FROM TAPE.    PR12352
*                                  THE BLOCKING BUFFER WAS NOT  PR12352
*                                  SIZED CORRECTLY FOR TAPE I/O PR12352
*
*        S920470   08/18/92  10032 CODE ADDED TO CLEAR SIGN     S920470
*                                  EXTENSION IN OBJECT RECORD   S920470
*                                  SEQUENCE NUMBER. CORRECTS    S920470
*                                  COMPARE PROBLEM WHEN 8000(16)S920470
*                                  OR MORE OBJECT RECORDS HAVE  S920470
*                                  BEEN READ.                   S920470
*
*        EIEE-34B  08/27/92  10032 CORRECT SETTINGS OF FLOATING EIEE-34B
*                                  POINT CONTEXT FLAG BITS.     EIEE-34B
*
*        VERSION   3.4.0.04
*
*        PR12424   10/06/92  10032 ADDED CODE TO PREVENT THE    PR12424
*                                  PASSING OF AN IMPROPER       PR12424
*                                  ARGUMENT TO THE M.LOC        PR12424
*                                  SERVICE WHEN OPTION 2 IS     PR12424
*                                  SET. THIS CAUSED PROBLEMS    PR12424
*                                  ON RMS SYSTEMS.              PR12424
*
*        ERMS-34   10/08/92  10032 ADDED CODE TO SET BIT 0 IN   ERMS-34
*                                  THE CNP OPTION FIELD WHEN    ERMS-34
*                                  DOING AN M.LOC ON A PATHNAME ERMS-34
*                                  OR PATHNAME BLOCK THAT       ERMS-34
*                                  SPECIFIES @@SYSTEM(SYSTEM).   ERMS-34
*                                  THIS FORCES A LOCAL FILE     ERMS-34
*                                  SEARCH ON RMS SYSTEMS.       ERMS-34
*
*        C023-34   10/09/92  10032 CHANGED ADDRESS MASK IN      C023-34
*                                  COMMON OBJECT RECORD         C023-34
*                                  PROCESSING ROUTINES. FULL    C023-34
*                                  ADDRESS RANGE IS NOW         C023-34
*                                  SUPPORTED.                   C023-34
*
*        VERSION   3.4.0.05
*
*        CAID      07/01/93  JBSYS ADD SUPPORT FOR AID FOR C        CAID
*                                  DEBUGGER.  INITIAL SUPPORT.      CAID
*
*        CAID1     09/01/93  JBSYS ADD SUPPORT FOR AID FOR C       CAID1
*                                  DEBUGGER.  INITIAL STRUCT AND   CAID1
*                                  POINTER SUPPORT.                CAID1
*
*        EDBG-34   10/15/93  10032 ADDED SUPPORT FOR DEBUGGER   EDBG-34
*                                  DIRECTIVE. ALLOWS LOAD       EDBG-34
*                                  MODULES TO SELECT THE AID    EDBG-34
*                                  FOR C DEBUGGER.              EDBG-34
*
*-----------------------------------------------------------------------
         PAGE
*
*
*   THE FOLLOWING EQUATES ARE NEEDED SINCE THEY ARE NOT IN M.EQUS
*     IN MPX-32 REV 2.X
*
*          THE SYMBOLS PR_????? REPRESENT EQUIVALENT PR.??? SYMBOLS.
*                                THEY ARE CHANGED TO AVOID A
*           CLASH WITH MPX3.3 MACRO. THE MACRO VALUE CAN BE USED
*           IF AND WHEN THESE SYMBOLS ARE DEFINED IN THE MPX2.X
*           MACRO AND A DEPENDENCY STATEMENT IS ISSUED.
*
PR_SFAID EQU       39W             BLOCK NUMBER OF MODULE INFO.  11005
PR_TIME  EQU       40W             TIME THE LOAD MODULE WAS BUILD 11005
PR_MPXBR EQU       44W             EXTDMPX VALUE                EBRM-33
PR_CATD  EQU       49W             SECTOR # HOLDING DIRECTIVES  ETCM-32
PR3_ETSA EQU       6               EXTENDED TSA ENABLE BIT      ETSA-32
PR3_TSA  EQU       7               EXTENDED TSA BIT             ETSA-32
PR4_MAPO EQU       0               MAPPED IN/OUT ENABLE BIT     EOUT-32
PR4_MOFL EQU       1               MAPPED OUT FLAG              EOUT-32
PR4_DPG  EQU       2               DEMAND PAGE FLAG             EDMP-32
PR4_NDPG EQU       3               NODEMAND FLAG                EDMP-32
PR_PRTGC EQU       X'10C'          CSECT PAGE REQUIREMENT (HW)  EOUT-32
PR_PRTGD EQU       X'10E'          DSECT PAGE REQUIREMENT       EOUT-32
PR_PRTGG EQU       X'110'          GLOBAL PAGE REQUIREMENT      EOUT-32
PR_PRTGE EQU       X'112'          EXTENDED PAGE REQUIREMENT    EOUT-32
PR4_SEGT EQU       4               SEGMENTED TASK FLAG          ELST-32D
PR_GID   EQU       X'B4'           1 BYTE TASK GROUP IDEMTIFIER  1.3#11
PR_TSBB  EQU       3               BIT OF FIELD PR.FLAG3        C008-30
*                       FOR TASK SUPPLIED BLOCKING BUFFERS       1.3#11
PR_RCMN  EQU       4               BIT OF FIELD PR.FLAG3        C008-30
PR_ONRA  EQU       1               BIT OF FIELD PR.FLAG3        ECSW-30
PR_OFRA  EQU       2               BIT OF FIELD PR.FLAG3        ECSW-30
PR_CATRV EQU       50W             CATALOG REVISION LEVEL NUM.  EOBJ-30
*                       INDICATE RETAIN MODULE NAME TO H.TAMM    1.3#11
PR_FLAG2 EQU       X'11'           1 BYTE OF FLAG BITS           1.3#11
PR_FLAG3 EQU       X'B5'           ANOTHER BYTE OF FLAG BITS    ECSW-30
PR_FLAG4 EQU       X'B6'           ANOTHER BUNCH OF FLAGS       EOUT-32
PR_LAS   EQU       X'8C'           1 HALFWORD FOR SPACE IN MBLKS 1.3#11
PR_AGE   EQU       X'108'          DEMAND PAGE AGE VALUE        EAGE-33
PR_FLTC  EQU       X'114'          FLOATING PT. CONTEXT WORD    EIEE-33
PR_NAMDB EQU       X'D0'           DEBUGGER NAME OFFSET         EDBG-34
*
*  THE FOLLOWING EQUATE IS NOT USED IN 3.3 BUT MAY BE IN 2.X
*
PR.GLOB  EQU       5               BIT 5 OF PR.CNTL            12004
*
*     SAME STORY FOR THE FOLLOWING RR.'S WHICH ARE USED IN       1.3#11
*     ANSI LABELED TAPE TYPE ASSIGNS PROCESSING.                 1.3#11
*                                                                1.3#11
RR_ANS   EQU       10
RR_10.SZ EQU       16                                            1.3#11
RR_FORM  EQU       X'6'                                          1.3#11
RR_PROT  EQU       X'7'                                          1.3#11
RR_RECL  EQU       X'10'                                         1.3#11
RR_BSIZE EQU       X'12'                                         1.3#11
RR_GENN  EQU       X'14'                                         1.3#11
RR_GENV  EQU       X'18'                                         1.3#11
RR_EXPIA EQU       X'1C'                                         1.3#11
RR_EXPIR EQU       X'20'                                         1.3#11
RR_LVID  EQU       X'22'                                         1.3#11
RR_AFID  EQU       X'28'                                         1.3#11
*-----------------------------------------------------------------------
         PAGE
* SPECIFIC ERROR CODES TO BE CHECKED FOR
*
V13ER.ND EQU       4               H.VOMM13 ERROR - DIR DOES NOT EXIST
V13ER.NR EQU       7               H.VOMM13 ERROR - RES DOES NOT EXIST
*
* SIZES OF FIXED LENGTH RRS ENTRIES
*
RR.9.SIZ EQU       10              MOUNT DEVICE - 10 WORDS
RR.4.SIZ EQU       4               LFC          -  4 WORDS
RR.2.SIZ EQU       4               TEMP         -  4 WORDS (+ VOL)
RR.3.SIZ EQU       6               DEVICE       -  6 WORDS
RR.1.SIZ EQU       4               PATHNAME     -  4 WORDS (+ PATH)
RR.6.SIZ EQU       12              RID          - 12 WORDS
         SPACE     3
ALIGN8W  DEFM      REG
         ADI       %REG,X'1F'      ROUND UP TO 8 WORD BOUNDARY
         SRL       %REG,5          STRIP OFF LOW 5 BITS
         SLL       %REG,5
         ENDM
*
*        DATA FOR PRODUCT ID AND REV
*            ALSO COMBINED WITH
*        DATA FOR COPYRIGHT MESSAGE AND TCW
*        ALSO SERVES FOR MESSAGE IN OBJECT
*            FOR HEADER LINE
*
CPYR.LNG DATAB     CPYR.END-CPYR.MSG
CMSG.LNG DATAB     CRLF.END-CATITLE                                11014
PRODREVL DATAB     CPYR.MSG-CATITLE
         SPACE     1
         BOUND     1W
*!PROD.TCW GEN       12/A(CPYR.MSG-CATITLE),20/B(CATITLE)        |1.3Q32
*!CPYR.TCW GEN       12/A(CPYR.END-CPYR.MSG),20/B(CPYR.MSG)      |1.3Q32
         SPACE     1
*CATITLE  DATAB     C' MPX-32 UTILITIES RELEASE 3.4.0  '            CAID
*CATITLE  DATAB     C' MPX-32 NBC RELEASE 1.1.0  '                  CAID
CATITLE  DATAB     C' MPX-32 NBC RELEASE 1.2.0  '                   CAID
         DATAB     C'(NBCAT.R3.4.0.05) '                            CAID
CPYR.MSG DATAB C' (C) COPYRIGHT 1983 ENCORE COMPUTER '
         DATAB C' CORPORATION, ALL RIGHTS RESERVED'
CPYR.END EQU       $
CRLG.MSG DATAB     C'"J"M'         LINE FEED AND CARRIAGE RETURN   11014
CRLF.END EQU       $                                               11014
         SPACE     1
HD1.CC   DATAB     C' '            CARR CNTRL FOR FIRST LINE       11012
HD2.CC   DATAB     C' '            CARR CNTRL FOR OTHER LINES      11012
         SPACE     1
PARAMBLK RES       11W             PARAMETER BLOCK FOR M.MYID      11012
         SPACE     1
         BOUND     1D
UTFCB    DATAW     G'UT '          FCB FOR INTERACTIVE GREETING    11012
*!         REZ       7W                                          |1.3Q32
         DATAW     0               TCW  NOT USED                 |1.3Q32
         GEN       8/X'02',24/0     INDICATE 16W FCB             |1.3Q32
         REZ       5W              BALANCE                       |1.3Q32
         REZ       8W              MAKE IT A 16W FCB             |1.3Q32
         SPACE     1
CATREV   DATAW     X'03040004'     CURRENT REV. NUM 03.04.00.04 EOBJ-30
RD.USER  EQU       160W                                         EXL-32
         TITLE     LFCTAB - LOGICAL FILE CODE CONTROL TABLE      1.3#04
*                                                                1.3#04
*   DATA STRUCTURES FOR LFCTAB                                   1.3#04
*   ==========================                                   1.3#04
*                                                                1.3#04
* EACH ENTRY IS A SINGLE WORD OF THE FOLLOWING FORMAT:           1.3#04
*                                                                1.3#04
*      BYTE-0     BYTE-1:2:3                                     1.3#04
*      LT.TYPE    LT.DATA                                        1.3#04
*                                                                1.3#04
*       REFERENCING EQUATES                                      1.3#04
*                                                                1.3#04
LT.TYPE  EQU       0B              FOR ENTRY TYPE REFERENCES     1.3#04
LT.LFCT  EQU       0W              FOR LFC REFERENCES            1.3#04
LT.FCBA  EQU       0W              FOR FCB REFERENCES            1.3#04
LT.PABDA EQU       0W              FOR DICTIONARY ABD REF'S      1.3#04
LT.DABDA EQU       0W              FOR DIRECTORY ABD REF'S       1.3#04
*                                                                1.3#04
*        DEFINED TYPES                                           1.3#04
*                                                                1.3#04
LT.TYP0  DATAW     0               ENTRY UNDEFINED               1.3#04
LT.TYP1  DATAW     X'01000000'     USED FOR LIBRARY SHARING FCB  1.3#04
LT.TYP2  DATAW     X'02000000'     USED FOR LIBRARY WITH FCB     1.3#04
LT.TYP3  DATAW     X'03000000'     USED FOR A DSC RES. DIRECTORY 1.3#04
LT.TYP4  DATAW     X'04000000'     USED FOR A MEM RES. DIRECTORY 1.3#04
LT.TYP5  DATAW     X'05000000'     USED FOR A DSC RES. DATAPOOL  1.3#04
LT.TYP6  DATAW     X'06000000'     USED FOR A MEM RES. DATAPOOL  1.3#04
LT.TYP7  DATAW     X'07000000'     SHARED FCB LIB AFTER OPEN     1.3#11
LT.TYP8  DATAW     X'08000000'     DSC RES DIRECTORY AFTER OPEN  1.3#11
LT.TYP9  DATAW     X'09000000'     CROSS LINKED LIB OR DIR      EXL-32
LT.TYPA  DATAW     X'0A000000'     LIB/DIR ASSIGND BY DIRECTIVE EXL-32
*                                                                1.3#04
* TYPES 9 - 255  UNDEFINED AND RESERVED                          1.3#04
*                                                                1.3#04
*                                                                1.3#04
*       DATA FIELD DEFINITIONS AS A FUNCTION OF TYPE             1.3#04
*                                                                1.3#04
*       TYPE         DATA FIELD CONTENTS                         1.3#04
*       ----         -------------------                         1.3#04
*        0           UNDEFINED                                   1.3#04
*        1           3 BYTE LEFT JUST. LFC (LT.LFCT)             1.3#04
*        2           ADDR OF RELATED FCB (LT.FCBA)               1.3#04
*        3           3 BYTE LEFT JUST. LFC (LT.LFCT)             1.3#04
*        4           ADDR OF RELATED DIRECTORY ABD (LT.DABDA)    1.3#04
*        5           3 BYTE LEFT JUST. LFC (LT.LFCT)             1.3#04
*        6           ADDR OF RELATED DITIONARY ABD (LT.PABDA)    1.3#04
*        7-255       UNDEFINED AND RESERVED                      1.3#04
*                                                                1.3#04
*  NOTE:   ABD IS NMEUMONIC FOR "ARRAY BOUND DESCRIPTOR"         1.3#04
*          DICTIONARY (DATAPOOL) RELATED ABD'S  AND              1.3#04
*          DIRECTORY (OBJECT LIBRARY) RELATED ABD'S ARE          1.3#04
*          DEFINED BELOW.                                        1.3#04
*                                                                1.3#04
*   ARRARY BOUND DESCRIPTORS.                                    1.3#04
*                                                                1.3#04
*  ABD FOR IN MEMOORY DIRECTORIES                                1.3#04
*                                                                1.3#04
*   THE ABD'S FOR DIRECTORIES ARE CREATED IN A SINGLE ARRAY      1.3#04
*   IN EXTENDED MEMORY. SPACE FOR THIS ARRAY IS ALLOCATED AS     1.3#04
*   PART OF THE PROCESSING OF THE FIRST "CATALOG/BUILD"          1.3#04
*   DIRECTIVE. THIS ARRAY IS LOCATED VIA THE VARIABLE LT.DABD    1.3#04
*   WHICH IS INITIALIZED WHEN THE MEMORY IS ALLOCATED.           1.3#04
*                                                                1.3#04
*   EACH DIRECTORY ABD IS A 2 WORD STRUCTURE. THE FIRST WORD     1.3#04
*   CONTAINS THE ADDRESS OF THE START OF THE FIRST ENTRY FOR     1.3#04
*   FOR THE DIRECTORY IT DESCRIBES. THE SECOND WORD CONTAINS     1.3#04
*   THE ADDRESS OF THE END OF THE LAST ENTRY FOR THIS DIRECTORY. 1.3#04
*   THE AREA BOUNDED BY THESE ENTRIES IS ASSUMED TO CONTAIN      1.3#04
*   CONTIGUOUS 3 WORD DIRECTORY ENTRIES. MULTIPLE DIRECTORY      1.3#04
*   ARRAYS NEED NOT BE CONTIGUOUS, HOWEVER THEY CURRENTLY ARE    1.3#04
*                                                                1.3#04
LT.DABD  DATAW     0               HOLDS ADDR OF ARRAY OF        1.3#04
*                                  DIRECTORY ABD'S               1.3#04
LIBBUFA  DATAW     0               HOLDS ADDRESS OF LIB BUFFER   1.3#04
LT.BASE  EQU       $               BASE ADDR OF LFC TABLE        1.3#04
LT.LIBS  EQU       $               BASE FOR LIBRARY AREA         1.3#04
         REZ       102W            RESERVE SPACE FOR 102 LIBS    1.3#04
LT.DIRS  EQU       $               BASE FOR DIRECTORY AREA       1.3#04
         REZ       102W            RESERVE SPACE FOR 102 DIRS    1.3#04
LT.DICTS EQU       $               BASE FOR DICTIONARY AREA      1.3#04
         REZ       102W            RESERVE SPACE FOR 102 DICTS   1.3#04
LT.END   EQU       $               END OF LFCTAB STRUCTURE       1.3#04
*                                                                1.3#04
LIBCNT   DATAW     0               COUNT OF ASSIGNED LIBS/DIRS   1.3#04
DPLCNT   DATAW     0               COUNT OF ASSIGNED DATAPOOLS   1.3#04
SYSDIR   EQU       $               TEMPORARY FOR REFERENCES      1.3#04
DIRFCB   EQU       $               DITTO                         1.3#04
LIBFCB   EQU       $               DITTO                         1.3#04
GPFCB1   DATAW     0             SPACE FOR A LIB SHARED FCB      1.3#04
         DATAW     0               FCB.TCW  NOT USED             1.3#04
         DATAW     X'0A000000'     SET 16W FCB + RANDOM ACCESS   1.3#04
         DATAW     0,0,0           WORDS 3,4 & 5                 1.3#04
         ACW       XLIRD.99        ERROR RETURN ADDRESS          1.3#04
         DATAW     0               WORD 7                        1.3#04
         DATAW     768             XFER 768 BYTES                1.3#04
         ACW       GPBUF1          TO GPBUF1                     1.3#04
         DATAW     0,0,0,0,0,0     WORDS 10 TO 15                1.3#04
*                                                                1.3#04
GPFCB2   DATAW     0             SPACE FOR A GENERAL PURPOSE FCB 1.3#04
         DATAW     0               FCB.TCW (NOT USED)            1.3#04
         DATAW     X'02000000'     SET 16W FCB
         DATAW     0,0,0           WORDS 3,4 & 5                 1.3#04
         ACW       XDLD.ERR        ERROR RETURN ADDRESS          1.3#04
         DATAW     0               WORD 7                        1.3#04
         DATAW     768             XFER 768 BYTES                1.3#04
         ACW       GPBUF1          TO GENERAL PURPOSE BUFFER     1.3#04
         DATAW     0,0,0,0,0,0     WORDS 10 TO 15                1.3#04
*                                USED FOR DISC RES. DIRS & DICTS 1.3#04
XDIRTMP  DATAW     G'DTM'    FCB FOR DIRECTIVES TEMP FILE       ETCM-32
         DATAW     0                                            ETCM-32
         DATAW     X'02000000'                                  ETCM-32
         DATAW     0,0,0,0,0,0                                  ETCM-32
         DATAW     768                                          ETCM-32
         DATAW     0,0,0,0,0,0,0                                ETCM-32
*                                                                1.3#04
XLMDIRS  DATAW     G'LMD'    FCB FOR LOAD MOD TO REPROCESS      ETCM-32
         DATAW     0                                            ETCM-32
         DATAW     X'02000000'                                  ETCM-32
         DATAW     0,0,0,0,0,0                                  ETCM-32
         DATAW     768                                          ETCM-32
         DATAW     0,0,0,0,0,0,0                                ETCM-32
*
         BOUND     1D                                            1.3#15
GPBUF1   REZ       192W            GENERAL PURPOSE BUFFER        1.3#04
GPBUF2   REZ       192W            SECOND GP BUFFER              1.3#15
*                                                                1.3#05
*     EQUATES FOR EXTENDED MEMORY BUFFER SIZES                   1.3#05
*                                                                1.3#05
EMDBG.SC EQU       20              SET TO 20 SECTORS             1.3#05
EMDBBSZ  EQU       EMDBG.SC*768    SIZE IN BYTS OF DEBG SYM BUF  1.3#05
*                      FOR EXTENDED MEMORY, ELSE 768 WIRED @@ B0. 1.3#05
LIBNSC   EQU       19              SIZE-1 IN SECTS OF LIB BUFFER 1.3#04
LIBBFSZ  EQU       LIBNSC+1*768    SIZE IN BYTES OF LIB BUFFER   1.3#04
*                                                                1.3#05
*!SLOBUFSS!!!EQU!!!!20!!!!!!!!!!!!!SIZE!IN!SECTORS!!!!!!!!!!!!!!ENCD-32
SLOBUFSS EQU       10              SIZE IN SECTORS              ENCD-32
SLOBUFSB EQU       SLOBUFSS*768    SIZE IN BYTES                 1.3#06
*                                                                1.3#06
SGOBUFSS EQU       20              SIZE IN SECTORS               1.3#06
SGOBUFSB EQU       SGOBUFSS*768    SIZE IN BYTES                 1.3#06
*                                                                1.3#06
*----------------------------------------------------------------1.3#04
         TITLE     CATDATA
         BOUND     1D
MPSAV    REZ       1F             SAVE FOR REGISTERS               11005
RDADDR   RES       192W            RESOURCE DESCRIPTOR             12004
XRBUFEND EQU       $                                               12004
XSYMBUF  DATAD     0,0             FOUR WORDS TO ASSEMBLE ENTRY  1.3#05
XINFOBUF RES       192W            MODULE INFORMATION BUFFER      11005
         SPACE     1
SLOCNP   DATAW     1               C N P  FOR THE SLO FILE       1100A
         ACW       SLO.EOPN        XFER IF ERROR ON OPEN         1.3#14
         GEN       8/4,24/0        OPEN FOR UPDATE ACCESS        1100A
         DATAW     0,0,0                                         1100A
         SPACE     1
UTCNP    DATAW     1               IMEDIATE RETURN               1.3#13
         DATAW     0               NO ALTERNATE                  1.3#13
         DATAH     0               OPTIONS                       1.3#13
         DATAH     0               STATUS                        1.3#13
         DATAW     0,0             RESERVED                      1.3#13
         DATAW     0               NO LINK ADDR                  1.3#13
READCNP   DATAW     1,0             C N P  FOR READ                1100A
         GEN       8/4,24/0        OPEN FOR UPDATE ACCESS         11007
         DATAW     0,0,0                                          1100A
         SPACE     1
RWCNP    DATAW     1,0             C N P  FOR READ AND WRITE     1100A
         GEN       8/4,24/0        OPEN FOR UPDATE ACCESS        1100A
         DATAW     0,0,0                                         1100A
         SPACE     1
INIT.CNP DATAW     0               WAIT? SET UP AS NEEDED        1.3#04
         DATAW     0               NO ALTERNATE RETURN           1.3#04
         DATAH     0               OPTIONS SET AS0NEDDED         1.3#04
         DATAH     0               STATUS RETURNED               1.3#04
         DATAW     0,0,0           NOT USED                      1.3#04
         SPACE     1
TEMP.RRS DATAW     0                   R R S      LFC GETS FILLED IN
         GEN       8/2,8/4,16/200  TEMPORARY FILE, SIZE=200
         GEN       4/1,28/0        UPDATE ACCESS
         GEN       6/1,3/1,23/0    BLOCKED=N,AUTOMATIC OPEN
         SPACE     1
EXITCNP  DATAW     1,0       SGO CNP WHEN EXITING OR ABORTING   PR10808
         GEN       8/1,24/0       OPEN IN READ MODE             PR10808
         DATAW     0,0,0                                        PR10808
         SPACE     1                                            PR10808
LMDCNP   DATAW     1,0       CNP TO OPEN LOAD MODULE            ETCM-32
         GEN       8/1,3/1,21/0                                 ETCM-32
         DATAW     0,0,0                                        ETCM-32
         SPACE     1                                            ETCM-32
PNTERS   REZ       8W              POINTERS FOR THE M.INQUIRY     1100A
SGPNTRS  REZ       8W              SGO INQUIRY POINTERS         ENCD-32
TDADDR   DATAW     0               DIRECTIVES TEMP BUFF ADDR    ETCM-32
TDPNTR   DATAW     0               DIRECTIVES BUFF CHAR COUNT   ETCM-32
DIRSECTS DATAW     0               # OF SECTS IN TEMP DIRS FILE ETCM-32
LDPNTR   DATAW     0         LOAD MOD DIRECTIVES BUFFER POINTER ETCM-32
LDADDR   DATAW     0         LOAD MOD DIRECTIVES BUFFER ADDR    ETCM-32
         BOUND     1D
SYCLFC   DATAW     G'SYC',0        SYC'S LFC FOR M.INQUIRY      PR11085
DPDLFC   DATAW     G'DPD',0        DPD'S LFC FOR THE M.INQUIRY    1100A
SYMLFC   DATAW     G'SYM',0        SYM'S LFC FOR THE M.INQUIRY    1100A
SLOLFC   DATAW     G'SLO',0        SLO'S LFC FOR THE M.INQUIRY    1100A
SGOLFC   DATAW     G'SGO',0        SGO'S LFC FOR M.INQUIRE       1.3#06
OBJLFC   DATAW     G'OBJ',0  LFC FOR OBJECT,PROGRAM FROM DIRS   ENCD-32
TMPLFC   DATAW     G'T01'    LFC OF CURRENT OBJ CODE TEMP FILE  ENCD-32
TMPCNT   DATAW     1         TEMP OBJ FILE COUNT FROM PASS A    ENCD-32
TCNT     DATAW     1         TEMP OBJ FILE COUNT DURING PASS B  ENCD-32
TMPSIZE  DATAW     0         TEMP OBJ FILE CREATE SIZE          ENCD-32
MAXTEMP  DATAW     20          MAX NUMBER OF TEMP OBJECT FILES  ENCD-32
         DATAW     G'    '         FILL FOR ERRLFC               1.3#10
ERRLFC   DATAW     C'LFC:',0       LFC FOR ERROR MESSAGES         0672
         SPACE     1
EXTDVAL  REZ       1W              RESERVE FOR EXTDMPX VALUE    EBRM-33
R1SAVE   DATAW     0                                              11005
DATETIME DATAD     0,0             RESERVE FOR TIME               11005
MAXADDR  DATAD     C'MAXADDR'      EXTDMPX OPTION               EBRM-33
MINADDR  DATAD     C'MINADDR'      EXTDMPX OPTION               EBRM-33
MAXA     DATAW     C'MAXA'         ABBREVIATION                 ETSA-32
MINA     DATAW     C'MINA'              ''                      ETSA-32
TSA      DATAW     C'TSA'          EXTENDED TSA OPTION          ETSA-32
NTSA     DATAD     C'NOTSA'        NON-EXTENDED TSA OPTION      ETSA-32
NOT      DATAW     C'NOTS'         ABBREVIATION                 ETSA-32C
STSA     DATAD     C'SYSTSA'       SYSTEM TSA MOVE OPTION       ETSA-32C
SYST     DATAW     C'SYST'         ABBREVIATION                 ETSA-32C
         SPACE     1
*
         BOUND     1D                                            1.3#11
PN.BLCK1 REZ       9D         STORAGE IN WHICH TO BUILD PNB      1.3#11
PN.BLCK2 DATAD     C'!VOLWORK'                                   1.3#11
         DATAD     C'!DIRWORK'                                   1.3#11
         DATAD     C'!RES    '                                   1.3#11
         DATAD     C'        '    STORE PARTITION NAME HERE      1.3#11
         DATAD     C'        '                                   1.3#11
PN.BLCK3 DATAD     C'!VOLSYST'                                   1.3#11
         DATAD     C'!DIRSYST'                                   1.3#11
         DATAD     C'!RES    '                                   1.3#11
         DATAD     C'        '    STORE PARTITION NAME HERE      1.3#11
         DATAD     C'        '                                   1.3#11
PNB.VCT1 DATAW     0                      VECTOR FOR LMPATH PNB  1.3#11
BLCK1.PT DATAW     0               HOLDS POINTER TO RESOURCE LOC 1.3#11
PNB.VCT2 GEN       8/40,24/W(PN.BLCK2)    VECTOR FOR WORK/WORK   1.3#11
PNB.VCT3 GEN       8/40,24/W(PN.BLCK3)    VECTOR FOR SYST/SYST   1.3#11
*
*        GENERATE LFC TABLE                                     ELFC-31
*                                                               ELFC-31
TABADDR  UTL:LFC   CI,SYC          COMMAND INPUT ENTRY          ELFC-31
         UTL:REF1  XSIRD91,SYCLFC                               PR11085
         UTL:REF2                                               ELFC-31
*                                                               ELFC-31
         UTL:LFC   DI,SGO          DATA INPUT ENTRY             ELFC-31
         UTL:REF1  XBIRD91,SGOLFC                               ELFC-31
         UTL:REF2                                               ELFC-31
*                                                               ELFC-31
         UTL:LFC   LO,SLO          AUDIT OUTPUT ENTRY           ELFC-31
         UTL:REF1  XPRNT91,SLOLFC                               ELFC-31
         UTL:REF2                                               ELFC-31
*                                                               ELFC-31
         UTL:LFC                   DATA OUTPUT ENTRY, NOT USED  ELFC-31
         UTL:REF1                                               ELFC-31
         UTL:REF2                                               ELFC-31
*                                                               ELFC-31
         UTL:LFC                   ERROR OUTPUT ENTRY, NOT USED ELFC-31
         UTL:REF1                                               ELFC-31
         UTL:REF2                                               ELFC-31
TABEND   EQU       $                                            ELFC-31
*                                                               ELFC-31
         SPACE     3
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**
*
*   FILE CONTROL BLOCK DEFINITIONS
*
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**
         SPACE
         BOUND     1W
         M.DFCB    XSYM91,SYM,120,XSYMC91,XSYM916
         M.DFCBE   XPRNT91,SLO,120,MPCCC+7,XPRNT.ER              1.3#14
         M.DFCBE   XSIRD91,SYC,80,MDBUF
         M.DFCBE   XBIRD91,SGO,120,MCBUF
         M.DFCBE   XOBJECT,OBJ,120,MCBUF          OBJ FILE      ENCD-32
         M.DFCBE   XTEMP,T01,120,MCBUF       TEMP OBJ CODE FILE ENCD-32
         M.DFCBE   XSYRD91,SYI,120,MCBUF
         M.DFCBE   INFOFCB,#ID,768,XINFOBUF
         M.DFCBE   MODFCB,MOD,0,$,,,,,,,RAN                      1.3#05
         PAGE
*
         TITLE     LFCSUB
*
*        LFC SUBSTITUTION ROUTINE - READS FPT AND LFC TABLE AND ELFC-31
*        SUBSTITUTES ASSIGNED LFC'S INTO REFERENCING DATA       ELFC-31
*        STRUCTURES                                             ELFC-31
*                                                               ELFC-31
LFCSUB   EQU       $               ROUTINE TO SUBSTITUTE LFC'S  ELFC-31
*!!!!!!!!!!LW!!!!!!!!R2,C.TSAD!!!!!!!GET!TSA!ADDRESS!!!!!!!!!!!!C021-32
         M.GTSAD                   GET TSA ADDR                 C021-32
         TRR       R1,R2           INTO R2                      C021-32
         LA        R1,TABADDR      LFC TABLE ADDRESS TO R1      ELFC-31
LSUB.0   LA        R7,TABEND       GET END ADDRESS OF TABLE     ELFC-31
         CAR       R1,R7           ARE WE AT THE END?           ELFC-31
         BLE       LSUB.7          RETURN IF SO                 ELFC-31
         LB        R5,3B,R1        GET NUMBER OF LFC'S IN ENTRY ELFC-31
         BZ        LSUB.3          NO ENTRY IF ZERO             ELFC-31
         TRN       R5,R5                                        ELFC-31
LSUB.1   ADI       R1,1W           POINT TO FIRST LFC           ELFC-31
         LW        R3,T.FPTA,R2    GET FPT ADDRESS              ELFC-31
         LNB       R4,T.FILES,R2   GET NUMBER OF FILES          ELFC-31
         LW        R6,0,R1         GET LFC                      ELFC-31
LSUB.2   CAMW      R6,0,R3         COMPARE TABLE LFC TO FPT LFC ELFC-31
         BEQ       LSUB.4          DO THEY MATCH?               ELFC-31
         ADI       R3,3W           CONTINUE IF NOT              ELFC-31
         BIB       R4,LSUB.2                                    ELFC-31
         BIW       R5,LSUB.1       GOTO NEXT LFC IN TABLE       ELFC-31
LSUB.3   ADI       R1,1W           NO MATCH FOUND, NEXT ENTRY   ELFC-31
         ADMW      R1,0,R1                                      ELFC-31
         ADI       R1,1W                                        ELFC-31
         ADMW      R1,0,R1                                      ELFC-31
         ADI       R1,1W                                        ELFC-31
         BU        LSUB.0                                       ELFC-31
LSUB.4   TRN       R5,R5           REMAINING LFC ENTRIES        ELFC-31
         ADR       R5,R1           ADD TO TABLE POINTER         ELFC-31
         LNB       R4,3B,R1        GET NUMBER OF REFERENCES     ELFC-31
         BEQ       LSUB.5B         SKIP IF ZERO                 ELFC-31
LSUB.5   ADI       R1,1W                                        ELFC-31
         LW        R3,0,R1                                      ELFC-31
         STW       R6,0,R3         SAVE LFC INTO REFERENCES     ELFC-31
         BIW       R4,LSUB.5                                    ELFC-31
LSUB.5B  ADI       R1,1W                                        ELFC-31
         LNB       R4,3B,R1        GET NUMBER OF C STRING REFS. ELFC-31
         BEQ       LSUB.6B                                      ELFC-31
         SLL       R6,8            SHIFT LFC STRING             ELFC-31
         SBR       R6,26           BLANK LAST BYTE              ELFC-31
LSUB.6   ADI       R1,1W                                        ELFC-31
         LW        R3,0,R1                                      ELFC-31
         STW       R6,0,R3         SAVE INTO REFERENCES         ELFC-31
         BIW       R4,LSUB.6                                    ELFC-31
LSUB.6B  ADI       R1,1W                                        ELFC-31
         BU        LSUB.0          NEXT ENTRY                   ELFC-31
LSUB.7   TRSW      R0                                           ELFC-31
*                                                               ELFC-31
         PAGE
***********************************************************************
*
*                  X - MONITOR INTERFACE ROUTINES
*
***********************************************************************
* XFLGS EQUS
XPRNTFST EQU       0
XPUNHFST EQU       1
XSIRDFST EQU       2
XBIRDFST EQU       3
XDATFST  EQU       4
XLISHFST EQU       5
XPUNHSKP EQU       6
XSYMTSUP EQU       8
XSYMCAR  EQU       9
XSYRDFST EQU       10              SYMTAB FILE READ ONCE
XABORTFL EQU       11              ABORT IF SET INSTEAD OF EXIT    21016
XLIBEDCK EQU       12              INDICATES OBJ RECORD FROM LIBR.  0270
XNEWMOD  EQU       13              A NEW MODULE FOR INFO RECORDS   11005
XCONNECT EQU       14              CONNECT DIRECTIVE FOR XCORE
XMDPR    EQU       15              MULTIPLE DATAPOOL REFERENCE     11017
XSYSPART EQU       16              A SYSTEM STATIC PARTITION     84-0209
XSLOEOM  EQU       17      SLO=UT AND USER SUPPRESSED OUTPUT     1.3#10
XLMFBAD  EQU       18      SET INDICATES NO LOAD MODULE CREATED  1.3#10
XCORI    EQU       19      SET INDICATES PARTION PNB IS BUILT    1.3#11
XREPMODE EQU       20      SET CAUSES STRINGBACK TO REPLACE      1.3#15
XINFOFST EQU       21      SET BY FIRST ACTUAL INFO RECORD       |1.3Q39
XOBRDFST EQU       22      SET AFTER INITIAL OBJ FILE OPEN      ENCD-32
XOUTDAT  EQU       23      SIGNALS OBJECT/SOURCE OUT OF DATE    ETCM-32
XSRCLFC  EQU       24      SET IF RECORD FOR SOURCE FILE        ETCM-32
XINCRRS  EQU       25      SET IF RECORD FOR INCLUDE FILE       ETCM-32
XOBJLFC  EQU       26      SET IF RECORD FOR OBJECT FILE        ETCM-32
XTCMTD   EQU       27      SET IF PROCESSING TIME/DATE FOR TCM  ETCM-32
XSILFC   EQU       28      SET IF PROCESSING SI FILE TCM RECORD ETCM-32
XLOLFC   EQU       29      SET IF PROCESSING LO FILE TCM RECORD ETCM-32
XBLKSET  EQU       30      SET WHEN CALL BLOCKS ARE SET UP      ETCM-32
XFLGS    DATAW     0               FLAGS   -CHANGE TO DATAW---->11017
XSYMMOD  REZ       100W                                         EAID-32
XSYML    DATAW     0                                            EAID-32
XSRCRT   DATAW     0                                            EAID-32
XSYMI1   ACW       XSYMMOD                                      EAID-32
XSYMI2   ACW       XSYMMOD                                      EAID-32
SRCE_PTR EQU       77W         PREAMBLE WORD POINTING TO SOURCE EAID-32
*
XSYMENT  DATAW     0               NUMBER OF LOCAL ENTRIES (SYM DEBUG)
XSYMFLGS DATAW     0               SYMBOLIC DEBUGGER FLAGS
*                                     0 = FIRST TIME INITIALIZATION
*                                     1 = ADDRESS NOW RESOLVING IS ABS
*                                     3 = ABSOLUTE DIRECTIVE IN EFFECT
*                                     28= ADDRESS INDIRECTION IS NEEDED
*                                     29= ADDRESS INDIRECTION IS NEEDED
*                                     30= VARIABLE NAME IS IN COMMON
*                                     31= VARIABLE NAME IS IN DATAPOOL
*
*
XRELGLBS DATAW     0               RELETIVE SECTOR FOR GLABAL SYMBOLS
XRELLOCS DATAW     0               RELETIVE SECTOR FOR LOCAL SYMBOLS
XCOMRELO DATAW     0               RELOCATION FOR BLANK COMMON
XRELINFO DATAW     0               RELETIVE SECTOR FOR MODULE INFO.11005
*       MPX MODULE IDENTIFIERS FOR INTERFACE ERROR REPORTING
XMDID.VM DATAH     C'VM'           FOR MODULE H.VOMM             1.3#05
         DATAH     0               REQUIRED FILLER               1.3#05
XMDID.RM DATAH     C'RM'           FOR MODULE H.REMM             1.3#05
         DATAH     0               REQUIRED FILLER               1.3#05
XMDID.RX DATAH     C'RX'           FOR MODULE H.REXS             1.3#05
         DATAH     0               REQUIRED FILLER               1.3#05
*
RECPERBL REZ       25W             EACH BYTE IS 1 BLK              11005
RPBX     DATAW     0                                               11005
*
*           MULTIPLE DATAPOOL TABLES AND INDEXES
*
*                                                                1.3#15
*    ABOVE TABLES REPLACED BY NEW MORE COMPREHENSIVE DATA        1.3#15
*    STRUCTURE AS FOLLOWS:                                       1.3#15
*                                                                1.3#15
*  EACH DPOOL (INCLUDING DATAPOOL) USES A FOUR WORD ENTRY        1.3#15
*  TO DESCRIBE THE DICTIONARY AND THE PARTITION.                 1.3#15
*                                                                1.3#15
*    WORD  |  0  |   1  |   2   |   3  |                         1.3#15
*           DPLFC,LPRIME,PRTSTRT,PRTEND                          1.3#15
*                                                                1.3#15
*       DPLFC   = DPD,P00-P99  DPD FOR DATAPOOL, PNN FOR MDP     1.3#15
*       LPRIME  = LARGEST PRIME FOR DICTIONARY SIZE              1.3#15
*       PRTSTRT = PARTITION STARTING ADDR                        1.3#15
*       PRTEND  = PARTITION ENDING ADDR                          1.3#15
*                                                                1.3#15
*       -1 IN ANY ENTRY INDICATES IT IS UNUSED.                  1.3#15
*                                                                1.3#15
DPLFC    EQU       0W                                            1.3#15
LPRIME   EQU       1W                                            1.3#15
PRTSTRT  EQU       2W                                            1.3#15
PRTEND   EQU       3W                                            1.3#15
*                                                                1.3#15
         BOUND     1D
DPOOLTAB EQU       $               TABLE STARTING ADDR           1.3#15
         REPT      101             NUMBER OF ENTRIES             1.3#15
         DATAW     -1,-1,-1,-1                                   1.3#15
         ENDR                                                    1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
XBLANK   DATAD     C'        '
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
         TITLE     XCOPYMOD - COPIES LM'S FROM OLD TO NEW FILE
*                                                                1.3#05
* XCOPYMOD                                                       1.3#05
*                                                                1.3#05
*        ROUTINE COPIES A SINGLE LOAD MODULE FROM THE OLD LM     1.3#05
*        FILE TO THE NEW LOAD MODULE FILE ACCORDING TO PARAMS    1.3#05
*                                                                1.3#05
*   IN    R4 = STARTING SECTOR ADDR IN OLD LM FILE               1.3#05
*         R5 = NUMBER OF SECTORS                                 1.3#05
*                                                                1.3#05
*    STARTING SECTOR ADDR IN NEW FILE IS EXPLICITLY ZERO.        1.3#05
*    BECAUSE XWRTMOD IS USED AND LMBASE IS UPDATED.              1.3#05
*                                                                1.3#05
*  OUT    ALL REGS RETURNED UNCHANGED                            1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XCOPYMOD EQU       $                                             1.3#05
         STF       R0,XCM.RET                                    1.3#05
         SBM       XCM.FRST,XCM.FLGS      SET FIRST BLOCK FLAG   |1.3Q18
         STW       R4,LMFCBIN+FCB.ERAA                           1.3#05
         LW        R7,DSCTBASE+MDSTFST GET STRTING ADR OF BUFFER 1.3#05
         STW       R7,LMFCBIN+FCB.ERWA                           1.3#05
         TRR       R7,R3           SET ADDR FOR XWRTMOD          1.3#05
         LW        R7,DSCTBASE+MDSTSIZ GET SIZE OF BUFFER        1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768                                        1.3#05
         CAR       R5,R7           IS BUFFER >= TO MODULE        |1.3Q26
         BLE       $+2W            SKIP IF NOT                   |1.3Q26
         TRR       R5,R7           ELSE USE MODULE SIZE          |1.3Q26
         NOP                       TO BOUND                      |1.3Q26
         STW       R7,XCM.SECT                                   1.3#05
         ES        R6                                            1.3#05
         MPI       R6,768                                        1.3#05
         STW       R7,LMFCBIN+FCB.EQTY                           1.3#05
         TRR       R7,R2           SET SIZE FOR XWRTMOD          1.3#05
         ZR        R4              INIT ADDR FOR XWRTMOD         1.3#05
         ZR        R1              USE XWRTMOD ERROR RETURN      1.3#05
         TRR       R5,R7           MOVE SIZE                     1.3#05
         ES        R6                                            1.3#05
         NOP                                                     1.3#05
XCM.1    EQU       $                                             1.3#05
         M.READ    LMFCBIN                                       1.3#05
         ZBM       XCM.FRST,XCM.FLGS     IS IT FIRST BLOCK       |1.3Q18
         BNS       XCM.11             SKIP IF NOT                |1.3Q18
         LW        R0,LMTABB       ELSE UPDATE INDEX LOCATION    |1.3Q18
         STW       R0,PR.INDEX,X3       IN MODULES PREAMBLE      |1.3Q18
         ZBM       PR.NOVL,PR.CNTL,X3    RESET NO OVERLAY FLAG   |1.3Q28
*                           ASSUME IF RECAT, THEN MUST BE OVLS   |1.3Q28
XCM.11   EQU       $                                             |1.3Q18
         LW        R0,XCM.SECT                                   1.3#05
         ARMW      R0,LMFCBIN+FCB.ERAA                           1.3#05
         BL        XWRTMOD                                       1.3#05
         ADMW      R4,XCM.SECT                                   1.3#05
         SUMW      R7,XCM.SECT                                   1.3#05
         CAMW      R7,XCM.SECT     IS BALANCE LESS THAN BUFF     1.3#05
         BGT       XCM.1           SKIP IF NOT                   1.3#05
         MPI       R6,768          CALCULATE REMAINING SIZE      1.3#05
         CI        R7,0            IS THERE ANY                  |1.3Q26
         BLE       XCM.XIT         RETURN IF NONE                |1.3Q26
         STW       R7,LMFCBIN+FCB.EQTY                           1.3#05
         TRR       R7,R2           UPDATE QUANTITIES             1.3#05
         M.READ    LMFCBIN                                       1.3#05
         BL        XWRTMOD         DO LAST PIECE                 1.3#05
XCM.XIT  EQU       $                                             |1.3Q26
         LF        R0,XCM.RET                                    1.3#05
         TRSW      R0                                            1.3#05
XCM.FLGS DATAH     0                                             |1.3Q18
XCM.FRST EQU       0    SET INDICATES FIRST BLOCK OF A LM        |1.3Q18
         BOUND     1F                                            1.3#05
XCM.RET  RES       1F                                            1.3#05
XCM.SECT DATAW     0                                             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE XLOC - READ RD OF LM FILE
*                                                                1.3#05
*    THIS ROUTINE READS RESOURCE DESCRIPTOR OF SPECIFIED         1.3#05
*    LM FILE TO SEE IF EXISTS AND TO COPY VOLUME NAME            1.3#05
*    FROM RD TO PNBVOL FOR XCRETMP.                              1.3#05
*                                                                1.3#05
*   ALL REGS PRESERVED                                           1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XLOC     STF       R0,XLOC.RET                                   1.3#05
         ZMD       XRD             ZAP RD INCASE RES NOT FOUND   1.3#09
         ZBM       MLOCF,MFLAG3    CLEAR FLAG FOR PNB           ERMS-34
         LW        R1,XPNBDESC     LOAD PNB VECTOR              ERMS-34
         BL        CHK4SYS         SEE IF IT'S @@SYSTEM(SYSTEM)  ERMS-34
*!!!!!!!!M.LOC!!!!!XPNBDESC,XRD!!!!DOES!LM!FILE!EXIST!!!!!!!!!!!ERMS-34
         M.LOC     XPNBDESC,XRD,CHKCNP  DOES LM FILE EXIST      ERMS-34
         BS        XL.1            SKIP IF IT DOES NOT           1.3#05
         LA        R3,XPNVOL       GET ADDR OF VOLUME PN         1.3#09
         LI        R7,X'40'        LOAD AN "@@"                   1.3#09
         BL        XSTB            AND STORE IT                  1.3#09
         LD        R6,XRD          GET VOLUME NAME               1.3#05
         BL        XST2            AND STORE IN PN               1.3#09+
         LD        R6,XRD+1D       SECOND HALF                   1.3#05
         BL        XST2            AND STORE IN PN               1.3#09+
         LI        R7,17           SET THE LENGTH                1.3#09
         STB       R7,XCT.VDSC     INTO THE PN VECTOR            1.3#09
         BU        XL.2            SKIP NOT FOUND                1.3#05
*                                                                1.3#05
XL.1     EQU       $                                             1.3#05
         LW        R6,XPNB+1W      DID AN LMPATH SUPPLY VOL      1.3#09
         CAMW      R6,=X'20202020' BLANK IF NOT                  1.3#09
         BNE       XL.10           SKIP IF NO VOL SUPPLIED       1.3#09
*                                                                1.3#09
         LA        R3,XPNVOL       ELSE USE SUPPLIED NAME        1.3#09
         LI        R7,X'40'        START WITH A "@@"              1.3#09
         BL        XSTB            AND STORE IT                  1.3#09
         LD        R6,XPNB+1D      FIRST HALF OF NAME            1.3#09
         BL        XST2            AND STORE IT                  1.3#09
         LD        R6,XPNB+2D      SECOND HALF                   1.3#09
         BL        XST2            AND STORE IT                  1.3#09
         LI        R7,17           SET LENGTH                    1.3#09
         STB       R7,XCT.VDSC     INTO VECTOR                   1.3#09
         BU        XL.2            AND EXIT                      1.3#09
*                                                                1.3#09
XL.10    EQU       $               HERE WHEN VOL NOT SUPPLIED    1.3#09
         LW        R6,XPNB+1W      GET VOLUME INDICATOR          1.3#09
*                              IF WE GET HERE MUST BE SYST/WORK  1.3#09
         CAMW      R6,=C'SYST'     SEE IF IT IS SYST             1.3#09
         BEQ       XL.11           BR TO USE  SYSTEM             1.3#09
*!!!!!!!!!!LW!!!!!!!!R1,C.TSAD!!!!!!!GET!ADDR!OF!TSA!!!!!!!!!!!!C021-32
         M.GTSAD   GET TSA ADDR INTO R1                         C021-32
         LA        R3,XPNVOL       ADDR OF VOLUME PN             1.3#09
         LI        R7,X'40'        GET AN "@@"                    1.3#09
         BL        XSTB            AND STORE IT                  1.3#09
         LD        R6,T.CVOL,X1    FIRST HALF OF DEFAULT VOLUME  1.3#09
         BL        XST2            AND STORE                     1.3#09
         LD        R6,T.CVOL+1D,X1 SECOND HALF                   1.3#09
         BL        XST2            AND SAVE                      1.3#09
         LI        R7,17           SET LENGTH                    1.3#09
         STB       R7,XCT.VDSC     INTO VECTOR                   1.3#09
         BU        XL.2            AND EXIT                      1.3#09
*                                                                1.3#09
XL.11    EQU       $               HERE IF CATALOG               1.3#09
         LW        R6,=C'@@SYS'                                   1.3#09+
         LW        R7,=C'TEM '                                   1.3#09+
         STD       R6,XPNVOL                                     1.3#05
         LD        R6,XBLANK                                     1.3#05
         STD       R6,XPNVOL+1D                                  1.3#05
         LI        R7,16           SET DEFAULT LENGTH            1.3#09
         STB       R7,XCT.VDSC     INTO PN VECTOR                1.3#09
XL.2     EQU       $                                             1.3#05
         LF        R0,XLOC.RET                                   1.3#05
         TRSW      R0              RETURN                        1.3#05
         BOUND     1F                                            1.3#05
XLOC.RET RES       1F                                            1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     XVALFILE - VALIDATE FILENAME
*                                                                1.3#10
*        ROUTINE VALIDATES CONTENTS OF R6/R7 TO BE A VALID       1.3#10
*        FILENAME BY REMOVING TRAILING BLANKS, ENCLOSING         1.3#10
*        STRING IN SINGLE QUOTES AND CALLING PATHNAME TO         1.3#10
*        PATHNAME BLOCK SERVICE.                                 1.3#10
*        RETURNS WITH CC1 RESET IF CONDITION MET ELSE CC1 IS SET 1.3#10
*                                                                1.3#10
*  IN     R6,R7 = STRING TO BE QUALIFIED                         1.3#10
*                                                                1.3#10
* OUT     ALL REGS RETURNED                                      1.3#10
*        CC1 RESET IF CONDION MET, ELSE SET                      1.3#10
*                                                                1.3#10
*----------------------------------------------------------------1.3#10
*                                                                1.3#10
XVALFILE EQU       $                                             1.3#10
         ZBR       R0,1            SET VALID FOR RETURN          1.3#10
         STF       R0,XVF.RET                                    1.3#10
         LA        R3,XVF.PNBF+1                                 1.3#10
         BL        XST2            STUFF R6,R7 INTO BUFFER       1.3#10
         LI        R2,1            INIT COUNTER                  1.3#10
         LI        R3,-8                                         1.3#10
         LI        R4,G' '         GET A BLANK                   1.3#10
XVF.1    EQU       $                                             1.3#10
         CAMB      R4,XVF.PNBF,X2      IS IT A BLANK             1.3#10
         BEQ       XVF.2           LEAVE ON FIRST BLANK          1.3#10
         ABR       R2,31           BUMP POINTER                  1.3#10
         BIB       R3,XVF.1        LOOP                          1.3#10
XVF.2    LI        R4,G'"''        GET CLOSING QUOTE             1.3#10
         STB       R4,XVF.PNBF,X2  AND STORE                     1.3#10
         ABR       R2,31           BUMP COUNT                    1.3#10
         SLL       R2,24           POSITION                      1.3#10
         LA        R1,XVF.PNBF     GET ADDR OF BUFFER            1.3#10
         ANMW      R1,=X'00FFFFFF' AND MASK                      1.3#10
         ORR       R2,R1           ADD IN COUNT                  1.3#10
         LW        R4,XVF.PBV      GET PATH BLOCK VECTOR         1.3#10
         ZR        R7              NO CNP                        1.3#10
         SVC       2,X'2E'         M.PNAMB                       1.3#10
         TRR       R7,R7           ANY ERROR                     1.3#10
         BZ        XVF.XIT         RETURN                        1.3#10
         SBM       1,XVF.RET       SET ERROR FLAG                1.3#10
XVF.XIT  LF        R0,XVF.RET      RECOVER STUFF                 1.3#10
         TRSW      R0              AND RETURN                    1.3#10
XVF.RET  RES       1F                                            1.3#10
*                                                                1.3#10
XVF.PBV  GEN       8/72,24/A(DUPBUF)                             1.3#10
XVF.PNBF DATAB     C'"''           OPENING QUOTE                 1.3#10
         RES       8B              MAX 8CHR FILENAME             1.3#10
         REZ       1B              CLOSING QUOTE                 1.3#10
         BOUND     1W              TRAILING BLANK REMOVED        1.3#10
*----------------------------------------------------------------1.3#10
         TITLE     XSTB - STORE R7 CONTENTS ON ANY BYTE BOUND    1.3#05
* XSTB                                                           1.3#05
*                                                                1.3#05
*   ROUTINE STORES CONTENTS OF R7 STARTING ON ANY BYTE BOUNDRY   1.3#05
*   ANY NULL (X'00') CHARACTERS ARE STRIPPED.                    1.3#05
*                                                                1.3#05
*  IN   R3 = BYTE ADDR TO BEGIN STORE                            1.3#05
*       R7 = DATA TO STORE                                       1.3#05
*                                                                1.3#05
* OUT   R3 = ADDR OF NEXT BYTE                                   1.3#05
*            ALL OTHERS PRESERVED                                1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XSTB     EQU       $                                             1.3#05
         STW       R2,XSTB.SD2     SAVE R2,R3                    1.3#05
         STD       R6,XSTB.SD6     SAVE R6,R7                    1.3#05
         LI        R2,-4           SET LOOP COUNT                1.3#05
XSTB.1   EQU       $                                             1.3#05
         ZR        R6                                            1.3#05
         SLLD      R6,8            MOVE DATA                     1.3#05
         TRR       R6,R6           IS IT ZERO                    1.3#05
         BZ        XSTB.2          SKIP IF NULL                  1.3#05
         TBM       1,ZROFLG        REPLACE ZEROS?               Q003-30
         BNS       XSTB.1A                                      Q003-30
         CAMB      R6,=X'30'       IS IT A ZERO?                Q003-30
         BNE       XSTB.2A         DON'T REPLACE ANYMORE IF NOT Q003-30
         ANMB      R6,=X'20'       CONVERT TO BLANK             Q003-30
XSTB.1A  EQU       $                                            Q003-30
         STB       R6,0,X3         AND STORE                     1.3#05
         ADI       R3,1            BUMP STORE                    1.3#05
XSTB.2   BIB       R2,XSTB.1       AND LOOP                      1.3#05
         LW        R2,XSTB.SD2                                   1.3#05
         LD        R6,XSTB.SD6                                   1.3#05
         TRSW      R0                                            1.3#05
XSTB.2A  ZBM       1,ZROFLG        CLEAR FLAG                   Q003-30
         BU        XSTB.1A         CONTINUE                     Q003-30
XSTB.SD2 DATAD     0                                             1.3#05
XSTB.SD6 DATAD     0                                             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
*    XST2    ENTRY POINT STORES BOTH R6&R7 USING XSTB            1.3#05
*                                                                1.3#05
XST2     EQU       $                                             1.3#05
         STW       R0,XST2.RET                                   1.3#05
         XCR       R6,R7           DO FIRST HALF FIRST           1.3#05
         BL        XSTB            STORE IT                      1.3#05
         XCR       R6,R7           POSITION SECOND HALF          1.3#05
         BL        XSTB            AND STORE IT                  1.3#05
         ZBM       1,ZROFLG        CLEAR FLAG (IF ALL ZEROES)   Q003-30
         BU        *XST2.RET       RETURN                        1.3#05
XST2.RET DATAW     0                                             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     XUNDFLOG - LOGS UNDEFINED ERRORS              1.3#05
*  XUNDFLOG                                                      1.3#05
*                                                                1.3#05
*  ROUTINE LOGS VARIOUS UNDEFINED VARIABLE OCCURENCES TO UT      1.3#05
*  AND SLO.                                                      1.3#05
*                                                                1.3#05
*  IN  R4 = ADDR OF REFERENCE                                    1.3#05
*      R5 = 0-99 UNDEFINED IS A VARIABLE IN DPOOL(00-99)         1.3#05
*           100  UNDEFINED IS A VARIABLE IN DATAPOOL             1.3#05
*           >100 OR <0 UNDEFINED IS AN EXTERNAL                  1.3#05
*                                                                1.3#05
*      R6,R7 = SYMBOL                                            1.3#05
*                                                                1.3#05
* OUT     ALL REGS RETURNED                                      1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XUNDFLOG EQU       $                                             1.3#05
         STF       R0,XUL.RSAV     SAVE THE USER FRAME           1.3#05
         LA        R3,XUL.MD2      SET UP STORAGE ADDR           1.3#05
         BL        XST2            STORE R6,R7                   1.3#05
         CI        R5,0            SORT OUT WHAT TYPE            1.3#05
         BLT       XUL.EXT         NEGATIVE MEANS EXTERNAL TYPE  1.3#05
         CI        R5,100                                        1.3#05
         BEQ       XUL.SDP         =100 MEANS DATAPOOL           1.3#05
         BGT       XUL.EXT         >100 MEANS EXTERNAL TYPE      1.3#05
*                           ALL OTHERS ARE DPOOL00-DPOOL99       1.3#05
         M.CONBAD                  ELSE CONVERT NUMBER           1.3#05
         SLL       R7,8            POSITION DATA                 1.3#05
         ANMW      R7,=X'00FFFF00' AND MASK                      1.3#05
         ORMW      R7,=X'4C000020' ADD IN "L00b"                 1.3#05
         LW        R6,=G'DPOO'     AND SET FIRST HALF            1.3#05
         BU        XUL.MRG1        GOTO MERGE POINT              1.3#05
XUL.SDP  EQU       $                                             1.3#05
         LW        R6,=G'DATA'     FIRST HALF                    1.3#05
         LW        R7,=G'POOL'     SECOND HALF                   1.3#05
         BU        XUL.MRG1        AND MERGE UP                  1.3#05
XUL.EXT  EQU       $                                             1.3#05
         LW        R6,=G'EXTE'                                   1.3#05
         LW        R7,=G'RNAL'                                   1.3#05
XUL.MRG1 EQU       $                                             1.3#05
         LA        R3,XUL.MD1      SET LOCATION                  1.3#05
         BL        XST2            STORE R6,R7                   1.3#05
*                                                                1.3#05
         LNB       R5,XUL.ML1      SET UP LENGTH (UT&SLO)        1.3#05
         LA        R6,XUL.MSG1     AND ADDR                      1.3#05
         BL        XTYPE           AND ISSUE LINE ONE            1.3#05
*                                                                1.3#15
         LW        R7,XUL.RSAV+4W    RECOVER LIST POINTER        1.3#10
         BL        XREFINFO          LOG REFERENCE INFO          1.3#15
*                                                                1.3#05
         LF        R0,XUL.RSAV     RECOVER USER CONTEXT          1.3#05
         TRSW      R0              AND RETURN                    1.3#05
         NOP                                                     1.3#05
*                                                                1.3#05
*  INTERNAL ROUTINE TO BUILD X'?????' OUT OF R6,R7               1.3#05
*                                                                1.3#05
XUL.HXR  EQU       $                                             1.3#05
         M.CONBAH                  CONVERT TO HEX                1.3#05
         SLLD      R6,8            POSITION DATA                 1.3#05
         ANMW      R6,=X'0000FFFF'                               1.3#05
         ORMW      R6,=X'58270000' OR IN X'                      1.3#05
         ORMW      R7,=X'00000027' AND '                         1.3#05
         TRSW      R0              RETURN                        1.3#05
         NOP                       BOUNDING                      1.3#05
*                                                                1.3#05
*   INTERNAL ROUTINE TO FORM AND PRINT REFERENCE INFO            1.3#15
*
*        R7 = ADDR OF REFERENCE                                  1.3#15
*   ALL REGS RETURNED                                            1.3#15
*
XREFINFO EQU       $                                             1.3#15
*                                                                1.3#15
         STF       R0,XRI.RSAV     SAVE CONTEXT                  1.3#15
         ANMW      R7,=X'0007FFFF'   KEEP ONLY ADR PART          1.3#10
         LW        R2,MSYMC        ADDR OF ACTIVE CONTROL        1.3#15
         LW        R5,1W,X2        GET CAT ALLOCATION            1.3#15
         ANMW      R5,=X'00FFFFFF'  KEEP ALLOC PART ONLY         1.3#15
         SUR       R5,R7           REMOVE FROM ADDR              1.3#15
         SUMW      R7,3W,X2        REMOVE PROGRAM ORIGIN         1.3#15
         TRR       R7,R5                                         1.3#15
         BL        XUL.HXR         CONVERT TO X'?????' FORM      1.3#05
         LA        R3,XUL.MD3      SET STARING ADDR              1.3#05
         BL        XST2            STORE R6,R7                   1.3#05
*
         LW        R2,MMODW        GET ADDR OF WORKING MODULE    1.3#05
         LD        R6,1D,X2        GET MODULE NAME               1.3#05
         LA        R3,XUL.MD6      SET UP ADDRES                 1.3#05
         BL        XST2            AND STORE                     1.3#05
*                                                                1.3#05
         LW        R5,XRI.RSAV+7W   RECOVER ADDR                 1.3#15
         SUMW      R5,5W,X2        REMOVE MODULE ORIGIN          1.3#15
         BL        XUL.HXR         CONVERT TO X'  ' FORM         1.3#10
         LA        R3,XUL.MD5      LOCATE IN MESSAGE             1.3#10
         BL        XST2            AND PLUG IT                   1.3#10
*
         LW        R2,MSYMC        ADDR OF ACTIVE CONTROL        1.3#15
         SUI       R2,4W           BACK IT DOWN TO PROG ENTRY    1.3#05
         LD        R6,1D,X2        GET PROGRAM NAME              1.3#05
         LA        R3,XUL.MD4      SET UP ADDR                   1.3#05
         BL        XST2            AND STORE IT                  1.3#05
*                                                                1.3#05
         LNB       R5,XUL.ML2      SET UP LENGTH                 1.3#05
         LA        R6,XUL.MSG2     PLUS ADDR                     1.3#05
         BL        XTYPE           AND ISSUE                     1.3#05
*                                                                1.3#15
         LF        R0,XRI.RSAV     RECOVER REGS                  1.3#15
         TRSW      R0              AND RETURN                    1.3#15
         NOP                       BOUNDING                      1.3#15
*                                                                1.3#15
         BOUND     1F                                            1.3#05
XUL.RSAV RES       1F                                            1.3#05
XRI.RSAV RES       1F                                            1.3#15
*                                                                1.3#05
XUL.MSG1 DATAB     C' CATALOG(WARNING) UNDEFINED  '              1.3#05&
XUL.MD1  REZ       8B              HOLDS UNDEFINED TYPE          1.3#05
         DATAB     C'  SYMBOL: '                                 1.3#05
XUL.MD2  REZ       8B              HOLDS SYMBOL NAME             1.3#05
XUL.ML1  DATAB     $-XUL.MSG1                                    1.3#05
         BOUND     1W
XUL.MSG2 DATAB     C'    REFERENCED AT: '                        1.3#05
XUL.MD3  REZ       8B              HOLDS PROGRAM OFFSET          1.3#05
         DATAB     C' IN PROGRAM: '                              1.3#05
XUL.MD4  REZ       8B              HOLDS PROGRAM NAME            1.3#05
         DATAB     C', ('                                        1.3#05
XUL.MD5  REZ       8B              HOLDS MODULE OFFSET           1.3#05
         DATAB     C' IN MODULE: '                               1.3#05
XUL.MD6  REZ       8B              HOLDS MODULE NAME             1.3#05
         DATAB     C').'                                         1.3#05
XUL.ML2  DATAB     $-XUL.MSG2                                    1.3#05
         BOUND     1W
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     XCRETMP - CREATE TEMPORARY FILE                  1.3
*                                                                   1.3
* XCRETMP                                                           1.3
*                                                                   1.3
*        THIS ROUTINE CREATES AND OPENS A TEMPORARY FILE            1.3
*        ACCORDING TO PARAMETERS SUPPLIED                           1.3
*                                                                   1.3
*    IF THE INITIAL SIZE IS >128, THEN MAX INCREMENT AND MIN        1.3
*    INCREMENT ARE SET TO MAXFUNC AND MINFUNC FACTORS RESPECIVELY   1.3
*                                                                   1.3
*    IF THE INITIAL SIZE IS <= 128, THEN MAX INCREMENT IS SET       1.3
*    EQUAL TO THE INITIAL REQUEST AND MIN INCREMENT IS SET TO       1.3
*    1/2 OF THE INITIAL REQUEST.                                    1.3
*                                                                   1.3
*                                                                   1.3
*    IN  R1 = ADDR OF FCB TO ASSOCIATE WITH FILE                    1.3
*        R5 = FILE SIZE REQUIRED IN SECTORS                         1.3
*             IF BIT ZERO IS SET CREATE AN OBJECT CODE TEMP     ENCD-32
*             FILE WITH MAXINC = SIZE AND MININC = 1/2 SIZE.    ENCD-32
*             IF BIT 1 IS SET, CREATE A DIRECTIVES TEMP FILE    ETCM-32
*             WITH MAXINC = SIZE AND MININC = 1/2 SIZE.         ETCM-32
*        R6 = NUMBER OF SEGMENTS ALLOWABLE                          1.3
*                                                                   1.3
*  OUT   R6 = 0 IFF NO ERROR ELSE                                   1.3
*             ELSE RETURNED NON ZERO  (STATUS IN R7)                1.3
*                                                                   1.3
*          R7 = 0 IFF NO ERROR                                      1.3
*                 ELSE CONTAINS ERROR CODE IN FORM XXNN             1.3
*                          XX - TWO CHARACTER MPX MODULE ID         1.3
*                          NN - TWO DIGIT STATUS CODE               1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
*                                                                   1.3
MAXFUNC  EQU       8               MAX EXTEND = 1/8                 1.3
MINFUNC  EQU       16              MIN EXTEND = 1/16                1.3
*                                                                   1.3
XCRETMP  EQU       $                                                1.3
         STF       R0,XCT.RET      SAVE USER FRAME                  1.3
         ZBM       MTMDIR,MFLAG2   CLEAR CREATE FLAGS           ETCM-32
         ZBM       MTMOBJ,MFLAG2                                ETCM-32
         TBR       R5,1            TEMP DIRECTIVES CREATE?      ETCM-32
         BNS       XCT1.0          CONTINUE IF NOT              ETCM-32
         ZBR       R5,1            CLEAR BIT                    ETCM-32
         SBM       MTMDIR,MFLAG2   SET FLAG                     ETCM-32
         BU        XCT1.2          JOIN TEMP OBJECT FILE CODE   ETCM-32
XCT1.0   TBR       R5,0            IS BIT 0 SET?                ENCD-32
         BNS       XCT1.1          NOT OBJECT TEMP CREATE       ENCD-32
         ZBR       R5,0            CLEAR FLAG BIT               ENCD-32
         SBM       MTMOBJ,MFLAG2   SHOW OBJECT TEMP CREATE      ENCD-32
XCT1.2   STW       R5,XTMRCB+RCB.OSIZ    SAVE CREATE SIZE       ENCD-32
         STW       R5,XTMRCB+RCB.MXEI    MAXI = SIZE            ENCD-32
         SRL       R5,1                                         ENCD-32
         STW       R5,XTMRCB+RCB.MNEI    MINI = 1/2 SIZE        ENCD-32
         SLL       R5,1                                         ENCD-32
         BU        XCT.1           MERGE                        ENCD-32
XCT1.1   STW       R5,XCTRCB+RCB.OSIZ  SAVE SIZE IN RCB             1.3
         CI        R5,128               IS IT A "BIG" FILE          1.3
         BGT       XCT.0               BR IF >128                   1.3
         STW       R5,XCTRCB+RCB.MXEI   ELSE SET MAXI=SIZE          1.3
         SRL       R5,1               1/2                           1.3
         STW       R5,XCTRCB+RCB.MNEI   INTO MINI                   1.3
         BU        XCT.1           AND SKIP BIG                     1.3
XCT.0    EQU       $                                                1.3
         ES        R4              SET TO GENERATE EXTENDS          1.3
         DVI       R4,MAXFUNC      CALC MAXI                        1.3
         STW       R5,XCTRCB+RCB.MXEI                               1.3
         LW        R5,XCT.RET+5W   RECOVER SIZE                     1.3
         ES        R4                                               1.3
         DVI       R4,MINFUNC      CALCULATE MINI                   1.3
         STW       R5,XCTRCB+RCB.MNEI                               1.3
XCT.1    EQU       $                                                1.3
         CI        R6,32           RANGE CHECK SEGMENT COUNT        1.3
         BLE       $+2W            SKIP IF OK                       1.3
         LI        R6,32     ELSE  CLAMP TO 32                      1.3
         STB       R6,XCT.CCNP+CP.OPTS     SET MAX SEGMENT COUNT    1.3
*                                                                   1.3
         TBM       MTMDIR,MFLAG2   TEMP DIRECTIVES CREATE       ETCM-32
         BNS       XCT.13          CONTINUE                     ETCM-32
         M.TEMP    XCT.CCNP,,XTMRCB   CREATE TEMP DIRS FILE     ETCM-32
         BCF       1,XCT.20        CONTINUE IF NO ERROR         ETCM-32
         BU        XCT.12          ELSE DO ERROR STUFF          ETCM-32
XCT.13   TBM       MTMOBJ,MFLAG2   TEMP OBJECT CREATE           ENCD-32
         BNS       XCT.11          DO LM CREATE IF NOT          ENCD-32
         M.TEMP    XCT.CCNP,XCT.VDSC,XTMRCB                     ENCD-32
         BCF       1,XCT.20        CONTINUE IF NO ERROR         ENCD-32
         BU        XCT.12          ELSE DO ERROR STUFF          ENCD-32
XCT.11   M.TEMP    XCT.CCNP,XCT.VDSC,XCTRCB                     ENCD-32
         BCF       1,XCT.2         SKIP IF NO ERROR                 1.3
*                                                                   1.3
XCT.12   LH        R7,XCT.CERR     GET ERROR CODE               ENCD-32
         LH        R4,=G'VM'       SET QUALIFIER                    1.3
XCT.ERR  EQU       $               SERVICE ERRORS COME HERE         1.3
         TRR       R7,R5           MOVE STATUS                      1.3
         M.CONBAD                  CONVERT TO DECIMAL               1.3
         SLL       R7,16           STRIP TOP                        1.3
         TRR       R4,R6           HALF                             1.3
         SRLD      R6,16           QUALIFY STATUS                   1.3
         STW       R7,XCT.RET+7W   STORE FOR USER                   1.3
         LI        R7,2            SET ERROR TYPE TO CALLER         1.3
         STW       R7,XCT.RET+6W   IN REG 6                         1.3
         BU        XCT.XIT         AND RETURN                       1.3
*---                                                                1.3
XCT.20   LW        R5,XTMRCB+RCB.OSIZ    GET REQUESTED SIZE     ENCD-32
         CAMW      R5,XCT.CCNP+3W        COMPARE TO ACTUAL      ENCD-32
         BLE       XCT.21          CONTINUE IF OK               ENCD-32
         SUMW      R5,XCT.CCNP+3W  CALCULATE DIFF               ENCD-32
         LI        R7,32           MAX NUMBER OF SEGMENTS       ENCD-32
         SUMB      R7,XCT.CCNP+4W  MINUS NUMBER USED            ENCD-32
         ES        R6                                           ENCD-32
         MPMW      R6,XTMRCB+RCB.MXEI    *MAX EXTENSION         ENCD-32
         CAR       R5,R7           WILL WE MAKE IT              ENCD-32
         BGE       XCT.21          CONTINUE IF WE WILL          ENCD-32
         M.DELR    XCTRID                                       ENCD-32
         LI        R7,11           SET SPACE                    ENCD-32
         LH        R4,=G'VM'       FROM H.VOLM                  ENCD-32
         BU        XCT.ERR         REPORT ERROR                 ENCD-32
*                                                               ENCD-32
XCT.2    EQU       $               HERE TO VERIFY SPACE             1.3
         LW        R5,XCTRCB+RCB.OSIZ   GET REQUESTED SIZE          1.3
         CAMW      R5,XCT.CCNP+3W       COMPARE TO ACTUAL           1.3
         BLE       XCT.21          CONTINUE IF OK                   1.3
         SUMW      R5,XCT.CCNP+3W  CALCULATE DIFF                   1.3
         LI        R7,32           MAX NUMBER OF SEGMENTS           1.3
         SUMB      R7,XCT.CCNP+4W  MINUS NUMBER USED                1.3
         ES        R6                                               1.3
         MPMW      R6,XCTRCB+RCB.MXEI   *MAX EXTENT                 1.3
         CAR       R5,R7           WILL WE MAKE IT                  1.3
         BGE       XCT.21          SKIP IF WE MIGHT MAKE IT         1.3
         M.DELR    XCTRID                                           1.3
         LI        R7,11           SET SPACE                        1.3
         LH        R4,=G'VM'       FROM H.VOLM                      1.3
         BU        XCT.ERR         AND REPORT ERROR                 1.3
*                                                                   1.3
*----                                                               1.3
*                                                                   1.3
XCT.21   EQU       $               HERE TO ASSIGN                   1.3
         LW        R1,XCT.RET+1W   GET FCB ADDR                     1.3
         LW        R7,0W,X1        GET LFC                          1.3
         ANMW      R7,=X'00FFFFFF' JUST AN LFC                      1.3
         STW       R7,XCTRRS       AND SET INTO RRS                 1.3
         M.ASSN    XCTRRS          ASSIGN WHAT WE JUST ALLOCATED    1.3
         BCF       1,XCT.3                                          1.3
         LH        R4,=G'RM'       SET QUALIFIER                    1.3
         BU        XCT.ERR         AND GO PROCESS ERROR             1.3
*                                                                   1.3
XCT.3    EQU       $                                                1.3
         TBM       MTMOBJ,MFLAG2   TEMP OBJECT CREATE?          ENCD-32
         BNS       $+3W            OPEN FILE IF NOT             ENCD-32
         ZBM       MTMOBJ,MFLAG2   CLEAR TEMP OBJECT FLAG       ENCD-32
         BU        XCT.4                                        ENCD-32
         LW        R1,XCT.RET+1W   GET FCB ADDR                     1.3
         LA        R7,XCT.OCNP     SETCCNP ADDR                     1.3
         SVC       2,X'42'         M.OPENR                          1.3
         BCF       1,XCT.4         BR IF NO ERRORS                  1.3
         LH        R7,XCT.OERR     GET CNP STATUS                   1.3
         LH        R4,=G'RM'       SET QUALIFIER                    1.3
         BU        XCT.ERR         AND PROCESS ERR                  1.3
XCT.4    EQU       $                                                1.3
         ZR        R7                                               1.3
         STW       R7,XCT.RET+6W   SHOW NO ERROR                    1.3
         STW       R7,XCT.RET+7W   IN BOTH PLACES                   1.3
XCT.XIT  EQU       $                                                1.3
         LF        R0,XCT.RET                                       1.3
         TRSW      R0              RETURN TO USER                   1.3
         NOP                                                        1.3
*                                                                   1.3
         BOUND     1F                                               1.3
XCT.RET  RES       1F                                               1.3
XCTRCB   DATAD     0               DEFAULT OWNER                    1.3
         DATAD     0               AND PROJECT                      1.3
         GEN 1/1,1/1,1/1,1/1,1/1,4/0,1/1,22/0  OWNER ALL ACCESS     1.3
         GEN 1/1,1/1,1/1,1/1,1/1,4/0,1/1,22/0  PROJ SAME            1.3
         GEN 1/1,1/0,1/0,1/0,1/0,4/0,1/0,22/0  OTHER READ ONLY      1.3
*             *   *   *   *   *   *   *    *                        1.3
*             *   *   *   *   *   *   *    *-RESERVED               1.3
*             *   *   *   *   *   *   *-BIT 9= DELETE ACCESS        1.3
*             *   *   *   *   *   *-RESERVED                        1.3
*             *   *   *   *   *-BIT 4= APPEND ACCESS                1.3
*             *   *   *   *-BIT 3= UPDATE ACCRESS                   1.3
*             *   *   *-BIT 2= MODIFY ACCESS                        1.3
*             *   *-BIT 1= WRITE ACCESS                             1.3
*             *-BIT 0= READ ACCESS                                  1.3
*                                                                   1.3
* GEN  8/X'CA',3/0,1/1,1/0,1/0,9/0,1/0,1/0,1/0,1/0,1/1,3/0,1/1      NBC
 GEN  8/X'CA',3/0,1/1,1/0,1/0,9/0,1/0,1/1,1/0,1/0,1/1,3/0,1/1       NBC
*      *       *   *   *   *   *   *   *   *   *   *   *   *        1.3
*      *       *   *   *   *   *   *   *   *   *   *   *   *-UNB    1.3
*      *       *   *   *   *   *   *   *   *   *   *   *-RESERVE    1.3
*      *       *   *   *   *   *   *   *   *   *   *-SHARED         1.3
*      *       *   *   *   *   *   *   *   *   *-CONTIGUOUS         1.3
*      *       *   *   *   *   *   *   *   *-MAN EXTENTIONS         1.3
*      *       *   *   *   *   *   *   *-AUTO EXTENTIONS            1.3
*      *       *   *   *   *   *   *-ZERO AT CREATION               1.3
*      *       *   *   *   *   *-RESERVED                           1.3
*      *       *   *   *   *-NOSAVE                                 1.3
*      *       *   *   *-FAST ACCESS                                1.3
*      *       *   *-EOF MANAFEMENT                                 1.3
*      *       *RESERVED                                            1.3
*      *-TYPE                                                       1.3
*      DONT'T FORGET WORD 15 IF YOU CHANGE ABOVE WORD!!!            1.3
*                                                                   1.3
         DATAW     0               MAXI EXTENTION                   1.3
         DATAW     0               MINI EXTENTION                   1.3
         DATAW     0               MAX FILE SIZE                    1.3
         DATAW     0               INITIAL FILE SIZE                1.3
         DATAW     0               FIRST SECTOR ADDRESS             1.3
         ACW       XCTRID          RID STORAGE                      1.3
         DATAW     0               DON'T OVERRIDE SPECIFIED ACC     1.3
* GEN  8/X'00',3/0,1/0,1/1,1/1,9/0,1/1,1/1,1/1,1/1,1/0,3/0,1/0      NBC
 GEN  8/X'00',3/0,1/0,1/1,1/1,9/0,1/1,1/0,1/1,1/1,1/0,3/0,1/0       NBC
*                                                                   1.3
XTMRCB   DATAD     0               DEFAULT OWNER                ENCD-32
         DATAD     0               AND PROJECT                  ENCD-32
         GEN       1/1,1/1,1/1,1/1,1/1,4/0,1/1,22/0  OWNER ACC  ENCD-32
         GEN       1/1,1/1,1/1,1/1,1/1,4/0,1/1,22/0  PROJ ACC   ENCD-32
         GEN       1/1,1/0,1/0,1/0,1/0,4/0,1/0,22/0  OTHER ACC  ENCD-32
  GEN  8/X'00',3/0,1/1,1/0,1/0,9/0,1/0,1/1,1/0,1/0,1/1,3/0,1/1  ENCD-32
         DATAW     0               MAXI EXTENSION               ENCD-32
         DATAW     0               MINI EXTENSION               ENCD-32
         DATAW     0               MAX FILE SIZE                ENCD-32
         DATAW     0               INITIAL FILE SIZE            ENCD-32
         DATAW     0               FIRST SECTOR ADDR            ENCD-32
         ACW       XCTRID          RID STORAGE                  ENCD-32
         DATAW     0               DON'T OVERRIDE SPECIFIED ACC ENCD-32
  GEN  8/X'00',3/0,1/0,1/1,1/1,9/0,1/1,1/0,1/1,1/1,1/0,3/0,1/0  ENCD-32
*
         BOUND     1D                                               1.3
XCTRRS   DATAW     0               LFC                              1.3
         GEN       8/6,8/12,16/0   TYPE & LENGTH                    1.3
         GEN  1/1,1/1,1/1,1/1,1/1,11/0,1/0,1/1,1/0,13/0             1.3
         GEN  4/0,1/0,1/1,1/0,1/0,24/0                              1.3
XCTRID   DATAW     0,0,0,0,0,0,0,0                                  1.3
*                                                                   1.3
XCT.OCNP DATAW     1               IMMEDIATE RETURN                 1.3
         DATAW     0               NO ALTERNATE RETURN              1.3
         GEN       8/4,1/0,1/1,1/1,1/0,1/0,1/0,1/0,1/0              1.3
*                   *   *   *   *   *   *   *   *   *-RESERVED      1.3
*                   *   *   *   *   *   *   *   *-RESERVED          1.3
*                   *   *   *   *   *   *   *-OVRD WITH IMP SHR     1.3
*                   *   *   *   *   *   *-DATA BLOCKED              1.3
*                   *   *   *   *   *-ACTUALLY BLOCKED              1.3
*                   *   *   *   *-ACTUALLY UNBLOCKED                1.3
*                   *   *   *-EXCLUSIVE USE                         1.3
*                   *   *-EXPLICIT SHARED                           1.3
*                   *-ACCESS MODE                                   1.3
XCT.OERR DATAH     0               STATUS HALF WORD                 1.3
         DATAW     0,0,0           WORD 3,4,5 NOT USED              1.3
*                                                                   1.3
XCT.CCNP DATAW     1               IMMEDIATE RETURN                 1.3
         DATAW     0               NO ALTERNATE RETURN              1.3
         DATAH     0               OPTION HALF WORD                 1.3
XCT.CERR DATAH     0               STATUS HALF WORD                 1.3
XCT.CSIZ DATAW     0               WORD 3   ACTUAL CREATED SIZE     1.3
XCT.CSEG DATAW     0               WORD 4   BYTE 0 NUMBER OF SEGS   1.3
         DATAW     0               WORD 5                           1.3
*                                                                   1.3
XCT.VDSC GEN       8/00,24/W(XPNVOL)                                1.3
XPNVOL   DATAD     C'                '                              1.3
         DATAW     C'    '     EXTRA SPACE INCASE VOL NAME 16CHR    1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
         TITLE     XDIRLD - LOAD DIRECTORY INTO EXTENDED MEMORY  1.3#04
*                                                                1.3#04
* XDIRLD                                                         1.3#04
*                                                                1.3#04
*      THIS ROUTINE EXTRACTS THE RELATIVE EOF POSITION OF THE    1.3#04
*  DIRECTORY FILE FROM THE RELATED FAT (DFT.EOF) AND CONVERTS    1.3#04
*  THIS VALUE INTO A READ TRANSFER COUNT. THIS AMOUNT OF MEMORY  1.3#04
*  IS REQUESTED AND GPFCB2 IS UPDATED. THE ENTIRE DIRECTORY IS   1.3#04
*  READ IN A SINGLE OPERATION. IF AN ERROR OCCURS ON THE READ    1.3#04
*  THE OPERATION IS ABANDONED, THE REQUESTED MEMORY IS RETURNED  1.3#04
*  AND THIS DIRECTORY WILL BE PROCESSED AS A DISC RESIDENT TYPE. 1.3#04
*                                                                1.3#04
*      IF THE READ COMPLETES, THE MEMORY ARRAY IS BACK SCANNED   1.3#04
*  FOR THE FIRST NON-ZERO WORD TO ESTABLISH THE ACTUAL LAST      1.3#04
*  ENTRY ADDRESS, THE ARRAY BOUND DESCRIPTOR IS BUILT, THE LFC   1.3#04
*  TABLE ENTRY IS CONVERTED TO A TYPE 4 AND UPDATED AND THE      1.3#04
*  UNUSED MEMORY IS RETURNED TO THE POOL.                        1.3#04
*                                                                1.3#04
*  IN      R1 = INDEX TO THE LFC TABLE ENTRY FOR THIS DIR        1.3#04
*          R2 = ADDRESS OF ARRAY BOUND DESCRIPTOR                1.3#04
*                                                                1.3#04
*  OUT     R2 = ADDR OF NEXT ABD IF NORMAL EXIT                  1.3#04+
*               NOT INCREMENTED IF AN ERROR                      1.3#04+
*          ALL OTHER REGS RETURNED AS ENTERED                    1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
*                                                                1.3#04
XDIRLD   EQU       $                                             1.3#04
         STF       R0,XDLD.RET     SAVE THE USER STUFFF          1.3#04
         LW        R3,GPFCB2       GET CURRENT LFC               1.3#04+
         STW       R3,2W,X2        AND STORE INTO ABD            1.3#04+
         ZMW       3W,X2           ZAP LAST WORD OF ABD          1.3#04+
         LA        R3,GPFCB2       GET ADDR OF DIR FCB           1.3#04
         LW        R3,FCB.FATA,X3  GET FAT ADDR                  1.3#04
         LW        R7,DFT.EOF,X3   GET RELATIVE EOF POS          1.3#04
         SUI       R7,1            REMOVE COUNT FOR PSEUDO EOF   1.3#04+
         ZR        R6                                            1.3#04
         MPI       R6,768          NUMBER OF BYTES TO READ       1.3#04
         STW       R7,GPFCB2+FCB.EQTY     SAVE IN THE FCB        1.3#04
         CI        R7,0            IS DIRECTORY EMPTY            1.3#04
         BP        XDLD.0          BR IF NOT EMPTY               1.3#04+
XDLD.NUL EQU       $               HERE IF DIRECTORY IS EMPTY    1.3#08
         ZMW       LT.LIBS,X1      ZERO THE LIB ENTRY            1.3#04
         ZMW       LT.DIRS,X1      ZERO THE DIR ENTRY            1.3#04
         SUI       R2,8            BACK UP THE ABD POINTER       1.3#04
         STW       R2,XDLD.RET+2W  AND UPDATE TO USER            1.3#04
         LW        R5,GPFCB2       GET LFC                       1.3#08
         ANMW      R5,=X'00FFFFFF' AND MASK                      1.3#08
         SBR       R5,2            MAKE 1ST CHAR A BLANK         1.3#08
         STW       R5,XDLD.M1D     AND STORE INTO MESSAGE        1.3#08
         LNB       R5,XDLD.M1L     MESSAGE LENGTH                1.3#08
         LA        R6,XDLD.M1      AND ADDR                      1.3#08
         BL        XTYPEF          AND LOG THE ERROR             1.3#08+
         BU        XDLD.XIT        QUIT THIS GUY                 1.3#04
XDLD.0   EQU       $                                             1.3#04
         TRR       R7,R1           SET UP TO                     1.3#04
         TRR       R2,R4           SAVE R2                       1.3#04
         BL        XGETEA          GET SOME SPACE  MEM RES DIR   1.3#04
         TRR       R2,R2           DID WE                        1.3#04
         BNZ       XDLD.01         SKIP IF WE GOT IT             1.3#04
         SUI       R4,4W           BACK UP ABD POINTER           1.3#04+
         STW       R4,XDLD.RET+2W  AND SAVE FOR THE USER         1.3#04+
         BU        XDLD.XIT        NOW JUST QUIT                 1.3#04+
XDLD.01  EQU       $                                             1.3#04+
         TRR       R3,R7           MEMORY SPACE BYTE SIZE TO R7 S880337
         ZR        R6              CLEAR  R6                    S880337
         DVI       R6,12           GET NUMBER OF 3W ENTRIES     S880337
         STW       R2,GPFCB2+FCB.ERWA   ELSE PUT ADDR INTO FCB   1.3#04
         XCR       R2,R4           SWAP EM                       1.3#04
         STW       R4,0W,X2        SAVE START ADDR IN ABD        1.3#04
         M.READ    GPFCB2          AND READ THE DIR              1.3#04
         ADR       R4,R3           FORM UP LAST ADDR IN BUFFR    1.3#04
         TRR       R3,R4           AND SAVE FOR LATER            1.3#04
XDLD.1   EQU       $               LOOP TOP                      1.3#04
         TRR       R7,R7           DID WE GO THRU ALL ENTRIES?  S880337
         BZ        XDLD.10         EMPTY DIRECTORY IF SO        S880337
         SUI       R3,3W           DECREMENT PONTER              1.3#04
         LW        R5,0W,X3        GET A WORD                    1.3#04
*        BZ        XDLD.1          AND LOOP IF ZERO             S880337
         BZ        XDLD.11         LOOP IF ZERO                 S880337
         CAMW      R5,=X'0F000000'  IS IT LIBED'S EOF MARK       1.3#08
*        BEQ       XDLD.1          KEEP CHECKING IF IT IS       S880337
         BEQ       XDLD.11         KEEP CHECKING IF IT IS       S880337
         BU        XDLD.12         ELSE GIVE BACK UNUSED SPACE  S880337
*                                                               S880337
XDLD.11  EQU       $                                            S880337
         SUI       R7,1            DECREMENT ENTRY COUNT        S880337
         BU        XDLD.1          KEEP CHECKING                S880337
*                                                               S880337
XDLD.10  EQU       $                                            S880337
         LW        R1,XDLD.RET+1W  RESTORE REGS. 1 AND 2        S880337
         LW        R2,XDLD.RET+2W                               S880337
         BU        XDLD.NUL        ISSUE EMPTY DIRECTORY MESSG. S880337
*                                                                1.3#08
XDLD.12  EQU       $                                            S880337
         ADI       R3,3W           BUMP PAST  END OF ENTRY       1.3#04
         SUR       R3,R4           CALCULATE UNUSED BYTE COUNT   1.3#04
         TRR       R4,R1           AND SET UP TO                 1.3#04
         BL        XRETEA          GIVE POOL BACK UNUSED         1.3#04
*                                                                1.3#04
         LW        R1,XDLD.RET+1W     RECOVER REG 1              1.3#04
         LW        R2,XDLD.RET+2W  RECOVER REG 2                 1.3#04
         CAMW      R3,0W,X2        TEST END AGAINST START        1.3#08
         BEQ       XDLD.NUL        BR IF EMPTY                   1.3#08
         STW       R3,1W,X2        STORE DIR END IN ABD          1.3#04
         STW       R3,DIREND       SAVE LAST ALLOCATED ADDR     ETCM-32
         ORMW      R2,LT.TYP4      MAKE IT AN IMD                1.3#04
         STW       R2,LT.DIRS,X1   AND UPDATE LFC TABLE          1.3#04
XDLD.XIT EQU       $
         LF        R0,XDLD.RET     RECOVER THE USER STUFFF       1.3#04
         ADI       R2,4W           BUMP R2 TO NEXT ENTRY         1.3#04+
         TRSW      R0              AND RETURN                    1.3#04
         NOP                                                     1.3#04
XDLD.ERR EQU       $               HERE IF READ ERROR            1.3#04
         TRR       R3,R1           SET UP TO                     1.3#04
         BL        XRETEA          GIVE BACK ALL MEMORY          1.3#04
         BU        XDLD.NUL        AND   TELL USER               1.3#04+
*----------------------------------------------------------------1.3#04
         BOUND     1F                                            1.3#04
XDLD.RET REZ       1F              HOLDS USER REGS               1.3#04
DIREND   DATAW     0               HOLDS LAST ALLOCATED ADDR    ETCM-32
*                                                                1.3#04
XDLD.M1  DATAB     C' CATALOG(WARNING) EMPTY DIRECTORY   '       1.3#08
XDLD.M1D REZ       4B              HOLDS LFC                     1.3#08&
         DATAB     C'  , RELATED LIBRARY WILL NOT BE SEARCHED.'
XDLD.M1L DATAB     $-XDLD.M1                                     1.3#08
         BOUND      1W
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
         TITLE     XBLDFCB - BUILD FCB'S FOR LIBRARIES           1.3#04
*                                                                1.3#04
*   THIS ROUTINE LOOPS THOUGH THE LIB SECTION OF THE LFC TABLE   1.3#04
*   AND ALLOCATES AVAILABLE EXTENDED MEMORY TO A FCB FOR EACH    1.3#04
*   LIBRARY PLUS A SINGLE DEBLOCKING BUFFER WHICH IS SHARED BY   1.3#04
*   ALL LIBRARIES. THE LFC TABLE ENTRY IS CONVERTED FROM A       1.3#04
*   TYPE 1 TO A TYPE 2 WITH THE DATA PORTION POINTING TO THE FCB 1.3#04
*   EACH FCB IS INITIALIZED WITH: LFC,WRD 2 BITS FOR EXPANDED    1.3#04
*   FCB & RANDOM ACCESS,THE BUFFER ADDRESS,A TRANSFER COUNT OF   1.3#04
*   7680 BYTES AND AN ERROR RETURN ADDRESS.                      1.3#04
*                                                                1.3#04
*  IN  R2 = ADDR OF ARRAY TO HOLD FCB'S AND I/O BUFFER           1.3#04
*                                                                1.3#04
*--------------------------------------------------------------- 1.3#04
XBLDFCB  EQU       $                                             1.3#04
         STW       R0,XBF.RET      SAVE RETURN                   1.3#04
         LW        R7,LIBCNT       GET NUMBER OF LIBS            1.3#04
         SLL       R7,6            MULTIPLY BY 64 (16W*4)        1.3#04
         ADR       R2,R7           ADD IN START OF ARRAY         1.3#04
         TRR       R7,R0           SAVE BUFFER ADDR              1.3#04
         STW       R0,LIBBUFA      AND UPDATE FOR OTHERS         1.3#04
         ZR        R1              INIT LFC TAB INDEX            1.3#04
         TRR       R2,R3           SAVE ADDR OF FIRST FCB        1.3#04
         LNW       R5,LIBCNT       GET LOOP CONTROL              1.3#04
         LW        R4,=X'00FFFFFF' GET LFC MASK                  1.3#04
         LA        R7,XLIRD.99     SET UP ERROR RETURN ADDR      1.3#04
         LI        R2,LIBBFSZ      XFER SIZE                     1.3#04
*                                                                1.3#04
XBF.1    EQU       $               LOOP TOP                      1.3#04
         LMW       R6,LT.LIBS,X1   GET LFC                       1.3#04
         STW       R6,0W,X3        STORE LFC INTO FCB            1.3#04
         ZMW       1W,X3           CLEAR IT OUT                  1.3#04
*                                                                1.3#04
         TRR       R3,R6           COPY ADDR OF FCB              1.3#04
         ORMW      R6,LT.TYP2      MAKE IT A TYPE 2 ENTRY        1.3#04
         STW       R6,LT.LIBS,X1   AND PUT INTO FCB              1.3#04
         ABR       R1,29           BUMP LFC TAB INDEX            1.3#04
         ZR        R6                                            1.3#04
         SBR       R6,6            SET 16W FCB                   1.3#04
         SBR       R6,4            MAKE FOR RANDOM ACCESS        1.3#04
         STW       R6,2W,X3        AND SET IN FCB                1.3#04
         ZMW       3W,X3           CLEAR IT OUT                  1.3#04
         ZMD       4W,X3           THIS TOO                      1.3#04
         STW       R7,6W,X3        PUT ERROR RETURN IN FCB       1.3#04
         ZMW       7W,X3           CLEAR IT OUT                  1.3#04
         STW       R0,8W,X3        SET BUFFER ADDR               1.3#04
         STW       R2,9W,X3        SET I/O XFER SIZE             1.3#04
         ZMD       10W,X3          CLEAR IT OUT                  1.3#04
         ZMD       12W,X3          DITTO                         1.3#04
         ZMD       14W,X3          DITTO DITTO                   1.3#04
         ADI       R3,16W          BUMP FCB POINTER              1.3#04
         BIB       R5,XBF.1        LOOP THROUGH ALL              1.3#04
         BU        *XBF.RET        RETURN TO CALLER              1.3#04
XBF.RET  DATAW     0               HOLDS RETURN ADDR             1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
         TITLE     XGETEA - GET EXTENDED MEMORY ARRAY            1.3#04
*                                                                1.3#04
*    THIS ROUTINE ACQUIRES AND MANAGES THE EXTENDED MEMORY ARRAY 1.3#04
*    USED TO HOLD DYNAMIC STRUCTURES. IF THE USERS REQUEST       1.3#04
*    EXCEEDS MEMORY AVAILABLE IN THE POOL, MORE MEMORY IS        1.3#04
*    REQUESTED FROM THE SYSTEM. WHEN EXPANDING THE POOL, ADDED   1.3#04
*    MEMORY IS ASSUMED TO BE LOGICALLY CONTIGUOUS.  THE MEMORY   1.3#04
*    POOL IS ALLOCATED TO USERS IN MODULO 4 BYTE QUANTITIES.     1.3#04
*    IF THE USERS REQUEST CAN NOT BE FILLED, EVEN AFTER A SYSTEM 1.3#04
*    REQUEST, THEN THE AMOUNT AVAILABLE IS RETURNED. IF THE USER 1.3#04
*    WISHES TO USE THIS MEMORY, HE MUST REISSUE THE REQUEST FOR  1.3#04
*    THE AMOUNT RETURNED                                         1.3#04
*                                                                1.3#04
*  IN    R1 = NUMBER OF BYTES (MOD 4, ROUTINE ROUNDS UP)         1.3#04
*                                                                1.3#04
* OUT    R2 = ADDR OF ARRAY, OR ZERO IF NOT ALLOCATED            1.3#04
*        R3 = NUMBER OF BYTES ALLOCATED OR AVAILABLE             1.3#04
*                                                                1.3#04
*--------------------------------------------------------------- 1.3#04
*                                                                1.3#04
XGETEA   EQU       $                                             1.3#04
         ZR        R2         CLOBER USER'S REG 2                1.3#04
         ZR        R3              AND 3                         1.3#04
         STF       R0,XGEA.RET     SAVE THE USER REGS            1.3#04
         SBM       XGEA.NFT,XGEA.FLG   SET NOT 1ST TIME FLAG     1.3#04+
         BS        XGEA.N          SKIP FIRST TIME STUFF IF SET  1.3#04+
         M.GD                      GET ONE MAPBLK                1.3#14
         TRR       R3,R3           DID WE GET IT                 1.3#14
         BZ        XGEA.NOM        REPORT NO MEMORY              1.3#14
         TRR       R4,R5           COPY END ADDR                 1.3#14
         SUR       R3,R5           CALCULATE MB SIZE             1.3#14
         STW       R3,XEABEG       SAVE START ADDR               1.3#14
         STW       R3,XEAOLD.B     IN BOTH POINTERS              1.3#14
         STW       R4,XEAEND       SAVE END ADDR                 1.3#14
         STW       R5,XEASIZ       SAVE AMOUNT IN POOL           1.3#14
         ADI       R5,4            BUMP SIZE TO CARDINAL NUMBER  1.3#14
         STW       R5,XEAMBSIZ     AND SIZE OF A MAP BLOCK       1.3#14
         CI        R5,8192         CHECK MAPBLOCK SIZE           1.3#14
         BGT       XGEA.N          >MEANS 32K SO GET ON WITH IT  1.3#14
         LI        R2,-3           GET 3 MORE BLOCKS             1.3#14
XGEA.F1  EQU       $                                             1.3#14
         M.GD                                                    1.3#14
         TRR       R3,R3           DID WE GET IT                 1.3#14
         BZ        XGEA.NOM        REPORT                        1.3#14
         STW       R4,XEAEND       UPDATE END POINTER            1.3#14
         SUMW      R4,XEABEG       CALCULATE SIZE                1.3#14
         STW       R4,XEASIZ       AND SAVE                      1.3#14
         BIB       R2,XGEA.F1      ELSE LOOP                     1.3#14
         BU        XGEA.N          AND SERVICE USER              1.3#14
XGEA.NOM EQU       $               HERE IF DENIAL ON MIN         1.3#14
         LD        R6,XGEA.XT1     GET LOGICAL TYPE              1.3#14
         LA        R3,XGEA.XMD     LOCATE IN MESSAGE             1.3#14
         CI        R4,1            IS IT A MIDAL OVERFLOW        1.3#14
         BEQ       $+2W            SKIP IF IT IS LOGICAL         1.3#14
         LD        R6,XGEA.XT2     ELSE LOAD PHYSICAL            1.3#14
         BL        XST2            AND SET INTO MESSAGE          1.3#14
         LNB       R5,XGEA.XML                                   1.3#14
         LA        R6,XGEA.XMA                                   1.3#14
         BL        XTYPEF                                        1.3#14
         LNB       R5,XGEA.X2L                                   1.3#14
         LA        R6,XGEA.X2A                                   1.3#14
         BL        XTYPEF          INDICATE REQUIREMENT          1.3#14
*                                                                1.3#14
         CI        R4,1            IS IT LOGICAL                 1.3#14
         BNE       XGEA.NM1        SKIP THIS MESSAGE FOR PHYS    1.3#14
         LW        R5,XEAEND       GET LAST ADDR OBTAINED        1.3#14
         ADI       R5,4            BUMP TO NEXT MAP              1.3#14
         M.CONBAH                  CONVERT TO HEX                1.3#14
         LA        R3,XGEA.X3D     LOCATE IN MESSAGE             1.3#14
         BL        XST2            STUFF HEX VALUE               1.3#14
         LNB       R5,XGEA.X3L                                   1.3#14
         LA        R6,XGEA.X3A                                   1.3#14
         BL        XTYPEF                                        1.3#14
XGEA.NM1 EQU       $                                             1.3#14
         BL        XABORT                                        1.3#14
XGEA.XMA DATAB     C' CATALOG<<FATAL>> INSUFFICIENT '            1.3#14
XGEA.XMD REZ       8B              "LOGICAL" OR "PHYSICAL"       1.3#14
         DATAB     C' MEMORY TO CATALOG THIS TASK.'              1.3#14
XGEA.XML DATAB     $-XGEA.XMA                                    1.3#14
*                                                                1.3#14
XGEA.X2A DATAB     C'   CATALOG REQUIRES A MINIMUM 32KB OF'      1.3#14
         DATAB     C' EXTENDED DATA SPACE TO EXECUTE.'           1.3#14
XGEA.X2L DATAB     $-XGEA.X2A                                    1.3#14
*                                                                1.3#14
XGEA.X3A DATAB     C'   LOGICAL MEMORY AT X"''                   1.3#14
XGEA.X3D REZ       8B                                            1.3#14
         DATAB     C'"'  IS UNEXPECTEDLY PRE-ALLOCATED!'         1.3#14
XGEA.X3L DATAB     $-XGEA.X3A                                    1.3#14
*                                                                1.3#14
XGEA.XT1 DATAD     C'LOGICAL '                                   1.3#14
XGEA.XT2 DATAD     C'PHYSICAL'                                   1.3#14
*                                                                1.3#04
*------------                                                    1.3#04
*                                                                1.3#04
XGEA.N   EQU       $                                             1.3#04+
         TRR       R1,R3                                         1.3#04
         ADI       R3,3            ADD MAXIMUN BOUND VALUE       1.3#04+
         SRL       R3,2            AND TRUNCATE                  1.3#04+
         SLL       R3,2            NOW BACK TO BYTES             1.3#04+
         STW       R3,XGEA.RET+3W  SAVE FOR USER                 1.3#04
* CHECK IF REQUEST CAN BE FILLED FROM POOL                       1.3#04
         CAMW      R3,XEASIZ                                     1.3#04
         BLE       XGEA.2          BR IF IT CAN                  1.3#15
* ELSE GET SOME FROM THE SYSTEM                                  1.3#04
         SUMW      R3,XEASIZ       CALCULATE THE SHORT FALL      1.3#04
         ES        R2              SET DVI                       1.3#04+
         DVMW      R2,XEAMBSIZ     CALCULATE NUMBER OF BLOCKS    1.3#04+
         TRR       R2,R2           IS THERE A REMAINDER          1.3#04
         BZ        $+2W            BR IF NOT                     1.3#04
         ADI       R3,1            ELSE BUMP MB COUNT            1.3#04
         TRN       R3,R1           SET UP FOR REQUEST LOOP       1.3#04+
         LW        R5,XEAEND       SET UP R5 INCASE ERROR ON 1ST 1.3#04+
XGEA.0   EQU       $                                             1.3#04
         M.GD            '         AND ASK FOR MEMORY            1.3#04+
         TRR       R4,R5           SAVE END ADDR                 1.3#04+
         TRR       R3,R3           ANY ERROR                     1.3#04
         BZ        XGEA.E0         BR IF ERROR                   1.3#04+
         BIB       R1,XGEA.0       AND LOOP FOR REQUESTED AMNT   1.3#04+
XGEA.1   EQU       $      WE HAVE ALL THERE IS OR REQUEST        1.3#04+
         STW       R4,XEAEND     SET UP CURRENT END              1.3#04+
         SUMW      R4,XEABEG     SUB OUT START                   1.3#04+
         STW       R4,XEASIZ       TO GET CURRENT FREE SIZE      1.3#04+
XGEA.2   EQU       $                                             1.3#04
         LW        R2,XEABEG       GET CURRENT BEGINNING         1.3#04
         STW       R2,XEAOLD.B     SAVE AS PREVIOUS BEGINNING    1.3#04
         TRR       R2,R4           SAVE IT IN CASE               1.3#04
         ADMW      R2,XGEA.RET+3W  ADD ROUNDED AMOUNT REQUESTED  1.3#04
         CAMW      R2,XEAEND       COMPARE TO CURRENT END        1.3#04
         BLE       XGEA.3          BR TO ALLOCATE TO CUSTOMER    1.3#04
         LW        R2,XEASIZ       ELSE GET AMOUNT AVAILABLE     1.3#04
         STW       R2,XGEA.RET+3W  AND TELL USER                 1.3#04
         BU        XGEA.4          THEN EXIT                     1.3#04
XGEA.3   EQU       $               HERE TO ALLOCATE POOL TO USER 1.3#04
         STW       R4,XGEA.RET+2W  STORE START ADDR IN USER REGS 1.3#04
         ADI       R4,1W           BUMP BEGINNING BY 1W          1.3#04+
         STW       R2,XEABEG       AND UPDATE CURRENT START      1.3#04
         LW        R4,XEAEND       GET THE END                   1.3#04
         SUR       R2,R4           CALCULATE SIZE                1.3#04
         STW       R4,XEASIZ       AND UPDATE                    1.3#04
XGEA.4   EQU       $               NOW WE CAN RETURN             1.3#04
         LF        R0,XGEA.RET      RECOVER THE USER REGS        1.3#04
         TRSW      R0              RETURN TO CALLER              1.3#04
XGEA.FLG DATAH     0               XGETEA FLAGS                  1.3#04+
XGEA.NFT EQU       0               IF SET, NOT FIRST TIME        1.3#04
*--------------------- HERE WHEN REQUEST FOR MEM ERRORS OUT      1.3#04
XGEA.E0  EQU       $                                             1.3#04+
         TRR       R5,R4           RECOVER LAST GOOD END         1.3#04+
         BU        XGEA.1          AND PROCESS WHAT WE GOT       1.3#04+
*                                                                1.3#04
         TITLE     XRETEA
*
*  XRETEA                                                        1.3#04
*                                                                1.3#04
*    THIS ENTRY POINT SUPPORTS A "RELEASE UNUSED" OPERATION      1.3#04
*  FOR POOL USERS. IT MAY BE CALLED ONCE AND ONLY ONCE AFTER     1.3#04
*  A CALL TO XGETEA TO GIVE BACK AN UNUSED PORTION AT THE END    1.3#04
*  OF WHAT WAS ALLOCATED. ANY AMOUNT UP TO ALL OF THE IMMEDIATE  1.3#04
*  PREVIOUS ALLOCATION MAY BE RETURNED.                          1.3#04
*                                                                1.3#04
*    INVALID REQUESTS WILL CAUSE EXACTLY THE AMOUNT LAST         1.3#04
*    ALLOCATED TO BE RETURNED.                                   1.3#04
*                                                                1.3#04
XRETEA   EQU       $                                             1.3#04
         STD       R4,XGEA.RET+4W  SAVE USER'S REG 4 & 5         1.3#04
         LW        R4,XEABEG       GET CURRENT BEG               1.3#04
         SUR       R1,R4           SUBTRACT LIBERATED AMOUNT     1.3#04
         CAMW      R4,XEAOLD.B     COMPARE TO PREVIOUS BEGINNING 1.3#04
         BLT       XREA.ERR        REPORT A PROBLEM              1.3#04
XREA.CON EQU       $                                             1.3#08
         STW       R4,XEABEG       SAVE AS CURRENT               1.3#04
         STW       R4,XEAOLD.B     AND AS PREVIOUS TO INHIBIT    1.3#04
         LW        R5,XEAEND       GET CURRENT END               1.3#04
         SUR       R4,R5           CALCULATE CURRENT SIZE        1.3#04
         STW       R5,XEASIZ       AND UPDATE                    1.3#04
XREA.XIT EQU       $               NOW RETURN                    1.3#04
         LD        R4,XGEA.RET+4W  RECOVER USER'S REG 4          1.3#04
         TRSW      R0              AND RETURN                    1.3#04
XREA.ERR EQU       $               IF AN INVALID CALL            1.3#04
         LW        R4,XEAOLD.B     LIMIT AMOUNT TO ALL OF IT     1.3#08
         BU        XREA.CON        AND GO FIX UP POINTERS        1.3#08+
*                                                                1.3#04
         BOUND     1F                                            1.3#04
XGEA.RET REZ       1F              HOLDS USER REGS               1.3#04
*                                                                1.3#04
XEAMBSIZ DATAW     0               HOLDS MACH TYPE MB SIZE       1.3#04+
XEABEG   DATAW     0               HOLDS FWA OF FREE AREA        1.3#04
XEAEND   DATAW     0               HOLDS LWA OF FREE AREA        1.3#04
XEASIZ   DATAW     0               HOLDS SIZE OF FREE SPACE      1.3#04
XEAOLD.B DATAW     0               HOLDS PREVIOUS XEABEG VALUE   1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
         TITLE XLFCCHK - SCAN FPT'S FOR CALLER SUPPLIED LFC      1.3#04
*                                                                1.3#04
*  ROUTINE SCANS FPT'S FOR DESIRED LFC                           1.3#04
*                                                                1.3#04
* IN     R3 = ADDR AT WHICH TO START/CONTINUE SEARCH             1.3#04
*             0 MEANS FIRST FPT                                  1.3#04
*        R5 = LFC TEXT TO MATCH ON SEARCH                        1.3#04
*                                                                1.3#04
* OUT    R3 = ADDR OF NEXT FPT, FIRST FPT IF END OF TABLE        1.3#04
*        R5 = ACTUAL LFC MATCHED, 0 MEANS NOT FOUND              1.3#04
*                                                                1.3#04
*   NOTE: R3 VALUE NOT USED ON FIRST-TIME CALL   0 OR NOT        1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
*                                                                1.3#04
XLFCCHK  EQU       $                                             1.3#04
         STD       R6,XLC.RS                                     1.3#04
         STW       R1,XLC.REG1     SAVE R1 VALUE                C021-32B
         SBM       XLC.FRST,XLC.FLGS   SET FIRST TIME FLAG       1.3#04
         BS        XLC.1           SKIP INIT CODE IF SET         1.3#04
*!!!!!!!!!!LW!!!!!!!!R3,C.TSAD!!!!!!!GET!TSA!ADDR!!!!!!!!!!!!!!!C021-32
         M.GTSAD                   GET TSA ADDR                 C021-32
         TRR       R1,R3           INTO R3                      C021-32
         LW        R1,XLC.REG1     RESTORE R1 VALUE             C021-32B
         LW        R6,T.FPTA,X3    GET ADDR OFTFPT TABLE         1.3#04
         STW       R6,XLC.FBEG     AND SAVE THIS FOR LATER CALLS 1.3#04
         LW        R6,T.SEGA,X3    ADDR OF SEG'S MARKS END OF FPT1.3#04
         STW       R6,XLC.FEND     AND SAVE IT                   1.3#04
         LW        R3,XLC.FBEG     NOW GET FPT ADDR              1.3#04
         NOP                                                     1.3#04
XLC.1    EQU       $                                             1.3#04
*        TRR       R3,R3           WHERE DO WE START             1.3#04
*        BNZ       XLC.2           SKIP IF USER KNOWS            1.3#04
         LW        R3,XLC.FBEG     START AT THE BEGINNING        1.3#04
XLC.2    EQU       $                                             1.3#04
         CAMW      R3,XLC.FEND     ARE WE DONE                   1.3#04
         BGE       XLC.3           BR IF YES                     1.3#04
         CAMW      R5,0,X3         COMPARE WITH FPT ENTRY        1.3#04
         BEQ       XLC.4           BR IF YES                     1.3#04
         ADI       R3,12           BUMP TO NEXT                  1.3#04
         BU        XLC.2           AND LOOP                      1.3#04
*                                                                1.3#04
XLC.3    EQU       $               HERE IF END OF FPT TABLE      1.3#04
         LW        R3,XLC.FBEG     RESTORE R3 TO START           1.3#04
         ZR        R5              SHOW NOT FOUND                1.3#04
         BU        XLC.XIT         AND RETURN                    1.3#04
*                                                                1.3#04
XLC.4    EQU       $               HERE WHEN THEY MATCH          1.3#04
         TRR       R2,R6           SAVE R2                       1.3#04
         LW        R2,2W,X3        GET RELATED FAT ADDR          1.3#04
         TBM       3,DFT.FLGS,X2   IS IT ASSIGNED TO NULL        1.3#04
         BNS       XLC.5           BR IF NOT                     1.3#04
         TRR       R6,R2           RESTORE R2                    1.3#04
         ZR        R5              SHOW NOT FOUND                1.3#04
         BU        XLC.6           AND QUIT                      1.3#04
XLC.5    EQU       $                                             1.3#04
         TRR       R6,R2           RESTORE R2                    1.3#04
         LW        R5,0W,X3        GET 1ST WRD                   1.3#04
XLC.6    EQU       $               HERE AFTER XLC.4 OR XLC.5     1.3#04
         ADI       R3,12           BUMP R3 TO NEXT               1.3#04
         CAMW      R3,XLC.FEND     IS IT TOO HIGH                1.3#04
         BLT       XLC.XIT         SKIP IF NOT                   1.3#04
         LW        X3,XLC.FBEG     RESTORE TO START              1.3#04
XLC.XIT  EQU       $                                             1.3#04
         LD        R6,XLC.RS       RECOVER R6,R7                 1.3#04
         TRSW      R0              GO HOME                       1.3#04
         NOP                                                     1.3#04
*                                                                1.3#04
         BOUND     1D                                            1.3#04
XLC.RS   DATAD     0               REGISTER SAVE AREA            1.3#04
XLC.FBEG DATAW     0               START OF FPT'S                1.3#04
XLC.FEND DATAW     0               ADDR+1 ENTRY OF LAST FPT      1.3#04
XLC.FLGS DATAW     0               STATUS FLAGS                  1.3#04
XLC.REG1 DATAW     0               REG. 1 SAVE AREA             C021-32B
XLC.FRST EQU       0               FIRST TIME FLAG               1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
         TITLE     XLFCBLD - BUILD LFCTAB FROM STATIC ASSIGNS    1.3#04
*                                                                1.3#04
*        THIS ROUTINE IDENTIFIES ALL STATICALLY ASSIGNED         1.3#04
*        LIBRARY,DIRECTORY AND DICTIONARY LFC'S AND BUILDS       1.3#04
*        THE REQUIRED LFCTAB ENTRIES.                            1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
*                                                                1.3#04
XLFCBLD  EQU       $                                             1.3#04
         STF       R0,XLB.RS       SAVE USER REGS                1.3#04
         ZR        R2              SET POINTER FOR LFCTAB STORES 1.3#04
         LW        R5,XLB.LIBC     ACTUAL LFC TO TEST            1.3#04
         LW        R4,XLB.DIRC     MATCHING DIRECTORY            1.3#04
         BL        XLB.SET         GO DO THIS PAIR               1.3#04
*                                                                1.3#04
         LI        R2,101W         SET POINTER TO LFCTAB         1.3#04
         LW        R5,XLB.LISC     SET ACTUAL LFC                1.3#04
         LW        R4,XLB.LIDC     AND MATCHING DIR LFC          1.3#04
         BL        XLB.SET         GO DO THIS PAIR               1.3#04
*                                                                1.3#04
         ZR        R1              INIT LIBRARY NUMBER           1.3#04
XLB.1    EQU       $               LOOP THRU ALL                 1.3#04
         CI        R1,100          DONE THEM ALL?                1.3#04
         BGE       XLB.2           BR,  IF YES                   1.3#04
         TRR       R1,R5           SET UP TO CONVERT             1.3#04
         BL        M0210                                         1.3#04
         ANMW      R7,XLB.MSK      KEEP LAST TWO DIGITS          1.3#04
         TRR       R7,R5           MOVE FOR LIB                  1.3#04
         TRR       R7,R4           MOVE FOR DIR                  1.3#04
         ORMW      R5,XLB.LCDE     ADD IN THE 'L'                1.3#04
         ORMW      R4,XLB.DCDE     ADD IN THE 'D'                1.3#04
         TRR       R1,R2           MOVE LIB # FOR INDEX          1.3#04
         SLL       R2,2            MAKE IT A BYTE OFFSET         1.3#04
         ABR       R2,29           R2 IS +1W TO ALLOW FOR "LIB"  1.3#04
         BL        XLB.SET         DO THIS PAIR                  1.3#04
         BIB       R1,XLB.1        LOOP FOR NEXT                 1.3#04
XLB.2    EQU       $               HERE WHEN DONE                1.3#04
         LF        R0,XLB.RS       RESTORE REGS                  1.3#04
         TRSW      R0              RETURN                        1.3#04
         NOP                       OUT OF EXECUTION PATH         1.3#04
*                                                                1.3#04
*----                                                            1.3#04
*                                                                1.3#04
XLB.SET  EQU       $               ROUTINE TO STORE LIB/DIR PAIR 1.3#04
         STW       R0,XLB.SRET     SAVE RETURN ADDR              1.3#04
         BL        XLFCCHK         SEE IF LIB IS ASSIGNED        1.3#04
         TRR       R5,R5           WELL WAS IT?                  1.3#04
         BZ        XLB.S2          BR IF NOT                     1.3#04
         ORMW      R5,LT.TYP1      ADD IN THE TYPE CODE          1.3#04
         STW       R5,LT.LIBS,X2   AND STORE IN LFCTAB           1.3#04
         TRR       R4,R5           SET UP FOR MATCHING DIR       1.3#04
         BL        XLFCCHK         IS IT ASSIGNED                1.3#04
         TRR       R5,R5           WAS IT?                       1.3#04
         BZ        XLB.S1          BR IF NOT                     1.3#04
         ORMW      R5,LT.TYP3      ADD IN TYPE CODE              1.3#04
         STW       R5,LT.DIRS,X2   AND STORE IN LFCTAB           1.3#04
         BU        XLB.S2          NOW GO ON                     1.3#04
XLB.S1   EQU       $               HERE IF RELEATED DIR NOT ASS  1.3#04
         ZMW       LT.LIBS,X2      RESET LIBRARY                 1.3#04
         STW       R4,XLB.SMD1     STORE DIRECTORY ID IN MSG     1.3#04
         LNB       R5,XLB.SML      GET MSG LENGTH                1.3#04
         LA        R6,XLB.SMSG     AND ADDR                      1.3#04
         BL        XTYPE           PRINT IT                      1.3#04
XLB.S2   EQU       $               HERE TO DO L00 - L99          1.3#04
         BU        *XLB.SRET       RETURN                        1.3#04
*                                                                1.3#04
*----                                                            1.3#04
*                                                                1.3#04
         BOUND     1F                                            1.3#04
XLB.RS   REZ       1F              REGISTER SAVE                 1.3#04
XLB.MSK  DATAW     X'0000FFFF'                                   1.3#04
XLB.LIBC GEN       8/0,24/C'LIB'                                 1.3#04
XLB.DIRC GEN       8/0,24/C'DIR'                                 1.3#04
XLB.LISC GEN       8/0,24/C'LIS'                                 1.3#04
XLB.LIDC GEN       8/0,24/C'LID'                                 1.3#04
XLB.LCDE GEN       8/0,8/C'L',16/0                               1.3#04
XLB.DCDE GEN       8/0,8/C'D',16/0                               1.3#04
XLB.SRET DATAW     0                                             1.3#04
*
         BOUND     1W
XLB.SMSG DATAB     C' CATALOG(WARNING) DIRECTORY     '           1.3#04&
XLB.SMD1 REZ       4B              HOLDS LFC                     1.3#04&
         DATAB     C'  NOT ASSIGNED, RELATED LIBRARY WILL'       1.3#04
         DATAB     C' --NOT-- BE SEARCHED.'                      1.3#04
XLB.SML  DATAB     $-XLB.SMSG      LENGTH EQUATE                 1.3#04
         BOUND     1W                                            1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
         TITLE     XLFCPAK - COMPRESS ZERO'S OUT OF LFC TABLE    1.3#04
*                                                                1.3#04
* XLFCPAK                                                        1.3#04
*                                                                1.3#04
*        THIS ROUTINE COMPRESSES ZERO'S (UNUSED ENTRIES) FROM    1.3#04
*        EACH AREA OF THE LFC CONTROL TABLE.                     1.3#04
*                                                                1.3#04
*        ACTIVE ENTRIES IN EACH AREA ARE MOVED TO THE BOTTOM     1.3#04
*        AND VACATED POSITIONS ARE ZERO'D.                       1.3#04
*                                                                1.3#04
*  IN    NOTHING                                                 1.3#04
* OUT    NOTHING                                                 1.3#04
*                                                                1.3#04
*        REGISTERS ARE --NOT-- PRESERVED!                        1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
*                                                                1.3#04
XLFCPAK  EQU       $                                             1.3#04
         TRR       R0,R7           SAVE RETURN                   1.3#04
         LA        R2,LT.LIBS      GET BASE ADDR OF LIB AREA     1.3#04
         LA        R4,LT.DIRS      LT.DIRS MARKS END OF LIB AREA 1.3#04
         BL        XLP.MOVE        MOVE ENTRIES DOWN             1.3#04
         STW       R6,LIBCNT       SAVE COUNT OF ACTIVE LIBS     1.3#04
*                                                                1.3#04
         LA        R2,LT.DIRS      NOW START AT LT.DIRS          1.3#04
         LA        R4,LT.DICTS     LT.DICTS MARKS END OF DIRS    1.3#04
         BL        XLP.MOVE        AND MOVE THESE GUYS DOWN      1.3#04
         CAMW      R6,LIBCNT       IS DIRCNT = LIBCNT            1.3#04
         BEQ       XLP.1           SKIP IF YES                   1.3#04
*>>>>>>>>>>SOME KIND OF ERROR HERE                               1.3#04
XLP.1    EQU       $                                             1.3#04
*                                                                1.3#04
         LA        R2,LT.DICTS     NOW DO DICTIONARIES           1.3#04
         LA        R4,LT.END       MARKS END OF DICTIONARY AREA  1.3#04
         BL        XLP.MOVE        AGAIN                         1.3#04
         STW       R6,DPLCNT       SAVE COUNT OF ACTIVE DATAPOOL 1.3#04
*                                                                1.3#04
         TRSW      R7              RETURN TO CALLER              1.3#04
         NOP                                                     1.3#04
*                                                                1.3#04
*----                                                            1.3#04
*                                                                1.3#04
XLP.MOVE EQU       $                                             1.3#04
         TRR       R2,R3           DUPLICATE START ADDR          1.3#04
         ZR        R6              RESET ACTIVE COUNT            1.3#04
XLP.M1   EQU       $               TOP OF LOOP                   1.3#04
         CAR       R4,R2           ARE WE DONE                   1.3#04
         BGE       XLP.MXIT        BR IF YES                     1.3#04
         LW        R5,0,X2         GET NEXT ENTRY                1.3#04
         BNZ       XLP.M2          BR IF ZERO                    1.3#04
         ABR       R2,29           BUMP THE IN POINTER PAST IT   1.3#04
         BU        XLP.M1          AND LOOP                      1.3#04
XLP.M2   EQU       $                                             1.3#04
         ZMW       0,X2            ZAP THE VACATED GUY           1.3#04
         STW       R5,0,X3         CONTINUE THE MOVE             1.3#04
         ABR       R6,31           BUMP ACTIVE COUNT             1.3#04
         ABR       R2,29           BUMP IN                       1.3#04
         ABR       R3,29           AND OUT                       1.3#04
         BU        XLP.M1          AND LOOP                      1.3#04
XLP.MXIT EQU       $                                             1.3#04
         TRSW      R0                                            1.3#04
         NOP                                                     1.3#04
*                                                                1.3#04
*----------------------------------------------------------------1.3#04
         TITLE     XLDOPN - OPEN Lxx/Dxx PAIR & WAIT IF BUSY        1.3
*                                                                   1.3
*  XLDOPN                                                           1.3
*                                                                   1.3
*        THIS ROUTINE OPENS A Lxx/Dxx PAIR OF FILES.                1.3
*   THE Lxx FILE IS OPENED FIRST. IF THIS FILE IS BUSY THEN WAIT    1.3
*   FOR IT TO COME AVAILABLE. ANY OTHER ERROR CAUSES ABORT. IF      1.3
*   TASK IS RUNNING INTERACTIVE THEN USER IS INFORMED IF BUSY       1.3
*   WAIT IS ENTERED. IN BATCH MODE NO MESSAGE IS ISSUED.            1.3
*   SIMILARLY, WHEN ACCESS IS OBTAINED, THE ONLINE USER IS          1.3
*   INFORMED.                                                       1.3
*                                                                   1.3
*        NEXT THE Dxx FILE IS ACCESSED. IF THIS FILE IS BUSY        1.3
*   THE Lxx  FILE IS CLOSED AND THE Dxx FILE IS ENQUED. THIS        1.3
*   IS INTENDED TO MINIMIZE DEADLOCK CONDITIONS. THE INTERACTIVE    1.3
*   USER IS INFORMED OF THE WAIT AND GRANT CONDITIONS AS WITH       1.3
*   THE Lxx FILE.                                                   1.3
*                                                                   1.3
*   ENTRY:   R5 = DEFAULT OPEN MODE                                 1.3
*            R6 = ADDR OF LIB FCB                                   1.3
*            R7 = ADDR OF DIR FCB                                   1.3
*                                                                   1.3
*    EXIT:  ALL REGS RETURNED AS SENT                               1.3
*                                                                   1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
*                                                                   1.3
XLDOPN   EQU       $                                                1.3
         STF       R0,XLDO.RET     SAVE RETURN ADDR                 1.3
         ZMB       XLDO.FLG        ZERO PROCESS FLAGS               1.3
         STB       R5,INIT.CNP+2W          INTO CNP                 1.3
         LI        R4,X'20'        SET EXPLICIT UNBLOCKED           1.3
         STB       R4,INIT.CNP+2W+1B       INTO CNP                 1.3
         ZMH       INIT.CNP+5H          ZAP THE STATUS FIELD        1.3
         ZMW       INIT.CNP+1W      ZAP ALTERNATE RETURN ADDR       1.3+
XLDO.10  EQU       $                                                1.3
         TBM       XLDO.LO,XLDO.FLG    IS Lxx OPEN                  1.3
         BS        XLDO.20           BRANCH IF OPEN                 1.3
         ZR        R3              INDICATE WAIT FOR FILE           1.3
         LA        R7,INIT.CNP     GET ADDR OF CNP                  1.3
         LW        R1,XLDO.RET+6W  GET ADDR OF LIB FCB              1.3
         BL        XOPENR          GO OPEN Lxx  FILE                1.3
         SBM       XLDO.LO,XLDO.FLG  AND SHOW IT OPEN               1.3
XLDO.20  EQU       $               NOW DO RELATED Dxx               1.3
         TBM       XLDO.DO,XLDO.FLG   IS Dxx OPEN                   1.3
         BS        XLDO.30         BRANCH IF OPEN                   1.3
         LI        R3,1            INDICATE RETURN IF BUSY          1.3
XLDO.21  EQU       $               HERE ON RETRY                    1.3
         LA        R7,INIT.CNP     GET ADDR OF CNP                  1.3
         LW        R1,XLDO.RET+7W  GET ADDR OF DIR FCB              1.3
         BL        XOPENR          GO OPEN IT                       1.3
         TRR       R3,R3           DID IT OPEN                      1.3
         BZ        XLDO.22         BRANCH IF OPEN                   1.3
         LW        R1,XLDO.RET+6W  RECOVER ADDR OF LIB FCB          1.3
         M.CLOSER                  CLOSE THE Lxx                    1.3
         ZBM       XLDO.LO,XLDO.FLG  AND SHOW IT CLOSED             1.3
         ZR        R3              INDICATE WAIT FOR FILE           1.3
         BU        XLDO.21         GO RETRY Dxx                     1.3
XLDO.22  EQU       $               HERE WHEN Dxx OPENS              1.3
         SBM       XLDO.DO,XLDO.FLG  SHOW IT OPEN                   1.3
         BU        XLDO.10         LOOP INCASE Lxx WAS CLOSED       1.3
XLDO.30  EQU       $               HERE TO GET OUT                  1.3
         LF        R0,XLDO.RET     RECOVER REGS                     1.3
         BU        *XLDO.RET       RETURN TO CALLER                 1.3
*----------------------------------------------------------------   1.3
         BOUND     1F                                               1.3
XLDO.RET REZ       1F              HOLDS USER REGS                  1.3
XLDO.FLG DATAW     0               FLAG WORD                        1.3
XLDO.LO  EQU       0               BIT 0 SET MEANS LIB IS OPEN      1.3
XLDO.DO  EQU       1               BIT 1 SET MEANS DIR IS OPEN      1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
         TITLE     XOPENR - OPEN FILE WITH WAIT FOR ACCESS          1.3
* XOPENR                                                            1.3
*                                                                   1.3
*        THIS ROUTINE OPENS THE REQUESTED FILE AND WAITS FOR        1.3
*    ACCESS IF FILE NOT AVAILABLE OR RETURNS AS INDICATED IN R3.    1.3
*                                                                   1.3
*    IF REQUESTED OPEN MODE IS FOR OUTPUT, ANY SPECIFICALLY         1.3
*    ASSIGNED OUTPUT MODE IS RETAINED( IFF SPECIFIC MODE IS         1.3
*    NUMERICALLY > REQUESTED MODE).                                 1.3
*                                                                   1.3
*    IF AN ERROR OCCURS, AND THE USER SUPPLIED CNP HAD A RETURN     1.3
*    ADDRESS THEN CONTROL IS TRANSFERRED TO THE RETURN ADDR.        1.3
*    OTHERWISE, TASK IS ABORTED WITH STATUS.                        1.3
*                                                                   1.3
*    ENTRY:     R1 = ADDR FOR FCB                                   1.3
*               R3 = ZERO MEANS TO WAIT IF FILE BUSY.               1.3
*                    ANY OTHER VALUE MEANS RETURN IF FILE BUSY.     1.3
*               R7 = ADDR OF APPROPRIATE CNP                        1.3
*                                                                   1.3
*      EXIT:   IF R3=0 IN                                           1.3
*               ALL REGS RETURNED.OFILEGWILL BE OPEN OR CNP         1.3
*               ALTERNATE RETURN(IFRSUPPLIED) IS TAKEN.             1.3
*               IF NO ALTERNATE SUPPLIED, TASK ABORTS.              1.3
*                                                                   1.3
*               IF R3#0 IN THEN, RETURN R3=0 IF OPEN                1.3
*                          ELSE RETURN R3#0 IF FILE BUSY.           1.3
*                          ANY OTHER ERROR CAUSES PROCESS ABORT.    1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
*                                                                   1.3
XOPENR   EQU       $                                                1.3
         STF       R0,XOP.RET      SAVE RETURN ADDR                 1.3
         TRR       R7,R2           USER CNP ADDR TO R2              1.3
         LB        R6,8B,X2        GET REQUESTED OPEN MODE          1.3
         CI        R6,1            IS IT READ                       1.3
         BEQ       XOP.01          SKIP IF READ                     1.3
*                                                                   1.3
* RETAIN ANY SPECIFICALLY ASSIGNED OUTPUT MODE THATS > REQUEST      1.3
*                                                                   1.3
         LW        R4,0W,X1        GET LFC                          1.3
         ANMW      R4,=X'00FFFFFF' AND LFC ONLY                     1.3
         LA        R1,PNTERS       GET POINTER SET ADDR             1.3
         ZR        R5              INDICATE WE'RE SENDING AN LFC    1.3
         ZR        R7              NO CNP                           1.3
         SVC       2,X'48'         M.INQUIRY                        1.3
         BS        XOP.IERR        PROCESS ERROR                    1.3
         LW        R3,PNTERS+1W    GET FAT ADDR                     1.3
         LB        R4,DFT.CACM,X3  GET CURRENT ACCESS MODE          1.3
         BZ        XOP.00          SKIP OPEN MODE CHANGE IF NONE    1.3
         CAMB      R4,8B,X2        COMPARE TO REQUESTED MODE        1.3
         BLE       XOP.00          SKIP CHANGE IFF <=               1.3
         STB       R4,8B,X2        ELSE USE ASSIGNED MODE           1.3
XOP.00   EQU       $                                                1.3
         LW        R1,XOP.RET+1W   RECOVER CALLING VALUES           1.3
         LW        R3,XOP.RET+3W          DITTO                     1.3
         LW        R7,XOP.RET+7W          DITTO                     1.3
*
XOP.01   EQU       $           ESTABLISH CORRECT WAIT ACTION        1.3
         LI        R4,1            SET IMEDIATE RETURN              1.3
         TBM       CTSM,CFLGS      ARE WE INTERACTIVE               1.3
         BS        XOP.02          SKIP  INFINITE SETTING IF YES    1.3
         TRR       R3,R3           DOES CALLER WANT CONTROL BACK    1.3
         BNZ       XOP.02          SKIP INFINITE SETTING IF YES     1.3
         ZR        R4              SET INFINITE WAIT                1.3
         NOP                                                        1.3
XOP.02   EQU       $               MERGE                            1.3
         STW       R4,0W,X2        VALUE TO CNP                     1.3
         LW        R4,1W,X2        GET ALTERNATE RETURN ADDR        1.3
         BNZ       $+2W            SKIP IF SUPPLIED                 1.3
         LA        R4,XOP.ERR0   ELSE USE INTERNAL ROUTINE          1.3
         STW       R4,XOP.EPNT     AND SET POINTER                  1.3
         ZMW       1W,X2           MAKE SURE NO ALT RETURN          1.3
*                                                                   1.3
XOP.1    EQU       $                                                1.3
         SVC       2,X'42'         DO THE OPEN (M.OPENR)            1.3
         BCT       1,XOP.ERR       ANY ERROR                        1.3
         ZMW       XOP.RET+3W      SHOW SUCCESS                     1.3
         ZBM       XOP.WD,XOP.FLGS RESET THE WAITED FLAG            1.3
         BNS       XOP.XIT         BRANCH IF IT WASN'T SET          1.3
         LB        R5,XOP.M2L      ELSE SET UP TO TELL USER         1.3
         LA        R6,XOP.MSG2     THAT WE ARE PROCEEDING.          1.3
         BL        XTYPEF                                           1.3
XOP.XIT  EQU       $                                                1.3
         LF        R0,XOP.RET                                       1.3
         TRSW      R0              RETURN TO CALLER                 1.3
         NOP                                                        1.3
*                                                                   1.3
*-----                                                              1.3
*                                                                   1.3
XOP.ERR  EQU       $                                                1.3
         TRR       R7,R2                                            1.3
         LH        R5,5H,X2        GET STATUS                       1.3
         CI        R5,51           IS IT COMPATABLE ACCESS ERROR    1.3
         BEQ       XOP.ERR1        THEN SAY SO                      1.3
         CI        R5,46           IS IT DUALPORT ACCESS PROBLEM    1.3
         BEQ       XOP.ERR1        THEN SAY SO                      1.3
         CI        R5,50           IS DUE TO LOCK                   1.3+
         BEQ       XOP.ERR1        THEN SAY SO                      1.3+
*                                                                   1.3+
*    GO TO CALLERS ALTERNATE RETURN OR INTERNAL ROUTINE             1.3+
*    AS INDICATED IN CNP                                            1.3+
*                                                                   1.3+
         BU        *XOP.EPNT                                        1.3+
*                                                                   1.3+
* SET APPROPRIATE ABORT MESSAGE                                     1.3
XOP.ERR0 EQU       $                                                1.3
         M.CONBAD                  CONVERT TO DECIMAL               1.3
         ANMW      R7,XOP.MSK1     EXTRACT LAST 2 DIGITS            1.3
         ORMW      R7,XOP.TYP      ADD IN TYPE CODE                 1.3
         LA        R3,XOP.M3D1     ADDR OF DATA                     1.3
         BL        XSTB            STORE DATA                       1.3
         LW        R7,0W,X1        GET THE LFC FROM FCB             1.3
         SLL       R7,8                                             1.3
         LA        R3,XOP.M3D2     DATA ADDR                        1.3
         BL        XSTB            AND STORE DATA                   1.3
         LNB       R5,XOP.M3L      GET LENGTH (SET "UT" & "SLO")    1.3
         LA        R6,XOP.MSG3     GET TEXT ADDR                    1.3
         BL        XTYPEF          AND ISSUE ERROR                  1.3
         BL        XABORT          NOW ABORT                        1.3
XOP.ERR1 EQU       $                                                1.3
         TRR       R3,R3           DID USER ASK FOR CONTROL?        1.3
         BNZ       XOP.XIT         THEN GIVE IT TO HIM              1.3
         SBM       XOP.WD,XOP.FLGS                                  1.3
         TBM       CTSM,CFLGS      ARE WE INTERACTIVE               1.3
         BNS       XOP.ERR2        SKIP MESSAGE IF NOT              1.3
         LW        R7,0W,X1        GET THE LFC FROM FCB             1.3
         SLL       R7,8                                             1.3
         LA        R3,XOP.M1D1     DATA ADDR                        1.3
         BL        XSTB            AND STORE DATA                   1.3
* ISSUE WAITING MESSAGE                                             1.3
         LA        R6,XOP.MSG1                                      1.3
         LB        R5,XOP.M1L                                       1.3
         BL        XTYPEF          TELL USER HE IS WAITING          1.3
XOP.ERR2 EQU       $               MERGE                            1.3
         ZMW       0W,X2           CONVERT CNP TO INFINITE WAIT     1.3
         LW        R7,XOP.RET+7W   RECOVER CNP ADDR                 1.3
         BU        XOP.1           GO REISSUE REQUEST               1.3
*                                                                   1.3
XOP.IERR EQU       $               HERE IF ERROR ON INQUIRY         1.3
         LW        R1,XOP.RET+1W   RECOVER FCB ADDR                 1.3
         TRR       R7,R5                                            1.3
         BU        XOP.ERR0        AND PROCESS                      1.3
*                                                                   1.3
         BOUND     1F                                               1.3
XOP.RET  REZ       1F              HOLDS USER REGS                  1.3
XOP.EPNT DATAW     0               ADDR OF NON-SPECIAL ERR PROC.    1.3
XOP.MSK1 DATAW     X'0000FFFF'     MASK FOR STATUS VALUE            1.3
XOP.TYP  DATAH     C'RM'           STATUS TYPE INDICATOR            1.3
         DATAH     0               PLUS FILLER FOR STATUS           1.3
*                                                                   1.3
XOP.MSG1 DATAB     C' CATALOG: waiting for access to  '             1.3
XOP.M1D1 REZ       3B                                               1.3
         DATAB     C',   enter WAKEUP to terminate.'                1.3
XOP.M1L  DATAB     $-XOP.MSG1                                       1.3
*                                                                   1.3
XOP.MSG2 DATAB     C' CATALOG: access granted, proceeding'          1.3
XOP.M2L  DATAB     $-XOP.MSG2                                       1.3
*                                                                   1.3
XOP.MSG3 DATAB     C' CATALOG<<FATAL>> STATUS='                     1.3
XOP.M3D1 REZ       4B                                               1.3
         DATAB     C'   OPENING LFC='                               1.3
XOP.M3D2 REZ       3B                                               1.3
         DATAB     C'.'                                             1.3
XOP.M3L  DATAB     $-XOP.MSG3                                       1.3
*                                                                   1.3
XOP.FLGS DATAW     0                                                1.3
XOP.WD   EQU       0                                                1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
         TITLE     XTYPE - OUTPUT MESSAGE TO "UT" IF INTERACTIVE    1.3
*                                                                   1.3
*    XTYPE                                                          1.3
*    PRINT ONE LINE ON UT  IFF ORIGIN IS INTERACTIVE                1.3
*    IFF R5 IS NEGATIVE THEN CALL XPRNT TO LOG SAME MESSAGE ON      1.3
*    SLO.                                                           1.3
*                                                                   1.3
*    USER CAN FORCE UT LOG OFF BY NOT ENTERING -CR- AT BOTTOM       1.3
*    OF SCREEN. ENTRY POINT  "XTYPEF" WILL WRITE THRU THIS          1.3
*    CONDITION. IT DOES NOT HOWEVER TURN UT BACK ON                 1.3
*                                                                   1.3
*        CALL R5  NUMBER OF CHARACTERS IN LINE                      1.3
*                 IF R5 NEGATIVE THEN PUT ON "SLO" ALSO             1.3
*             R6  ADDRESS OF DATA                                   1.3
*                                                                   1.3
*----------------------------------------------------------------   1.3
*                                                                   1.3
XTYPEF   EQU       $               WRITE REGARDLESS OF UT STATE     1.3
         SBM       XT.UTFRC,XT.FLGS                                 1.3
XTYPE    EQU       $                                                1.3
         ZBM       XT.SLO,XT.FLGS  RESET SLO ALSO FLAG              1.3
         TRR       R5,R5                                            1.3
         BP        XTYP.1          BRANCH IF R5 POSITIVE            1.3
         TRN       R5,R5           ELSE MAKE IT SO AND              1.3
         TBM       CSLOUT,CFLGS    IS SLO ON UT                     1.3
         BS        XTYP.1          THEN UT IS ENOUGH                1.3
         SBM       XT.SLO,XT.FLGS  INDICATE "SLO" OUTPUT            1.3
*                                                                   1.3
XTYP.1   EQU       $                                                1.3
         STF       R0,XTP.RSAV                                      1.3
         TBM       CTSM,CFLGS      ARE WE INTERACTIVE               1.3
         BNS       XTYP.2          BRANCH IF NOT                    1.3
         ZBM       XT.UTFRC,XT.FLGS  IS FORCE FLAG ON               1.3
         BS        XTYP.11         YES, DO IT REGARDLESS            1.3
         TBM       XT.UTOFF,XT.FLGS   IS UT OFF                     1.3
         BS        XTYP.2          THEN SKIP UT OUTPUT              1.3
XTYP.11  EQU       $                                                1.3
         STW       R6,UTFCB+FCB.ERWA    SET BUFFER ADDR IN FCB   |1.3Q32
         STW       R5,UTFCB+FCB.EQTY    SET XFER COUNT INTO FCB  |1.3Q32
         LA        R1,UTFCB        GET FCB ADDR                     1.3
         SVC       1,X'32'         AND ISSUE MESSAGE                1.3
         TBM       7,3W,X1         DID USER SUPPRESS?               1.3
         BNS       XTYP.2          BR IF NOT                        1.3
         SBM       XT.UTOFF,XT.FLGS ELSE TURN OFF UT                1.3
         SBM       XT.LOGED,XT.FLGS  SET TO INHIBIT ACTION MESSAGE  1.3+
         BS        XTYP.2            SKIP IF WE ALREADY DID IT      1.3+
         LI        R2,XT.ML        GET MESSAGE LENGTH            |1.3Q32
         STW       R2,UTFCB+FCB.EQTY     INTO FCB                |1.3Q32
         LA        R2,XT.MA        GET MESSAGE ADDR              |1.3Q32
         STW       R2,UTFCB+FCB.ERWA     INTO FCB                |1.3Q32
         SVC       1,X'32'           AND WRITE                      1.3+
XTYP.2   EQU       $                                                1.3
         LF        R0,XTP.RSAV                                      1.3
         ZBM       XT.SLO,XT.FLGS  RESET "SLO" FLAG                 1.3
         BNS       XTYP.3          RETURN IF NOT SET                1.3+
         ABR       R6,31           BUMP ADDR BY BY                  1.3+
         SUI       R5,1            DECREMENT COUNT                  1.3+
         BU        XPRNT           AND GOTO SLO WRITER              1.3+
XTYP.3   EQU       $                                                1.3+
         TRSW      R0              ELSE RETURN TO CALLER            1.3
XT.FLGS  DATAH     0               HOLDS XTYPE FLAGS AS FOLLOWS     1.3
XT.SLO   EQU       0               WHEN SET INDICATES CALL XPRNT    1.3
XT.UTOFF EQU       1               WHEN SET UT FORCE-OFF BY USER    1.3
XT.UTFRC EQU       2               ONESHOT FLAG TO FORCE OUTPUT     1.3
XT.LOGED EQU       3               SUPPRESS MESSAGE ISSUED          1.3+
         BOUND     1F                                               1.3
XTP.RSAV RES       1F                                               1.3
XTYP.MSK DATAW     X'0007FFFF'                                      1.3
*                                                                   1.3+
*!XT.LTCW  GEN       12/XT.ML,20/B(XT.MA)                           1.3+
XT.MA    DATAB     C' CATALOG: WARNING Message log to UT'           1.3+
         DATAB     C' suspended.'                                   1.3+
XT.ML    EQU       $-XT.MA                                          1.3+
         BOUND     1W                                               1.3+
*                                                                   1.3
*----------------------------------------------------------------   1.3
         TITLE     XPRNT    - OUTPUT LINE TO 'SLO'
***********************************************************************
*
*                  XPRNT
*
***********************************************************************
*
*        PRINT ONE LINE ON SLO WITH SINGLE SPACE CARRIAGE CONTROL.
*        OTHER CARRIAGE CONTROL CAN BE SPECIFIED IN LAST BYTE OF MPCCC*
*        CALL R5  NUMBER OF CHARACTERS IN LINE
*             R6  ADDRESS OF DATA
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
XPRNT    STF       R0,XPRNT90
XPRNT1   ZR        R1
         TRR       R6,R2
         TRN       R5,R3
         BEQ       XPRNT2.5
XPRNT2   LB        R4,0,R2         MOVE MSG TO BUFFER
         STB       R4,MPBUF,R1
         ABR       R1,31
         ABR       R2,31
         BIB       R3,XPRNT2
XPRNT2.5 ABR       R5,31           INCREMENT FOR CONTROL CHAR
         STW       R5,XPRNT91+9W   ..... TO FCB
         LA        R4,MPCCC+7      ADDRESS OF CONTROL CHARACTER
         STW       R4,XPRNT91+8W   TO FCB
XPRNT2.7 M.WRIT    XPRNT91         OUTPUT LINE OF TEXT
         TBM       CSLOUT,CFLGS    SLO=UT?                       1.3#10
         BNS       XPRNT2.8        SKIP IF NOT                   1.3#10
         TBM       7,3W,X1         EOM?                          1.3#10
         BNS       XPRNT2.9        SKIP IF NOT SET               1.3#14
         SBM       XSLOEOM,XFLGS   ELSE SET GLOBALLY             1.3#10
         BU        XPRNT2.9        CONTINUE                      1.3#14
XPRNT2.8 EQU       $               HERE IF SLO NOT TERMINAL      1.3#14
         TBM       7,3W,X1         TEST FOR EOM                  1.3#14
         BS        XPRNT.ER        ABORT                         1.3#14
         TBM       6,3W,X1         TEST FOR EOF                  1.3#14
         BNS       XPRNT2.9        CONTINUE IF NOT SET           1.3#14
         SBM       7,3W,X1         ELSE SET EOM                  1.3#14
         BU        XPRNT.ER        AND ABORT                     1.3#14
XPRNT2.9 EQU       $               CONTINUE                      1.3#14
         LI        R1,-16D
         LW        R5,=C'    '
         TRR       R5,R4           COPY BLANKS TO R4
         ZR        R2
XPRNT3   STD       R4,MPBUF,R2     BLANK FILL BUFFER
         ADI       R2,1D           INCREMENT INDEX BY DOUBLEWORD
         BID       R1,XPRNT3
         LI        R1,G' '         CARRIAGE CONTROL FOR NEXT LINE
         STB       R1,MPCCC+7      IS SINGLE SPACE
         LF        R0,XPRNT90
         TRSW      R0              RETURN
         NOP                                                     1.3#14
SLO.EOPN EQU       $               HERE IF ERROR ON SLO OPEN     1.3#14
         LH        R5,SLOCNP+5H    GET STATUS                    1.3#14
         M.CONBAD                  CONVERT TO DECIMAL            1.3#14
         ANMW      R7,=X'0000FFFF'  KEEP TWO DIGITS              1.3#14
         ORMW      R7,=G'RM"@@"@@'   OR IN IDENTIFIER              1.3#14
         TRR       R7,R3           MOVE TO CORRECT REGISTER      1.3#14
         BU        XPRNT.EC        AND ABORT                     1.3#14
*                                                                1.3#14
XPRNT.ER EQU       $               HERE IF I/O ERROR             1.3#14
         TBM       7,3W,X1         TEST EOM BIT                  1.3#14
         BS        XPRNT.EA        PROCESS EOM                   1.3#14
         TBM       2,3W,X1         TEST BB BIT                   1.3#14
         BS        XPRNT.EB        PROCESS BLOCKING BUFFER ERR   1.3#14
         LW        R3,=G'IO21'     ELSE SET CATCH ALL            1.3#14
         BU        XPRNT.EC        AND MERGE                     1.3#14
XPRNT.EA LW        R3,=G'IO98'     SET SIZE ERROR                1.3#14
         BU        XPRNT.EC        AND MERGE                     1.3#14
XPRNT.EB LW        R3,=G'IO16'     SET BB ERROR                  1.3#14
XPRNT.EC EQU       $               COMMON ABORT EXIT             1.3#14
         LW        R2,=G' ST='     SET MODIFIER                  1.3#14
         LW        R5,=G'CT04'     AND ABORT CODE                1.3#14
         ZR        R6                                            1.3#14
         ZR        R7                                            1.3#14
         SVC       1,X'62'         AND ABORT                     1.3#14
*                                                                1.3#14
         SPACE
XPRNT90  RES       1F
*
*-----------------------------------------------------------------------
         TITLE     XSIRD    - READ CATALOG DIRECTIVE
***********************************************************************
*
*                  XSIRD
*
***********************************************************************
*
*        DETERMINE WHERE TO READ CATALOG DIRECTIVES FROM        ETCM-32
*        ( SYC FILE, DIRECTIVES FILE, OR LOAD MODULE )          ETCM-32
*        AND READ IN THE NEXT CATALOG DIRECTIVE. IF DIRECTIVE   ETCM-32
*        SAVING IS NOT INHIBITED, THE DIRECTIVE IS WRITTEN      ETCM-32
*        TO THE DIRECTIVES TEMP FILE BUFFER FOR LATER INCLUSION ETCM-32
*        IN THE GENERATED LOAD MODULE.                          ETCM-32
*
*        RETURN R5  0 IF NO EOF IS READ
*                   1 IF AN EOF IS READ
*
***********************************************************************
XSIRD    STF       R0,XSIRD90
         ZMW       XSIRD90+5W
         ZMB       CCFLD
         ZMB       CCPTR
         SBM       XSIRDFST,XFLGS
         BS        XSIRD1          BR IF NOT FIRST ENTRY
         TBM       MOPT4,MFLAG2    SAVE DIRECTIVES?             ETCM-32
         BS        XSIRD.1         DON'T CREATE FILE IF NOT     ETCM-32
         TBM       MSOP4,MFLAG2    SET NODIRECTIVES READ?       ETCM-32
         BS        XSIRD.1         DON'T CREATE FILE IF SO      ETCM-32
         LA        R1,XDIRTMP      DIRECTIVE TEMP FILE FCB ADDR ETCM-32
         LI        R5,16           INITIAL SIZE 16 SECTORS      ETCM-32
         SBR       R5,1            SIGNAL DIRECTIVE TEMP CREATE ETCM-32
         LI        R6,4            4 SEGMENTS                   ETCM-32
         BL        XCRETMP         CREATE DIRECTIVES TEMP FILE  ETCM-32
         LI        R1,768          BUFFER WILL BE 1 SECTOR      ETCM-32
         BL        XGETEA          GET BUFFER                   ETCM-32
         CAR       R1,R3                                        ETCM-32
         BEQ       XSIRD.0                                      ETCM-32
         SBM       MOPT4,MFLAG2    SET NODIRECTIVES IF NO MEM   ETCM-32
         LNB       R5,SIRDM.1L     GET LENGTH OF MESSAGE        ETCM-32
         LA        R6,SIRDM.1A     GET MESSAGE ADDRESS          ETCM-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         BU        XSIRD.1         CONTINUE                     ETCM-32
XSIRD.0  STW       R2,XDIRTMP+8W   SAVE BUFFER ADDR IN FCB      ETCM-32
         STW       R2,TDADDR       AND IN BUFFER ADDR VARIABLE  ETCM-32
*!XSIRD.1!!LW!!!!!!!!R3,C.TSAD!!!!!!!GET!ADDR.!OF!OUR!TSA!!!!!!!C021-32
XSIRD.1  M.GTSAD                   GET TSA ADDR                 C021-32
         TRR       R1,R3           INTO R3                      C021-32
         LW        R2,T.LINBUF,R3  GET ADDR. OF THE LINE BUFFER   0311
         BZ        XSIRD05         IF NO LINE BUFFER OPEN SYC     0311
*!!!!!!!!M.TSCAN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR11086
*!!!!!!!!CAMD!!!!!!R6,BLANKS!!!!!!!IS!THIS!IN!"TSM"!MODE!!!!!!!!PR11086
*!!!!!!!!BEQ!!!!!!!XSIRD05!!!!!!!!!YES!GO!OPEN!"SYC"!FILE!!!!!!!PR11086
*!!!!!!!!LW!!!!!!!!R3,C.TSAD!!!!!!!GET!ADDRESS!OF!OUR!TSA!!!!!!!PR11086
*!!!!!!!!LW!!!!!!!!R2,T.LINBUF,R3!!GET!ADDRESS!OF!THE!LINE!BUFF!PR11086
*!!!!!!!!ADI!!!!!!!R2,5W!!!!!!!!!!!BUMP!POINTER!TO!LINE!BUFFER!!PR11086
*!XSIRD1.7!!LB!!!!!R5,0,R2!!!!!!!!!GET!LINE!BUFFER!CHARACTER!!!!PR11086
*!!!!!!!!CI!!!!!!!!R5,G' '!!!!!!!!!SKIP!OVER!'CATALOG'!!!!!!!!!!PR11086
*!!!!!!!!BEQ!!!!!!!$+3W!!!!!!!!!!!!GO!READ!IN!FILE!NAME!!!!!!!!!PR11086
*!!!!!!!!ADI!!!!!!!R2,1!!!!!!!!!!!!ADJUST!POINTERS!!!!!!!!!!!!!!PR11086
*!!!!!!!!BU!!!!!!!!XSIRD1.7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR11086
*!!!!!!!!ADI!!!!!!!R2,1!!!!!!!!!!!!ADJUST!INPUT!BUFF!POINTER!!!!PR11086
         M.CMD                                                  PR11086
         SUR       R7,R2           COMPUTE REL. START LOC.      PR11086A
         TRN       R2,R2           MAKE IT POS.                 PR11086A
         CI        R2,72           ARE WE PAST COL 72           PR11086A
         BGE       XSIRD05         FORGET IT                    PR11086A
         TRR       R7,R2           COPY START ADDR              PR11086
         BZ        XSIRD05         SKIP IF NO PARAMETER         PR11086
         TRN       R6,R7           SET LENGTH                   PR11086
         ZR        R3                                           ETCM-32
XSIRD1.8 LB        R5,0,R2         GET BYTE FROM LINE BUFFER    ETCM-32
*!!!!!!!!CI!!!!!!!!R5,X'0D'!!!!!!!!END!OF!LINE?!!!!!!!!!!!!!!!!!PR11086
*!!!!!!!!BEQ!!!!!!!XSIRD1.9!!!!!!!!DONE!IF!SO!!!!!!!!!!!!!!!!!!!PR11086
         STB       R5,PATHLOC,X3   SAVE BYTE IN PATHNAME BUFF   ETCM-32
         ADI       R3,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
*!!!!!!!!BU!!!!!!!!XSIRD1.8!!!!!!!!NEXT!BYTE!!!!!!!!!!!!!!!!!!!!PR11086
         BIB       R7,XSIRD1.8     AND LOOP                     PR11086
XSIRD1.9 STB       R3,PNRLB        SAVE LENGTH OF FILE NAME     ETCM-32
         LA        R2,PNRLB        GET ADDRESS OF LOG BLOCK     ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'29'         M.LOGR                       ETCM-32
         TBM       4,PNRLB+7W      WAS FILE LOCATED             ETCM-32
         BS        XSRD.0          BRANCH IF FOUND              ETCM-32
         LNB       R5,SIRDM.2L     GET MESSAGE LENGTH           ETCM-32
         LA        R6,SIRDM.2A     GET MESSAGE ADDRESS          ETCM-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         BU        XSIRD05         CONTINUE                     ETCM-32
XSRD.0   LW        R1,PNRLB        GET PATHNAME VECTOR          ETCM-32
         SBM       MLOCF,MFLAG3    SET FLAG FOR PATHNAME STRING ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!LA!!!!!!!!R6,LIBRD!!!!!!!!GET!ADDRESS!OF!RD!BUFFER!!!!!ERMS-34
*!!!!!!!!ZR!!!!!!!!R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!SVC!!!!!!!2,X'2C'!!!!!!!!!M.LOC!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
         M.LOC     PNRLB,LIBRD,CHKCNP   GET RD FOR FILE         ERMS-34
         LB        R5,LIBRD+64W    GET FILE TYPE FROM RD        ETCM-32
         CI        R5,X'CA'        IS IT A LOAD MODULE?         ETCM-32
         BEQ       XSIRD1.A        DIRECTIVES FROM LOAD MOD     ETCM-32
         LA        R1,XSIRD91      ADDRESS OF SYC FCB           ETCM-32
         M.DASN                    DEASSIGN SYC FILE            ETCM-32
         LW        R7,SYCLFC       GET SYC LFC                  ETCM-32
         SLL       R7,8            POSITION                     PR11085
         LA        R3,LFCLOC       LOCATION TO PUT IT           ETCM-32
         BL        XSTB            PUT FCB IN CALL BLOCK        ETCM-32
         LB        R5,PNRLB        GET LENGTH OF FILE NAME      ETCM-32
         ADI       R5,12           ADD FIXED LENGTH STUFF       ETCM-32
         STW       R5,SCOUNT       SAVE BYTE COUNT IN CALL BLK  ETCM-32
         ZR        R7                                           ETCM-32
         M.TSMPC   LIBPCB          GET RRS                      ETCM-32
         LA        R1,LIBRS        ADDRESS OF RETURNED RRS      ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'52'    ASSIGN DIRECTIVES FILE TO SYC     ETCM-32
         TRR       R7,R7           CHECK STATUS                 ETCM-32
         BEQ       XSR.1           CONTINUE IF OK               ETCM-32
         TRR       R7,R5           STATUS TO R5                 ETCM-32
         M.CONBAD                  CONVERT TO ASCII             ETCM-32
         ANMW      R7,=X'0000FFFF'                              ETCM-32
         LA        R3,SIRDM.3S     PLACE TO PUT STATUS          ETCM-32
         BL        XSTB            PUT STATUS IN MESSAGE        ETCM-32
         LNB       R5,SIRDM.3L     MESSAGE LENGTH               ETCM-32
         LA        R6,SIRDM.3A     MESSAGE ADDRESS              ETCM-32
         BL        XTYPEF          PUT OUT MESSAGE              ETCM-32
         BL        XABORT          AND ABORT                    ETCM-32
XSR.1    SBM       MDIRFIL,MFLAG2  SHOW DIRECTIVES FROM FILE    ETCM-32
         BU        XSIRD05         PROCESS DIRECTIVES           ETCM-32
XSIRD1.A LW        R7,=C'LMD '     LOAD MODULE DIRECTIVES LFC   ETCM-32
         LA        R3,LFCLOC       PLACE TO PUT IT              ETCM-32
         BL        XSTB            PUT LFC IN CALL BLOCK        ETCM-32
         LB        R5,PNRLB        GET PATHNAME LENGTH          ETCM-32
         ADI       R5,12           ADD FIXED LENGTH STUFF       ETCM-32
         STW       R5,SCOUNT       SAVE BYTE COUNT IN CALL BLK  ETCM-32
         ZR        R7                                           ETCM-32
         M.TSMPC   LIBPCB          GET RRS                      ETCM-32
         LA        R1,LIBRS        ADDRESS OF RETURNED RRS      ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'52'         ASSIGN LOAD MODULE FILE      ETCM-32
         TRR       R7,R7           CHECK STATUS                 ETCM-32
         BEQ       XSR.2           CONTINUE IF OK               ETCM-32
         TRR       R7,R5           STATUS TO R5                 ETCM-32
         M.CONBAD                  CONVERT TO ASCII             ETCM-32
         ANMW      R7,=X'0000FFFF'                              ETCM-32
         LA        R3,SIRDM.4S     PLACE TO PUT STATUS          ETCM-32
         BL        XSTB            PUT STATUS IN MESSAGE        ETCM-32
         LNB       R5,SIRDM.4L     MESSAGE LENGTH               ETCM-32
         LA        R6,SIRDM.4A     MESSAGE ADDRESS              ETCM-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,SIRDM.5L     SECOND HALF OF MESSAGE       ETCM-32
         LA        R6,SIRDM.5A     LENGTH                       ETCM-32
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         BU        XSIRD05         READ FROM SYC                ETCM-32
XSR.2    LI        R1,768          DO 1 SECTOR READS            ETCM-32
         BL        XGETEA          GET BUFFER FOR READS         ETCM-32
         CAR       R1,R3           DID WE?                      ETCM-32
         BEQ       XSR.3           CONTINUE IF MEM ALLOCATED    ETCM-32
         LNB       R5,SIRDM.6L     MESSAGE LENGTH               ETCM-32
         LA        R6,SIRDM.6A     MESSAGE ADDRESS              ETCM-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,SIRDM.5L     LENGTH OF SECOND HALF        ETCM-32
         LA        R6,SIRDM.5A     ADDRESS                      ETCM-32
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         BU        XSIRD05         READ FROM SYC                ETCM-32
XSR.3    STW       R2,XLMDIRS+8W   SAVE BUFFER ADDRESS          ETCM-32
         STW       R2,LDADDR       HERE TOO                     ETCM-32
         M.OPENR   XLMDIRS,LMDCNP  OPEN LOAD MODULE FILE        ETCM-32
         M.READ    XLMDIRS         READ PREAMBLE                ETCM-32
         LW        R3,LDADDR       GET BUFFER ADDRESS           ETCM-32
         LW        R4,PR_CATD,X3   GET DIRECTIVE SECTOR NUMBER  ETCM-32
         BNZ       $+8W            GO READ DIRECTIVES FROM LM   ETCM-32
         LNB       R5,SIRDM.7L     MESSAGE LENGTH               PR11087
         LA        R6,SIRDM.7A     MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,SIRDM.8L     SECOND HALF                  PR11087
         LA        R6,SIRDM.8A                                  PR11087
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         BU        XSIRD05         OPEN SYC                     PR11087
         SBM       MLMDIR,MFLAG2   SHOW LOAD MODULE DIRECTIVES  ETCM-32
         SUI       R4,1            BACK UP ONE SECTOR           ETCM-32
         TRN       R4,R4           NEGATE SKIP COUNT            ETCM-32
         LA        R1,XLMDIRS      FCB ADDRESS                  ETCM-32
         SVC       1,X'33'         SKIP FORWARD IN FILE         ETCM-32
         BIB       R4,$-1W                                      ETCM-32
         M.READ    XLMDIRS         READ IN DIRECTIVES           ETCM-32
         ZMW       LDPNTR          INITIALIZE BUFFER POINTER    ETCM-32
         BU        XSIRD1          PROCESS DIRECTIVES           ETCM-32
         ZR        R3              DESTINATION BUFFER INDEX
         LI        R1,-18W         LOOP COUNT
XSIRD03  LW        R5,5W,R2        PICK UP BUFFER
         STW       R5,MDBUF,R3     COPY TO "MDBUF"
         ABR       R2,29
         ABR       R3,29
         BIW       R1,XSIRD03      COPY 72 CHARACTERS
         SBM       6,XSIRD91+3W    SET "EOF" FLAG
         LI        R1,18W          GET LENGTH OF BUFFER          1.3#14
         STH       R1,MDBFL        AND SAVE FOR USERS            1.3#14
         BU        XSIRD2          TAKE NORMAL EXIT FIRST TIME
XSIRD05  M.OPENR   XSIRD91,READCNP  OPEN 'SYC'                     1100A
         M.INQUIRY PNTERS,SYCLFC                                PR11085
         LW        R3,PNTERS+1W    GET FAT ADDR                 PR11085
         LW        R5,0W,X3        GET FIRST WRD OF FAT         PR11085
         ZBM       CCISYC,CFLGS    RESET CI=SYC FLAG            PR11085
*                                                               PR11085
         TBM       7,DFT.STB,X3 IS IT A "TSM"  RESOURCE         PR11085
         BNS       XSIRD05A        TRY FOR REAL SYC IF NOT      PR11085
         SBM       CCISYC,CFLGS    ELSE SET CI=SYC FLAG         PR11085
         BU        XSIRD1          ANS CONTINUE                 PR11085
XSIRD05A LB        R5,DFT.ACF,X3   GET SYSTEM FILE CODE         PR11085
         BZ        XSIRD1          SKIP IF NOT SYSTEM FILE      PR11085
         SBM       CCISYC,CFLGS    ELSE SET CI=SYC FLAG         PR11085
*                                                               PR11085
*   HERE AFTER FIRST TIME THROUGH                               PR11085
*                                                               PR11085
XSIRD1   TBM       MLMDIR,MFLAG2   DIRECTIVES FROM LOAD MODULE? ETCM-32
         BNS       XSIRD1.B        READ FROM SYC IF NOT         ETCM-32
         TBM       6,XLMDIRS+3W    DONE WITH LM DIRECTIVES?     ETCM-32
         BS        XSIRD1A         EXIT OUT IF SO               ETCM-32
         ZR        R3                                           ETCM-32
         LI        R5,G' '         GET A BLANK                  ETCM-32
XSIRD1.C STB       R5,MDBUF,X3     BLANK OUT MDBUF              ETCM-32
         CI        R3,79           AT THE END                   ETCM-32
         BEQ       XSIRD1.D        DONE IF SO                   ETCM-32
         ADI       R3,1            ADJUST POINTER               ETCM-32
         BU        XSIRD1.C        KEEP GOING                   ETCM-32
XSIRD1.D LW        R3,LDPNTR       POINTER TO DIRECTIVE BUFF    ETCM-32
         CI        R3,767          AT END OF BUFFER             ETCM-32
         BLE       XSIRD1.E        NO...READ DIRECTIVE          ETCM-32
XSRD.1   M.READ    XLMDIRS         READ IN ANOTHER SECTOR       ETCM-32
         ZMW       LDPNTR          CLEAR BUFFER POINTER         ETCM-32
         BU        XSIRD1.D        LOOP BACK                    ETCM-32
XSIRD1.E ZR        R2                                           ETCM-32
         ADMW      R3,LDADDR       ADD BUFFER ADDRESS           ETCM-32
XSIRD1.F LB        R5,0,X3         GET BYTE FROM BUFFER         ETCM-32
         CI        R5,X'04'        LAST DIRECTIVE IN SECTOR?    ETCM-32
         BEQ       XSRD.1          READ ANOTHER SECTOR IF SO    ETCM-32
         CI        R5,X'03'        END OF THIS DIRECTIVE?       ETCM-32
         BEQ       XSRD.2          PROCESS DIRECTIVE            ETCM-32
         STB       R5,MDBUF,X2     PUT BYTE IN MDBUF            ETCM-32
         ADI       R2,1            ADJUST POINTERS              ETCM-32
         ADI       R3,1                                         ETCM-32
         BU        XSIRD1.F        NEXT BYTE                    ETCM-32
XSRD.2   STH       R2,MDBFL        SAVE LENGTH OF DIRECTIVE     ETCM-32
         TRR       R2,R5                                        ETCM-32
         ADI       R2,1            ADD ONE FOR EOL CHARACTER    ETCM-32
         ARMW      R2,LDPNTR       ADD LENGTH TO BUFF POINTER   ETCM-32
         BU        XSRD.3          PROCESS DIRECTIVE            ETCM-32
XSIRD1.B TBM       6,XSIRD91+3W    WAS EOF DETECTED ON FIRST READ
         BS        XSIRD1A
         M.READ    XSIRD91         READ CATALOG DIRECTIVE
         TBM       6,XSIRD91+3W    WAS EOF                       1.3#08
         BS        XSIRD1C         TELL USER                    C017-32
         TBM       7,XSIRD91+3W    WAS IT EOM                    1.3#08
         BS        XSIRD1C          TELL USER                   C017-32
         LW        R5,XSIRD91+4W   GET XFER LENGTH               1.3#14
         CI        R5,72           LINE LONGER THAN 72 CHARS    PR11370
         BLE       $+2W            BRANCH IF NOT                PR11370
         LI        R5,72           TRUNCATE LINE TO 72 CHARS    PR11370
         STH       R5,MDBFL        AND SAVE FOR USERS            1.3#14
         TRR       R5,R3           LENGTH TO INDEX              PR11086
         BZ        XSIRD1.B        REREAD IF NULL               PR11086
         LI        R6,X'20'        GET A "CR"                   PR11086
XSRD1B.1 CEQU      $                                            PR11086
         CI        R3,80           DID WE GET A FULL LOAD       PR11086
         BGT       XSRD1B.2        GO HANDLE LONG  LINES        PR11086
         STB       R6,MDBUF,X3     AND SET EOL                  PR11086
         ADI       R3,1            NOW BUMP COUNT               PR11086
         BU        XSRD1B.1        AND LOOP                     PR11086
XSRD1B.2 CEQU      $               AND CONTINUE                 PR11086
XSRD.3   TBM       MOPT4,MFLAG2    DIRECTIVE SAVING INHIBITED?  ETCM-32
         BS        XSIRD1.0        DON'T SAVE DIRECTIVE IF SO   ETCM-32
         TBM       MSOP4,MFLAG2    WAS SET NODIRECTIVES READ?   ETCM-32
         BS        XSIRD1.0        DON'T SAVE DIRECTIVES IF SO  ETCM-32
XSIRD1.6 TRR       R5,R3           DIRECTIVE LENGTH TO R3       ETCM-32
         SUI       R3,1            DON'T READ EOL CHARACTER     ETCM-32
XSRD.4   CI        R3,0            DONE WITH THIS DIRECTIVE     ETCM-32
         BEQ       XSRD.5          SAVE DIRECTIVE IN BUFFER     ETCM-32
         LB        R5,MDBUF,X3     GET BYTE OF DIRECTIVE        ETCM-32
         CI        R5,G' '         IS IT A BLANK                ETCM-32
         BNE       XSRD.5          DONE IF NOT                  ETCM-32
         SUI       R3,1            NEXT BYTE                    ETCM-32
         BU        XSRD.4                                       ETCM-32
XSRD.5   ADI       R3,1            ADD ONE FOR EOL CHARACTER    ETCM-32
         STH       R3,MDBFL        SAVE DIRECTIVE LENGTH        ETCM-32
         TRR       R3,R5           MOVE IT TO R5                ETCM-32
         LW        R3,TDPNTR       GET CURRENT CHAR COUNT       ETCM-32
         ADR       R5,R3           ADD  COUNT FOR THIS LINE     ETCM-32
         ADI       R3,1            PLUS 1 FOR END OF LINE CHAR  ETCM-32
         CI        R3,768          WILL IT FIT IN BUFFER        ETCM-32
         BLT       XSIRD1.5        YES...PUT IT IN BUFFER       ETCM-32
         LW        R3,TDPNTR       GET CURRENT CHAR COUNT       ETCM-32
         STW       R3,XDIRTMP+9W   SAVE IN FCB                  ETCM-32
         ABM       31,XDIRTMP+9W                                ETCM-32
         ADMW      R3,TDADDR       ADD CURR PNTR TO START ADDR  ETCM-32
         TRR       R5,R6           SAVE LENGTH FOR LATER        C016-32
         LI        R5,X'04'        LAST DIRECTIVE IN SECTOR     ETCM-32
         STB       R5,0,X3         PUT IN BUFFER                ETCM-32
         M.WRIT    XDIRTMP         WRITE OUT BUFFER             ETCM-32
         ZMW       TDPNTR          CLEAR OUT COUNT              ETCM-32
         ABM       31,DIRSECTS     BUMP SECTOR COUNT            ETCM-32
         TRR       R6,R5           RESTORE DIRECTIVE LENGTH     C016-32
         BU        XSIRD1.6        BRANCH BACK                  ETCM-32
XSIRD1.5 LW        R3,TDADDR       GET BUFFER ADDR              ETCM-32
         LW        R5,TDPNTR       GET CURRENT CHAR COUNT       ETCM-32
         ADR       R5,R3           BUFFER LOCATION INTO R3      ETCM-32
         LH        R5,MDBFL                                     ETCM-32
         ADI       R5,1            EOL CHARACTER                ETCM-32
         ARMW      R5,TDPNTR       UPDATE CHAR COUNT            ETCM-32
         ZR        R2                                           ETCM-32
XSIRD1.3 CAMH      R2,MDBFL        DONE WITH  THIS LINE         ETCM-32
         BEQ       XSIRD1.4        YES                          ETCM-32
         LB        R5,MDBUF,X2     GET CHARACTER                ETCM-32
         STB       R5,0,X3         PUT IN DIRECTIVES FILE BUFF  ETCM-32
         ADI       R2,1            BUMP POINTERS                ETCM-32
         ADI       R3,1                                         ETCM-32
         BU        XSIRD1.3        NEXT CHARACTER               ETCM-32
XSIRD1.4 LI        R5,X'03'        EOL CHARACTER                ETCM-32
         STB       R5,0,X3         STORE IN BUFFER              ETCM-32
*                                                                1.3#08
*!XSIRD1.0!!TBM!!!!MOPTTXT,MFLGS!!!IS!OPTION!TEXT!ON!!!!!!!!!!!!PR11085
*!!!!!!!!BNS!!!!!!!XSIRD1.1!!!!!!!!ECHO!IF!NOT!!!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!TBM!!!!!!!CTSM,CFLGS!!!!!!ARE!WE!INTERACTIVE!!!!!!!!!!!PR11085
*!!!!!!!!BNS!!!!!!!XSIRD1.2!!!!!!!!DONT!ECHO!IF!NOT!!!!!!!!!!!!!PR11085
*!!!!!!!!TBM!!!!!!!CSLOUT,CFLGS!!!!SLO=UT?!!!!!!!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!BS!!!!!!!!XSIRD1.2!!!!!!!!DONT!ECHO!IF!IT!IS!!!!!!!!!!!PR11085
*!XSIRD1.1!!EQU!!!!$!!!!!!!!!!!!!!!DO!THE!ECHO!!!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!LA!!!!!!!!R6,MDBUF!!!!!!!!ADDR!OF!MDBUF!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!TBM!!!!!!!MLMDIR,MFLAG2!!!DIRECTIVES!FROM!LOAD!MODULE!!PR11085
*!!!!!!!!BNS!!!!!!!$+3W!!!!!!!!!!!!SKIP!IF!NOT!!!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!LH!!!!!!!!R5,MDBFL!!!!!!!!GET!DIRECTIVE!LENGTH!!!!!!!!!PR11085
*!!!!!!!!BU!!!!!!!!$+2W!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!LW!!!!!!!!R5,XSIRD91+4W!!!GET!LENGTH!!!!!!!!!!!!!!!!!!!PR11085
*!!!!!!!!BL!!!!!!!!XPRNT!!!!!!!!!!!AND!LOG!ON!SLO!!!!!!!!!!!!!!!PR11085
*!XSIRD1.2!!EQU!!!!$!!!!!!!!!!!!!!!DONT!DO!THE!ECHO!!!!!!!!!!!!!PR11085
XSIRD1.0 CEQU      $               CHECK PRINTING REQ'S         PR11085
         TBM       MOPTTXT,MFLGS   IS OPTION TEXT SET           PR11085
         BNS       XSIRD101        THEN WRITE TO LO FILE        PR11085
         TBM       CLOSLO,CFLGS    IS LO=SLO                    PR11085
         BNS       XSIRD101        WRITE IF NOT                 PR11085
         TBM       CCISYC,CFLGS    IS CI FILE ON SYC            PR11085
         BS        XSIRD102        WE'RE DONE IF IT IS          PR11085
XSIRD101 LA        R6,MDBUF        SET UP BUFFER ADDR           PR11085
         LH        R5,MDBFL        AND LENGTH                   PR11085
         BL        XPRNT           AND NOW WRITE IT TO LO       PR11085
XSIRD102 TBM       CTSM,CFLGS      ARE WE INTERACTIVE           PR11085
         BNS       XSIRD109        FINISHED IF NOT              PR11085
         TBM       MOPTTXT,MFLGS   OPTION TEXT ON?              PR11085
         BNS       XSIRD109        FINISHED IF NOT              PR11085
*!!!!!!!!TBM!!!!!!!CCISYC,CFLGS!!!!IS!CI!ON!SYC!!!!!!!!!!!!!!!!!PR11085B
*!!!!!!!!BS!!!!!!!!XSIRD109!!!!!!!!FINISHED!IF!IT!IS!!!!!!!!!!!!PR11085B
         TBM       CSLOUT,CFLGS    IS SLO ON UT                 PR11085
         BS        XSIRD109        FINISHED IF IT IS            PR11085
         LA        R6,MDBUF-1      ELSE GET ADDR                PR11085
         LH        R5,MDBFL        LENGTH                       PR11085
         ADI       R5,1                                         PR11085
         BL        XTYPE           AND TYPE                     PR11085
XSIRD109 CEQU      $               WE'RE DONE WITH THIS STUFF   PR11085
*                                                                1.3#08
         LB        R6,MDBUF        GET FIRST CHARACTER           1.3#08
         CI        R6,X'2A'        IS IT A "*"                   1.3#08
         BEQ       XSIRD1          THEN LOOP FOR ANOTHER         1.3#08
*                                                                1.3#08
         LW        R6,MDBUF        CHECK FOR EXIT/X
         CAMW      R6,=C'EXIT'
         BEQ       XSIRD1B         BRANCH IF 'EXIT'
         CAMW      R6,=C'X   '
         BNE       XSIRD1C         BRANCH IF NOT 'X'
XSIRD1B  SBM       6,XSIRD91+3W    SET E-O-F
         SBM       MEXIT,MFLAG3    SHOW EXIT DIRECTIVE READ     C017-32
XSIRD1C  TBM       6,XSIRD91+3W    TEST FOR EOF
         BNS       XSIRD2
         TBM       MOPT4,MFLAG2    DIRECTIVE SAVING INHIBITED?  ETCM-32
         BS        XSIRD1D         DON'T WRITE DIRECTIVES IF SO ETCM-32
         TBM       MSOP4,MFLAG2    SET NODIRECTIVES READ?       ETCM-32
         BS        XSIRD1D         DON'T WRITE DIRECTIVES IF SO ETCM-32
         LW        R3,TDPNTR       GET CURRENT CHAR COUNT       ETCM-32
         TBM       MEXIT,MFLAG3    WAS EXIT DIRECTIVE READ      C017-32
         BS        XSR1C           BRANCH IF SO                 C017-32
         ADI       R3,6            ADD LENGTH OF EXIT/EOL/EOS   C017-32
         CI        R3,768          WILL IT FIT IN BUFFER        C017-32
         BLE       XSR2C           YES...BRANCH                 C017-32
         LW        R3,TDPNTR       GET CURRENT CHAR COUNT       C017-32
         STW       R3,XDIRTMP+9W   SAVE IN FCB                  C017-32
         ABM       31,XDIRTMP+9W   ADD IN ONE FOR EOS CHARACTER C017-32
         ADMW      R3,TDADDR       FORM POINTER INTO BUFFER     C017-32
         LI        R5,X'04'        GET END OF SECTOR CHAR       C017-32
         STB       R5,0,X3         PUT IN BUFFER                C017-32
         M.WRIT    XDIRTMP         WRITE BUFFER OUT             C017-32
         ABM       31,DIRSECTS     BUMP SECTOR COUNT            C017-32
         LW        R3,TDADDR       GET BUFFER ADDRESS           C017-32
         LI        R5,G'E'         PLACE EXIT/EOL/EOS IN BUFF   C017-32
         STB       R5,0,X3                                      C017-32
         LI        R5,G'X'                                      C017-32
         STB       R5,1,X3                                      C017-32
         LI        R5,G'I'                                      C017-32
         STB       R5,2,X3                                      C017-32
         LI        R5,G'T'                                      C017-32
         STB       R5,3,X3                                      C017-32
         LI        R5,X'03'                                     C017-32
         STB       R5,4,X3                                      C017-32
         LI        R5,X'04'                                     C017-32
         STB       R5,5,X3                                      C017-32
         LI        R5,6            LENGTH OF EXIT/EOL/EOS       C017-32
         STW       R5,XDIRTMP+9W   STORE IN FCB                 C017-32
         M.WRIT    XDIRTMP         WRITE OUT BUFFER             C017-32
         ABM       31,DIRSECTS     BUMP SECTOR COUNT            C017-32
         BU        XSIRD1D         DEASSIGN AND EXIT            C017-32
XSR2C    LW        R3,TDPNTR       GET CURRENT CHAR COUNT       C017-32
         STW       R3,XDIRTMP+9W   SAVE IN FCB                  C017-32
         ABM       29,XDIRTMP+9W   ADD LENGTH OF EXIT/EOL/EOS   C017-32
         ABM       30,XDIRTMP+9W                                C017-32
         ADMW      R3,TDADDR       FORM BUFFER POINTER          C017-32
         LI        R5,G'E'         PUT EXIT/EOL/EOS IN BUFFER   C017-32
         STB       R5,0,X3                                      C017-32
         LI        R5,G'X'                                      C017-32
         STB       R5,1,X3                                      C017-32
         LI        R5,G'I'                                      C017-32
         STB       R5,2,X3                                      C017-32
         LI        R5,G'T'                                      C017-32
         STB       R5,3,X3                                      C017-32
         LI        R5,X'03'                                     C017-32
         STB       R5,4,X3                                      C017-32
         LI        R5,X'04'                                     C017-32
         STB       R5,5,X3                                      C017-32
         M.WRIT    XDIRTMP         WRITE OUT BUFFER             C017-32
         ABM       31,DIRSECTS     BUMP SECTOR COUNT            C017-32
         BU        XSIRD1D         DEASSIGN AND EXIT            C017-32
XSR1C    STW       R3,XDIRTMP+9W   SAVE IN FCB                  ETCM-32
         ABM       31,XDIRTMP+9W   PLUS ONE FOR EOS CHARACTER   ETCM-32
         ADMW      R3,TDADDR       ADD CURR PNTR TO START ADDR  ETCM-32
         LI        R5,X'04'        END OF SECTOR CHARACTER      ETCM-32
         STB       R5,0,X3         STORE IN BUFFER              ETCM-32
         M.WRIT    XDIRTMP         WRITE OUT BUFFER             ETCM-32
         ABM       31,DIRSECTS     BUMP SECTOR COUNT            ETCM-32
XSIRD1D  LA        R1,XLMDIRS      LOAD MODULE FCB ADDRESS      ETCM-32
         M.DASN                    DEASSIGN LOAD MODULE FILE    ETCM-32
         SBM       6,XLMDIRS+3W    SHOW END OF DIRECTIVES       ETCM-32
XSIRD1A  EQU       $
         SBM       31,XSIRD90+5W
XSIRD2   LF        R0,XSIRD90
         TRSW      R0
         SPACE
XSIRD90  RES       1F
PNRLB    GEN       8/0,24/A(PATHLOC)                            ETCM-32
         REZ       4W                                           ETCM-32
         GEN       8/1,24/A(RLBUFF)                             ETCM-32
         REZ       2W                                           ETCM-32
*                                                               ETCM-32
SIRDM.1A DATAB     C' CATALOG(WARNING) DIRECTIVES CAN NOT BE '  ETCM-32
         DATAB     C' SAVED, NO MEMORY FOR BUFFER.'             ETCM-32
SIRDM.1L DATAB     $-SIRDM.1A                                   ETCM-32
*                                                               ETCM-32
SIRDM.2A DATAB     C' CATALOG(WARNING) DIRECTIVE / L.M. '       ETCM-32
         DATAB     C' FILE NOT FOUND, DIRECTIVES READ FROM SYC' ETCM-32
SIRDM.2L DATAB     $-SIRDM.2A                                   ETCM-32
*                                                               ETCM-32
SIRDM.3A DATAB     C' CATALOG<<FATAL>> DIRECTIVES FILE COULD '  ETCM-32
         DATAB     C' NOT BE ASSIGNED, STATUS = RM'             ETCM-32
SIRDM.3S REZ       2B                                           ETCM-32
SIRDM.3L DATAB     $-SIRDM.3A                                   ETCM-32
*                                                               ETCM-32
SIRDM.4A DATAB     C' CATALOG(WARNING) LOAD MODULE FILE COULD ' ETCM-32
         DATAB     C' COULD NOT BE ASSIGNED, STATUS = RM'       ETCM-32
SIRDM.4S REZ       2B                                           ETCM-32
SIRDM.4L DATAB     $-SIRDM.4A                                   ETCM-32
*                                                               ETCM-32
SIRDM.5A DATAB     C'                  DIRECTIVES READ FROM '   ETCM-32
         DATAB     C' SYC.'                                     ETCM-32
SIRDM.5L DATAB     $-SIRDM.5A                                   ETCM-32
*                                                               ETCM-32
SIRDM.6A DATAB     C' CATALOG(WARNING) NO MEMORY FOR LOAD '     ETCM-32
         DATAB     C' MODULE DIRECTIVES BUFFER.'                ETCM-32
SIRDM.6L DATAB     $-SIRDM.6A                                   ETCM-32
*
SIRDM.7A DATAB     C' CATALOG(WARNING) LOAD MODULE CONTAINS '   PR11087
         DATAB     C'NO DIRECTIVES.'                            PR11087
SIRDM.7L DATAB     $-SIRDM.7A                                   PR11087
*
SIRDM.8A DATAB     C'                  DIRECTIVES READ FROM '   PR11087
         DATAB     C'CI/SYC.'                                   PR11087
SIRDM.8L DATAB     $-SIRDM.8A                                   PR11087
         TITLE     XBIRD    - READ OBJECT RECORD FROM 'SGO'
***********************************************************************
*
*                  XBIRD
*
***********************************************************************
*
*        READ A CARD FROM SGO FILE INTO MCBUF
*
*        RETURN R5  0 IF NO EOF IS READ
*                   1 IF AN EOF IS READ
*
***********************************************************************
XBIRD    STF       R0,XBIRD90
         SBM       MSGORD,MFLGS    SHOW WERE READING FROM SGO   ETCM-32
         SBM       XBIRDFST,XFLGS
         BS        XBIRD1          BR IF NOT FIRST ENTRY
*!!!!!!!!M.OPENR!!!XBIRD91,READCNP!!OPEN!OBJECT!CODE!FILE!!!!!!!ENCD-32
         LA        R1,XBIRD91                                   ENCD-32
         LW        R1,FCB.FAT,X1   GET EXTENDED FCB ADDRESS     ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
         LA        R7,CNPOPN       OPEN SGO FILE                ETCM-32
         SVC       2,X'42'                                      ETCM-32
*!XBIRD1!M.READ!!!!XBIRD91!!!!!!!!!READ!RECORD!FROM!OBJECT!FILE!ENCD-32
XBIRD1   LA        R1,XBIRD91                                   ENCD-32
         BL        BB.READ         READ RECORD FROM SGO         ENCD-32
         LW        R2,XBIRD91                                     0672
         STW       R2,ERRLFC+1W    STORE LFC INCASE OF ERROR     0672
         ZMW       XBIRD90+5W
         TBM       6,XBIRD91+3W    TEST FOR EOF
         BS        XBIRD1.2
         LI        R2,X'0F00'      CHECK FOR '0F' RECORD (SPRRTM170)
         CAMH      R2,MCBUF
         BNE       XBIRD2          GO RETURN                    ETCM-32
         SBM       6,XBIRD91+3W    SET EOF BIT
XBIRD1.2 EQU       $
         SBM       31,XBIRD90+5W
*!!!!!!!!M.RWND!!!!XBIRD91!!!!!!!!!REWIND!OBJECT!FILE!!!!!!!!!!!ENCD-32
         LA        R1,XBIRD91                                   ENCD-32
         BL        BB.RWND         REWIND SGO                   ENCD-32
XBIRD2   LF        R0,XBIRD90
         TRSW      R0              RETURN
         SPACE
XBIRD90  RES       1F
         TITLE     XOBRD    - READ OBJECT RECORD FROM 'OBJ'
***********************************************************************
*                                                               ENCD-32
*                  XOBRD                                        ENCD-32
*                                                               ENCD-32
***********************************************************************
*                                                               ENCD-32
*        READ A CARD FROM FILE CURRENTLY ASSIGNED TO OBJ        ENCD-32
*        INTO MCBUF.                                            ENCD-32
*                                                               ENCD-32
*        RETURN R5  0 IF NO EOF IS READ                         ENCD-32
*                   1 IF AN EOF IS READ                         ENCD-32
*                                                               ENCD-32
***********************************************************************
XOBRD    STF       R0,XOBRD90                                   ENCD-32
         ZBM       MSGORD,MFLGS    SHOW WERE READING FROM OBJ   ETCM-32
         SBM       XOBRDFST,XFLGS                               ENCD-32
         BS        XOBRD1          BR IF NOT FIRST ENTRY        ENCD-32
         LA        R1,XOBJECT                                   ENCD-32
         LW        R1,FCB.FAT,X1   GET EXTENDED FCB ADDRESS     ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
         ZMW       FCB.B1F,X1      CLEAR BUFFER 1 FLAGS         ETCM-32
         SBM       EMPTY,FCB.B1F,X1  SHOW BLOCK 1 EMPTY         ETCM-32
         ZMW       FCB.B2F,X1      CLEAR BUFFER 2 FLAGS         ETCM-32
         SBM       EMPTY,FCB.B2F,X1  SHOW BLOCK 2 EMPTY         ETCM-32
         SBM       EMPTY,FCB.BAF,X1  SHOW ACTIVE BLOCK EMPTY    ETCM-32
         LA        R7,CNPOPN       OPEN OBJ FILE                ETCM-32
         SVC       2,X'42'                                      ETCM-32
XOBRD1   LA        R1,XOBJECT                                   ENCD-32
         BL        BB.READ         READ RECORD FROM OBJECT FILE ENCD-32
         LW        R2,XOBJECT                                   ENCD-32
         STW       R2,ERRLFC+1W    STORE LFC INCASE OF ERROR    ENCD-32
         ZMW       XOBRD90+5W                                   ENCD-32
         TBM       6,XOBJECT+3W    TEST FOR EOF                 ENCD-32
         BS        XOBRD1.2                                     ENCD-32
         LI        R2,X'0F00'      CHECK FOR '0F' RECORD        ENCD-32
         CAMH      R2,MCBUF                                     ENCD-32
         BNE       XOBRD2          GO RETURN                    ETCM-32
         SBM       6,XOBJECT+3W    SET EOF BIT                  ENCD-32
XOBRD1.2 EQU       $                                            ENCD-32
         SBM       31,XOBRD90+5W                                ENCD-32
         LA        R1,XOBJECT                                   ENCD-32
         BL        BB.RWND         REWIND OBJECT FILE           ENCD-32
XOBRD2   LF        R0,XOBRD90                                   ENCD-32
         TRSW      R0              RETURN                       ENCD-32
         SPACE                                                  ENCD-32
XOBRD90  RES       1F                                           ENCD-32
         TITLE     XTMRD    - READ OBJECT RECORD FROM 'TEMP'
***********************************************************************
*                                                               ENCD-32
*                  XTMRD                                        ENCD-32
*                                                               ENCD-32
***********************************************************************
*                                                               ENCD-32
*        READ A CARD FROM THE CURRENT OBJECT CODE TEMP FILE     ENCD-32
*        RETURN R5  0 IF NO EOF IS READ                         ENCD-32
*                   1 IF AN EOF IS READ                         ENCD-32
*                                                               ENCD-32
***********************************************************************
XTMRD    STF       R0,XTMRD90                                   ENCD-32
         LA        R1,XTEMP                                     ENCD-32
         BL        BB.READ         READ REC. FROM TEMP OBJ FILE ENCD-32
         LW        R2,XTEMP                                     ENCD-32
         STW       R2,ERRLFC+1W    STORE LFC INCASE OF ERROR    ENCD-32
         ZMW       XTMRD90+5W                                   ENCD-32
         TBM       6,XTEMP+3W      TEST FOR EOF                 ENCD-32
         BS        XTMRD1.2                                     ENCD-32
         LI        R2,X'0F00'      CHECK FOR '0F' RECORD        ENCD-32
         CAMH      R2,MCBUF                                     ENCD-32
         BNE       XTMRD2                                       ENCD-32
         SBM       6,XTEMP+3W      SET EOF BIT                  ENCD-32
XTMRD1.2 EQU       $                                            ENCD-32
         SBM       31,XTMRD90+5W                                ENCD-32
         LA        R1,XTEMP                                     ENCD-32
         BL        BB.RWND         REWIND TEMP. OBJECT FILE     ENCD-32
XTMRD2   LF        R0,XTMRD90                                   ENCD-32
         TRSW      R0              RETURN                       ENCD-32
         SPACE                                                  ENCD-32
XTMRD90  RES       1F                                           ENCD-32
         TITLE     XSYRD    - READ SYMTAB RECORD FROM 'SYI'
***********************************************************************
*
*                  XSYRD
*
***********************************************************************
*
*        READ A CARD FROM SYI FILE INTO MCBUF
*        RETURN R5  0 IF NO EOF IS READ
*                   1 IF AN EOF IS READ
*
***********************************************************************
XSYRD    STF       R0,XBIRD90
         SBM       XSYRDFST,XFLGS
         BS        XSYRD1          BR IF NOT FIRST ENTRY
         M.OPENR   XSYRD91,READCNP  OPEN SYMTAB FILE             1100A
XSYRD1   M.READ    XSYRD91         READ RECORD FROM SYMTAB FILE
         LW        R1,XSYRD91                                     0672
         STW       R1,ERRLFC+1W    STORE LFC INCASE OF ERROR        0672
         ZMW       XBIRD90+5W
         TBM       6,XSYRD91+3W    TEST FOR EOF                    11015
         BNS       XSYRD2          BRANCH IF NOT EOF
         SBM       31,XBIRD90+5W
XSYRD2   LF        R0,XBIRD90
         TRSW      R0              RETURN
         SPACE
         TITLE     XADRS    - GET MEMORY LIMITS
***********************************************************************
*
*                  XADRS
*
***********************************************************************
*
*        CORE ADDRESS INQUIRY
*        RETURN R6  ADDRESS OF FIRST CELL ALLOCATED
*               R7  ADDRESS OF LAST CELL ALLOCATED
*
***********************************************************************
XADRS    M.ADRS
         TRSW      R0
*
*-----------------------------------------------------------------------
         TITLE     XWRTMOD  - WRITES TO LOADMODULE TEMP FILE     1.3#05
*                                                                1.3#05
*   XWRTMOD                                                      1.3#05
*                                                                1.3#05
*        THIS ROUTINE WRITES VARIABLE SIZE BUFFERS TO RANDOM     1.3#05
*        SECTORS IN THE LOADMODULE TEMP FILE.                    1.3#05
*                                                                1.3#05
*        CALLERS MAY SUPPLY AN ALTERNATE RETURN ADDR IN R1       1.3#05
*        IF SUPPLIED, ROUTINE RETURNS TO THIS ADDRESS WITH       1.3#05
*        R1 POINTING TO THE FCB IF AN ERROR OCCURS OR            1.3#05
*        IF FCB.SFLG IS NON ZERO. IF ALTERNATE RETURN IS NOT     1.3#05
*        SUPPLIED THEN ANY ERROR CONDITION WILL CAUSE A FATAL    1.3#05
*        ERROR MESSAGE SHOWING FCB STATUS WORD AND THE PROCESS   1.3#05
*        IS ABORTED.                                             1.3#05
*                                                                1.3#05
*   IN     R1 # 0  USE CONTENTS AS ERROR RETURN ADDRESS          1.3#05
*             = 0  USE INTERNAL ERRROR RETURN                    1.3#05
*          R2 = QUANTITY TO WRITE                                1.3#05
*          R3 = ADDR OF DATA BUFFER                              1.3#05
*          R4 = SECTOR ADDR AT WHICH TO WRITE                    1.3#05
*                                                                1.3#05
*  OUT     ALL REGS RETURNED OR PROCESS ABORT ON ERROR           1.3#05
*          IFF ERROR RETURN TAKEN:                               1.3#05
*      R1 = FCB ADDRESS                                          1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XWRTMOD  EQU       $                                             1.3#05
         STD       R0,XWM.RSAV                                   1.3#05
         STW       R4,XWM.R4SV                                   1.3#05
         LA        R1,MODFCB       GET ADDR OF "MOD" FCB         1.3#05
         ADMW      R4,LMBASE       ADD IN BASE OF THIS SEGMENT   1.3#05
         STW       R4,FCB.ERAA,X1  STORE SECTOR NUMBER INTO FCB  1.3#05
         STW       R3,FCB.ERWA,X1  STORE BUFFER ADDRESS          1.3#05
         STW       R2,FCB.EQTY,X1  STORE AMOUNT                  1.3#05
         LW        R0,XWM.RSAV+1W  GET USER REG 1                1.3#05
         BNZ       $+2W            SKIP IF NOT ZERO              1.3#05
         LA        R0,XWM.ERRT     ADDR OF ERROR RETURN          1.3#05
         STW       R0,FCB.ERRT,X1  PLUG INTO FCB                 1.3#05
         SVC       1,X'32'         WRITE BUFFER                  1.3#05
         LB        R4,FCB.SFLG,X1  GET STATUS BYTE               1.3#05
         BZ        XWM.XIT         SKIP IF ZERO                  1.3#05
         STD       R0,XWM.RSAV     UPDATE RETURN TO ALTERNATE    1.3#05
XWM.XIT  EQU       $                                             1.3#05
         LD        R0,XWM.RSAV     RECOVER REGISTER 0&1          1.3#05
         LW        R4,XWM.R4SV               AND     4           1.3#05
         TRSW      R0              AND RETURN                    1.3#05
         NOP                                                     1.3#05
         BOUND     1D                                            1.3#05
XWM.RSAV DATAD     0               HOLDS USER REG 0&1            1.3#05
XWM.R4SV DATAW     0               HOLDS USER REG 4              1.3#05
*                                                                1.3#05
XWM.ERRT EQU       $               HERE IF I/O ERROR             1.3#05
         LW        R5,3W,X1        GET FCB STATUS                1.3#05
         M.CONBAH                  CONVERT                       1.3#05
         STW       R6,XBUF.MD1     SAVE IN MESSAGE               1.3#05
         STW       R7,XBUF.MD1+1W  SECOND HALF                   1.3#05
         LA        R6,XBUF.MSG     GET MESSAGE ADDR              1.3#05
         LNB       R5,XBUF.ML      AND LENGTH                    1.3#05
         BL        XTYPEF          LOG IT                        1.3#05
         BL        XABORT          AND QUIT                      1.3#05
*                                                                1.3#05
XBUF.MSG DATAB     C' CATALOG<<FATAL>>  FCB STATUS:  '           1.3#05
XBUF.MD1 REZ       8B              HOLDS ACH OF STATUS WORD      1.3#05&
         DATAB     C'  WRITING LOAD MODULE TEMPORARY FILE.'      1.3#05&
XBUF.ML  DATAB     $-XBUF.MSG                                    1.3#05
         BOUND     1W
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     XPATH    - BUILD PNB FOR LOAD MODULE FILE
***********************************************************************
*
*                  XPATH
*
***********************************************************************
*
*        BUILD PNB FOR LOAD MODULE FILE
*
*        OUTPUT:
*                  R1 = PNB DESCRIPTOR
*                  XPNB = THE FULL PNB BUFFER
*                  XPNBDESC = PNB DESCRIPTOR
*                  XPATHLEN = PNB LENGTH (BYTES)
*
***********************************************************************
XPATH    STF       R0,XPATH90
         TBM       CPTH,CFLGS      CHECK IF LMPATH DIRECTIVE     1.3#05
         BS        XPATH1          BRANCH IF XPNB SET UP ALREADY
*
* MUST SET UP VOLUME AND DIRECTORY.
*
*        IF 'CATALOG' DIRECTIVE USED - DEFAULT TO @@SYSTEM(SYSTEM)
*        IF 'BUILD'   DIRECTIVE USED - DEFAULT TO WORKING DIRECTORY
*
         LW        R7,=C'WORK'     VOL/DIR ARE 'WORK' FOR 'BUILD'
         TBM       MBUILD,MFLGS    WILL BE SET IF 'BUILD' USED
         BS        XPATH2          BRANCH IF 'BUILD' USED
         LW        R7,=C'SYST'     VOL/DIR ARE 'SYST'
XPATH2   LW        R6,=C'!VOL'
         STD       R6,XPNB
         LW        R6,=C'!DIR'
         STD       R6,XPNB+1D
         LI        R7,4W           SET UP LENGTH OF PNB
         STW       R7,XPATHLEN
         STW       R7,XRESPOS      SET UP REL POS OF RES ENTRY   1.3#09
*
* COMMON POINT WHETHER VOL/DIR WAS EXPLICIT OR NOT.
* THE PNB IS IN XPNB AND THE LENGTH IS IN XPATHLEN
*
* ADD THE FILENAME PORTION TO THE PNB
*
XPATH1   EQU       $
         TBM       CRES,CFLGS      DID LMPATH SET FILENAME       1.3#05
         BS        XPATH3          BR IF IT DID                  1.3#05
         LW        R2,XRESPOS     GET POSITION OF RES ENTRY      1.3#09
         LW        R6,=C'!RES'
         LW        R7,=C'    '
         STD       R6,XPNB,R2      ADD TO PNB
         LD        R6,XCREATNM     FILENAME
         STD       R6,XPNB+1D,R2   ADD TO PNB
         LW        R7,=C'    '     PAD FILENAME TO 16 CHARS
         TRR       R7,R6           SPACES IN R6/R7 NOW
         STD       R6,XPNB+2D,R2   PAD OUT TO 16 CHAR FILENAME
         STD       R6,XPNB+3D,X2                                 1.3#05
         ADI       R2,24           TOTAL LENGTH OF PNB
         STW       R2,XPATHLEN     UPDATE TOTAL PNB LENGTH
         LA        R3,XPNB         ADDRESS OF PNB
         SLL       R3,8
         SRLD      R2,8            PATHNAME DESCRIPTOR INTO R3
         STW       R3,XPNBDESC     SAVE DESCRIPTOR (FOR RECATALOG CASE)
XPATH3   EQU       $                                             1.3#05
         LF        R0,XPATH90
         TRSW      R0
XPATH90  RES       1F
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     XDEBBUF  - OUTPUT DEBUG SYMBOLS TO TEMP FILE
*                                                                1.3#05
*   FOLLOWING ROUTINE IS REPLACED BY ROUTINE THAT ADDS A FOUR    1.3#05
*   ENTRY TO THE BUFFER AND FLUSHES IF FULL                      1.3#05
*                                                                1.3#05
*   THE NAME OF THE ROUTINE WAS CHANGED TO ALLOW FOR EASY        1.3#05
*   LOCALIZATION OF ALL REFERENCES TO CURRENT ROUTINE            1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
*  XDBGSYM                                                       1.3#05
*                                                                1.3#05
*   THIS ROUTINE TRANSFERS THE FOUR WORDS IN "XSYMBUF" TO THE    1.3#05
*   BLOCKING BUFFER AND OUTPUTS THE BUFFER WHEN IT IS FULL       1.3#05
*                                                                1.3#05
*   DOUBLE WORD BOUNDING IS REQUIRED ON BOTH "XSYMBUF" AND THE   1.3#05
*   BLOCKING BUFFER                                              1.3#05
*                                                                1.3#05
*   IN = NONE (OTHER THAN CONTENTS OF "XSYMBUF")                 1.3#05
*  OUT = ALL REGISTERS RETURNED AS ENTERED                       1.3#05
*                                                                1.3#05
*   IF AN ERROR OCCURS ON THE WRITE, SYMBOL GENERATION IS        1.3#05
*   TURNED "OFF" AND THE FOLLOWING MESSAGE IS ISSUED TO SLO & UT 1.3#05
*   AS REQUIRED:                                                 1.3#05
*                                                                1.3#05
*  CATALOG(WARNING) FCB STATUS XXXXXXXX WRITING DEBUG SYMBOLS    1.3#05
*  OPTION 19 SET OFF.                                            1.3#05
*                                                                1.3#05
*     XXXXXXXX IS FCB STATUS AS POSTED IN WORD 3                 1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XDBGSYM  EQU       $                                             1.3#05
         TBM       MOPT19,MFLGS    OPTION ON                     1.3#05
         BS        $+2W            ENTER IF ON                   1.3#05
         TRSW      R0              ELSE RETURN                   1.3#05
         NOP                                                     1.3#05
         STF       R0,XDS.RET      SAVE USER FRAME               1.3#05
         LW        R3,XDS.CUR      GET CURRENT PONTER            1.3#05
         LD        R4,XSYMBUF      GET 1ST HALF OF ENTRY         1.3#05
         STD       R4,0D,X3        AND PLUG                      1.3#05
         LD        R4,XSYMBUF+2W   GET SECOND WORD               1.3#05
         STD       R4,1D,X3        AND PLUG                      1.3#05
         ADI       R3,4W           BUMP POINTER                  1.3#05
         STW       R3,XDS.CUR      AND SAVE                      1.3#05
         CAMW      R3,XDS.BEND     COMPARE TO END                1.3#05
         BGE       XDS.FLSH        AND FLUSH IF FULL             1.3#05
XDS.XIT  EQU       $                                             1.3#05
         LF        R0,XDS.RET      RECOVER USER FRAME            1.3#05
         TRSW      R0              AND RETURN                    1.3#05
         NOP                                                     1.3#05
XDS.FLSH EQU       $               HERE TO WRITE OUT BUFFER      1.3#05
         LW        R2,XDS.BSIZ     SET UP BUFFER SIZE            1.3#05
         LW        R3,XDS.BBEG     SET STARTING ADDR             1.3#05
         LW        R4,XDS.SCNT     SET UP SECTOR ADDR            1.3#05
         LA        R1,XDS.WERR     SET ERROR RETURN ADDR         1.3#05
         BL        XWRTMOD         AND WRITE IT OUT              1.3#05
         LW        R1,XDS.BBEG     GET BUFFER STARTING ADDR      1.3#05
         STW       R1,XDS.CUR      AND SAVE IN CURRENT           1.3#05
         LW        R1,XDS.SSIZ     GET SIZE IN SECTORS           1.3#05
         ARMW      R1,XDS.SCNT     AND UPDATE COUNT              1.3#05
         BU        XDS.XIT         AND RETURN                    1.3#05
*                                                                1.3#05
*  XDBGBND                                                       1.3#05
*                                                                1.3#05
*     THIS ENTRY POINT WILL ZERO FILL THE BUFFER TO THE NEXT     1.3#05
*     SECTOR BOUNDRY. IF THAT FILLS THE BUFFER, IT WILL BE       1.3#05
*     FLUSHED.                                                   1.3#05
*                                                                1.3#05
XDBGBND  EQU       $                                             1.3#05
         TBM       MOPT19,MFLGS    SYMBOLS REQUESTED             1.3#05
         BS        XDB.0           CONTINUE IF SET               1.3#05
         TRSW      R0              ELSE RETURN                   1.3#05
         NOP                       FOR BOUNDING                  1.3#05
XDB.0    EQU       $                                             1.3#05
         STF       R0,XDS.RET      SAVE USER FRAME               1.3#05
         LW        R5,XDS.CUR      GET CURRENT POINTER           1.3#05
         SUMW      R5,XDS.BBEG     REMOVE THE BASE               1.3#05
         SRL       R5,4            CONVERT TO NUMBER OF ENTRIES  1.3#05
         ES        R4                                            1.3#05
         DVI       R4,48           DIVIDE BY NUM ENT/ SECT       1.3#05
         TRR       R4,R4           ANY REMAINDER                S8700640
         BZ        XDS.XIT         BOUNDED IF NONE              S8700640
         LI        R6,48           INIT COUNT                    1.3#05
         SUR       R4,R6           CONVERT REMAINDER             1.3#05
         TRR       R6,R4           BACK TO R4                    1.3#05
         ZR        R6              SET UP R6                     1.3#05
         ZR        R7              AND R7 FOR BOUNDING OPER.     1.3#05
         LW        R3,XDS.CUR      AND GET POINTER               1.3#05
XDB.1    EQU       $               LOOP TOP                      1.3#05
         TRR       R4,R4           TEST COUNTER                  1.3#05
         BZ        XDB.2           OUT WHEN DONE                 1.3#05
         STD       R6,0W,X3        ZERO 1ST HALF                 1.3#05
         STD       R6,2W,X3        AND SECOND HALF               1.3#05
         ADI       R3,4W           BUMP R3                       1.3#05
         SUI       R4,1            DECREMENT COUNTER             1.3#05
         BU        XDB.1           AND LOOP                      1.3#05
XDB.2    EQU       $                                             1.3#05
         STW       R3,XDS.CUR      UPDATE CURRENT                1.3#05
         CAMW      R3,XDS.BEND     IS BUFFER FULL                1.3#05
         BGE       XDS.FLSH        GO FLUSH IF IT IS             1.3#05
         BU        XDS.XIT         ELSE RETURN TO USER           1.3#05
*                                                               EAID-32
* XDBGSRC                                                       EAID-32
*                                                               EAID-32
* ROUTINE TO FLUSH PROGRAM SOURCE TO LOAD MODULE                EAID-32
*                                                               EAID-32
XDBGSRC  EQU       $                                            EAID-32
         TBM       MOPT19,MFLGS    DEBUG STUFF REQUESTED?       EAID-32
         BS        $+2W            YES, CONTINUE                EAID-32
         TRSW      R0              NO, RETURN                   EAID-32
         NOP                                                    EAID-32
         STF       R0,XDS.RET                                   EAID-32
         LNW       R4,AID.SLEN     SOURCE PRESENT?              EAID-32
         BZ        XDBGPRG         GO FLUSH THE BUFFER          EAID-32
         BL        AID.FLSH        FLUSH CURRENT SOURCE BUFFER  EAID-32
         NOP                       WORK AROUND 87 CACHE BUG     EAID-32
         NOP                       WORK AROUND 87 CACHE BUG     EAID-32
         NOP                       WORK AROUND 87 CACHE BUG     EAID-32
         ZMW       AID.FCB+10W     RESET RANDOM ACCESS ADDRESS  EAID-32
         LW        R1,XDS.CUR      GET CURRENT BUFFER POSITION  EAID-32
         SUMW      R1,XDS.BBEG     SUBTRACT BUFFER BEGINNING    EAID-32
         ZR        R0                                           EAID-32
         DVI       R0,768          # OF SECTORS IN CURRENT BUFF EAID-32
         ADMW      R1,XDS.SCNT     ADD OFFSET FOR THIS BLOCK    EAID-32
         STW       R1,BPREAMB+SRCE_PTR  SOURCE PNTR TO PREAMBLE EAID-32
XDS.AID  EQU       $                                            EAID-32
         LW        R1,XDS.CUR      GET CURRENT BUFFER ADDRESS   EAID-32
         STW       R1,AID.FCB+8W   STORE FOR READ               EAID-32
         LW        R7,XDS.BEND     CALCULATE SIZE OF READ       EAID-32
         SUMW      R7,XDS.CUR                                   EAID-32
         CAMW      R7,AID.SLEN     IS BUFFER LARGER THAN SOURCE EAID-32
         BLE       $+2W                                         EAID-32
         LW        R7,AID.SLEN     JUST READ WHATS THERE        EAID-32
         STW       R7,AID.FCB+9W   STORE COUNT FOR READ         EAID-32
         ARMW      R7,XDS.CUR      UPDATE BUFFER POINTER        EAID-32
         M.READ    AID.FCB         READ SOME SOURCE             EAID-32
         LW        R2,XDS.CUR      CALCULATE BYTES FOR WRITE    EAID-32
         SUMW      R2,XDS.BBEG                                  EAID-32
         LW        R3,XDS.BBEG     GET BUFFER BEGINNING         EAID-32
         LW        R4,XDS.SCNT     GET SECTOR ADDRESS           EAID-32
         LA        R1,XDS.WERR     AND ERROR RETURN ADDRESS     EAID-32
         BL        XWRTMOD         FLUSH THE BUFFER             EAID-32
         LW        R1,XDS.BBEG     RESET CURRENT POINTER        EAID-32
         STW       R1,XDS.CUR                                   EAID-32
         LW        R1,XDS.SSIZ     UPDATE SECTOR POINTER        EAID-32
         ARMW      R1,XDS.SCNT                                  EAID-32
         LW        R1,AID.FCB+9W   CALC NEW RANDOM SECTOR #     EAID-32
         ZR        R0                                           EAID-32
         DVI       R0,768                                       EAID-32
         ARMW      R1,AID.FCB+10W  AND UPDATE IN THE FCB        EAID-32
         LW        R1,AID.SLEN     NUM OF BYTES LEFT TO WRITE   EAID-32
         SUMW      R1,AID.FCB+9W   MINUS NUMBER WRITTEN         EAID-32
         STW       R1,AID.SLEN     REPLACE                      EAID-32
         BP        XDS.AID         IF POSITIVE, CONTINUE COPY   EAID-32
         LI        R1,-1                                        EAID-32
         STW       R1,XDS.SCNT     ZAP POSITION, MUST BE RESET  EAID-32
         ZMW       AID.FCB+10W     RESET RANDOM ACCESS ADDRESS  EAID-32
         ZMW       AID.OFST        RESET AID BUFFER POINTER     EAID-32
         ZMH       AID.BOFS        RESET SOURCE BYTE OFFSET     EAID-32
         ZMW       AID.SSCT        RESET SOURCE SECTOR          EAID-32
         ZMW       CRT.SO          RESET CARET STRUCTURE        EAID-32
         ZMH       CRT.BO          DITTO                        EAID-32
         LI        R1,AID.BLEN                                  EAID-32
         STW       R1,AID.BPOS     RESET AID BUFFER COUNTER     EAID-32
         TRN       R1,R1           NEGATE                       EAID-32
         STW       R1,AID.FCB+9W   RESET READ COUNT             EAID-32
         LA        R1,AID.BUF                                   EAID-32
         STW       R1,AID.FCB+8W   RESET READ ADDRESS           EAID-32
         BU        XDS.XIT                                      EAID-32
*                                                                1.3#05
* XDBGPRG                                                        1.3#05
*                                                                1.3#05
*     THIS ENTRY POINT IS CALLED TO ONCE ONLY AT THE END         1.3#05
*     OF SEGMENT PROCESSING TO FORCE BOUNDING AND FLUSHING OF    1.3#05
*     THE BLOCKING BUFFER.                                       1.3#05
*                                                                1.3#05
XDBGPRG  EQU       $                                             1.3#05
         TBM       MOPT19,MFLGS    OPTION ON                     1.3#05
         BS        $+2W            ENTER IF ON                   1.3#05
         TRSW      R0              ELSE RETURN                   1.3#05
         NOP                                                     1.3#05
         STF       R0,XDP.RET      SAVE USER REGS                1.3#05
         BL        XDB.0           GO BOUND BUFFER               1.3#05
         LW        R2,XDS.CUR      GET CURRENT POINTER           1.3#05
         SUMW      R2,XDS.BBEG     REMOVE THE BASE               1.3#05
         BZ        XDP.XIT         RETURN IF FLUSHED             1.3#05
         LW        R3,XDS.BBEG     GET BUFFER ADDR               1.3#05
         LW        R4,XDS.SCNT     AND FILE ADDR                 1.3#05
         LA        R1,XDS.WERR     PLUS OUR ERROR RETURN         1.3#05
         BL        XWRTMOD         AND SLIP LAST OUT             1.3#05
         LI        R1,-1                                         1.3#05
         STW       R1,XDS.SCNT     ZAP POSITION, MUST BE RESET   1.3#05
         LW        R1,XDS.BBEG     GET START                     1.3#05
         STW       R1,XDS.CUR      AND INIT NEXT POINTER         1.3#05
XDP.XIT  EQU       $                                             1.3#05
         LF        R0,XDP.RET      RECOVER USER                  1.3#05
         TRSW      R0              AND RETURN                    1.3#05
         NOP                                                     1.3#05
*                                                                1.3#05
* XDBGINIT                                                       1.3#05
*                                                                1.3#05
*    THIS ENTRY POINT IS CALLED ONCE WHEN THE DEBUG SYMBOL FILE  1.3#05
*    IS CREATED TO INITIALIZE VARIABLES FOR THE OTHER ENTRY      1.3#05
*    POINTS. THE INPUT VALUES ARE:                               1.3#05
*                                                                1.3#05
*   IN    R2 = ADDRESS OF MEMORY AREA FOR SYMBOL STORAGE BUFFER  1.3#05
*         R3 = SIZE IN BYTES OF THE AREA                         1.3#05
*         R4 = FIRST SECTOR ADDRESS AT WHICH TO WRITE DATA       1.3#05
*                                                                1.3#05
*  OUT    REGS RETURNED                                          1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
XDBGINIT EQU       $                                             1.3#05
         STF       R0,XDS.RET      SAVE USER FRAME               1.3#05
         TBR       R2,29           CHECK BOUNDING                1.3#05
         BNS       $+2W            SKIP IF EVEN                  1.3#05
         ADI       R2,1W           ELSE BUMP 1W                  1.3#05
         STW       R2,XDS.BBEG     SET BUFFER STARTING ADDR      1.3#05
         STW       R2,XDS.CUR      AND CURRENT POINTER           1.3#05
         ES        R2                                            1.3#05
         DVI       R2,768          CALCULATE SECTOR COUNT        1.3#05
         STW       R3,XDS.SSIZ     INIT SECTOR COUNT IN BUFFER   1.3#05
         ES        R2                                            1.3#05
         MPI       R2,768          CALCULATE ACTUAL BYTE COUNT   1.3#05
         STW       R3,XDS.BSIZ     INIT BYTE COUNT IN BUFFER     1.3#05
         ADMW      R3,XDS.BBEG     ADD IN BASE ADDR              1.3#05
         STW       R3,XDS.BEND     AND SET END ADDR +1W          1.3#05
         STW       R4,XDS.SCNT     INIT STARTING SECTOR ADDR     1.3#05
         LF        R0,XDS.RET      RECOVER USER CONTEXT          1.3#05
         TRSW      R0              RETURN TO USER                1.3#05
         NOP                                                     1.3#05
*                                                                1.3#05
XDS.WERR EQU       $                                             1.3#05
         ZBM       MOPT19,MFLGS    TURN OFF SYMBOL GENERATION    1.3#05
         SBM       XABORTFL,XFLGS  SET ABORT ON TERMINATION      1.3#14
         LW        R5,3W,X1        GET FCB STATUS WORD           1.3#05
         M.CONBAH                  CONVERT TO ASCII HEX          1.3#05
         STW       R6,XDS.MD1      SAVE IN MESSAGE               1.3#05
         STW       R7,XDS.MD1+1W   AND SECOND HALF               1.3#05
         LNB       R5,XDS.MSL      GET LENGTH (UT & SLO)         1.3#05
         LA        R6,XDS.MSG      GET MESSAGE ADDRESS           1.3#05
         BL        XTYPEF          LOG ERROR                     1.3#05
         BU        XDS.XIT         AND RETURN                    1.3#05
*                                                                1.3#05
         BOUND     1F                                            1.3#05
XDS.RET  RES       1F            USER SAVE FOR XDBGSYM&XDBGBND   1.3#05
XDP.RET  RES       1F              USER SAVE FOR XDBGPRG         1.3#05
XDS.BBEG DATAW     0               HOLDS BUFFER START            1.3#05
XDS.BEND DATAW     0               HOLDS BUFFER END   ADDR       1.3#05
XDS.CUR  DATAW     0               HOLDS CURRENT POINTER(REL 0)  1.3#05
XDS.FCBA DATAW     0               HOLDS FCB ADDR                1.3#05
XDS.SCNT DATAW     0               HOLDS SECTORS WRITEN COUNT    1.3#05
XDS.BSIZ DATAW     0               HOLDS BUFFER SIZE IN BYTES    1.3#05
XDS.SSIZ DATAW     0               HOLDS BUFFER SIZE IN SECTORS  1.3#05
*                                                                1.3#05
XDS.MSG  DATAB     C' CATALOG(WARNING) FCB STATUS    '           1.3#05
XDS.MD1  REZ       8B              HOLDS ACH FCB STATUS          1.3#05
         DATAB     C'   WRITING DEBUG SYMBOLS, OPT 19 SET OFF.'  1.3#05
XDS.MSL  DATAB     $-XDS.MSG                                     1.3#05
         BOUND     1W
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     WRTINFO  - OUTPUT MODULE INFOMATION TO TEMP FILE
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
*
*                   WRTINFO
*
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
*
*        OUTPUT MODULE I.D. INFOMATION TO TEMP FILE
*
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
WRTINFO  STF       R0,XWINF.RS     SAVE USER FRAME               1.3#05
         TBM       MOPT15,MFLGS    IS MODULE INFOMATION WANTED ?
         BNS       WRTINFO9        NO - CLEAR COUNT AND RETURN NO OUTPUT
         SBM       0,XIDFLGS       SET FIRST TIME FLAG
         BS        WRTINFO5        IF SET - FILE ALREADY ALLOC & OPEN
*        M.OPENR   INFOFCB,RWCNP  OPEN TEMP FILE FOR MODULE INFO
         LA        R1,INFOFCB      GET FCB ADDRESS                1100A
         STW       R1,RWCNP+5W     AND STORE INTO CNP FOR OPEN    1100A
         LW        R1,INFOFCB      GET LFC                        1100A
         STW       R1,TEMP.RRS     AND STORE INTO RRS             1100A
         SBM       10,RWCNP+2W     SET BLOC=N FOR OPEN            1100A
         M.ASSN    TEMP.RRS,RWCNP  ASSIGN AND OPEN FOR SYM DEB INFO1100A
         ZMW       RWCNP+5W        CLEAR CNP                      1100A
         ZBM       10,RWCNP+2W     RESET BIT IN CNP               1100A
WRTINFO5 M.WRIT    INFOFCB        WRITE BUFFER
WRTINFO9 LA        R2,XINFOBUF      CLEAR BUFFER
WRTINFOA ZMD       0,R2
         ADI       R2,1D           INCREMENT POINTER BY A DOUBLEWORD
         CAMW      R2,=XINFOBUF+192W IS THE END OF THE BUFFER REACHED
         BLT       WRTINFOA        KEEP GOING UNTIL DONE
         LF        R0,XWINF.RS     RSTORE USER CONTEXT           1.3#05
         TRSW      R0              RETURN
XIDFLGS  DATAB     0
         BOUND     1F                                            1.3#05
XWINF.RS RES       1F                                            1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
XPNBDESC DATAW     0               PATHNAME DESCRIPTOR OF LM FILE
XPATHLEN DATAW     0               CURRENT LENGTH OF PATHNAME
XRESPOS  DATAW     0               HOLDS REL ADDR OF RES POS.    1.3#09
XCREATNM DATAD     0
XPNBSIZ  EQU       10D             10 DOUBLE WORDS FOR FULL PATH 1.3#05
XRD      REZ       96D             TO HOLD FILES RD'S IN
XPNB     EQU       $               FOR LM PATHNAMES              1.3#05
         DATAD     0                                             1.3#05
         DATAD     0                                             1.3#05
         DATAD     0                                             1.3#05
XPNB.F   DATAD     0     USED WHEN DEFAULT WORK OR SYST USED     1.3#05
         DATAD     0                                             1.3#05
         REZ       5D              BALANCE FOR LONGEST PNB
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     XCLOS    - CLOSE LOAD MODULE FILE
***********************************************************************
*
*        CLOSE AND DEALLOCATE MODULE FILE
*
***********************************************************************
XCLOS    STF       R0,XCLOS90                                    1.3#05
         ZBM       XDATFST,XFLGS
         TBM       4,MOPTS
*!!!!!!!!!!BS!!!!!!!!XCLOS1!!!!!!!!!!BR!IF!NO!OUTPUT!TO!PERM!FILE|1.3Q19
         BS        XCLOS1.1        BR IF NO OUTPUT TO PERM FILE  |1.3Q19
         TBM       MOPT18,MFLGS    IS OPTION 18 ON               |1.3Q19
         BNS       XCLOS0          THEN ALWAYS REPLACE LM        |1.3Q19
         TBM       XABORTFL,XFLGS  DID A SERIOUS ERROR OCCUR     |1.3Q19
         BS        XCLOS1.1        THEN DON'T REPLACE LM         |1.3Q19
XCLOS0   EQU       $               CONTINUE                      |1.3Q19
*
* XRD CONTAINS THE RD FOR THE OLD LM FILE (IF IT EXISTED) ELSE ZERO
*
* USE EITHER M.REPLAC OR M.TEMPER ACCORDINGLY
*
         LW        R7,XRD          FIRST WORD 0??
         BZ        XCLOS2          BRANCH IF LM DOES NOT ALREADY EXIST
*
* USE THE M.REPLAC SERVICE
*
         LA        R2,XRD          RID ADDRESS
         ORMW      R2,=X'20000000' LENGTH TO TOP BYTE
         M.REPLAC  MODFCB        REPLACE EXISTING LOAD MODULE    1.3#05
         BNS       XCLOS1          BRANCH IF SUCCESSFUL
         TRR       R7,R5                                         1.3#05
         M.CONBAD                  CONVERT ERROR STATUS TO DEC   1.3#05
         ANMW      R7,=X'0000FFFF' KEEP LAST TWO DIGITS          1.3#05
         ORMW      R7,XMDID.VM     SHOW AS H.VOMM ERROR          1.3#05
         STW       R7,XCF.M1D                                    1.3#05
         LD        R6,XCREATNM     GET NAME                      1.3#14
         LA        R3,XCF.M1D1     LOCATE IN MESSAGE             1.3#14
         BL        XST2            AND STUFF                     1.3#14
         LA        R6,XCF.MSG1                                   1.3#05
         LNB       R5,XCF.M1L                                    1.3#05
         BL        XTYPEF                                        1.3#05
         BL        XABORT                                        1.3#05
*                                                                1.3#05
*
* USE THE M.TEMPER SERVICE
*
XCLOS2   LA        R1,MODFCB       ADDRESS OF TEMP FILE FCB
         M.TEMPER  ,XPNBDESC
         BNS       XCLOS3          BRANCH IF SUCCESSFUL
         TRR       R7,R5                                         1.3#05
         M.CONBAD                                                1.3#05
         ANMW      R7,=X'0000FFFF'                               1.3#05
         ORMW      R7,XMDID.VM                                   1.3#05
         STW       R7,XCF.M2D                                    1.3#05
         LD        R6,XCREATNM                                   1.3#14
         LA        R3,XCF.M2D1     LOCATE IN MESSAGE             1.3#14
         BL        XST2                                          1.3#14
         LA        R6,XCF.MSG2                                   1.3#05
         LNB       R5,XCF.M2L                                    1.3#05
         BL        XTYPEF                                        1.3#05
         BL        XABORT                                        1.3#05
*                                                                1.3#05
*
* DEALLOCATE THE FILE
*
XCLOS3   LA        R1,MODFCB       FCB ADDRESS
         M.DASN                    DE-ALLOCATE FILE
XCLOS1   EQU       $                                             1.3#10
         ZBM       XLMFBAD,XFLGS   INDICATE GOOD FILE            1.3#10
XCLOS1.1 EQU       $               EXIT WITH OUT UPDATE          |1.3Q19
         LF        R0,XCLOS90                                    1.3#05
         TRSW      R0
         SPACE
XREPCNP  DATAW     0                                               22005
         DATAW     0                                               22005
         DATAW     X'80000000'     FLAG TO ALLOW M.REPLAC TO WORK  22005
*                                  ON CURRENTLY ASSIGNED RESOURCES 22005
         BOUND     1F                                            1.3#05
XCLOS90  RES       1F                                            1.3#05
XCF.MSG1 DATAB     C' CATALOG<<FATAL>> ERROR STATUS: '           1.3#05
XCF.M1D  REZ       4B              HOLDS XXNN STATUS             1.3#05&
         DATAB     C'   REPLACING LOAD MODULE: '                 1.3#05
XCF.M1D1 REZ       8B              LM NAME                       1.3#14
         DATAB     C'.'                                          1.3#14
XCF.M1L  DATAB     $-XCF.MSG1                                    1.3#05
*                                                                1.3#05
         BOUND     1W
XCF.MSG2 DATAB     C' CATALOG<<FATAL>> ERROR STATUS: '           1.3#05&
XCF.M2D  REZ       4B              HOLDS XXNN STATUS             1.3#05&
         DATAB     C'   MAKING LOAD MODULE: '                    1.3#05
XCF.M2D1 REZ       8B              HOLDS LM NAME                 1.3#14
         DATAB     C'  PERMANENT.'                               1.3#14
XCF.M2L  DATAB     $-XCF.MSG2                                    1.3#05
         BOUND     1W
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     XLISH    - SEARCH SUBROUTINE LIBRARIES
***********************************************************************
*
*                  XLISH
*
***********************************************************************
*
*        SEARCH SYSTEM SUBROUTINE LIBRARY DIRECTORY
*        CALL R6,7  ASCII EXTERNAL NAME
*
*        RETURN R6  ADDRESS FROM DIRECTORY ENTRY
*               R7  WORD INDEX INTO LFC TABLE OF CONTAINING LIB  1.3#04
*                   OR   -NEGATIVE-   IF NOT FOUND               1.3#04
*
***********************************************************************
         SPACE
XLISH    EQU       $                                             1.3#04
         STF       R0,XLISH90      SAVE USER REGS                1.3#04
         STD       R6,XLISH94      SAVE SYMBOL FOR OTHERS USERS  1.3#04
         LI        R3,-1                                         1.3#04
         STW       R3,XLISH90+7W   PRESET ANSWER AS NOT FOUND    1.3#04
         STW       R3,GPB.LFCX     RESET ACTIVE BUF FOR XLIRD    1.3#11
         LNW       R0,LIBCNT       OUTER LOOP CONTROL            1.3#04
         BZ        XLISH.X         QUIT IF NO LIBS               1.3#04
         ZR        R2             INIT LOOP COUNTER              1.3#04
         LW        R4,=X'00FFFFFF' LFC TAB MASK                  1.3#04
XLISH.0  EQU       $               OUTER LOOP TOP                1.3#04
         LB        R3,LT.DIRS,X2   GET FIRST DIR ENTRY TYPE      1.3#04
         CI        R3,4            IS IT TYPE 4 (MEM RES)        1.3#04
         BEQ       XLISH.20        GO DO MEM RES SEARCH ROUTINE  1.3#04
         CI        R3,8            IS IT TYPE 8 (DISC RES,OPEN)  1.3#04
         BEQ       XLISH.10        GO DO DISC RES SEARCH ROUTINE 1.3#04
         CI        R3,3            IS IT TYPE 3 (DSC RES, NOTOPN)1.3#11
         BNE       XLISH.1         THEN SKIP THIS ENTRY          1.3#11
*                                                                1.3#11
*        OPEN LIB/DIR PAIR                                       1.3#11
*                                                                1.3#11
         LMW       R7,LT.DIRS,X2   GET DIR LFC                   1.3#11
         STW       R7,GPFCB2       AND SET INTO  FCB             1.3#11
         LA        R7,GPFCB2       GET ADDR OF FCB               1.3#11
         LMW       R6,LT.LIBS,X2   GET LIB LFC                   1.3#11
         STW       R6,GPFCB1       SAVE IN FCB                   1.3#11
         LA        R6,GPFCB1       GET ADDR OF FCB               1.3#11
         LI        R5,1            DEFAULT MODE = READ           1.3#11
         BL        XLDOPN          OPEN THIS LIB/DIR PAIR        1.3#11
         LI        R6,7            GET NEW LIB TYPE              1.3#11
         STB       R6,LT.LIBS,X2   UPDATE LIBRARY ENTRY          1.3#11
         LI        R6,8            GET NEW DIR TYPE              1.3#11
         STB       R6,LT.DIRS,X2   UPDATE DIRECTORY ENTRY        1.3#11
         LD        R6,XLISH94      RECOVER REQUESTED SYMBOL      1.3#11
         BU        XLISH.10        AND GO SEARCH DISC            1.3#11
XLISH.1  EQU       $               HERE IF NOT 4 OR 8 AND AFTER  1.3#04
*                                  APPROPRIATE SEARCH ROUTINE    1.3#04
         ABR       R2,29           BUMP COUNTER                  1.3#04
         BIB       R0,XLISH.0      LOOP FOR NEXT ACTIVE LIB/DIR  1.3#04
         BU        XLISH.X         EXIT WHEN ALL DONE            1.3#04
XLISH.2  EQU       $               HERE WHEN SYMBOL FOUND        1.3#04
         TRR       R2,R7           LOOP COUNTER AS LIB INDEX     1.3#04
         STD       R6,XLISH90+6W   PLUG ANSWERS                  1.3#04
XLISH.X  EQU       $                                             1.3#04
         LF        R0,XLISH90      RESTORE USER CONTEXT          1.3#04
         TRSW      R0              AND RETURN                    1.3#04
         NOP                                                     1.3#04
*                                                                1.3#04
XLISH.10 EQU       $          SEARCH DISC RESIDENT DIRECTORY     1.3#04
         LMW       R3,LT.DIRS,X2   GET LFC                       1.3#04
         STW       R3,GPFCB2+FCB.LFC   AND PLUG INTO FCB         1.3#04
         M.RWND    GPFCB2          REWIND THIS DIRECTORY         1.3#04
XLISH.11 EQU       $                                             1.3#04
         M.READ    GPFCB2          GET A CHUNK OF IT             1.3#04
         TBM       6,3W,X1         IS IT AN EOF                  1.3#04
         BS        XLISH.1         BR TO DO NEXT DIR IF IT IS    1.3#04
         ZR        R5              ELSE SET UP TO                1.3#04
         LI        R3,-192W        SEARCH THIS SECTOR            1.3#04
XLISH.12 EQU       $               LOOP TOP                      1.3#04
         CAMW      R5,GPBUF1+192W,X3       IS IT END OF SYMBOLS  1.3#04
         BEQ       XLISH.1            BR TO DO NEXT DIR IF TRUE  1.3#04
         CAMW      R6,GPBUF1+192W,X3  DOES FIRST HALF MATCH      1.3#04
         BNE       XLISH.13           GO DO NEXT IF NOT          1.3#04
         CAMW      R7,GPBUF1+193W,X3  DOES SECOND HALF MATCH     1.3#04
         BEQ       XLISH.14           BR TO FOUND IF IT DOES     1.3#04
XLISH.13 EQU       $                                             1.3#04
         ABR       R3,28           BUMP INDEX BY 2W              1.3#04
         BIW       R3,XLISH.12     PLUS 1W                       1.3#04
         BU        XLISH.11        DO NEXT SECTOR WHEN DONE      1.3#04
XLISH.14 EQU       $               HERE WHEN THEY MATCH          1.3#04
         LW        R6,GPBUF1+194W,X3    GET ADDR INFO            1.3#04
         BU        XLISH.2            AND GOTO TELL USER         1.3#04
*                                                                1.3#04
XLISH.19 EQU       $               HERE WHEN AN I/O ERROR        1.3#04
         LW        R6,0W,X1        GET LFC                       1.3#04
         SLL       R6,8                                          1.3#04
         SRL       R6,8            ZERO OUT THE TOP              1.3#04
         SBR       R6,2            NOW MAKE IT A BLANK           1.3#04
         STW       R6,XLISH.D2     AND STORE INTO MESSAGE        1.3#04
         LW        R5,3W,X1        GET FCB STATUS                1.3#04
         BL        M0216           AND CONVERT                   1.3#04
         STW       R6,XLISH.D1     SAVE 1ST HALF                 1.3#04
         STW       R7,XLISH.D1+1W  AND 2ND HALF IN MESSAGE       1.3#04
         LNB       R5,XLISH.ML     SET MESSAGE LENGTH (UT+SLO)   1.3#04
         LA        R6,XLISH.MT     AND MESSAGE ADDR              1.3#04
         BL        XTYPEF          NOW TELL THE USER             1.3#04
         LD        R6,XLISH94      RECOVER TEST SYMBOL           1.3#04
         ZMW       LT.DIRS,X2      ZERO DIR ENTRY                1.3#04
         BU        XLISH.1         AND CONTINUE ON NEXT DIR      1.3#04
*                                                                1.3#04
XLISH.20 EQU       $      HERE TO SEARCH MEM RESIDENT DIRECTORY  1.3#04
         LMW       R1,LT.DIRS,X2   GET ADDR OF DIRECTORY ABD     1.3#04
         LW        R3,0W,X1        SET UP R3 AS SEARCH INDEX     1.3#04
         LW        R5,1W,X1        SET UP R5 AS LIMIT            1.3#04
XLISH.21 EQU       $               LOOP TOP                      1.3#04
         CAMW      R6,0W,X3        TEST 1ST HALF OF SYMBOL       1.3#04
         BNE       XLISH.22        TRY NEXT IF NO MATCH          1.3#04
         CAMW      R7,1W,X3        ELSE TEST 2ND HALF            1.3#04
         BEQ       XLISH.23        AND SHOW FOUND IF MATCH       1.3#04
XLISH.22 EQU       $                                             1.3#04
         ADI       R3,3W           BUMP THE INDEX BY 1 ENTRY     1.3#04
         CAR       R5,R3           TEST FOR DIRECTORY END        1.3#04
         BLT       XLISH.21        LOOP IF NOT END               1.3#04
         BU        XLISH.1         DO NEXT DIRECTORY AT END      1.3#04
XLISH.23 EQU       $               HERE IF MATCH                 1.3#04
         LW        R6,2W,X3        GET ADDR INFO                 1.3#04
         BU        XLISH.2         AND GO TELL USER              1.3#04
XLISH90  RES       1F
XLISH94  DATAD     0
XLISH.MT DATAB     C' CATALOG(WARNING)   FCB STATUS= '           1.3#04
XLISH.D1 DATAB     C'12345678'                                   1.3#04
         DATAB     C' WHILE READING LFC= '                       1.3#04
XLISH.D2 DATAB     C'1234'                                       1.3#04
         DATAB     C' SEARCHING DISCONTINUED.'                   1.3#04
XLISH.ML DATAB     $-XLISH.MT                                    1.3#04
         BOUND     1W                                            1.3#04+
*
*-----------------------------------------------------------------------
         TITLE     XLIRD    - READ OBJECT RECORD FROM LIBRARY
***********************************************************************
*
*                  XLIRD
*
***********************************************************************
*
*----------------------------------------------------------------1.3#04
*                                                                1.3#04
*   XLIRD                                                        1.3#04
*                                                                1.3#04
*        THIS ROUTINE TRANSFERS THE NEXT LOGICAL RECORD FROM     1.3#04
*        THE LIBRARY DEBLOCKING BUFFER TO MCBUF.                 1.3#04
*                                                                1.3#04
*        IF THE REQUESTED RECORD IS FOR A SHARED FCB LIBRARY     1.3#04
*        THEN GPBUF1 IS USED, ELSE THE LIBBUF IS USED.           1.3#04
*                                                                1.3#04
*        IF THE REQUESTED RECORD IS NOT IN MEMORY, THE           1.3#04
*        APPROPRIATE BUFFER IS CHARGED.                          1.3#04
*                                                                1.3#04
*        IF R5<0 THEN NEXT SEQUENTIAL LOGICAL RECORD ON THE      1.3#04
*        CURRENT LFC IS RETURNED. THIS MODE IS SEQUENTIAL ACCESS 1.3#04
*        AND THE FILE WILL BE ADVANCED LOGICAL RECORD BY LOGICAL 1.3#04
*        AS REQUIRED. OTHERWISE, THE LOGICAL RECORD (SECTOR      1.3#04
*        RELATIVE) REQUESTED BY -R6- FROM SECTOR IN -R5- ON      1.3#04
*        FILE INDEXED (TO LFC TABLE) BY -R7- IS RETURNED         1.3#04
*                                                                1.3#04
*   IN   R7 = LFC TABLE INDEX OF DESIRED LIBRARY                 1.3#04
*        R6 = RELATIVE LOGICAL RECORD NUMBER (IFF R5>=0)         1.3#04
*        R5 = RELATIVE SECTOR NUMBER     OR                      1.3#04
*             IF < 0  NEXT SEQUENTIAL LOGICAL RECORD             1.3#04
*                                                                1.3#04
*   MAJOR VARIABLES                                              1.3#04
*                                                                1.3#04
GPB.LFCX DATAW  -1   LFC TABLE INDEX FOR FILE IN GPBUF1          1.3#04
GPB.SECT DATAW  -1   SECTOR NUMBER CURRENTLY IN GPBUF1           1.3#04
GPB.NLRC DATAW  -1   NEXT LOGICAL RECORD NUMBER IN GPBUF1        1.3#04
GPB.ADRX DATAW  -1   INDEX INTO GPBUF1 (RELATIVE GPBUF1)         1.3#04
GPB.NRIS DATAW  -1   NUMBER OF RECORDS IN BUFFER (FROM FILE)     1.3#04
*                                                                1.3#04
LBB.LFCX DATAW  -1   LFC TABLE INDEX FOR FILE IN LIBBUF          1.3#04
LBB.FSCT DATAW  -1   SECTOR NUMBER OF FIRST SECTOR IN LIBBUF     1.3#04
LBB.LSCT DATAW  -1   NUMBER OF LAST SECTOR IN LIBBUF             1.3#04
LBB.CSCT DATAW  -1   CURRENTLY ACTIVE SECTOR IN LIBBUF           1.3#04
LBB.CSBA DATAW  -1   BASE ADDR (REL 0) OF ACTIVE SECTOR BUFFER   1.3#04
LBB.NLRC DATAW  -1   NEXT LOGICAL RECORD NUMBER IN LBB.CSCT      1.3#04
LBB.NRIS DATAW  -1   NUMBER OF RECORDS IN CURRENT SECTOR BUFFER  1.3#04
LBB.ADRX DATAW   0   INDEX INTO LBB.CSCT (RELAIVE LIBBUF)        1.3#04
*                                                                1.3#04
XLIRD.CC DATAW     0               CALL COUNT                    1.3#04
XLIRD.PR DATAW     0               READ COUNT                    1.3#04
XLIRD.R0 DATAW     0               RETURN ADDR SAVE AREA        ENCD-32
*----------------------------------------------------------------1.3#04
*                                                                1.3#04
XLIRD    EQU       $                                             1.3#04
         ABM       31,XLIRD.CC     BUMP CALL COUNT               1.3#04
         STF       R0,XLIRD90      SAVE USER CONTEXT             1.3#04
         TRR       R5,R5           IS MODE NEXT SEQUENTIAL       1.3#04
         BN        XLIRD.30        BR, IF YES                    1.3#04
XLIRD.RC EQU       $               RECURSIVE CALL ENTRY          1.3#04
         TRR       R7,R2           ELSE, FIND REQUIRED LIB DATA  1.3#04
         LW        R4,=X'00FFFFFF' SET UP LFC TABLE MASK         1.3#04
         LB        R7,LT.LIBS,X2   GET TYPE CODE THIS LIBRARY    1.3#04
         CI        R7,2            IS IT PRIVATE FCB TYPE        1.3#04
         BEQ       XLIRD.20        BR, IF YES                    1.3#04
         CI        R7,7            IS IT SHARED FCB TYPE         1.3#04
         BEQ       XLIRD.10        BR, IF YES                    1.3#04
XLIRD.X  EQU       $               ELSE                          1.3#04
         LF        R0,XLIRD90      RECOVER USER CONTEXT          1.3#04
         TRSW      R0              AND RETURN                    1.3#04
         NOP                                                     1.3#04
*                                                                1.3#04
XLIRD.10 EQU       $               HERE TO QUALIFY TYPE 1 LIBS   1.3#04
         CAMW      R2,GPB.LFCX     IS CORRECT LIBRARY IN BUFFER  1.3#04
         BEQ       XLIRD.12        YES, SO GO CHECK DATA         1.3#04
XLIRD.11 EQU       $                                             1.3#04
         LMW       R7,LT.LIBS,X2            GET REQUESTED LFC    1.3#04
         STW       R7,GPFCB1+FCB.LFC        AND PLUG INTO FCB    1.3#04
         SBR       R7,2              MAKE TOP BYTE A BLANK       1.3#14
         STW       R7,ERRLFC+1W     AND SET INCASE LATER ERROR   1.3#14
         STW       R5,GPFCB1+FCB.ERAA       SET SECTOR ADDR      1.3#04
         ABM       31,XLIRD.PR     BUMP READ COUNT               1.3#04
         M.READ    GPFCB1             AND READ A CHUNK           1.3#04
         TBM       6,3W,X1         EOF?                          1.3#04
         BS        XLIRD.99        TREAT AS ERROR                1.3#04
         TBM       7,3W,X1         EOM?                          1.3#04
         BS        XLIRD.99        ALSO AN ERROR                 1.3#04
         TBM       8,GPBUF1        TEST FOR EOI                  1.3#11
         BNS       XLIRD.1A        SKIP IF NOT                   1.3#11
         SBM       6,3W,X1         SET EOF IN FCB                1.3#11
         BU        XLIRD.99        AND REPORT                    1.3#11
XLIRD.1A EQU       $                                             1.3#11
         STW       R2,GPB.LFCX     UPDATE GPBUF1 CONTROL         1.3#04
         STW       R5,GPB.SECT     INCLUDING SECTOR NUMBER       1.3#04
         ZMW       GPB.NLRC        LOGICAL RECORD NUMBER         1.3#04
         LB        R7,GPBUF1       GET NUM LOGICAL RECS IN BUFF  1.3#04
         STW       R7,GPB.NRIS     AND SET INTO CONTROL VARIABLE 1.3#04
         LI        R7,2W                                         1.3#04
         STW       R7,GPB.ADRX     AND BLOCK INDEX               1.3#04
         CAMW      R6,GPBUF1       IS REQUESTED RECORD IN SECTOR 1.3#04
         BGT       XLIRD.98        FORCE SEQUENCE ERROR IF NOT   1.3#04
XLIRD.12 EQU       $               HERE WHEN AT LEAST LFC IS OK  1.3#04
         CAMW      R5,GPB.SECT     CORRECT SECTOR IN MEMORY      1.3#04
         BNE       XLIRD.11        GO READ REQUIRED SECTOR       1.3#04
         LMW       R3,LT.LIBS,X2   GET LFC                       1.3#14
         SBR       R3,2            MAKE TOP BYTE A BLANK         1.3#14
         STW       R3,ERRLFC+1W    SAVE INCASE LATER ERROR       1.3#14
         ZMW       GPB.NLRC        RESET NEXT LOGICAL RECORD     1.3#11
         LI        R3,2W           AND                           1.3#11
         STW       R3,GPB.ADRX     INIT BLOCK POINTER            1.3#11
XLIRD.13 EQU       $               LOOP TOP                      1.3#04
         CAMW      R6,GPB.NLRC     ELSE, CHECK LOGICAL RECORD    1.3#04
         BEQ       XLIRD.14        BR IF POSITION OK             1.3#04
         ADMB      R3,GPBUF1,X3    BUMP BUFFER INDEX             1.3#04
         ABR       R3,31           TO NEXT RECORD LENGTH ENTRY   1.3#04
         STW       R3,GPB.ADRX     AND UPDATE IN MEMORY          1.3#04
         ABM       31,GPB.NLRC     BUMP NEXT LOGICAL RECORD      1.3#04
         BU        XLIRD.13        AND LOOP                      1.3#04
XLIRD.14 EQU       $               HERE WHEN ALL INDICES OK      1.3#04
         LA        R7,GPBUF1       GET BASE ADDR OF BUFFER       1.3#04
         STW       R7,XLR.ABA      AND SET ACTIVE BUFFER ADDRESS 1.3#04
         SBM       XLR.GPBA,XLR.FLAGS  INDICATE GP BUFFER IN USE 1.3#04
         BU        XLIRD.30        NOW DO NEXT SEQUENTIAL RECORD 1.3#04
*                                                                1.3#04
XLIRD.98 EQU       $                                             1.3#04
         LI        R3,-30W         ZERO THE MCBUFF               1.3#04
         ZMW       MCBUF+30W,X3                                  1.3#04
         BIW       R3,$-1W                                       1.3#04
         BU        XLIRD.X         AND QUIT                      1.3#04
*                                                                1.3#04
XLIRD.99 EQU       $               HERE IF A READ ERROR ON LIB   1.3#04
         LW        R5,0W,X1        GET THE LFC                   1.3#04
         SLL       R5,8                                          1.3#04
         SRL       R5,8            ZERO THE TOP                  1.3#04
         SBR       R5,2            MAKE IT A BLANK               1.3#04
         STW       R5,XLR.MD2      STORE INTO MESSAGE            1.3#04
         LW        R5,3W,X1        GET FCB STATUS                1.3#04
         M.CONBAH                  CONVERT TO HEX                1.3#04
         STW       R6,XLR.MD1      SAVE 1ST HALF                 1.3#04
         STW       R7,XLR.MD1+1W   AND SECOND HALF               1.3#04
         LNB       R5,XLR.ML       GET LENGTH (UT&SLO)           1.3#04
         LA        R6,XLR.MSG      TEXT ADDR                     1.3#04
         BL        XTYPEF          AND LOG TO USER               1.3#04
         BL        XABORT          AND QUIT                      1.3#04
*                                                                1.3#04
XLR.MSG  DATAB     C' CATALOG<<FATAL>>  FCB STATUS = '           1.3#04&
XLR.MD1  REZ       8B              HOLDS ACH FCB STATUS          1.3#04&
         DATAB     C'   ON LFC   '                               1.3#04&
XLR.MD2  REZ       4B              HOLDS LFC                     1.3#04&
XLR.ML   DATAB     $-XLR.MSG                                     1.3#04
         BOUND      1W                                           1.3#04+
*                                                                1.3#04
*                                                                1.3#04
XLIRD.20 EQU       $               HERE FOR PRIVATE FCB'S        1.3#04
         CAMW      R2,LBB.LFCX     TEST WHICH FILE               1.3#04
         BEQ       XLIRD.23        BR IF OK                      1.3#04
XLIRD.21 EQU       $                                             1.3#04
         LI        R7,LIBNSC       SET UP DEFAULT BLOCK SIZE     1.3#04
         ADR       R5,R7           ADD IN REQUESED FIRST SECTOR  1.3#04
         STW       R7,LBB.LSCT     IN CONTROL VARIABLE           1.3#04
         LMW       R1,LT.LIBS,X2   GET FCB ADDR                  1.3#04
         LMW       R7,0W,X1        GET LFC                       1.3#14
         SBR       R7,2            MAKE TOP BYTE A BLANK         1.3#14
         STW       R7,ERRLFC+1W    STORE INCASE LATER ERROR      1.3#14
         STW       R5,FCB.ERAA,X1  SET UP RANDOM ADDRESS         1.3#04
         ABM       31,XLIRD.PR     BUMP READ COUNT               1.3#04
         M.READ                                                  1.3#04
         TBM       6,3W,X1         EOF?                          1.3#04
         BS        XLIRD.2A        PROCESS IF SET                1.3#04
         TBM       7,3W,X1         EOM?                          1.3#04
         BNS       XLIRD.22        BR IF NOT                     1.3#04
XLIRD.2A EQU       $               HERE IF EOF OR EOM            1.3#04
         BL        XUL.HXR         TO FORM X'...'                1.3#10
         LA        R3,XLR.M2D2     LOCATE                        1.3#10
         BL        XST2            AND PLUG                      1.3#10
         LW        R7,0W,X1        GET LFC                       1.3#10
         ANMW      R7,=X'00FFFFFF' MASK                          1.3#10
         LA        R3,XLR.M2D1     LOCATE                        1.3#10
         BL        XSTB            AND PLUG                      1.3#10
         LNB       R5,XLR.M2L                                    1.3#10
         LA        R6,XLR.M2A                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BL        XABORT                                        1.3#10
*                                                                1.3#10
XLR.M2A  DATAB     C' CATALOG<<FATAL>> EOF/EOM ON LFC  '         1.3#10
XLR.M2D1 REZ       3B              LFC CODE                      1.3#10
         DATAB     C'  READING SECTOR  '                         1.3#10
XLR.M2D2 REZ       8B              HEX SECTOR NUMBER             1.3#10
         DATAB     C'.'                                          1.3#10
XLR.M2L  DATAB     $-XLR.M2A                                     1.3#10
         BOUND     1W                                            1.3#10
*                                                                1.3#10
*----------------------------------------------------------------1.3#10
*                                                                1.3#10
XLIRD.22 EQU       $                                             1.3#04
         LW        R7,4W,X1        GET XFER COUNT                1.3#04
         CAMW      R7,9W,X1        IS IT WHAT WE ASKED FOR       1.3#10
         BEQ       XLIRD.2B        THEN CONTINUE                 1.3#10
         ZR        R3                                            1.3#04
         XCR       R3,R6           SAVE R6                       1.3#04
         DVI       R6,768          CALCULATE NUMBER OF SECTORS   1.3#04
         ADR       R5,R7           ADD IN FIRST REQUESTED SECTOR 1.3#10+
         STW       R7,LBB.LSCT     SAVE AS BLOCK SIZE            1.3#10+
         XCR       R6,R3           RESTORE R6                    1.3#04
         NOP                       OUT OF EXECUTION PATH         1.3#04
XLIRD.2B EQU       $                                             1.3#10
         STW       R2,LBB.LFCX     INIT LIBBUF CONTROL VARIABLES 1.3#04
         STW       R5,LBB.FSCT     INCLUDING  FIRST SECTOR NUM   1.3#04
         STW       R5,LBB.CSCT     CURRENT SECTOR NUMBER         1.3#04
         LW        R2,LIBBUFA      GET BUFFER BASE ADDR          1.3#04
         TBM       8,0,X2          IS THIS THE EOI BLOCK         1.3#10
         BS        XLIRD.27        TREAT AS AN EOF/EOM           1.3#10
         STW       R2,LBB.CSBA     AND SET UP SECTOR BUFFER BASE 1.3#04
         ZMW       LBB.NLRC        NEXT LOGICAL RECORD           1.3#04
         LI        R7,2W           START AT 8 BYTES              1.3#04
         STW       R7,LBB.ADRX       AS SECTOR BUFFER OFFSET     1.3#04
         LB        R7,0W,X2        GET NUMBER OF RECS THIS SECT  1.3#04
         STW       R7,LBB.NRIS     AND SET CONTROL VARIABLE      1.3#04
         BU        XLIRD.24        SKIP LOCATOR STUFF            1.3#10
*
*
XLIRD.23 EQU       $               HERE WHEN AT LEAST FILE IS OK 1.3#04
         CAMW      R5,LBB.FSCT     TEST SECTOR RANGE             1.3#04
         BLT       XLIRD.21        READ SECTOR IF BELOW          1.3#04
         CAMW      R5,LBB.LSCT     TRY LAST SECTOR               1.3#04
         BGT       XLIRD.21        READ IF ABOVE                 1.3#04
         LW        R2,LT.LIBS,X2   GET FCB ADDR                  1.3#14
         LMW       R2,0W,X2        GET LFC                       1.3#14
         SBR       R2,2            MAKE TOP BYTE A BLANK         1.3#14
         STW       R2,ERRLFC+1W    SAVE INCASE LATER ERROR       1.3#14
         STW       R5,LBB.CSCT     SET REQUESTED AS CURRENT      1.3#04
         SUMW      R5,LBB.FSCT     REMOVE START OF BUFFER SECT # 1.3#04
         ZR        R4                                            1.3#04
         MPI       R4,768          MULTIPLY BY SECTOR SIZE       1.3#04
         ADMW      R5,LIBBUFA      ADD IN BUFFER BASE ADDR       1.3#04
         TRR       R5,R2           AND USE AS INDEX              1.3#04
         TBM       8,0,X2          IS THIS THE EOI BLOCK         1.3#10
         BS        XLIRD.27        TREAT AS EOF/EOM              1.3#10
         LB        R5,0W,X2        GET NUMBER RECS THIS SECTOR   1.3#04
         STW       R5,LBB.NRIS     AND SAVE                      1.3#04
         STW       R2,LBB.CSBA     AND SET CUR.SECT BASE ADDR    1.3#04
         ZMW       LBB.NLRC        INIT LOGICAL REC COUNTER      1.3#04
         LI        R5,2W           SET SECTOR OFFSET             1.3#04
         STW       R5,LBB.ADRX     AS 8 BYTES                    1.3#04
XLIRD.24 EQU       $                                             1.3#04
         CAMW      R6,LBB.NRIS     VALIDATE REQUESTED REC #      1.3#04
         BGT       XLIRD.98        BR TO FORCE SEQ ERR IF GT     1.3#04
         LW        R3,LBB.CSBA     GET SECTOR BASE               1.3#04
         ADMW      R3,LBB.ADRX     ADD THIS SECTOR OFFSET        1.3#04
XLIRD.25 EQU       $               LOOP TO CORRECT LOGICAL REC.  1.3#04
         CAMW      R6,LBB.NLRC     ARE WE THERE                  1.3#04
         BEQ       XLIRD.26        BR IF YES                     1.3#04
         LB        R4,0,X3         GET NEXT REC SIZE             1.3#04
         ABR       R4,31           BUMP TO START OF NEXT RECORD  1.3#04
         ARMW      R4,LBB.ADRX     UPDATE RELATIVE POINTER       1.3#04
         ADR       R4,R3           UPDATE ABSOLUTE POINTER       1.3#04
         ABM       31,LBB.NLRC     UPDATE NEXT LOGICAL RECORD    1.3#04
         BU        XLIRD.25        AND LOOP                      1.3#04
XLIRD.26 EQU       $               HERE WHEN POSITIONED          1.3#04
         LW        R7,LBB.CSBA     GET CURRENT SECT BUFF BASE    1.3#04
         STW       R7,XLR.ABA      AND SET ACTIVE BUFFER         1.3#04
         ZBM       XLR.GPBA,XLR.FLAG    INDICATE LIBBUF IN USE   1.3#04
         BU        XLIRD.30        AND PROCESS                   1.3#04
*
XLIRD.27 EQU       $               HERE IF EOI DETECTED          1.3#04
         LW        R1,LBB.LFCX     GET ACTIVE LFC INDEX          1.3#10
         LW        R1,LT.LIBS,X1   GET FCB ADDR                  1.3#10
         LW        R5,LBB.CSCT     GET CURRENT SECTOR NUMBER     1.3#10
         BU        XLIRD.2A        AND REPORT ERROR              1.3#10
*                                                                1.3#04
*
*
XLIRD.30 EQU       $                                             1.3#04
         TBM       XLR.GPBA,XLR.FLAG    WHICH MODE               1.3#04
         BNS       XLIRD.50         GO DO LARGE BUFFER           1.3#04
XLIRD.40 EQU       $               HERE FOR SMALL BUFFER         1.3#04
         LW        R3,GPB.NRIS     GET NUMBER OF RECORDS IN SECT 1.3#04
         CAMW      R3,GPB.NLRC     ARE WE IN SECTOR              1.3#04
         BGT       XLIRD.41        BR IF YES                     1.3#04
         LW        R5,GPB.SECT     ELSE GET SECTOR NUMBER        1.3#04
         ABR       R5,31           BUMP TO NEXT                  1.3#04
         ZR        R6              AND FIRST LOGICAL RECORD      1.3#04
         LW        R7,GPB.LFCX     AND FILE INDEX                1.3#04
         BU        XLIRD.RC        AND GO GET NEXT SECTOR        1.3#04
XLIRD.41 EQU       $               HERE IF IN SECTOR             1.3#04
         LA        R3,GPBUF1       ADDR OF GP BUFFER             1.3#04
         ADMW      R3,GPB.ADRX     ADD IN THE CURRENT OFFSET     1.3#04
         TRR       R3,R7           SAVE FOR LATER                1.3#04
         LNB       R4,0B,X3        GET SIZE OF THIS RECORD       1.3#04
         ABR       R3,31           BUMP PAST LENGTH BYTE         1.3#04
         BL        XLIRD.60        GO XFER DATA                  1.3#04
         TRR       R7,R3           RECOVER INDEX                 1.3#04
         LB        R4,0B,X3        GET LENGTH OF REC JUST XFERD  1.3#4
         ABR       R4,31           BUMP RECORD SIZE              1.3#04
         ARMW      R4,GPB.ADRX     AND ADD TO BUFFER OFFSET      1.3#04
         ABM       31,GPB.NLRC     BUMP NEXT LOGICAL RECORD      1.3#04
         BU        XLIRD.X         AND RETURN TO USER            1.3#04
*                                                                1.3#04
XLIRD.50 EQU       $                                             1.3#04
         LW        R3,LBB.NRIS     GET NUMBER RECS IN SECTOR     1.3#04
         CAMW      R3,LBB.NLRC     ARE WE STILL IN SECTOR        1.3#04
         BGT       XLIRD.51        BR IF WE ARE                  1.3#04
         LW        R5,LBB.CSCT     ELSE GET CURRENT SECTOR       1.3#04
         ABR       R5,31           AND BUMP                      1.3#04
         ZR        R6              SET UP FIRST LOGICAL REC      1.3#04
         LW        R7,LBB.LFCX     AND GET FILE INDEX            1.3#04
         BU        XLIRD.RC        AND CYCLE TO UPDATE BUFFER    1.3#04
XLIRD.51 EQU       $               HERE WHEN IN SECTOR           1.3#04
         LW        R3,LBB.CSBA     GET ADDR OF THIS SECTOR BUF   1.3#04
         ADMW      R3,LBB.ADRX     BUMP BY CURRENT OFFSET        1.3#04
         TRR       R3,R7           HOLD FOR LATER                1.3#04
         LNB       R4,0B,X3        GET LENGTH OF CURRENT REC     1.3#04
         ABR       R3,31           BUMP PAST LENGTH BYTE         1.3#04
         BL        XLIRD.60        GO XFER RECORD                1.3#04
         TRR       R7,R3           RECOVER BUFFER INDEX          1.3#04
         LB        R4,0B,X3        GET SIZE OF RECORD JUST XFERD 1.3#04
         ABR       R4,31           INCLUDE THE LENGTH BYTE       1.3#04
         ARMW      R4,LBB.ADRX     AND UPDATE OFFSET             1.3#04
         ABM       31,LBB.NLRC     BUMP TO NEXT LOGICAL RECORD   1.3#04
         BU        XLIRD.X         AND RETURN TO USER            1.3#04
*                                                                1.3#04
XLIRD.60 EQU       $               ROUTINE TO MOVE DATA          1.3#04
         LA        R2,MCBUF        GET ADDR OF DESTINATION       1.3#04
XLIRD.61 EQU       $               LOOP TOP                      1.3#04
         LB        R1,0B,X3        GET A BYTE                    1.3#04
         STB       R1,0B,X2        PUT A BYTE                    1.3#04
         ABR       R2,31           BUMP DEST                     1.3#04
         ABR       R3,31           BUMP SOURCE                   1.3#04
         BIB       R4,XLIRD.61     AND LOOP                      1.3#04
         TRSW      R0              RETURN TO CALLER              1.3#04
*                                                                1.3#04
XLIRD90  RES       1F
XLR.ABA  DATAW     0               HOLDS BASE OF ACTIVE BUFFER   1.3#04
XLR.FLAG DATAW     0               PROCESSING FLAGS              1.3#04
XLR.GPBA EQU       0           SET INDICATES GPBUF1 IS ACTIVE    1.3#04
         TITLE     XABORT   - CATALOG ABORT ROUTINE
***********************************************************************
*
*  XABORT  -  COMMON ABORT ROUTINE FOR UNSUCCESSFUL CATALOGING
*
*        THIS ROUTINE PRINTS THE MESSAGE "CATALOGING NOT SUCCESSFUL"
*        AND THEN ISSUES AN ABORT WITH ABORT CODE "CT06".
***********************************************************************
*
XABORT   EQU       $                                             1.3#10
         TBM       XLMFBAD,XFLGS   DID WE GET A LOAD MODULE      1.3#10
         BS        XABORT01        SKIP IF WE DID NOT            1.3#10
         LNB       R5,TRMMSG.L                                   1.3#10
         LA        R6,TRMMSG                                     1.3#10
         BL        XTYPEF                                        1.3#10
         BU        XABORT1                                       1.3#10
XABORT01 EQU       $                                             1.3#10
         LA        R6,MCATUN       ADDR OF "CATALOGING NOT SUCCESSFUL"
         LNB       R5,MCATUN.L                                   1.3#10
         BL        XTYPEF                                        1.3#10
XABORT1  EQU       $               ENTRY POINT FOR ABORT AT EXIT   21016
*!!!!!!!!BL!!!!!!!!XBIRD!!!!!!!!!!!READ!SGO!(INCASE!NOT!OPEN)!!!ENCD-32
*!!!!!!!!BL!!!!!!!!XBIRW!!!!!!!!!!!NOW!REWIND!IT!!!!!!!!!!!!!!!!ENCD-32
         LW        R3,SGPNTRS+1W   GET SGO FAT ADDRESS          PR10808
         LW        R5,DFT.EOF,X3   GET SGO SIZE                 PR10808
         CI        R5,0            ANYTHING ON SGO?             PR10808
         BEQ       XABORT3         SKIP REWIND IF NO SGO        PR10808
         TBM       XBIRDFST,XFLGS  IS SGO OPEN?                 PR10808
         BS        XABORT2         SKIP OPEN IF SO              PR10808
         M.OPENR   XBIRD91,EXITCNP   OPEN SGO                   PR10808
XABORT2  M.RWND    XBIRD91           REWIND SGO                 PR10808
XABORT3  EQU       $                                            PR10808
         M.BORT    =C'CT06'        ABORT CATALOG
         TITLE     XGOPO    - POSITION OBJECT FILE TO PROGRAM
************************************************************************
*
*                  XGOPO
*
************************************************************************
*
*        POSITION OBJECT FILE TO PROGRAM WHOSE NAME IS SPECIFIED IN    *
*        R6,R7.
*
*        IN : R6,R7 - PROGRAM NAME TO POSITION FILE TO          ENCD-32
*             R5 - IF ZERO POSITION SGO FILE                    ENCD-32
*                  IF NON-ZERO POSITION OBJ FILE                ENCD-32
*                                                               ENCD-32
*        OUT : R6 - ZERO IF PROGRAM NOT FOUND                   ENCD-32
*
************************************************************************
XGOPO    STF       R0,XGOPO90
         ZBM       MOBJPOS,MFLAG2  CLEAR FROM PREVIOUS CALL     ENCD-32
         CI        R5,0            WHICH FILE TO POSITION       ENCD-32
         BEQ       XGOPO1.2        POSITION SGO                 ENCD-32
         SBM       MOBJPOS,MFLAG2  SIGNAL OBJ POSITIONING       ENCD-32
         BU        XGOPO1.3                                     ENCD-32
*!XGOPO1!!!BL!!!!!!XBIRD!!!!!!!!!!!READ!A!CARD!FROM!SGO!!!!!!!!!ENCD-32
XGOPO1   TBM       MOBJPOS,MFLAG2  WHICH FILE TO POSITION?      ENCD-32
         BS        XGOPO1.3        POSITION OBJ                 ENCD-32
XGOPO1.2 BL        XBIRD           READ CARD FROM SGO           ENCD-32
         BU        XGOPO1.4        CONTINUE                     ENCD-32
XGOPO1.3 BL        XOBRD           READ CARD FROM OBJ           ENCD-32
XGOPO1.4 TRR       R5,R5                                        ENCD-32
         BEQ       XGOPO4          BR IF NO EOF READ
         TBM       MOBJPOS,MFLAG2  WHICH ARE WE POSITIONING     ENCD-32
         BS        XGOPO1.5        OBJ                          ENCD-32
         BL        XBIRW           REWIND SGO
         BU        XGOPO1.6        CONTINUE                     ENCD-32
XGOPO1.5 BL        XOBRW           REWIND OBJ FILE              ENCD-32
XGOPO1.6 SBM       7,XGOPO92                                    ENCD-32
         BNS       XGOPO1          BR IF NO PREVIOUS EOF
         ZMW       XGOPO90+6W
XGOPO2   ZMB       XGOPO92
         LF        R0,XGOPO90
         TRSW      R0              RETURN
XGOPO4   LW        R5,=C'    '
         STW       R5,XGOPO91
         STW       R5,XGOPO91+1W
         LI        R4,X'F0'
         LA        R2,MCBUF
         LMB       R5,6B,R2
         CI        R5,X'50'
         BNE       XGOPO1          BR IF NOT PROGRAM NAME RECORD
         SRL       R4,4
         LMB       R3,6B,R2
         SUI       R3,3B
         TRN       R3,R3
         BGT       XGOPO1          BR IF BAD CARD
         BZ        XGOPO6
         LI        R1,7B
XGOPO5   LB        R5,MCBUF,R1
         STB       R5,XGOPO91-7B,R1
         ABR       R1,31
         BIB       R3,XGOPO5
XGOPO6   CAMD      R6,XGOPO91
         BEQ       XGOPO2          BR IF PROGRAM FOUND
         BU        XGOPO1
XGOPO90  RES       1F
XGOPO91  DATAD     0
XGOPO92  DATAB     0
         TITLE     XTMPO    - POSITION 'TEMP' FILE TO PROGRAM   ENCD-32
************************************************************************
*                                                               ENCD-32
*                  XTMPO                                        ENCD-32
*                                                               ENCD-32
************************************************************************
*
*        POSITION SGO FILE TO PROGRAM WHOSE NAME IS SPECIFIED IN R6,7.
*        R6 IS ZERO ON RETURN IF PROGRAM NOT FOUND
*
************************************************************************
XTMPO    STF       R0,XTMPO90                                   ENCD-32
         BL        XTMRW                                        ENCD-32
XTMPO1   BL        XTMRD           READ A CARD FROM TEMP        ENCD-32
         TRR       R5,R5                                        ENCD-32
         BEQ       XTMPO4          BR IF NO EOF READ            encd-32
         BL        XTMRW           REWIND SGO                   ENCD-32
         SBM       7,XTMPO92                                    ENCD-32
         BNS       XTMPO1          BR IF NO PREVIOUS EOF        ENCD-32
         ZMW       XTMPO90+6W                                   ENCD-32
XTMPO2   ZMB       XTMPO92                                      ENCD-32
         LF        R0,XTMPO90                                   ENCD-32
         TRSW      R0              RETURN                       ENCD-32
XTMPO4   LW        R5,=C'    '                                  ENCD-32
         STW       R5,XTMPO91                                   ECD-32
         STW       R5,XTMPO91+1W                                ENCD-32
         LI        R4,X'F0'                                     ENCD-32
         LA        R2,MCBUF                                     ENCD-32
         LMB       R5,6B,R2                                     ENCD-32
         CI        R5,X'50'                                     ENCD-32
         BNE       XTMPO1        BR IF NOT PROGRAM NAME RECORD  ENCD-32
         SRL       R4,4                                         ENCD-32
         LMB       R3,6B,R2                                     ENCD-32
         SUI       R3,3B                                        ENCD-32
         TRN       R3,R3                                        ENCD-32
         BGT       XTMPO1          BR IF BAD CARD               ENCD-32
         BZ        XTMPO6                                       ENCD-32
         LI        R1,7B                                        ENCD-32
XTMPO5   LB        R5,MCBUF,R1                                  ENCD-32
         STB       R5,XTMPO91-7B,R1                             ENCD-32
         ABR       R1,31                                        ENCD-32
         BIB       R3,XTMPO5                                    ENCD-32
XTMPO6   CAMD      R6,XTMPO91                                   ENCD-32
         BEQ       XTMPO2          BR IF PROGRAM FOUND          ENCD-32
         BU        XTMPO1                                       ENCD-32
XTMPO90  RES       1F                                           ENCD-32
XTMPO91  DATAD     0                                            ENCD-32
XTMPO92  DATAB     0                                            ENCD-32
         TITLE     XBIRW    - REWIND 'SGO' FILE
************************************************************************
*
*                  XBIRW
*
************************************************************************
*
*        REWIND SGO FILE
*
************************************************************************
XBIRW    STD       R0,XBIRW90
         TBM       XBIRDFST,XFLGS
         BNS       XBIRW1          BR IF SGO NOT OPEN
*!!!!!!!!M.RWND!!!!XBIRD91!!!!!!!!!REWIND!SGO!!!!!!!!!!!!!!!!!!!ENCD-32
         LA        R1,XBIRD91                                   ENCD-32
         BL        BB.RWND         REWIND SGO                   ENCD-32
XBIRW1   LD        R0,XBIRW90
         TRSW      R0              RETURN
XBIRW90  DATAD     0
         SPACE     4
         TITLE     XOBRW    - REWIND 'OBJ' FILE
************************************************************************
*                                                               ENCD-32
*                  XOBRW                                        ENCD-32
*                                                               ENCD-32
************************************************************************
*                                                               ENCD-32
*        REWIND OBJ FILE                                        ENCD-32
*                                                               ENCD-32
************************************************************************
XOBRW    STD       R0,XOBRW90                                   ENCD-32
         TBM       XOBRDFST,XFLGS                               ENCD-32
         BNS       XOBRW1          BR IF OBJ NOT OPEN           ENCD-32
*!!!!!!!!M.RWND!!!!XOBJECT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
         LA        R1,XOBJECT                                   ENCD-32
         BL        BB.RWND         REWIND OBJ                   ENCD-32
XOBRW1   LD        R0,XOBRW90                                   ENCD-32
         TRSW      R0              RETURN                       ENCD-32
XOBRW90  DATAD     0                                            ENCD-32
         SPACE     4
         TITLE     XTMRW    - REWIND 'TEMP' FILE
************************************************************************
*                                                               ENCD-32
*                  XTMRW                                        ENCD-32
*                                                               ENCD-32
************************************************************************
*                                                               ENCD-32
*        REWIND TEMP FILE                                       ENCD-32
*                                                               ENCD-32
************************************************************************
XTMRW    STD       R0,XTMRW90                                   ENCD-32
         LA        R1,XTEMP                                     ENCD-32
         BL        BB.RWND         REWIND FILE                  ENCD-32
XTMRW1   LD        R0,XTMRW90                                   ENCD-32
         TRSW      R0              RETURN                       ENCD-32
XTMRW90  DATAD     0                                            ENCD-32
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     XGETDP   - GET DATAPOOL DEFINITION
************************************************************************
*                  XGETDP
************************************************************************
*
*        CALLING     R5 = DPOOLTAB INDEX                         1.3#15
*                 R6,R7 = SYMBOL TO FIND                         1.3#15
*                                                                1.3#15
*        EXIT      R5 = RELATIVE ADDRESS OF SYMBOL               1.3#15
*                 CC1 = 1 IF SYMBOL NOT FOUND                    1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
*                                                                1.3#15
         SPACE     3
*                                                                1.3#15
XGETDP   STF       R0,DPSAVE       SAVE THE REGS                 1.3#15
*                                                                1.3#15
*   FOLLOWING CODE MOVED FROM M2DPL AS PART OF MULTI-DATAPOOL    1.3#15
*   PERFORMANCE ENHANCEMENT.                                     1.3#15
*                                                                1.3#15
         SBM       M2DPF,MFLGS                                   1.3#15
         BS        XGTDP1.5        BR IF NOT FIRST ENTRY         1.3#15
         LNW       R5,MDPNE                                      1.3#15
         LW        R1,MDPFT                                      1.3#15
         STW       R1,MDPNS                                      1.3#15
XGTDP1   ZMW       0,R1            CLEAR DATAPOOL TABLE          1.3#15
         ZMW       1W,R1                                         1.3#15
         ZMW       2W,R1                                         1.3#15
         ADI       R1,3W                                         1.3#15
         BIB       R5,XGTDP1                                     1.3#15
         ZMW       MDPNA           INDICATE TABLE IS EMPTY       1.3#15
XGTDP1.5 EQU       $                                             1.3#15
*@@XGTDP3!!!LNW!!!!!!!R5,MDPNA!!!!USE!NUMBER!OF!ACTIVE!ENTRIES!!!|86.1217
XGTDP3   LNW       R4,MDPNA        USE NUMBER OF ACTIVE ENTRIES |86.1217
         BZ        XGTDP4.2        TABLE IS EMPTY                1.3#15
         LW        R1,MDPFT                                      1.3#15
XGTDP4   LW        R6,0,R1                                       1.3#15
         LW        R7,1W,R1                                      1.3#15
         CAMD      R6,DPSAVE+6W                                  1.3#15
         BNE       XGTDP4.1        BR IF NAME NOT FOUND IN TABLE 1.3#15
         LB        R5,2W,X1        GET DPOOL NUM.                1.3#15
         CAMB      R5,DPSAVE+5W+3B SEE IF DPOOL NUM. MATCH      S890747
         BNE       XGTDP4.1        IF NOT, KEEP SEARCHING        1.3#15
         LW        R5,2W,X1        GET VALUE                     1.3#15
         ANMW      R5,=X'00FFFFFF' KEEP OFFSET ONLY              1.3#15
         STW       R5,DPSAVE+5W    SAVE FOR USER                 1.3#15
         ZBM       1,DPSAVE        CLEAR NOT FOUND FLAG          1.3#15
         BU        DPI             AND RETURN                    1.3#15
XGTDP4.1 ADI       R1,3W                                         1.3#15
*@@!!!!!!!!!BIB!!!!!!!R5,XGTDP4!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!|86.1217
         BIB       R4,XGTDP4                                    |86.1217
*                                                                1.3#15
XGTDP4.2 EQU       $          HERE IF NOT FOUND IN TABLE         1.3#15
*                                                                1.3#15
         LW        R3,DPSAVE+5W    RESTORE R5 CALL VALUE         1.3#15
         SLL       R3,4            CONVERT TO TABLE INDEX        1.3#15
         LW        R5,DPOOLTAB+LPRIME,X3    GET PRIME VALUE      1.3#15
         STW       R5,DPSIZE       AND SET UP FOR HASHER         1.3#15
         LW        R5,DPOOLTAB+DPLFC,X3     GET LFC              1.3#15
         CAMW      R5,=X'FFFFFFFF' IS THIS ENTRY UNUSED         S880176
         BNE       $+3W            CONTINUE IF NOT              S880176
         SBM       1,DPSAVE        SET NOT FOUND FLAG           S880176
         BU        DPI             RETURN                       S880176
         STW       R5,GPFCB2       AND SAVE IN FCB               1.3#15
         SBM       4,GPFCB2+2W     MAKE SURE ITS RANDOM I/O      1.3#15
         LA        R5,GPBUF2       ADDR OF BUFFER                1.3#15
         STW       R5,GPFCB2+FCB.ERWA  INTO FCB                  1.3#15
         LI        R5,768          SIZE                          1.3#15
         STW       R5,GPFCB2+FCB.EQTY  INTO FCB                  1.3#15
*
         LW        R7,DPSAVE+6W
         EOMW      R7,DPSAVE+7W    EXCLUSIVE 'OR' LABEL HALVES.
         ZR        R6
         DVMW      R6,DPSIZE       DIVIDE BY PRIME NO. OF ENTRIES.
         BL        DPF             R6=ENTRY NUMBER.
         ZR        R6
         DVMW      R6,DPSIZE       DIVIDE 1ST QUOTIENT BY PRIME NO.
DPE      EQU       $
         BL        DPF             R6=ENTRY NUMBER.
         ADI       R6,37           INCREMENT FOR NEW ENTRY NUMBER.
         CAMW      R6,DPSIZE
         BLT       DPE
         SUMW      R6,DPSIZE       USE MODULO ARITHMETIC
         BU        DPE
         SPACE     5
DPF      EQU       $
         ZR        R3
         TRR       R6,R2           R2=ENTRY NUMBER.
         SRLD      R2,3            R2=ENTRY NO.IN BLOCK.
         SLC       R3,3
         STW       R2,GPFCB2+FCB.ERAA    SET SECTOR ADDRESS      1.3#15
         MPI       R2,24W          R3=POINTER TO ENTRY IN BLOCK.
         M.READ    GPFCB2          READ COMPUTED BLOCK NUMBER    1.3#15
         TBM       24,GPBUF2+22W,R3                              1.3#15
         BNS       DPG             SKIP IF ENTRY INACTIVE.
         LD        R4,GPBUF2,R3                                  1.3#15
         CAMD      R4,DPSAVE+6W
         BEQ       DPH             BRANCH IF LABEL MATCH FOUND.
DPG      EQU       $
         TBM       28,GPBUF2+22W,R3                              1.3#15
         BNS       DPT             DENIAL IF NO COLLISIONS HERE.
         TRSW      R0              RETURN FOR NEXT MAPING ALGO.
         SPACE     5
DPH      EQU       $
         LW        R5,DPSAVE+5W    GET DATAPOOL NUMBER          S890747B
         SLL       R5,24           POSITION IT                  S890747B
         ORMW      R5,GPBUF2+20W,R3    OR IN RELATIVE ADDRESS   S890747B
*!!!!!!!!LW!!!!!!!!R5,GPBUF2+20W,R3!!GET!RELATIVE!ADDR.!!!!!!!!!S890747B
         STW       R5,DPSAVE+5W                                  1.3#15
*                                                                1.3#15
         LD        R6,DPSAVE+6W    RECOVER SYMBOL                1.3#15
         LW        R2,MDPNS                                      1.3#15
         STW       R6,0,R2         STORE NAME IN DATAPOOL TABLE  1.3#15
         STW       R7,1W,R2                                      1.3#15
         LB        R4,DPSAVE+5W    GET DPOOL NUM.
         SLL       R4,5            GET READY FOR DOUBLE SHIFT    1.3#15
         SLL       R5,13                                         1.3#15
         SRLD      R4,13           DPOOL NUM. AND REL ADDRESS    1.3#15
         STW       R5,2W,R2         ADDR LIMITED TO 19 BITS      1.3#15
         ADI       R2,3W                                         1.3#15
         LW        R7,MDPNE                                      1.3#15
         CAMW      R7,MDPNA        WHERE IS ACTIVE               1.3#15
         BEQ       DPH.1           BR,  IF TABLE FULL            1.3#15
         ABM       31,MDPNA        ELSE BUMP COUNT               1.3#15
         BU        DPH.2           CONTINUE                      1.3#15
DPH.1    EQU       $                                             1.3#15
         SBM       XGDPTF,XGDPFLGS  DID WE TELL USER             1.3#15
         BS        DPH.2           CONTINUE IF WE DID            1.3#15
         LW        R5,MPLST        GET TOP OF TABLES             1.3#15
         ADI       R5,4W           ROUND UP                      1.3#15
         CAMW      R5,=X'00080000'  COMPARE TO END OF NONEXTND   1.3#15
         BGE       DPH.2           DON'T BOTHER WITH MESSAGE     1.3#15
         LB        R5,XGDP.MSL                                   1.3#15
         LA        R6,XGDP.MSG                                   1.3#15
         BL        XTYPEF                                        1.3#15
*                                                                1.3#15
DPH.2    EQU       $                                             1.3#15
         MPI       R6,3W                                         1.3#15
         ADMW      R7,MDPFT                                      1.3#15
         CAR       R2,R7                                         1.3#15
         BGT       $+2W            BR IF NOT END OF TABLE        1.3#15
         LW        R2,MDPFT                                      1.3#15
         STW       R2,MDPNS                                      1.3#15
*                                                                1.3#15
         ZBM       1,DPSAVE        INDICATE GOOD VALUE           1.3#15
DPI      EQU       $
         LF        R0,DPSAVE
         TRSW      R0              RETURN TO CALLER.
XGDPFLGS DATAH     0               XGETDP FLAGS                  1.3#15
XGDPTF   EQU       0               SET INDICATES TABLE FULL      1.3#15
*
         SPACE     5
*
DPT      EQU       $                                             1.3#15
         SBM       1,DPSAVE        SET ERROR FLAG                1.3#15
         BU        DPI
         SPACE     5
         BOUND     8W
DPSAVE   RES       8W
DPSIZE   DATAW     0
SDPSIZE  DATAW     0               MAX. PRIME OF DPD             11017
DPADDR   DATAW     0
SDPADDR  DATAW     0               ADDRESS OF DATAPOOL           11017
DPLAST   DATAW     0
SDPLAST  DATAW     0               END OF DATAPOOL               11017
DPNAME   DATAD     C'DATAPOOL'
*
XGDP.MSG DATAB     C' Datapool Dictionary table wrap around,'    1.3#15
         DATAB     C' $ALLOCATE (+2000) to improve performance.' 1.3#15
XGDP.MSL DATAB     $-XGDP.MSG                                    1.3#15
         BOUND     1W                                            1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
         TITLE     XSYM     - OUTPUT SYMTAB TO 'SYM'
***********************************************************************
*
*                  XSYM
*
***********************************************************************
*
*        SYMTAB OUTPUT
*
***********************************************************************
XSYM     STF       R0,XSYM90
XSYM3.5  LW        R5,MPLST
         SUI       R5,3W
         STW       R5,XSYM92
XSYM4    LW        R4,=X'80000000'
         ZR        R7
         LW        R5,XSYM92
         SUI       R5,4W
         BL        MSSCH           SEARCH FOR NEXT SEGMENT ENTRY
         TRR       R5,R1
         BZ        XSYM10          BR IF NONE FOUND
         SUI       R5,4W
         BL        MSSCH           FIND END OF SEGMENT'S ENTRIES
         TRR       R5,R5
         BNZ       XSYM5
         LW        R5,MSYMN
         BU        XSYM6
XSYM5    ADI       R5,4W
XSYM6    ADI       R5,4W
         STW       R5,XSYM92
         TBM       2,1B,R1
         BNS       XSYM4           BR IF SYM OPTION NOT ON
         ZMW       1W,R1           CLEAR ID
         ZMB       1B,R1           AND OPTION BITS
         LI        R2,-8B
         TRR       R1,R3
XSYM7    LB        R5,2W,R3        EXTRACT SEGMENT NAME
         CI        R5,G' '
         BEQ       XSYM8
         STB       R5,XSYM93+9B,R2
         ABR       R3,31
         BIB       R2,XSYM7
XSYM8    ADI       R2,8B
         TRR       R2,R5
         ABR       R5,31
         ADI       R2,X'50'        NAME RECORD ID
         STB       R2,XSYM93
         BL        XSYMC
         ADI       R1,4W
XSYM9    ZMB       XSYM93          OUTPUT SEGMENT'S SYMTAB DATA
         LD        R6,0,R1
         STD       R6,XSYM93+1B
         LD        R6,1D,R1
         STD       R6,XSYM93+9B
         LI        R5,17B
         BL        XSYMC
         CAMW      R1,XSYM92
         BLE       XSYM4           BR IF DONE
         SUI       R1,4W
         BU        XSYM9
XSYM10   LW        R5,XSYM94
         BNZ       XSYM12          BR IF ANY SYMTAB RECORDS WRITTEN
XSYM11   LF        R0,XSYM90
         TRSW      R0
XSYM12   BL        M0210
         STW       R7,XSYM95+4W
         STW       R7,XSYM96+7W
         LI        R5,G'0'
         STB       R5,MPCCC+7B     DOUBLE SPACE
         LI        R5,28B
         LA        R6,XSYM95
         TBM       XSYMTSUP,XFLGS
         BNS       XSYM13          BR IF OUTPUT NOT SUPPRESSED
         LI        R5,49B
         LA        R6,XSYM96
XSYM13   BL        XPRNT           WRITE APPROPRIATE SYMTAB MESSAGE
         BU        XSYM11
         BOUND     8W
XSYM90   RES       8W              REGISTER SAVE
XSYM916  EQU       $               HERE IF I/O ERROR                1.3
         LW        R5,3W,X1        GET FCB STATUS                   1.3
         M.CONBAH                  CONVERT TO HEX                   1.3
         LA        R3,XSY.M1D1     LOCATE DATA                      1.3
         BL        XST2            AND STUFF R6,R7                  1.3
         LNB       R5,XSY.M1L                                       1.3
         LA        R6,XSY.M1A                                       1.3
         BL        XTYPEF                                           1.3
         SBM       XSYMTSUP,XFLGS  INDICATE SYM OUTPUT OFF          1.3
         SBM       XABORTFL,XFLGS  INDICATE ERROR                   1.3
         BU        XSYMC6          CONTINUE                         1.3
XSY.OPNE EQU       $               HERE IF ERROR ON OPEN            1.3
         LH        R5,RWCNP+5H     GET STATUS                       1.3
         M.CONBAD                  CONVERT TO DECIMAL               1.3
         ANMW      R7,=X'0000FFFF'  SAVE TWO DIGITS                 1.3
         ORMW      R7,=G'RM"@@"@@'   ADD IN MODIFIER                  1.3
         LA        R3,XSY.M3D1     LOCATE IN MESSAGE                1.3
         BL        XSTB            AND STUFF                        1.3
         LNB       R5,XSY.M3L                                       1.3
         LA        R6,XSY.M3A                                       1.3
         BL        XTYPEF          REPORT                           1.3
         SBM       XSYMTSUP,XFLGS  INHIBIT OUTPUT                   1.3
         SBM       XABORTFL,XFLGS   INDICATE ERROR                  1.3
         ZMW       RWCNP+1W         RESET ALTERNATE RETURN          1.3
         BU        XSYM3.5          CONTINUE                        1.3
*                                                                   1.3
XSYM92   DATAW     0               ADDR OF LAST WD OF SEG'S SYMTAB OPUT
         BOUND     1D              BOUNDING FOR
         RES       7B              XSYM93
XSYM93   RES       17B             DATA BLOCK FOR XSYMC INPUT
XSYM94   DATAW     0               NO. OF SYMTAB RECS WRITTEN/REQUIRED
XSYM95   DATAW     C'SYMTAB OCCUPIES      RECORDS'
XSYM96   DATAW     C'SYMTAB OUTPUT UNSUCCESSFUL:      RECORDS REQUIRED'
*
XSY.M1A  DATAB     C' CATALOG(WARNING) ERROR ON OUTPUT TO LFC: SYM'
         DATAB     C' FCB STATUS=X"''
XSY.M1D1 REZ       8B
         DATAB     C'"'.'
XSY.M1L  DATAB     $-XSY.M1A
*
XSY.M2A  DATAB     C' CATALOG(WARNING) LFC: SYM NOT ASSIGNED, SYMTAB'
         DATAB     C' NOT SAVED.'
XSY.M2L  DATAB     $-XSY.M2A
*
XSY.M3A  DATAB     C' CATALOG(WARNING) STATUS= '
XSY.M3D1 REZ       4B
         DATAB     C'  OPENING LFC: SYM, SYMTAB NOT SAVED.'
XSY.M3L  DATAB     $-XSY.M3A
         BOUND     1W
*
*-----------------------------------------------------------------------
         TITLE     XSYMC    - 'XSYM' SUBROUTINE
*******************************************************************
*
*                  XSYMC
*
*******************************************************************
*
*        XSYMC - XSYM DATA OUTPUT SUBROUTINE
*                DATA TO OUTPUT IN XSYM93; NO. BYTES TO OUTPUT IN R5
*
*******************************************************************
XSYMC    STF       R0,XSYMC90
*                                                                1.3#14
         SBM       XSYMC.IN,XSYMC.FG      SET INIT FLAG          1.3#14
         BS        XSYMC0            SKIP IF ALREADY SET         1.3#14
         M.INQUIRY PNTERS,SYMLFC   SEE IF 'SYM' ASSIGNED         1.3#14
         TRR       R7,R7                                         1.3#14
         BZ        XSYMC.1         BR IF SYM FC ASSIGNED         1.3#14
         SBM       XSYMTSUP,XFLGS  SUPPRESS OUTPUT               1.3#14
         SBM       XABORTFL,XFLGS  INDICATE ERROR                1.3#14
         LNB       R5,XSY.M2L                                    1.3#14
         LA        R6,XSY.M2A                                    1.3#14
         BL        XTYPEF          REPORT NO SYMS                1.3#14
         BU        XSYMC3          JUST RETURN                   1.3#14
XSYMC.1  LW        R1,PNTERS+1W    GET FAT ADDR.                 1.3#14
         LB        R6,DFT.ACF,X1   GET SYSTEM FILE CODE          1.3#14
         TBR       R6,29                                         1.3#14
         BS        XSYMC.2         BR IF ASSIGNED TO SBO         1.3#14
         LW        R1,PNTERS+2W    GET UDT ADDR.                 1.3#14
         LB        R6,UDT.DTC,X1   GET DEVICE TYPE CODE          1.3#14
         CI        R6,7                                          1.3#14
         BEQ       XSYMC.2         BR IF CARD OUTPUT             1.3#14
         CI        R6,9                                          1.3#14
         BNE       XSYMC.3         BR IF NOT CARD OUTPUT         1.3#14
XSYMC.2  SBM       XSYMCAR,XFLGS   CARD OUTPUT FLAG              1.3#14
XSYMC.3  LA        R1,XSYM91       GET ADDR OF FCB               1.3#14
         LA        R7,RWCNP        GET ADDR OF CNP               1.3#14
         LA        R3,XSY.OPNE     GET ADDR OF OPEN ALTERNATE    1.3#14
         STW       R3,RWCNP+1W     AND STO IN CNP                1.3#14
         ZR        R3              INDICATE WAIT                 1.3#14
         BL        XOPENR          AND DO POLITE OPEN            1.3#14
         ZMW       RWCNP+1W        RESET RWCNP                   1.3#14
         LF        R0,XSYMC90      RECOVER CALLING REGS          1.3#14
*                                                                1.3#14
XSYMC0   EQU       $                                             1.3#14
         LI        R4,X'FF'
         STB       R4,XSYMC91
         LB        R1,XSYMC91+1B
         ARMB      R5,XSYMC91+1B   INCREMENT CARD DATA BYTE COUNT
         TRN       R5,R5
         ZR        R2
XSYMC1   LB        R4,XSYM93,R2    MOVE DATA TO BUFFER
         STB       R4,XSYMC91+6B,R1
         ABR       R1,31
         ABR       R2,31
         BIB       R5,XSYMC1
         LW        R5,XSYMC90+1W
         CAMW      R5,XSYM92
         BGT       XSYMC2          BR IF NOT END OF SEGMENT'S SYMTAB
         LI        R5,X'DF'
         STB       R5,XSYMC91
         LI        R5,X'F1'
         STB       R5,XSYMC91+6B,R1  "END" BYTE
         ABM       6,XSYMC91+1B    INCREMENT CARD DATA BYTE COUNT
         BU        XSYMC4
XSYMC2   ABM       7,XSYMC92
         LB        R5,XSYMC92
         CI        R5,6B
         BEQ       XSYMC4          BR IF 6 DATA BLOCKS ON CARD
XSYMC3   LF        R0,XSYMC90
         TRSW      R0
XSYMC.FG DATAH     0               XSYMC FLAGS                   1.3#14
XSYMC.IN EQU       0               SET INDICATES FILE OPEN       1.3#14
*                                                                1.3#14
XSYMC4   TBM       XSYMTSUP,XFLGS
         BS        XSYMC6          BR IF OUTPUT SUPPRESSED
         ABM       7,XSYMC91+5B    INCREMENT CARD SEQUENCE NUMBER
         LNB       R2,XSYMC91+1B
         ZR        R5
         ZR        R3
XSYMC5   ADMB      R5,XSYMC91+6B,R3  CHECKSUM CARD
         ABR       R3,31
         BIB       R2,XSYMC5
         STH       R5,XSYMC91+1H
         M.WRIT    XSYM91          OUTPUT CARD IMAGE
         TBM       7,XSYM91+3W
         BS        XSYM916         REPORT EOM
XSYMC6   ABM       31,XSYM94       INCREMENT CARD COUNT
         ZMB       XSYMC92
         ZMW       XSYMC91
         LI        R2,-57H
XSYMC7   ZMH       XSYMC91+60H,R2  CLEAR BUFFER
         BIH       R2,XSYMC7
         LW        R5,XSYMC90+1W
         CAMW      R5,XSYM92
         BGT       XSYMC3          BR IF NOT END OF SEGMENT'S SYMTAB
         ZMH       XSYMC91+1W      CLEAR CARD SEQUENCE NUMBER
         TBM       XSYMCAR,XFLGS
         BS        XSYMC3          BR IF OUTPUT TO CARDS
         TBM       XSYMTSUP,XFLGS
         BS        XSYMC3          BR IF OUTPUT SUPPRESSED
         M.WEOF    XSYM91          WRITE 'EOF' ON SYM
         BU        XSYMC3
         BOUND     8W
XSYMC90  RES       8W              REGISTER SAVE
XSYMC91  REPT      30              CARD BUFFER
         DATAW     0
         ENDR
XSYMC92  DATAB     0               NO. DATA BLOCKS IN CARD BUFFER
         TITLE     XCORE    - FIND MEMORY PARTITION DEFINITION
************************************************************************
*
*                  XCORE
*
************************************************************************
*
*        LOCATE DEFINITION OF CORE PARTITION WHOSE NAME IS IN R6,7
*                                                                1.3#15
*    DIRECTORIES SEARCHED ARE:                                   1.3#15
*                              1) LMPATH TARGET (IFF LMPATH USED)1.3#15
*                              2) CURRENT WORKING (IF BUILD USED)1.3#15
*                              3) @@SYSTEM(SYSTEM)                1.3#15
*                                                                1.3#15
*                                                                1.3#15
*   IN R6,R7 = PARTITION NAME                                    1.3#15
*                                                                1.3#15
*  OUT    R6 =  NUMBER OF 512W PAGES IN PARTITION                1.3#15
*         R7 =  STARTING BYTE ADDRESS OF PARTITION               1.3#15
*        CC1 =  0                                                1.3#15
*  IF NOT LOCATED                                                1.3#15
*                                                                1.3#15
*        ALL REGS RESTORED   AND                                 1.3#15
*        CC1 = 1                                                 1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
*
************************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         SPACE     1
XCORE    STF       R0,XCOR90
         LW        R5,C.REV        GET OS REV NUMBER           1.1.9
         CAMW      R5,=G'3.1 '     IF 3.1 TREAT AS 2.*         1.1.9
         BEQ       XCORREV2                                    1.1.9
         LB        R5,C.REV        GET OS REV NUMBER           1.1.9
         CI        R5,G'2'         IS IT REV 2.*               1.1.9
         BNE       XCORREV3        IF NOT BRANCH               1.1.9
XCORREV2 LI        R5,96W          GET INDEX INTO RD           1.1.9
         STW       R5,CORPGST      FOR STARTING PAGE           1.1.9
         LI        R5,97W          GET INDEX INTO RD           1.1.9
         STW       R5,CORPGLN      FOR PAGE LENGTH             1.1.9
         BU        XCOR0           CONTINUE                    1.1.9
*
XCORREV3 LI        R5,88W          GET 3.* INDEXES             1.1.9
         STW       R5,CORPGST                                  1.1.9
         LI        R5,89W                                      1.1.9
         STW       R5,CORPGLN                                  1.1.9
XCOR0    EQU       $                                           1.1.9
         TBM       CPTH,CFLGS      WAS LMPATH USED               1.3#11
         BS        XCOR0.1         GO PROCESS                    1.3#11
         ZBM       XCONNECT,XFLGS  IS CALL FROM CONNECT          1.3#11
         BS        XCOR0.2         ALWAYS DO CURRENT             1.3#11
         TBM       MBUILD,MFLGS    WAS BUILD USED                1.3#11
         BS        XCOR0.2         GO PROCESS                    1.3#11
         BU        XCOR0.3    ELSE DO JUST SYSTEM/SYSTEM         1.3#11
*                                                                1.3#11
XCOR0.1  EQU       $               HERE FOR LMPATH               1.3#11
         TBM       XCORI,XFLGS     HAVE WE BUILD VOL/DIR PART    1.3#11
         BS        XCOR0.12        SKIP IF WE HAVE               1.3#11
         LNW       R3,BLCK1.PT     LENGTH OF PNB FROM LMPATH     1.3#11
         ZR        R1              INIT FOR LOOP                 1.3#11
XCOR0.11 EQU       $               LOOP TOP                      1.3#11
         LB        R4,XPNB,X1                                    1.3#11
         STB       R4,PN.BLCK1,X1                                1.3#11
         ADI       R1,1            BUMP POINTER                  1.3#11
         BIB       R3,XCOR0.11     LOOP FOR ALL                  1.3#11
         LW        R4,=G'!RES'                                   1.3#14
         STW       R4,PN.BLCK1,X1  SAVE !RES IDENTIFIER          1.3#14
         LW        R4,=G'    '     GET BLANKS                    1.3#14
         STW       R4,PN.BLCK1+4,X1    AND SAVE                  1.3#14
         ADI       R1,8            BUMP TO START OF NAME         1.3#14
         STW       R1,BLCK1.PT     AND SAVE                      1.3#14
*                                                                1.3#11
         ADI       R1,8            BUMP BY NAME LENGTH           1.3#11
         LA        R2,PN.BLCK1     GET PNB ADDR                  1.3#11
         SLL       R1,24           POSITION LENGTH               1.3#11
         ORR       R2,R1           ADD IN ADDR                   1.3#11
         STW       R1,PNB.VCT1     AND STORE VECTOR              1.3#11
         SBM       XCORI,XFLGS     INDICATE INITIALIZED          1.3#11
XCOR0.12 EQU       $                                             1.3#11
         LW        R3,BLCK1.PT     GET LOCATION TO STORE NAME    1.3#11
         STD       R6,PN.BLCK1,X3  SET PARTITION NAME            1.3#11
         ZBM       MLOCF,MFLAG3    CLEAR FLAG FOR PNB           ERMS-34
         LW        R1,PNB.VCT1     LOAD PNB VECTOR              ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!M.LOC!!!!!PNB.VCT1,RDADDR!!!LOOK!FOR!IT!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!TRR!!!!!!!R7,R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
         M.LOC     PNB.VCT1,RDADDR,CHKCNP   LOCATE FILE         ERMS-34
         LH        R7,CHKCNP+5H    LOAD RETURN STATUS           ERMS-34
         BZ        XCOR3           BR IF FOUND                   1.3#11
*                                                                1.3#11
XCOR0.2  EQU       $               HERE FOR WORK/WORK SEARCH     1.3#11
         LD        R6,XCOR90+6W    RECOVER NAME                  1.3#11
         STD       R6,PN.BLCK2+3D  STORE NAME                    1.3#11
         ZBM       MLOCF,MFLAG3    CLEAR FLAG FOR PNB           ERMS-34
         LW        R1,PNB.VCT2     LOAD PNB VECTOR              ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!M.LOC!!!!!PNB.VCT2,RDADDR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!TRR!!!!!!!R7,R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
         M.LOC     PNB.VCT2,RDADDR,CHKCNP   LOCATE FILE         ERMS-34
         LH        R7,CHKCNP+5H    LOAD RETURN STATUS           ERMS-34
         BZ        XCOR3           BR IF FOUND                   1.3#11
*                                                                1.3#11
XCOR0.3  EQU       $               HERE FOR SYST/SYST SEARCH     1.3#11
         LD        R6,XCOR90+6W    RECOVER NAME                  1.3#11
         STD       R6,PN.BLCK3+3D                                1.3#11
         ZBM       MLOCF,MFLAG3    CLEAR FLAG FOR PNB           ERMS-34
         LW        R1,PNB.VCT3     LOAD PNB VECTOR              ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!M.LOC!!!!!PNB.VCT3,RDADDR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!TRR!!!!!!!R7,R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
         M.LOC     PNB.VCT3,RDADDR,CHKCNP   LOCATE FILE         ERMS-34
         LH        R7,CHKCNP+5H    LOAD RETURN STATUS           ERMS-34
         BZ        XCOR3           BR IF FOUND                   1.3#11
*                                                                1.3#11
         LD        R6,XCOR90+6W    RECOVER NAME                  1.3#15
         LA        R3,XCOR.M2D     LOCATE                        1.3#11
         BL        XST2            AND STUFF NAME                1.3#11
         LNB       R5,XCOR.M2L                                   1.3#11
         LA        R6,XCOR.M2A                                   1.3#11
         BL        XTYPEF                                        1.3#11
XCOR1    EQU       $               ERRROR NOT FOUND              1.3#15
         SBM       1,XCOR90        SET ERROR FLAG TO USER        1.3#15
XCOR2    LF        R0,XCOR90
         TRSW      R0
*
*
XCOR3    EQU       $
         LA        R2,RDADDR       GET RD INDEX                1100A
         LH        R7,RD.RTYPE,X2  GET THE RESOURCE TYPE          1100A
         CI        R7,15           DYNAMIC MEM PARTITION?        1100A
         BEQ       XCOR3.1         YES                            1100A
         CI        R7,14                SYSGEN MEM PARTITION?     1100A
         BEQ       XCOR3.00        CONTINUE IF STATIC PARTITION  1.3#15
         LD        R6,XCOR90+6W    RECOVER NAME                  1.3#15
         LA        R3,XCOR.M3D     LOCATE IN MESSAGE             1.3#15
         BL        XST2            STUFF                         1.3#15
         LNB       R5,XCOR.M3L                                   1.3#15
         LA        R6,XCOR.M3A                                   1.3#15
         BL        XTYPEF                                        1.3#15
         BU        XCOR1           ERROR RETURN                  1.3#15
XCOR3.00 EQU       $               CONTINUE                      1.3#15
         BL        XCOR3.01        RRS ENTRY ALREADY ?            12007
         BNS       XCOR3.1         RRS ENTRY ALREADY BUILT        12007
*        ZBM       XCONNECT,XFLGS  SEE IF COMING FROM CONNECT     11017
*        BS        XCOR3.1         IF SO JUST GET INFO.           11017
         LI        R6,XCORE.NW     NEW ENTRY SIZE IN WORDS
         CAMW      R6,MRRSFREE     ROOM IN RRS TABLE??
         BLE       C23             BRANCH IF O.K.
         LD        R6,XCOR90+6W
         LA        R3,XCOR.M1D     LOCATE                        1.3#11
         BL        XST2            STUFF NAME                    1.3#11
         LNB       R5,XCOR.M1L                                   1.3#11
         LA        R6,XCOR.MSG                                   1.3#11
         BL        XTYPEF                                        1.3#11
         BL        XABORT                                        1.3#11
*
*
DUPSAV   REZ       1F                                            12007
XCOR3.01 STF       R0,DUPSAV                                     12007
         LNB       R4,MRRSN        NO. OF ENTRIES IN MRRS        12007
         BZ        XCOR3.04        NO RRS ENTRIES YET            12007
         LA        R2,MRRS         START OF MRRS ENTRIES         12007
         LD        R6,XCOR90+6W    PROSPECTIVE ENTRY NAME        12007
XCOR3.02 LB        R5,1W+1B,R2     RRS ENTRY SIZE                12007
         LB        R3,1W,R2        RRS TYPE                      12007
         SLL       R5,2            WORD ADJUST LENGTH            12007
         CI        R3,1            TYPE 1 RRS ?
         BNE       XCOR3.03        IF NOT TYPE 1, TRY NEXT ONE   12007
         CAMD      R6,4W,X2        DOES THIS ONE MATCH          1.3#03
         BEQ       XCOR3.05        FOUND ONE                     12007
XCOR3.03 EQU       $                                            1.3#03
         ADR       R5,R2           BUMP TO NEXT ENTRY           1.3#03
         BIB       R4,XCOR3.02     TRY NEXT ONE                  12007
XCOR3.04 SBM       1,DUPSAV        NO MATCH FOUND                12007
XCOR3.05 LF        R0,DUPSAV                                     12007
         TRSW      R0                                            12007
*
C23      LW        R7,=G'***'      LFC FOR CORE PARTITION
         SBR       R7,0
         SBR       R7,5                                            0686
         STW       R7,MRRS.OLD
         ZR        R2              INDEX INTO PARTITION NAME
         LI        R0,-8
         ZR        R6
C23.5    LB        R5,XCOR90+6W,R2 NEXT BYTE OF NAME
         SUI       R5,X'20'
         SLLD      R6,6
         ADR       R5,R7
         ADI       R2,1B
         BIB       R0,C23.5
         STW       R6,MRRS.OLD+1W
         STW       R7,MRRS.OLD+2W
         LI        R6,XCORE.NW     LENGTH OF NEW FORMAT RRS ENTRY
         SBM       XSYSPART,XFLGS  SET SYSTEM PARTITION FLAG     84-0209
         BL        MRRSCONV        ADD IT TO THE RRS TABLE
XCOR3.1  LW        R2,CORPGST      GET INDEX FOR STARTING PAGE 1.1.9
         LW        R6,RDADDR,X2        GET STARTING LOGICAL PAGE # 1100A
         CAMW      R6,CLGC
         BGT       XCOR4
         STW       R6,CLGC         SAVE LOWEST PAGE #
XCOR4    LW        R2,CORPGLN      GET INDEX FOR PAGE LENGTH   1.1.9
         ADMW      R6,RDADDR,X2         ADD SIZE                   1100A
         CAMW      R6,CHGC
         BLE       XCOR5
         STW       R6,CHGC         SAVE HIGHEST PAGE USED
XCOR5    EQU       $
         LW        R2,CORPGST                                  1.1.9
         LW        R7,RDADDR,X2         GET LOGICAL PAGE START     1100A
         SLL       R7,11           SHIFT TO WORD ADDRESS
         LW        R2,CORPGLN                                  1.1.9
         LW        R6,RDADDR,X2         GET LENGTH IN PAGES        1100A
         STD       R6,XCOR90+6W
         ZBM       1,XCOR90        RESET ERROR FLAG              1.3#15
         BU        XCOR2
XCOR90   RES       1F
*
XCOR.MSG DATAB     C' CATALOG<<FATAL>> STATIC MEMORY PARTITION  '
XCOR.M1D REZ       8B                                            1.3#11
         DATAB     C'  CAUSES RRS TABLE OVERFLOW.'               1.3#11
XCOR.M1L DATAB     $-XCOR.MSG                                    1.3#11
*                                                                1.3#11
XCOR.M2A DATAB     C' CATALOG<<FATAL>> PARTITION  '              1.3#11
XCOR.M2D REZ       8B                                            1.3#11
         DATAB     C'  NOT DEFINED IN DIRECTORIES SEARCHED.'     1.3#11
XCOR.M2L DATAB     $-XCOR.M2A                                    1.3#11
*                                                                1.3#15
XCOR.M3A DATAB     C' CATALOG<<FATAL>>  '                        1.3#15
XCOR.M3D REZ       8B              PART NAME                     1.3#15
         DATAB     C'  DEFINED, BUT NOT AS A PARTITION.'         1.3#15
XCOR.M3L DATAB     $-XCOR.M3A                                    1.3#15
         BOUND     1W                                            1.3#11
*
*-----------------------------------------------------------------------
         PAGE
***********************************************************************
*
*                  M VARIABLES
*
***********************************************************************
MCATUN   DATAB     C' - - -LOAD MODULE FILE    NOT    CREATED/UPDATED.'
MCATUN.L DATAB     $-MCATUN
TRMMSG   DATAB     C' - - -LOAD MODULE FILE HAS BEEN  CREATED/UPDATED.'
TRMMSG.L DATAB     $-TRMMSG
MSOFMSG  DATAB     C' CATALOG<<FATAL>>   SYMBOL TABLE OVERFLOW,' 1.3#10
         DATAB     C'  $ALLOCATE MORE MEMORY.'                   1.3#10
MSOFMLN  DATAB     $-MSOFMSG
MTGID    DATAB     0     HOLDS TASK GROUP ID FROM CAT/BLD DIR    1.3#11
MMODM    DATAD     C' MODULE:        '
         BOUND     8
MCBUF    RES       30W             BINARY CARD BUFFER
MDBFL    DATAH     0        HOLDS LENGTH OF CURRENT DIRE. BUFF   1.3#14
         DATAH     G'  '           SUPPLY A BLANK FOR MDBUF CC   1.3#14
MDBUF    RES       30W             DIRECTIVE BUFFER
MPCCC    DATAD     0               PR CARR CONT CHAR FOR MPBUF
MPBUF    DATAD     C'        '     PRT BUFF FOR DYNAMIC FORMATTED MSGS
         DATAD     C'        '     132 BYTES
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAD     C'        '
         DATAW     C'    '
         SPACE     1
MPNAM    DATAD     C'        '     NAME OF PGM BEING PROCESSED BY A OR B
MSYMN    ACW       0               ADDR OF WD 0 OF NEXT OPEN SYMTAB SLOT
MMODF    ACW       0         ADDR OF LAST SEGMENT ENTRY FOUND BY MSSCH
MCTLF    DATAW     0         ADDR OF LAST CONTROL ENTRY FOUND BY MSSCH
MMODW    ACW       MSYMTAB         ADD OF WORKING MODULE ENTRY
MPABS    DATAW     0               ADDR OF DSECT    FROM ABS DIRECTIVE
MDPFT    ACW       0               ADDRESS OF DATAPOOL TABLE
MDPNE    DATAW     0               NO. ENTRIES IN DATAPOOL TABLE
MSYMC    ACW       0               ADDR OF WD 0 OF CURR SYMTAB CONT ENT
MCOMPTR  ACW       0               ADDR OF COMMON RECORD BEING ALLOCATED
MDPNS    ACW       0               NEXT STORE ADDRESS IN DATAPOOL TABLE
MDPNA    DATAW     0   NUMBER OF ACTIVE ENTS IN DATAPOOL TABLE   1.3#15
MPFST    ACW       MPFSTTAG        ADDR OF FIRST WORD OF GEN TAB AREA
MPEXLST  ACW       MPFSTTAG        ADDR OF LAST EXCLUDE ENTRY    1.3#02
MPINFST  ACW       MPFSTTAG        ADDR OF FIRST INCLUDE ENTRY   1.3#02
MPINLST  ACW       MPFSTTAG        ADDR OF LAST  INCLUDE ENTRY   1.3#02
MPRFFST  ACW       MPFSTTAG        ADDR OF FIRST REFERENCE ENTRY 1.3#02
MPLST    ACW       0               ADDR OF LAST CELL OF CAT GENERAL
*                                  TABLE AREA
MCREC    DATAW     0               NO. 192-WORD RECS IN MODULE BEING PRO
MLIBN    DATAW     0               SUBROUTINE LIBRARY FCB INDEX
MLIBL    DATAW     0               LOC IN LIB OF SUBROUTINE
MEXTS    DATAW     0               NO. ENTRIES IN EXTERNALS TABLE
MXUND    ACW       C               NEXT STORE ADDRESS FOR UNDEF EX REF
MDUND    ACW       CA90            NEXT STORE ADDRESS FOR UNDEF DATAPL
MPNXT    ACW       0               A PASS: ADDR AT WHICH LAST DOUBLE
*                                          WORD EXTERNAL WAS STORED
*                                  B PASS: BYTE ADDR AT WHICH NEXT PGM
*                                          DATA IS TO BE STORED
MTRNS    ACW       0               BYTE SCALED SIZE OF DECLARED OVERLAY
*                                  TRANSIENT AREA
MOBJC    ACW       0               OBJECT CODE COUNT, SCALED BYTES AND
*                                  UPWARD WORD BOUNDED, OBTAINED FROM
*                                  COMM ORIGIN RECS CAN BE RELATIVE
MSEC1    DATAW     0               SECTION ONE ORIGIN FOR
*                                  SYMTAB BIAS ROUTINE
MSEC1O   DATAW     0               ORIGIN OF SECTION ONE
DEBIAS   DATAW     0               CSECT DEBUG SYMBOL BIAS      ELST-32
*!MPAGESZ!!DATAW!!!!!X'8000'!!!!!!!!PAGE!SIZE!IN!BYTES!!!!!!!!!!C004-30
MPAGESZ  DATAW     X'2000'        PAGE SIZE IN BYTES            C004-30
PRMEMS   DATAW     0              PREAMBLE MEMORY TYPE
MGCBASE  DATAW     0               LOGICAL BASE OF GLOBAL COMMON
MSYND    ACW       0               ADDRESS OF WORD ZERO OF LAST SYMTAB
*                                  ENTRY RESTORED FOR SYMTAB DIRECTIVE
MTOTALL  DATAW     0               TOTAL ALLOCATION REQUIRED FOR LOAD
*                                  MODULE DSECT. INCLUDES MAIN AND
*                                  LARGEST OVERLAY AT EACH LEVEL.
MTOTALC  DATAW     0               TOTAL ALLOCATION REQUIRED    ESOV-32
*                                  FOR LOAD MODULE CSECT.       ESOV-32
*                                  FOR NON-SHARED TASKS THIS    ESOV-32
*                                  INCLUDES THE MAIN AND        ESOV-32
*                                  THE LARGEST OVERLAY AT EACH  ESOV-32
*                                  LEVEL. FOR SHARED TASKS THIS ESOV-32
*                                  INCLUDES THE MAIN AND ALL    ESOV-32
*                                  OVERLAYS AT ALL LEVELS.      ESOV-32
MALTD    DATAW     0               NO. BYTES FROM ALLOCATE CARD
MOPTD    DATAW     0               PROGRAM OPTION WORD
MOPTD2   DATAW     0               2ND PROGRAM OPTION WORD      EOPT-32
         BOUND     1W
MXSEQ    DATAH     X'00000000'     NO. EXPECTED IN SEQ FIELD OF OBJ CARD
MLAS     DATAH     0               HOLDS SPACE COMMAND VALUE     1.3#11
*
*                  BYTE VARIABLES
*
MSEGFILE DATAB     5               SEGFILES = N DIRECTIVE
MTMPSEG  DATAB     0               TEMP SEG FILES HOLD AREA     ENCD-32
MVOLUMES DATAB     0               VOLUMES  = N DIRECTIVE
*
MBCNT    DATAB     X'00'           NO. BYTES OBJECT DATA IN MCBUF
MBLKX    DATAB     X'00'           AN INDEX POINTING TO 1ST BYTE OF OBJ
*                                  RECORD IN MCBUF BEING PROCESSED
MOPTS    DATAB     X'00'           SELECTED CATALOGER OPTIONS
*                                  00000001  DO NOT OUTPUT MODULE MAP
*                                  00001000  NO MODULE TO PERM FILE
*                                  00010000  OUTPUT MODULE TO CARDS
*                                  00100000  OUTPUT SYMTAB
MPRIO    DATAB     X'00'           DECLARED REALTIME TASK PRIORITY
MRRSN    DATAB     X'00'           NO. OF ENTRIES IN MRRS
*!MFILE!!!DATAB!!!!!5!!!!!!!!!!!!!!NO.!OF!FILES!!!!!!!!!!!!!!!!!EAID-32
*!MBUFR!!!DATAB!!!!!3!!!!!!!!!!!!!!NO.!OF!BUFFERS!!!!!!!!!!!!!!!EAID-32
MFILE    DATAB     9               NO. OF FILES                 EAID-32
MBUFR    DATAB     4               NO. OF BUFFERS               EAID-32
MTMPBUF  DATAB     0               TEMP BUFFERS HOLD AREA       ENCD-32
MTMPFIL  DATAB     0               TEMP FILES HOLD AREA         ENCD-32
MFLAG    DATAB     0               FLAGS INITIALIZED BY 'ENVIRONMENT'
MFLAG2   DATAW     0                                            ELST-32
MOPT6    EQU       0               OPTION 6                     ELST-32
MPSOBJ   EQU       1               PURELY SECTIONED FLAG        ELST-32
MOSOBJ   EQU       2               OLD STYLE OBJECT FLAG        ELST-32
M2.5MB   EQU       3               2.5MB TASK FLAG              ELST-32
MPREBA   EQU       4               PRE-BIASED EXTERNAL ADDR BIT ELST-32
MSBADR   EQU       5               0 : STRINGBACK ADDR IN DSECT ELST-32
*                                  1 : STRINGBACK ADDR IN CSECT ELST-32
MDEFADR  EQU       6               0 : DEFINITION ADDR IN DSECT ELST-32
*                                  1 : DEFINITION ADDR IN CSECT ELST-32
MOPT4    EQU       7               OPTION 4 FLAG                ENCD-32
MOPT5    EQU       8               OPTION 5 FLAG                ENCD-32
MTMOBJ   EQU       9               TEMP OBJECT FILE CREATE FLAG ENCD-32
MFILD    EQU       10              FILE DIRECTIVE FLAG          ENCD-32
MBUFD    EQU       11              BUFFER DIRECTIVE FLAG        ENCD-32
MCATD    EQU       12              FIRST CATALOG DIRECTIVE FLAG ENCD-32
MOBJPOS  EQU       13              OBJ/SGO POSITIONING FLAG     ENCD-32
MSOP1    EQU       14              SET DIRECTIVE OPTION 1 FLAG  ENCD-32
MSOP2    EQU       15               "      "       "    2   "   ENCD-32
MSOP3    EQU       16               "      "       "    3   "   ENCD-32
MSOP4    EQU       17               "      "       "    4   "   ENCD-32
MSOP5    EQU       18               "      "       "    5   "   ENCD-32
MSOP6    EQU       19               "      "       "    6   "   ENCD-32
MSOP15   EQU       20               "      "       "    15  "   ENCD-32
MSOP18   EQU       21               "      "       "    18  "   ENCD-32
MSOP19   EQU       22               "      "       "    19  "   ENCD-32
MSOP20   EQU       23               "      "       "    20  "   ENCD-32
MSOPTX   EQU       24               "      "       "   TEXT "   ENCD-32
MOBDIR   EQU       25              OBJECT DIRECTIVE READ FLAG   ENCD-32
MPRGDIR  EQU       26              PROGRAM XXX FROM DIR FLAG    ENCD-32
MOPT7    EQU       27              2.5 MB TASK OPTION FLAG      ELST-32C
MSOP7    EQU       28              SET DIRECTIVE OPTION 7 FLAG  ELST-32C
MLMDIR   EQU       29              DIRECTIVES FROM LOAD MODULE  ETCM-32
MTMDIR   EQU       30              TEMP DIRECTIVES FILE CREATE  ETCM-32
MDIRFIL  EQU       31              DIRECTIVES FROM FILE         ETCM-32
*
*                  BIT VARIABLES
*
MFLGS    DATAW     X'00000000'     FLAGS
*                  MFLGS EQUS
MMIN     EQU       0               MAPPED IN MPX BIT            EOUT-32
MTYPE    EQU       1               MODULE TYPE - 0 UNPRIV, 1 PRIV
MPEND    EQU       2               PGM END REC READ BY MOBSC
MTSA     EQU       3               EXTENDED TSA BIT             ETSA-32
MFSTE    EQU       4               1ST PGM ELE BEING PROC'D BY B PASS
MONRA    EQU       5               REAL TIME ACCOUNTING ON      ECSW-30
MOFRA    EQU       6               REAL TIME ACCOUNTING OFF     ECSW-30
MABS     EQU       7               ABSOLUTE DIRECTIVE WAS READ
MSTMD    EQU       8               MSYMS IS TO STORE MODULE ENTRY
M2DPF    EQU       9               NOT FIRST ENTRY TO XGETDP     1.3#15
MMOUT    EQU       10              MAPPED OUT MPX BIT           EOUT-32
MTRNSFG  EQU       11              TRANSIENT AREA IS SPECIFIED
MOPT3    EQU       12    OPTION  3-NEW LINKBACK USAGE OPTION     12010
MOPT19   EQU       13    OPTION 19-INCLUDE SYMBOLIC DEBUGGER OUTPUT
MSAM     EQU       14              SET IF 'SA' OPTION ON CAT/BUILD DIR
MOPT1    EQU       15    OPTION  1-SUPRESS AUTOMATIC LIBRARY SEARCH
MOPT2    EQU       16    OPTION  2-SET IF SEPARATE FILES FOR OLAYS 22001
MRECAT   EQU       17              SET IF RECATALOGING NEW FORM LM
MCREAT   EQU       18              SET IF NEW FORM LM CREATED
MBUILD   EQU       19              SET IF 'BUILD' NOT 'CATALOG'
MNTSA    EQU       20              NON-EXTENDED TSA BIT         ETSA-32
MSEGF    EQU       21              SET IF SEGFILE DIRECTIVE SPECIFIED
MOPT15   EQU       22              INCLUDE MODULE INFO RECORDS    11005
MOPT16   EQU       23    OPTION 16-RESERVE OPTION 16 FOR FUTURE  1.3#05
MOPT17   EQU       24    OPTION 17-RESERVE OPTION 17 FOR FUTURE  1.3#05
MOPT18   EQU       25    OPTION 18-RESERVE OPTION 18 FOR FUTURE  1.3#05
MOPT20   EQU       26    OPTION 20-INHIBIT EXTENDED MEMORY USE   1.3#04
MSECTS   EQU       27    SET INDICATES CURRENT MODULE SECTIONED  1.3#05
MOPTTXT  EQU       28    SET INDICATES THAT OPTION TEXT WAS SET  1.3#10
MTSBB    EQU       29    SET IF TSBB FIELD ON ENVIRONMENT        1.3#11
MRCMN    EQU       30    SET IF KEEPNAME FIELD ON ENVIRONMENT    1.3#11
MSGORD   EQU       31    SET IF READING OBJECT FROM SGO         ETCM-32
*
MFLAG3   DATAW     0               FLAG WORD                    ETSA-32C
*
MSYST    EQU       0               SYSTEM TSA EXTDMPX OPTION    ETSA-32C
MSYSM    EQU       1               SYSTEM MAPOUT OPTION         EOUT-32B
MDMPG    EQU       2               DEMAND PAGE OPTION           EDMP-32
MNDMPG   EQU       3               NODEMAND OPTION              EDMP-32
MSOP8    EQU       4               AUDIT/NOAUDIT FLAG           C011-32
MOPT8    EQU       5               OPTION 8 FLAG                C011-32
MEXIT    EQU       6               EXIT DIRECTIVE FLAG          C017-32
MADJADR  EQU       7      MAPPED OUT DSECT ADDR ADJUSTMENT FLAG PR11735C
MOPT9    EQU       8               OPTION 9 FLAG                EUIC-32
MSOP9    EQU       9               ZERO/NOZERO FLAG             EUIC-32
MIEOBJ   EQU       10              IEEE OBJECT FLAG             EIEE-33
MINDIR   EQU       11              INDIRECT BRANCH FLAG         ELST-33F
MINDMS   EQU       12              INDIRECT BRANCH ERROR FLAG   ELST-33F
MFOURB   EQU       13              FOUR BYTE DATA FLAG          ELST-33F
MBADR    EQU       14              BIASED ADDRESS CONSTANT FLAG EBAC-33C
MSEGR    EQU       15                                           ECSV-33
MTERM    EQU       16      BACX STRINGBACK TERMINATOR FLAG      EBAC-33C
MDIVM    EQU       17      DIVIDE MODE FLAG FOR FLOATMODE DIR.  EFLM-33
MLOCF    EQU       18              SYSTEM FILE CHECK FLAG       ERMS-34
*                                  0 - PATHNAME BLOCK VECTOR    ERMS-34
*                                  1 - PATHNAME STRING VECTOR   ERMS-34
MCOBJ    EQU       19              OBJECT IS FOR C              CAID
*-----------------------------------------------------------------------
*
CORPGST  DATAW     0               INDEX FOR PAGE START        1.1.9
CORPGLN  DATAW     0               INDEX FOR PAGE LENGTH       1.1.9
         BOUND     32
MSAVER   RES       8W              REG SAVE FOR NON-REENTS
MGLOB    DATAD     C'GLOBAL  '
MGLOB00  DATAD     C'GLOBAL00'
MGLOB99  DATAD     C'GLOBAL99'
MSYMTAB  DATAD     C'        '     MODULE NAME FOR MBERR
         DATAD     C'SYMTAB  '     SYMTAB PROCESSING
*
MDPOOL00 DATAD     C'DPOOL00 '                                   11017
MDPOOL99 DATAD     C'DPOOL99 '                                   11017
MODFCBA  DATAW     0    HOLDS ADDRESS OF FCB FOR LFC "MOD"       1.3#05
*                                                                1.3#05
*     DATA STRUCTURE FOR MANAGING CODE ASSEMBLY AREAS            1.3#05
*
*   SECTION RELATIVE CONTROL VARIABLES                           1.3#05
*                                                                1.3#05
MDSTFST  EQU       0W   HOLDS ADDRESS OF START OF IMAGE AREA     1.3#05
MDSTPEB  EQU       1W   HOLDS IMG AREA ADDRESS OF START OF PROG  1.3#05
MDSTNXT  EQU       2W   HOLDS NEXT AVAILABLE LOC. IN IMAGE AREA  1.3#05
MDSTHST  EQU       3W   HOLDS HIGHEST BYTE+1 USED IN ASSEM AREA  1.3#05
MDSTBOUT EQU       4W   HOLDS NUMBER OF BYTES WRITTEN TO LM FILE 1.3#05
MDSTSOUT EQU       5W   HOLDS NUMBER OF SECTORS OUTPT TO LM FILE 1.3#05
MDSTRMAD EQU       6W   HOLDS START ADDR RELOCATION MATRIX AREA  1.3#05
MDSTRMSZ EQU       7W   HOLDS SIZE IN BYTES OF RELOCATION MATRIX 1.3#05
MDSTORG  EQU       8W   HOLDS PROG ELEMENT RELATIVE OBJ CODE ORG 1.3#05
MDSTSIZ  EQU       9W   HOLDS SIZE IN BYTES OF IMAGE I/O BUFFER  1.3#05
MDSTLST  EQU       10W  HOLDS LAST ADDR OF DSECT ASSEMBLY AREA   1.3#05
MDSTCHKD EQU       11W  ACCUMULATES CHECKSUM VALUE FOR SECTION   1.3#05
MDSTSFAD EQU       12W  HOLDS STARTING SECTOR ADDR OF SECTION    1.3#05
MDINTREF EQU       13W  HOLDS INTER-SECTION MEMORY REF. BIAS    ELST-32
*                                                                1.3#05
*        CONTROL VARIABLE STORAGE                                1.3#05
*                                                                1.3#05
DSCTBASE REZ       16W                                           1.3#05
CSCTBASE REZ       16W                                           1.3#05
*                                                                1.3#05
CURRBASE DATAW     0      HOLDS ADDR OF DSCTBASE OR CSCTBASE     1.3#05
*                         DEPENDING ON CURRENT AREA IN USE       1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*
MRRSBLKS EQU       2               2 BLOCKS OF RRS PER MODULE
MPREBLKS EQU       1               1 BLOCK OF PREAMBLE PER MODULE
MRRSNEXT DATAW     MRRS            NEXT FREE WORD IN MRRS
MRRSFREE DATAW     MRRSBLKS*192    NUMBER OF FREE WORDS IN MRRS
MRRS.OLD RES       3W              TO BUILD OLD RRS ENTRIES
*
         TITLE     ISBRANCH   - CHECK FOR DIRECT BRANCHES       ELST-32
*                                                               ELST-32
****************************************************************ELST-32
*                                                               ELST-32
*        ISBRANCH  :  CHECKS INPUT DATA TO DETERMINE IF IT IS   ELST-32
*                     A BRANCH OR EXM INSTRUCTION.              ELST-33F
*                                                               ELST-32
*        INPUT : R5 CONTAINS THE INSTRUCTION PREVIOUSLY MASKED  ELST-32
*                BY THE VALUE X'FC900000'                       ELST-32
*                                                               ELST-32
*        OUTPUT : CC1 SET IF BRANCH OR EXM INSTRUCTION          ELST-33F
*                                                               ELST-32
*                 CC1 RESET IF NON-BRANCH                       ELST-32
*                                                               ELST-32
****************************************************************ELST-32
*                                                               ELST-32
ISBRANCH STF       R0,BRSAV                                     ELST-32
         TBR       R5,11           IS THIS INSTR INDIRECT       ELST-32
         BNS       $+2W            SKIP FLAG SET IF NOT         ELST-33F
         SBM       MINDIR,MFLAG3   SHOW INDIRECT INSTRUCTION    ELST-33F
         ZR        R4              CLEAR R4                     ELST-32
         SLLD      R4,9            POSITION OPCODE              ELST-32
         CI        R4,X'1F1'       BL INSTRUCTION?              ELST-32
         BEQ       ISBRNCH         YES                          ELST-32
         SRL       R4,1            ALL OTHERS ARE 6 BIT         ELST-32
         CI        R4,X'EC'        BU OR BCT?                   ELST-32
         BEQ       ISBRNCH                                      ELST-32
         CI        R4,X'F0'        BCF OR BFT                   ELST-32
         BEQ       ISBRNCH                                      ELST-32
         CI        R4,X'F4'        BIB,BIH,BIW, OR BID          ELST-32
         BEQ       ISBRNCH                                      ELST-32
         CI        R4,X'A8'        IS IT AN EXM?                ELST-33F
         BEQ       ISBRNCH         YES...BRANCH                 ELST-33F
NOBRNCH  ZBM       1,BRSAV         CLEAR BRANCH FLAG            ELST-33F
         ZBM       MINDIR,MFLAG3   AND INDIRECT FLAG            ELST-33F
         LF        R0,BRSAV        RESTORE REGISTERS            ELST-33F
         TRSW      R0              RETURN                       ELST-33F
ISBRNCH  SBM       1,BRSAV         SHOW BRANCH                  ELST-32
         TBM       MINDIR,MFLAG3   WAS INSTRUCTION INDIRECT     ELST-33F
         BNS       ISBR2           NO...BRANCH                  ELST-33F
         ZBM       MINDIR,MFLAG3   CLEAR INDIRECT FLAG          ELST-33F
         TBM       MINDMS,MFLAG3   WAS MESSAGE ALREADY OUTPUT   ELST-33F
         BS        ISBR2           YES...SKIP MESSAGE WRITE     ELST-33F
         SBM       MINDMS,MFLAG3   SHOW MESSAGE OUTPUT          ELST-33F
         ZR        R4                                           ELST-33F
         LW        R5,PROGNAM      GET CURRENT PROGRAM NAME     ELST-33F
         ZR        R2                                           ELST-33F
         LI        R3,-4           PROCESS 4 BYTES FROM NAME    ELST-33F
ISBR3    SLLD      R4,8            SHIFT OUT ONE BYTE           ELST-33F
         STB       R4,BRMSG.N,X2   SAVE IN MESSAGE              ELST-33F
         ADI       R2,1            INCREMENT POINTER            ELST-33F
         BIB       R3,ISBR3        NEXT CHARACTER               ELST-33F
         LI        R3,-4           PROCESS NEXT 4 BYTES OF NAME ELST-33F
         LW        R5,PROGNAM+1W                                ELST-33F
ISBR4    SLLD      R4,8            SHIFT OUT ONE BYTE           ELST-33F
         STB       R4,BRMSG.N,X2   SAVE IN MESSAGE              ELST-33F
         ADI       R2,1            INCREMENT POINTER            ELST-33F
         BIB       R3,ISBR4        NEXT CHARACTER               ELST-33F
         LNB       R5,BRMSG.L      GET MESSAGE LENGTH           ELST-33F
         LA        R6,BRMSG        AND MESSAGE ADDRESS          ELST-33F
         BL        XTYPE           OUTPUT MESSAGE               ELST-33F
ISBR2    LF        R0,BRSAV                                     ELST-32
         TRSW      R0                                           ELST-32
*                                                               ELST-32
BRMSG    DATAB     C' CATALOG<<WARNING>> SEGMENT TASK'          ELST-33F
         DATAB     C' CONTAINS INDIRECT BRANCH IN PROGRAM - '   ELST-33F
BRMSG.N  REZ       8B                                           ELST-33F
BRMSG.L  DATAB     $-BRMSG                                      ELST-33F
*
BRSAV    REZ       8W              REG SAVE AREA                ELST-32
         TITLE     M1002    - CONVERT DECIMAL TO BINARY
***********************************************************************
*
*                  M1002
*
***********************************************************************
*
*        CONVERT ASCII CODED DECIMAL TO BINARY
*                  SOURCE IN R6,R7, LEFT JUSTIFIED ASCII WITH
*                  TRAILING ASCII BLANKS
*                  RESULTS
*                          R6 BINARY ZERO IF CHARACTER IS NOT NUMERIC *
*                          R7 BINARY EQUIVALENT OF INPUT
*
***********************************************************************
M1002    STF       R0,MSAVER       SAVE REGISTERS
         LI        R1,1            INITIALIZE SCALING MULTIPLIER
         LI        R4,X'FF'        INITIALIZE BYTE TRANSFER MASK
         LI        R5,-8B          INITIALIZE ITERATION COUNTER
         ZMW       MSAVER+7W       INITIALIZE RESULT
M10021   TRRM      R7,R3           TRANSFER 1 BYTE
         SRLD      R6,8            SHIFT TO NEXT BYTE
         CI        R3,X'20'        IS THIS CHARACTER A BLANK
         BEQ       M10022          IF YES, IGNORE
         SUI       R3,X'30'        SUBRRACT OUT ASCII'S LEADING 3
         BLT       M10024          ERROR IF NOT NUMERIC
         CI        R3,X'09'
         BGT       M10024          DITTO
         MPR       R1,R2           CONVERT
         ARMW      R3,MSAVER+7W    ADD TO RESULT
         MPI       R0,10           INCREASE SCALER BY FACTOR OF 10
M10022   BIB       R5,M10021       NEXT BYTE
M10023   LF        R0,MSAVER       RESTORE REGS
         TRSW      R0              RETURN
M10024   ZMW       MSAVER+6W       SET ERROR RESULT
         BU        M10023          RETURN
         TITLE     M1602    - CONVERT HEXADECIMAL TO BINARY
***********************************************************************
*
*                  M1602
*
***********************************************************************
*
*        CONVERT ASCII CODED HEXADECIMAL TO BINARY
*                  SOURCE-R6,R7 LEFT JUSTIFIED ASCII WITH TRAILING
*                                SPACES
*                  RESULT-R7    BINARY   R6 ZERO IF CHAR NOT NUMERIC  *
*
***********************************************************************
M1602    STF       R0,MSAVER       SAVE REGS
         LI        R3,-8           INITIALIZE ITERATION COUNTER
         LI        R4,X'FF'        BYTE MASK
         SRC       R4,8
         ZR        R5              INITIALIZE RESULT
M16021   TRRM      R6,R2           BYTE TO R2
         SLC       R2,8
         SLLD      R6,8            SHIFT CURRENT BYTE OUT OF SOURCE
         ZR        R1              CLEAR SEARCH INDEX
         CI        R2,X'20'        IS CURRENT BYTE A BLANK
         BEQ       M16024          IF YES, DONE
M16022   CAMB      R2,M16026,R1    SEARCH FOR CHARACTER
         BEQ       M16023          BRANCH IF FOUND
         CI        R1,15           IS TABLE EXHAUSTED
         BGE       M16025          IF YES, CHARACTER INVALID
         BIB       R1,M16022       CONTINUE SEARCH
M16023   SLL       R5,4            FOUND, MAKE ROOM FOR NEW CHARACTER
         ORR       R1,R5           'OR' INDEX (BIN CH VAL) TO RESULT
         BIB       R3,M16021       IF REQUIRED, DO ANOTHER ITERATION
M16024   STW       R5,MSAVER+7W    STORE RESULT
         LF        R0,MSAVER       RESTORE REGS
         TRSW      R0              RETURN
M16025   ZMW       MSAVER+6W       SET ERROR RESULT
         BU        M16024          RETURN
M16026   DATA      C'0123456789ABCDEF'
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     M0210    - CONVERT BINARY TO DECIMAL
***********************************************************************
*
*                  M0210
*
***********************************************************************
*
*        CONVERT BINARY TO ASCII CODED DECIMAL
*                  SOURCE-R5    POSITIVE BINARY
*                  RESULT-R6,R7 ASCII, RIGHT JUSTIFIED WITH LEADING
*                               ZEROS
*        NOTE-     IF SOURCE EXCEEDS 99,999,999 THE MOST SIGNIFICANT  *
*                  DIGITS WILL NOT BE CONVERTED
*
***********************************************************************
M0210    STF       R0,MSAVER
         LI        R1,-8           INITIALIZE COUNTER
         LI        R2,10           INITIALIZE DIVISOR
         LI        R3,X'30'        INITIALIZE ASCII CHAR GENERATOR
M02101   ZR        R4              CLEAR FOR DIVIDE
         DVR       R2,R4           RESULT-R5,REMAINDER-R4,IS NEW CHAR
         ORR       R3,R4           GENERATE ASCII CHAR
         SRC       R4,8            LEFT JUSTIFY
         SRLD      R6,8
         ORR       R4,R6           'OR' NEW CHAR INTO RESULT
         BIB       R1,M02101
         STD       R6,MSAVER+6W    STORE RESULT
         LF        R0,MSAVER       RESTORE REGS
         TRSW      R0              RETURN
         TITLE     M0216    - CONVERT BINARY TO HEXADECIMAL
***********************************************************************
*
*                  M0216
*
***********************************************************************
*
*        CONVERT BINARY TO ASCII CODED HEXADECIMAL
*                  SOURCE-R3 BINARY
*                  RESULT-R4,R5 ASCII CODED HEXADECIMAL
*
***********************************************************************
M0216    STF       R0,MSAVER
         LI        R1,-8
         ZR        R5
M02161   ZR        R2              CONV TO HEX
         SLLD      R2,4
         SLLD      R4,8
         ORMB      R5,M02164,R2
         BIB       R1,M02161
         STD       R4,MSAVER+4W
         LF        R0,MSAVER
         TRSW      R0              RETURN
M02164   DATA      C'0123456789ABCDEF'
*
*-----------------------------------------------------------------------
         BOUND     1D
         TITLE     MARCLR - CLEAR ARRAY IN MEMORY
*                                                                1.3#05
*  MARCLR                                                        1.3#05
*                                                                1.3#05
*    THIS ROUTINE CLEARS AN ARRAY STARTING AT (R3) AND LIMITED   1.3#05
*    BY (R2)-1W                                                  1.3#05
*                                                                1.3#05
*   THE START AND END ADDRESSES ARE MANIPULTED TO ALLOW BODY     1.3#05
*   OF ARRAY TO BE ZEROED IN DOUBLE WORD INCREMENTS              1.3#05
*                                                                1.3#05
*   IN    R3 = STARTING ARRAY ADDRESS                            1.3#05
*         R2 = ENDING ARRAY ADDRESS+1W                           1.3#05
*                                                                1.3#05
*  OUT    ALL REGS ARE RETURNED UNCHANGED                        1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
MARCLR   EQU       $                                             1.3#05
         STD       R2,MAC.RSAV                                   1.3#05
         SUI       R2,1W           BACK IT DOWN TO LAST WORD     1.3#05
*  BOUND THE STARTING ADDR                                       1.3#05
         TBR       R3,29           IS IT DOUBLE                  1.3#05
         BNS       $+3W            SKIP IF IT IS                 1.3#05
         ZMW       0W,X3           ELSE ZAP FIRST WORD           1.3#05
         ADI       R3,1W           AND BUMP START                1.3#05
* BOUND THE ENDING ADDR                                          1.3#05
         TBR       R2,29           IS IT DOUBLE                  1.3#05
         BNS       $+3W            SKIP IF IT IS                 1.3#05
         SUI       R2,1W           ELSE JUST DROP DOWN 1W        1.3#05
         BU        $+3W            AND SKIP ODD CASE             1.3#05
         ZMW       0W,X2           ZAP THE LAST WORD             1.3#05
         SUI       R2,2W           AND BACK POINTER DOWN 1D      1.3#05
*  NOW LOOP THRU BODY                                            1.3#05
         ZMD       0D,X3           ZAP NEXT DOUBLEWORD           1.3#05
         ADI       R3,1D           AND BUMP POINTER              1.3#05
         CAR       R2,R3           COMPARE TO END                1.3#05
         BLE       $-3W            AND LOOP                      1.3#05
*                                                                1.3#05
         LD        R2,MAC.RSAV                                   1.3#05
         TRSW      R0              RETURN                        1.3#05
MAC.RSAV DATAD     0               HOLDS CALLERS R2,R3           1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     MCHKSUM - CALCULATE CHECKSUM FOR LM COMPONENT
*                                                                1.3#05
*   MCHKSUM                                                      1.3#05
*                                                                1.3#05
*    CALCULATES LOAD MODULE COMPONENT CHECKSUM ACCORDING TO      1.3#05
*    INPUT PARAMETERS.                                           1.3#05
*                                                                1.3#05
*  IN    R2 = LOCATION TO ACCUMULATE VALUE                       1.3#05
*        R3 = STARTING LOCATION                                  1.3#05
*        R4 = ENDING LOCATION                                    1.3#05
*                                                                1.3#05
* OUT    ALL REGS RETURNED                                       1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
MCHKSUM  EQU       $                                             1.3#05
         STD       R2,MCS.RSAV                                   1.3#05
         LW        R2,0,X2         GET VALUE                     1.3#05
MCS.1    EQU       $                                             1.3#05
         ADMH      R2,0,X3         ACCUMULATE                    1.3#05
         ADI       R3,1H           BUMP                          1.3#05
         CAR       R4,R3           COMPARE                       1.3#05
         BLT       MCS.1           AND LOOP                      1.3#05
         TRR       R2,R3                                         1.3#05
         LW        R2,MCS.RSAV     RECOVER ACCUMULATOR ADDR      1.3#05
         STW       R3,0,X2         STORE                         1.3#05
         LW        R3,MCS.RSAV+1W  RECOVER USER REG 3            1.3#05
         TRSW      R0              AND RETURN                    1.3#05
MCS.RSAV DATAD     0                                             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     MFLSHBUF  - FLUSH THE ASSEMBLY BUFFER         1.3#05
*                                                                1.3#05
*   MFLSHBUF                                                     1.3#05
*                                                                1.3#05
*  THIS ROUTINE FINDS THE LARGEST MULTIPLE OF 768 IN THE USED    1.3#05
*  ASSEMBLY AREA, CHECKSUMS THIS AMOUNT AND WRITES IT OUT.       1.3#05
*                                                                1.3#05
*  THE REMAINDER OF THE BUFFER IS MOVED TO THE BEGINNING OF THE  1.3#05
*  ASSEMBLY AREA AND THE ASSEMBLY POINTERS ARE UPDATED.          1.3#05
*                                                                1.3#05
*   IN      R1 = CONTAINS ADDR OF APROPRIATE DOPE VECTOR         1.3#05
*           MDSTFST,MDSTPEB,MDSTNXT,MDSTLST  ARE USED AND        1.3#05
*                                                                1.3#05
* OUT               MDSTPEB,MDSTNXT          ARE MODIFIED        1.3#05
*                                                                1.3#05
*    ALL REGS RETURNED UNCHANGED                                 1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
MFLSHBUF EQU       $                                             1.3#05
         STF       R0,MFB.RSAV                                   1.3#05
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ECSV-33
         BNS       FLUSH.1         NO...BRANCH                  ECSV-33
         TBM       MSEGR,MFLAG3    CSEGVAL DEF READ?            ECSV-33
         BNS       FLUSH.1         NO...BRANCH                  ECSV-33
         ZBM       MSEGR,MFLAG3    SHOW CSEGVAL ADJUSTED        ECSV-33
         LW        R2,CREGBAS      GET CSEGVAL BASE ADDR        ECSV-33
         ADMW      R2,CREGLOC      ADD IN PROGRAM RELATIVE ADDR ECSV-33
         LW        R7,C31.7T       GET CSECT ORIGIN ADDRESS     ECSV-33
         ARMW      R7,0,X2         ADD TO CSEGVAL               ECSV-33
FLUSH.1  LW        R7,MDSTNXT,X1       GET NEXT LOCATION         1.3#05
         SUMW      R7,MDSTFST,X1       MINUS BEGINNING           1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768          CALCULATE NUMBER OF SECTORS   1.3#05
         TRR       R7,R5           USE TRUNCATED                 1.3#05
         ES        R4                                            1.3#05
         MPI       R4,768          CALCULATE SIZE                1.3#05
*                                                                1.3#05
         LW        R2,MMODW        GET ADDR OF THIS SEG ENTRY    1.3#05
         TBM       4,1B,X2         IS MODULE OUTPUT SUPRESSED    1.3#05
         BS        MFB.1           SKIP TO DATA MOVE IF IT IS    1.3#05
*                                                                1.3#05
         LA        R2,MDSTCHKD,X1    GET ADDR OF SECTION CHKSUM  1.3#05
         LW        R3,MDSTFST,X1       GET AREA STARTING ADDR    1.3#05
         TRR       R5,R4                                         1.3#05
         ADR       R3,R4      CALCULATE ENDING ADDR              1.3#05
         BL        MCHKSUM                                       1.3#05
*                                                                1.3#05
         TRR       R5,R2           NUMBER OF BYTES               1.3#05
         LW        R4,MDSTSFAD,X1      ADDR OF SECTION ON DISC   1.3#05
         ADMW      R4,MDSTSOUT,X1       PLS ACCUMULTED SECTORS   1.3#05
         ZR        R1                                            1.3#05
         BL        XWRTMOD                                       1.3#05
         LW        R1,MFB.RSAV+1W  RECOVER DOPE VECTOR ADDR      1.3#05
         ARMW      R7,MDSTSOUT,X1       UPDATE SECTORS OUT       1.3#05
*
MFB.1    EQU       $                                             1.3#05
         LW        R3,MDSTFST,X1       GET START OF MEMORY AREA  1.3#05
         TRR       R5,R2           START OF UNWRITTEN PART       1.3#05
         ADR       R3,R2
         TRN       R6,R4           NEGATE SIZE OF REMAINDER      1.3#05
         BZ        MFB.3           NOTHING TO MOVE IF ZERO       1.3#05
MFB.2    EQU       $               LOOP TOP                      1.3#05
         LW        R7,0,X2         GET NEXT UNWRITTEN WORD       1.3#05
         STW       R7,0,X3         TO NEXT LOCATION IN BUFFER    1.3#05
         ABR       R3,29                                         1.3#05
         ABR       R2,29                                         1.3#05
         BIW       R4,MFB.2                                      1.3#05
*                                                                1.3#05
MFB.3    EQU       $                                             1.3#05
         LW        R4,MDSTPEB,X1       GET PROGRAM ELEMENT START 1.3#05
         SUR       R5,R4                                         1.3#05
         STW       R4,MDSTPEB,X1       UPDATE PROG ELEMT START   1.3#05
         LW        R4,MDSTNXT,X1       GET NEXT AVAIL POINTER    1.3#05
         SUR       R5,R4                                         1.3#05
         STW       R4,MDSTNXT,X1       UPDATE NEXT AVAIL POINTER 1.3#05
         STW       R4,MDSTHST,X1       RESET HIGHEST USED        1.3#05
         ARMW      R5,MDSTBOUT,X1       UPDATE BYTES OUT COUNT   1.3#05
*
         LW        R3,MDSTNXT,X1       START ADDR                1.3#05
         LW        R2,MDSTLST,X1       END OF BUFFER             1.3#05
         BL        MARCLR
*                                                                1.3#05
         LF        R0,MFB.RSAV                                   1.3#05
         TRSW      R0                                            1.3#05
         BOUND     1F                                            1.3#05
MFB.RSAV RES       1F                                            1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     MPRGEBUF - LIKE MFLSHBUF BUT USED AT SEG END
*                                                                1.3#05
*     IN   R1 = CONTAINS ADDR OF APROPRIATE DOPE VECTOR          1.3#05
*                                                                1.3#05
*   OUT   REGS NOT PRESERVED                                     1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
MPRGEBUF EQU       $                                             1.3#05
         STW       R0,MPB.RET                                    1.3#05
         LW        R5,MDSTNXT,X1       GET NEXT AVAIL POINTER    1.3#05
         SUMW      R5,MDSTFST,X1       MINIUS AREA START         1.3#05
*                                                                1.3#05
         LW        R2,MMODW        GET ADDR OF THIS SEG ENTRY    1.3#05
         TBM       4,1B,X2         IS MODULE OUTPUT SUPRESSED    1.3#05
         BS        *MPB.RET        QUIT IF IT IS                 1.3#05
*                                                                1.3#05
         LA        R2,MDSTCHKD,X1    GET ADDR OF SECTION CHKSUM  1.3#05
         LW        R3,MDSTFST,X1       GET AREA START            1.3#05
         TRR       R5,R4                                         1.3#05
         ADR       R3,R4      CALCULATE ENDING ADDR              1.3#05
         BL        MCHKSUM                                       1.3#05
*                                                                1.3#05
         TRR       R5,R2           NUMBER OF BYTES               1.3#05
         LW        R4,MDSTSFAD,X1      ADDR OF SECTION ON DISC   1.3#05
         ADMW      R4,MDSTSOUT,X1       PLUS ACCUMULATED SECTRS  1.3#05
         ZR        R1                                            1.3#05
         BL        XWRTMOD                                       1.3#05
*                                                                1.3#05
         BU        *MPB.RET                                      1.3#05
*                                                                1.3#05
MPB.RET  DATAW     0                                             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     MBERR    - ERROR MESSAGE OUTPUT ROUTINE
***********************************************************************
*
*                  MBERR
*        OUTPUT OBJECT RECORD ERROR MSG AND TERMINATE CATALOGER
***********************************************************************
* INPUT:
*        R5 = MESSAGE NUMBER
*        R6 = 0 IF ONLY MESSAGE IS DESIRED
*
* MESSAGE FORMAT:
*        "MODULE 'NAME'"           - 'NAME' IS THE CURRENT MODULE NAME*
*        "PROGRAM 'NAME', OBJECT RECORD 'HHHH' - 'MESSAGE'"
*                                  - 'NAME' IS FOUND IN "MPNAM"
*                                  - 'HHHH' IS THE HEX RECORD NUMBER  *
*                                  - 'MESSAGE' IS INDEXED TO BY R5
*        "CATALOGING NOT SUCCESSFUL"
*               MESSAGES ARE:
*    E.OUTSEQ = 1 OUT OF SEQUENCE
*    E.CHKSUM   2 CHECKSUM ERROR
*    E.ABSORG = 3 ABSOLUTE ORIGIN
*    E.BOUND  = 4 BOUND ERROR
*    E.ILLFNC = 5 UNASSIGNED FUNCTION CODE
*    E.COMORG = 6 ILLEGAL COMMON ORIGIN
*    E.PGMBND = 7 OBJECT CODE BEYOND END OF PROGRAM              1.3#17
*    E.COMREF = 8 REFERENCE TO UNDEFINED COMMON BLOCK
*    E.GBLCOM =10 GLOBAL COMMON INITIALIZED
*    E.PREEOF =11 PREMATURE END OF FILE
*    E.DATPOL =12 DATAPOOL REF OUT OF RANGE
*    E.BLOCK  =13 LFC WAS NOT ASSIGNED UNBLOCKED                 21004 *
*
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
*   NOTE: ALL CALLS TO THIS ROUTINE CHANGED FROM "BU" TO "BL     1.3#05
*         TO PROVIDE TRACE BACK INFO                             1.3#05
*       LOCATIONS ARE MARKED "1.3#05" TO INDICATE CHANGE         1.3#05
*                                                                1.3#05
*         THIS ROUTINE MODIFIED TO OUTPUT TO UT & SLO IF         1.3#05
*         ENVIROMNENT IS INTERACTIVE                             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
E.OUTSEQ EQU       1
E.CHKSUM EQU       2
E.ABSORG EQU       3
E.BOUND  EQU       4
E.ILLFNC EQU       5
E.COMORG EQU       6
E.PGMBND EQU       7          OBJECT CODE BEYOND END OF PROGRAM  1.3#17
E.COMREF EQU       8
E.GBLCOM EQU       10
E.PREEOF EQU       11
E.DATPOL EQU       12
E.BLOCK  EQU       13                                             21004
MBERR    STW       R5,MBERR90      SAVE ERROR MESSAGE INDEX.
         STW       R6,MBERR90+1W   SAVE OUTPUT FLAG               21004
         LW        R1,MMODW
         LD        R6,2W,R1
         STD       R6,MMODM+1D
         LI        R5,-16B         SET FOR UT & SLO              1.3#05
         LA        R6,MMODM
         BL        XTYPEF          MODULE: NAME MSG              1.3#05
         LD        R6,MBERR91      "PROGRAM "
         STD       R6,MPBUF
         LD        R6,MPNAM        ADD PGM ELEMENT NAME TO MSG
         STD       R6,MPBUF+1D
         LH        R3,MXSEQ
         BL        M0216           CONV SEQ NO. TO HEX
         STW       R5,MBERR92+4W
         LI        R2,2D           SET INDEX REGISTER FOR STORES   22008
         ZR        R1
         LI        R3,-23          LENGTH OF PREFIX
MBERR3   LB        R5,MBERR92,R1   MOVE TO BUFFER
         STB       R5,MPBUF,R2
         ABR       R1,31
         ABR       R2,31
         BIB       R3,MBERR3
MBERR3.1 LW        R3,MBERR90      PICK UP MESSAGE ID.
         SUI       R3,1B           CONV TO
         SLL       R3,2            WORD IX
         LW        R1,MBERR94,R3   ADDR OF MSG
         LB        R5,0,R1         LENGTH OF ERROR MESSAGE
         LNB       R3,0,R1         GET NEGATIVE LENGTH FOR LOOP COUNT
MBERR4   LB        R0,1B,X1        STORE MSG IN BUFFER
         STB       R0,MPBUF,R2
         ABR       R1,31
         ABR       R2,31
         BIB       R3,MBERR4
         ADI       R5,39           ADD LENGTH OF PREFIX TO MESSAGE
MBERR5   LA        R6,MPBUF-1      ADDRESS OF MESSAGE BUFFER
         ADI       R5,1            BUMP FOR CC                   1.3#05
         TRN       R5,R5           SET FOR UT & SLO              1.3#05
         BL        XTYPEF          AND OUTPUT                    1.3#05
         BL        XABORT           EXIT FROM THE CATALOGER......
         SPACE     4
MBERR90  RES       2W              INDEX SAVE LOCATION.
MBERR91  DATAD     C'PROGRAM:'
MBERR92  DATAW     C', OBJECT REC. X"'    "' -'
MBERR94  ACW       MBERR95         MSG ADDRESSES
         ACW       MBERR96
         ACW       MBERR97
         ACW       MBERR98
         ACW       MBERR99
         ACW       MBERR100
         ACW       MBERR101        RE-ACTIVATED AT REL>>>>>>>    1.3#17
         ACW       MBERR102
         DATAW     0               SPARE
         ACW       MBERR104
         ACW       MBERR105
         ACW       MBERR106
         ACW       MBERR107                                    21004
**MESSAGES.  FIRST BYTE CONTAINS NO. CHARS IN MSG
         BOUND     1W
MBERR95  DATAB     16
         DATAB     C' OUT OF SEQUENCE'
         BOUND     1W
MBERR96  DATAB     15
         DATAB     C' CHECKSUM ERROR'
         BOUND     1W
MBERR97  DATAB     16
         DATAB     C' ABSOLUTE ORIGIN'
         BOUND     1W
MBERR98  DATAB     12
         DATAB     C' BOUND ERROR'
         BOUND     1W
MBERR99  DATAB     25
         DATAB     C' UNASSIGNED FUNCTION CODE'
         BOUND     1W
MBERR100 DATAB     22
         DATAB     C' ILLEGAL COMMON ORIGIN'
         BOUND     1W                                            1.3#17
MBERR101 DATAB     35                                            1.3#17
         DATAB     C' OBJECT CODE OUTSIDE PROGRAM BOUNDS'        1.3#17
         BOUND     1W
MBERR102 DATAB     36
         DATAB     C' REFERENCE TO UNDEFINED COMMON BLOCK'
         BOUND     1W
MBERR104 DATAB     26
         DATAB     C' GLOBAL COMMON INITIALIZED'
         BOUND     1W
MBERR105 DATAB     22
         DATAB     C' PREMATURE END OF FILE'
         BOUND     1W
MBERR106 DATAB     32
         DATA      C' DATAPOOL REFERENCE OUT OF RANGE'
         BOUND     1W
MBERR107 DATAB     31                                             21004
         DATA      C' XXX WAS NOT ASSIGNED UNBLOCKED'             21004
*
*-----------------------------------------------------------------------
         TITLE  MEADD - ADDS AN ENTRY TO THE EXTERNAL TABLE      1.3#02
*                                                                1.3#02
*    THIS ROUTINE ADDS A SYMBOL TO EXTERNAL TABLE                1.3#02
*             IFF IT IS NOT ALREADY THERE AND IT IS NOT          1.3#02
*             ALREADY IN THE MAIN SYMBOL TABLE                   1.3#02
*                                                                1.3#02
*    IN       R6,R7  CONTAIN SYMBOL TO BE ADDED                  1.3#02
*                                                                1.3#02
*                                                                1.3#02
*   OUT       R1= ADDR OF SLOT SET BY THIS CALL(IF SYMBOL ADDED) 1.3#02
*                                                                1.3#02
*             CC-1 RESET  IFF SYMBOL ADDED                       1.3#02
*             CC-1 SET    IF SYMBOL NOT ADDED                    1.3#02
*                                                                1.3#02
*----------------------------------------------------------------1.3#02
*                                                                1.3#02
MEADD    EQU       $                                             1.3#02
         STF       R0,MEADD.RS                                   1.3#02
         BL        MESCH            SEE IF IT EXISTS IN EXTERNAL 1.3#02
         BCT       1,MEADD.5        BR IF FOUND                  1.3#02
*                                                                1.3#02
*       NOW CHECK MAIN SYMBOL TABLE                              1.3#02
*                                                                1.3#02
         ZR        R5         ELSE, SEE IF IT IS DEFINED         1.3#02
MEADD.1  LW        R4,=X'40000000'                               1.3#02
         BL        MSSCH           SEARCH SYMTAB FOR MATCHING DEF1.3#02
         TRR       R5,R5                                         1.3#02
         BEQ       MEADD.4         BR IF NOT FOUND               1.3#02
         LW        R2,MMODF                                      1.3#02
         LW        R4,1W,R2                                      1.3#02
         BEQ       MEADD.5          BR IF DEF IS IN MAIN         1.3#02
         LW        R1,MMODW                                      1.3#02
         CAMW      R4,1W,R1                                      1.3#02
         BEQ       MEADD.5         BR IF DEF IN CURRENT MODULE   1.3#02
         LH        R4,1W,R1        CURRENT OVERLAY LEVEL         1.3#02
         CAMH      R4,1W,R2                                      1.3#02
         BGT       MEADD.3         BR IF DEF IN LOWER LEVEL MOD  1.3#02
         BLT       MEADD.5         BR IF DEF IN HIGHER MODULE    1.3#02
MEADD.2  SUI       R5,4W                                         1.3#02
         BU        MEADD.1                                       1.3#02
MEADD.3  TRR       R5,R4           SAVE RESUME ADDRESS           1.3#02
         LW        R5,1W,R2                                      1.3#02
         BL        MLINK                                         1.3#02
         TRR       R5,R5                                         1.3#02
         BNE       MEADD.5         BR IF LINKED TO DEF'D MODULE  1.3#02
         TRR       R4,R5                                         1.3#02
         BU        MEADD.2                                       1.3#02
MEADD.4  EQU        $              HERE IF IT IS TO BE ADDED     1.3#02
         LW        R1,MPNXT        RECOVER EXT.TAB POINTER       1.3#02
         STD       R6,0,X1          AND ADD SYMBOL               1.3#02
         STW       R1,MEADD.RS+1W  SAVE ADDR OF SLOT USED        1.3#02
         ABR       R1,28            BUMP TO NEXT                 1.3#02
         STW       R1,MPNXT         AND SAVE                     1.3#02
MEADD.X  EQU       $                                             1.3#02
         LF        R0,MEADD.RS      RECOVER USER CONTEXT         1.3#02
         TRSW      R0               AND RETURN                   1.3#02
         NOP                                                     1.3#02
*             HERE IF FOUND IN EXTERNAL TABLE                    1.3#02
MEADD.5  EQU       $                                             1.3#02
         SBM       1,MEADD.RS      SHOW SYMBOL FOUND             1.3#02
         BU        MEADD.X          THEN RETURN                  1.3#02
*                                                                1.3#02
         BOUND     1F                                            1.3#02
MEADD.RS REZ       1F                                            1.3#02
*                                                                1.3#02
*--------------------------------------------------------------- 1.3#02
         TITLE MESCH - SEARCH EXTERNAL TABLE                     1.3#02
*                                                                1.3#02
*    THIS ROUTINE SEARCHES THE EXTERNAL TABLE FOR DUPLICATES.    1.3#02
*                                                                1.3#02
*   IN      R6,R7 = SYMBOL TO BE MATCHED.                        1.3#02
*                                                                1.3#02
*    NOTE BIT-0=1 OF ENTRIES MEANS SYMBOL IS SPECIFICALLY        1.3#02
*         EXCLUDED.                                              1.3#02
*                                                                1.3#02
*  OUT    CC-1 RESET IFF NOT FOUND                               1.3#02
*         CC-1 SET   IF FOUND                                    1.3#02
*              AND  CC-2 SET IF FOUND IN EXCLUDE TABLE           1.3#02
*                                                                1.3#02
*      R1=ADDR OF NEXT POSITION IN TABLE IF NOT FOUND (MPNXT)    1.3#02
*         ADDR OF MATCHING ENTRY IF FOUND                        1.3#02
*                                                                1.3#02
*--------------------------------------------------------------- 1.3#02
MESCH    EQU       $                                             1.3#02
         SLL       R0,5            STRIP CC'S                    1.3#02
         SRL       R0,5            AND RESTORE RETURN ADDR       1.3#02
         STF       R0,MESCH.RS                                   1.3#02
MESCH.0  EQU       $                                             1.3#02
         LW        R1,MPFST        GET START OF EXTERNAL TABLE   1.3#02
         BU        MESCH.4         AND SEE IF ANYTHING TO SEARCH 1.3#02
MESCH.1  EQU       $               LOOP TOP                      1.3#02
         LD        R4,0,X1         GET TABLE ENTRY               1.3#02
         CAR       R5,R7           TEST SECOND HALF              1.3#02
         BNE       MESCH.3         GO FOR NEXT IF NOT EQ         1.3#02
         SRLD      R4,31           EXTRACT SYMBOL PART           1.3#02
         SRLD      R6,31           THIS ONE TOO                  1.3#02
         CAR       R5,R7           AND TEST SYMBOL PARTS         1.3#02
         BNE       MESCH.2         GO DO NEXT IF NOT EQ          1.3#02
*                                                                1.3#02
*               AT THIS POINT SYMBOLS MATCH                      1.3#02
*                                                                1.3#02
         SBM       1,MESCH.RS      SHOW FOUND IN TABLE           1.3#02
         TRR       R4,R4           WAS IT EXCLUDED               1.3#02
         BZ        MESCH.X         BR IF NOT                     1.3#02
         SBM       2,MESCH.RS      SHOW IT AS EXCLUDED           1.3#02
         BU        MESCH.X                                       1.3#02
*                                                                1.3#02
MESCH.2  EQU       $                                             1.3#02
         LD        R6,MESCH.RS+6W  RESTORE R6,R7                 1.3#02
MESCH.3  EQU       $               BUMP TO NEXT ENTRY            1.3#02
         ABR       R1,28           BY INCREMENTING 1D            1.3#02
MESCH.4  STW       R1,MESCH.RS+1W  SAVE R1 FOR CALLER            1.3#02
         CAMW      R1,MPNXT        ARE WE AT THE END?            1.3#02
         BLT       MESCH.1         BR IF MORE TO TEST            1.3#02
*               AT THIS POINT SYMBOL WAS NOT FOUND               1.3#02
*                                                                1.3#02
MESCH.X  EQU       $                                             1.3#02
         LF        R0,MESCH.RS     AND EXIT                      1.3#02
         TRSW      R0                                            1.3#02
         NOP                                                     1.3#02
*                                                                1.3#02
         BOUND     1F                                            1.3#02
MESCH.RS REZ       1F                                            1.3#02
*                                                                1.3#02
*----------------------------------------------------------------1.3#02
         TITLE     MSSCH    - SEARCH SYMBOL TABLE
***********************************************************************
*
*                  MSSCH
*
***********************************************************************
*
*        SEARCH SYMBOL TABLE (SYMTAB) FOR SPECIFIED ENTRY TYPE.
*        SEARCH IS FROM INITIAL ENTRY (HIGH CORE) TO FINAL ENTRY (LOW *
*        CORE).
* INPUTS:
*        R4 ENTRY TYPE.  BIT IS SET IN POSITION IN WORD TO BE TESTED. *
*        R6,7  OPTIONAL NAME TO BE SEARCHED FOR.   IF OMITTED,
*              R7 IS BINARY ZERO.  IF PRESENT, LEFT  JUSTIFIED.
*        R5   OPTIONAL ADDRESS AT WHICH TO BEGIN SEARCH.
*             ZERO IF OMITTED.
* OUTPUT:
*        R5 = ADDRESS OF SYMBOL TABLE ENTRY (WORD 0) IF FOUND.
*             ZERO IF NO ENTRY FOUND.
*
*   MMODF   ENTRY ADDR OF LAST MODULE ENTRY FOUND
*   MCTLF   ENTRY ADDR OF LAST CONTROL ENTRY FOUND
*
***********************************************************************
MSSCH    STD       R0,MSSCH90                                    1.3#05
         ZR        R1              PRESET RETURN                 1.3#05
         XCR       R1,R5           MOVE R5 TO R1                 1.3#05
         BNZ       MSSCH3.5        BR IF START ADDR SUPPLIED     1.3#05
         LW        R1,MPLST        IF NOT, START AT INITIAL ENTRY
         SUI       R1,3W           WD 0
MSSCH2   TBM       0,0,R1
         BNS       MSSCH25         BR IF NOT MODULE ENTRY
         STW       R1,MMODF
MSSCH25  EQU       $                                             1.3#10
         TBM       5,0,X1          CONTROL ENTRY                 1.3#10
         BNS       MSSCH26         SKIP IF NOT                   1.3#10
         STW       R1,MCTLF        SAVE ADDR                     1.3#10
MSSCH26  EQU       $                                             1.3#10
         LMW       R5,0,R1         1ST/NEXT ENTRY HAVE DESIRED ID
         BEQ       MSSCH3          BR TO LOOP IF NOT
         TRR       R7,R7
         BZ        MSSCH4          LEAVE IF NO NAME MATCH        1.3#05
         CAMD      R6,0+2W,R1
         BEQ       MSSCH4          LEAVE IF MATCH                1.3#05
MSSCH3   SUI       R1,4W           NEXT ENTRY
MSSCH3.5 CAMW      R1,MSYMN
         BGT       MSSCH2          BR IF NOT FINISHED
         ZR        R1              STAGE ZERO RESPONSE           1.3#05
MSSCH4   EQU       $
         XCR       R1,R5
         LD        R0,MSSCH90                                    1.3#05
         TRSW      R0              RETURN
         BOUND     1D                                            1.3#05
MSSCH90  RES       1D                                            1.3#05
         TITLE     MSYMS    - STORE ENTRY INTO SYMBOL TABLE
***********************************************************************
*
*                  MSYMS
*
***********************************************************************
*        STORE AN ENTRY IN THE SYMBOL TABLE (SYMTAB)
*        R4,5,6,7 CONTAIN THE ENTRY TO BE STORED
*        MSTMD IS SET IF A MODULE OR LINKBACK ENTRY IS TO BE STORED
*        M.EXIT ON TABLE FULL
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
MSYMS    STF       R0,MSYMS90      SAVE REGS
         LW        R1,MSYMN        PICK UP BOTTOM OF SYMBOL TABLE
MSYMS1   CAMW      R1,MPNXT        MPNXT=LAST EX REF STORED
         BGT       MSYMS2          BR IF NO CLASH BETWEEN TABLES
         LA        R6,MSOFMSG      SYM TAB OVERFLOW MSG
         LNB       R5,MSOFMLN                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BL        XABORT
MSYMS2   LF        R4,MSYMS90+4W
         STD       R4,0D,X1        SAVE FIRST HALF               1.3#02
         STD       R6,1D,X1        NOW SECOND HALF               1.3#02
         ZBM       MSTMD,MFLGS
         BS        MSYMS3          BR IF MODULE ENTRY STORED
         LW        R1,MSYMC
         ABM       31,0,R1         INCREMENT NO. ENTRIES IN CONT ENTRY
MSYMS3   LW        R5,MSYMN
         SUI       R5,4W           UPDATE IX
         STW       R5,MSYMN
         LF        R0,MSYMS90
         TRSW      R0              RETURN
         BOUND     8W
MSYMS90  RES       8W
         TITLE     MTCOR    - STORE PROGRAM DATA INTO BUFFER
***********************************************************************
*
*                  MTCOR
*
***********************************************************************
*
*        STORE PROGRAM DATA IN MEMORY
*
*        R1 = TYPE OF REQUEST-WORD SCALED VALUES
MT.SORG  EQU       1W SET/RESET ORIGIN
MT.REL   EQU       2W STORE A RELOCATABLE WORD
MT.ABS   EQU       3W STORE ABSOLUTE DATA
MT.RORG  EQU       4W RESET ORIGIN
MT.CORG  EQU       5W SET CSECT ORIGIN
MT.COM   EQU       6W STORE A WORD REFERENCING COMMON
*
*        MTCORCL2 = DATA FOR CALL TYPES AS FOLLOWS
*        MT.SORG   =  ORIGIN (1 WORD) IN RAW ADDRESS FORM
*        MT.REL    =  ONE RELOCATABLE WORD OF DATA
*        MT.ABS    =  ONE TO SIXTEEN BYTES OF ABS DATA
*        MT.RORG   =  ORIGIN (1 WORD) IN PGM ELE RELATIVE FORM
*        MT.CORG   =  ORIGIN (1 WORD) IN RAW ADDRESS FORM
*        MT.COM    =  ONE WORD CONTAINING THE COMMON ADDRESS
*
*        MTCORCL3 = CONTAIN COUNT OF BYTES IN MTCORCL2 FOR CALL TYPE 3*
*
***********************************************************************
MTCOR    STF       R0,MTCOR90      SAVE REGS
         TBM       M2.5MB,MFLAG2   GENERATE 2.5 MB TASK?        ELST-32
         BNS       MTCOR.0         CONTINUE IF NOT              ELST-32
*!!!!!!!!ZR!!!!!!!!R2!!!!!!!!!!!!!!CLEAR!!R2!!!!!!!!!!!!!!!!!!!!PR12009
*!!!!!!!!LB!!!!!!!!R7,MTCORCL3!!!!!GET!NUMBER!OF!BYTES!OF!DATA!!PR12009
         CI        R1,8            RELOCATABLE DATA?            PR12009
         BNE       MTCOR.0         NO...BRANCH                  PR12009
MTCOR.00 LW        R4,=X'FC900000' OPCODE AND INDIRECT MASK     ELST-32
         LMW       R5,MTCORCL2     GET DATA WORD                ELST-32
         BL        ISBRANCH        CHECK FOR BRANCHES IF SO     ELST-32
         BNS       MTCOR.0         CONTINUE IF NOT A BRANCH     ELST-32
*!!!!!!!!CI!!!!!!!!R1,8!!!!!!!!!!!!RELOCATABLE DATA?!!!!!!!!!!!!PR12009
*!!!!!!!!BU!!!!!!!!MTC.ERR!!!!!!!!!ERROR!IF!RELO.!AND!BRANCH!!!!ELST-32F
*!!!!!!!!LW!!!!!!!!R4,=X'FFF00000'!MASK!FOR!OPCODE!AND!OTHERS!!!PR12009
*!!!!!!!!LMW!!!!!!!R5,MTCORCL2!!!!!GET!NON-ADDRESS!BITS!!!!!!!!!PR12009
*!!!!!!!!LW!!!!!!!!R4,=X'000FFFFF'!MASK!FOR!ADDRESS!!!!!!!!!!!!!PR12009
*!!!!!!!!LMW!!!!!!!R6,MTCORCL2!!!!!GET!ADDRESS!!!!!!!!!!!!!!!!!!PR12009
*!!!!!!!!SRL!!!!!!!R6,1!!!!!!!!!!!!ADJUST!BRANCH!ADDRESS!!!!!!!!PR12009
*!!!!!!!!ORR!!!!!!!R6,R5!!!!!!!!!!!COMBINE!INSTR!AND!ADDR!!!!!!!PR12009
*!!!!!!!!STW!!!!!!!R5,MTCORCL2!!!!!SAVE!MODIFIED!DATA!!!!!!!!!!!PR12009
*!MTCOR.01!!!SUI!!!R7,4!!!!!!!!!!!!ONE!WORD!PROCESSED!!!!!!!!!!!PR12009
*!!!!!!!!CI!!!!!!!!R7,0!!!!!!!!!!!!ANY!MORE!DATA?!!!!!!!!!!!!!!!PR12009
*!!!!!!!!BLE!!!!!!!MTCOR.0!!!!!!!!!BRANCH!IF!NOT!!!!!!!!!!!!!!!!PR12009
*!!!!!!!!SUI!!!!!!!R7,4!!!!!!!!!!!!GET!NEXT!WORD!IF!MORE!!!!!!!!ELST-32E
*!!!!!!!!ADI!!!!!!!R2,4!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR12009
*!!!!!!!!BU!!!!!!!!MTCOR.00!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR12009
MTCOR.0  SUI       R1,1W                                        ELST-32
         BU        *MTCOR1,R1      BR ACCORDING TO CALL TYPE
MTCOR1   ACW       MTC.SORG        SET ORIGIN
         ACW       MTC.REL         RELOCATABLE DATA
         ACW       MTC.ABS         ABSOLUTE DATA
         ACW       MTC.RORG        RESET ORIGIN
         ACW       MTC.CORG        CSECT ORIGIN
         ACW       MTC.COM         COMMON REFERENCE
*
MTC.CORG EQU       $                                             1.3#05
         LA        R2,CSCTBASE     SET DOPE VECTOR ADDR TO CSECT 1.3#05
         STW       R2,CURRBASE                                   1.3#05
*
         LW        R1,MTCORCL2     PICK UP ORIGIN
         ADMW      R1,MDSTPEB,X2       ADD BASE ADDR OF PROG ELE 1.3#05
         BU        MTCOR6
         SPACE
MTC.SORG EQU       $
         LA        R2,DSCTBASE     SET DOPE VECTOR TO DSECT      1.3#05
         STW       R2,CURRBASE                                   1.3#05
*
         LW        R1,MSYMC        OBTAIN COMMON DELTA
         LW        R4,=X'00FFFFFF'
         LMW       R1,1W,X1
         ADMW      R1,MTCORCL2     ADD CALL VALUE
MTCOR2.5 EQU       $                                             1.3#05
         LW        R2,CURRBASE                                   1.3#05
         ADMW      R1,MDSTPEB,X2       BASE ADDR                 1.3#05
         BU        MTCOR6
         SPACE
MTC.RORG LW        R4,=X'FFFFFF'   LOAD MASK FOR LOW ORDER 24-BITS
         LMW       R1,MTCORCL2     PICK UP DISPLACEMENT TO ORIGIN
         BU        MTCOR2.5
         SPACE
MTC.COM  ZR        R1              SET FLAG TO INDICATE COMMON REF.
MTC.REL  LI        R4,3
         LW        R2,CURRBASE     SET UP ACTIVE DOPE VECTOR     1.3#05
         LMW       R5,MDSTNXT,X2       NEXT AVAIL LOCATION       1.3#05
         BEQ       MTCOR5          BR IF ON WORD BOUNDARY
         LI        R5,E.BOUND      BOUND ERROR MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
MTCOR5   TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BNS       MTCOR5.1        BR IF NOT ABSOLUTE
         LW        R5,MPABS        GET ABSOLUTE BASE
         LW        R7,MTCORCL2     GET RELOCATABLE WORD            1055
         SLLD      R6,13           CLEAR OFF INSTR. BITS           1055
         SRL       R7,13                                           1055
         ADR       R5,R7           ADD ABSOLUTE BASE TO RELOCAT.   1055
         SLL       R7,13           SHIFT BACK                      1055
         SRLD      R6,13                                           1055
         STW       R7,MTCORCL2     AND STORE BACK                  1055
         BU        MTCOR5.2        DO NOT SET BIT IN RELOC. MATRIX
MTCOR5.1 LW        R5,MDSTNXT,X2       GET NEXT AVAIL ADDRESS    1.3#05
         BL        MSETR           SET BIT IN RELOC MATRIX
MTCOR5.2 LW        R5,MTCORCL2     GET DATA WORD
         LW        R4,=X'0007FFFC' MASK FOR ADDRESS PORTION
         TRRM      R5,R6           SEND ADDRESS TO R6
         TRR       R1,R1           IS THIS A COMMON REFERENCE
         BEQ       MTCOR5.3        BR IF COMMON REFERENCE
         ADMW      R6,DSCTBASE+MDSTORG  RELS ALWYS BIAS BY DSCT  1.3#05
MTCOR5.3 TRRM      R6,R6           ONLY 19-BIT ADDRESS ALLOWED
         TRC       R4,R4           FFF80003 MASK
         ANR       R4,R5           LEAVE ONLY OPCODE AND REG FIELD IN R5
         ADR       R6,R5           MERGE ADDRESS INTO INSTRUCTION
         LW        R1,MDSTNXT,X2       GET NEXT AVAIL ADDRESS    1.3#05
         STW       R5,0,R1         STORE THE DATA
         ADI       R1,1W           INCREMENT STORAGE ADDRESS
         BU        MTCOR6          BRANCH TO EXIT
         SPACE
MTC.ABS  EQU       $                                             1.3#05
         LW        R2,CURRBASE                                   1.3#05
         LW        R1,MDSTNXT,X2       STORAGE ADDRESS           1.3#05
         LNB       R4,MTCORCL3     PICK UP NO. OF ABSOLUTE BYTES
         ZR        R3              CLEAR INPUT INDEX
MTCOR10  LB        R5,MTCORCL2,R3  LOAD NEXT DATA BYTE
         STB       R5,0,R1         STORE DATA INTO PROGRAM
         ABR       R1,31           INCREMENT STORAGE POINTER
         ABR       R3,31           INCREMENT INPUT INDEX
         BIB       R4,MTCOR10      MOVE ALL ABSOLUTE DATA
*
MTCOR6   ANMW      R1,=X'FFFFFF'   SAVE 24 BITS
         CAMW      R1,MDSTLST,X2   COMPARE TO END OF ASSEM AREA  1.3#17
         BLE       MTCOR6.1        SKIP IF OK                    1.3#17
         LI        R5,E.PGMBND     SET ERROR CODE                1.3#17
         LI        R6,E.PGMBND     SET FOR FULL MESSAGE          1.3#17
         BL        MBERR           ISSUE MESSAGE  (NO RETURN)    1.3#17
MTCOR6.1 EQU       $                                             1.3#17
         STW       R1,MDSTNXT,X2       SAVE ADDR FOR NEXT WORD   1.3#05
         CAMW      R1,MDSTHST,X2       CMPR NEW ADDR TO PREV. HI
         BLE       MTCOR8
         STW       R1,MDSTHST,X2       RESET HIGHEST BOUND
MTCOR8   EQU       $
         LF        R0,MTCOR90
         TRSW      R0              RETURN
MTC.ERR  LNB       R5,MTC.LN1      REPORT DSECT BRANCH ERROR    ELST-32
         LA        R6,MTC.ER1                                   ELST-32
         BL        XTYPEF          PUT OUT MESSAGE              ELST-32
         BL        XABORT          AND ABORT                    ELST-32
         SPACE
MTC.ER1  DATAB     C' CATALOG<<FATAL>> BRANCH INSTRUCTION WITH' ELST-32
         DATAB     C' A DSECT TARGET ADDRESS.'                  ELST-32
MTC.LN1  DATAB     $-MTC.ER1                                    ELST-32
         SPACE                                                  ELST-32
MTCOR90  RES       1F              REGISTER SAVE AREA
         SPACE
MTCORCL2 RES       4W              DATA FROM CALLING PROGRAM
MTCORCL3 RES       1B              FOR ABS DATA, NO. BYTES IN MTCORCL2
         TITLE     MLINK    - SEARCH LINKBACK TABLE
************************************************************************
*
*                  MLINK
*
************************************************************************
*
*        SEARCH MODULE'S LINKBACK ENTRIES
*        CALL  R1 ADDRESS OF SYMTAB MODULE ENTRY
*              R5 LHW, OVERLAY LEVEL  RHW, OVERLAY SEQUENCE NUMBER
*        RETURN  R5 ZERO IF NOT FOUND
*
************************************************************************
MLINK    STF       R0,MLINK90
         LNH       R3,1H,R1
         BEQ       MLINK2          BR IF NO LINKBACK ENTRIES
MLINK1   SUI       R1,1W
         CAMW      R5,0,R1
         BEQ       MLINK3          BR IF ENTRY MATCHES
         BIB       R3,MLINK1
MLINK2   ZMW       MLINK90+5W      NO FIND INDICATOR
MLINK3   LF        R0,MLINK90
         TRSW      R0              RETURN
         SPACE
MLINK90  RES       1F              REGISTER SAVE AREA
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     MOBSC    - PROCESS OBJECT RECORDS
***********************************************************************
*
*                  MOBSC
*
***********************************************************************
*
*        PROCESS ASSEMBLER OBJECT RECORDS FROM MCBUF.
*        CONTROL IS TRANSFERRED TO THE
*        APPROPRIATE SUBROUTINE FOR PROCESSING EACH DATA RECORD TYPE. *
*                  CALL TYPE IN R5:  0 A PASS PROCESSING
*                                    1 B PASS PROCESSING
*                                    2 SYMTAB DATA PROCESSING
*
***********************************************************************
MOBSC    STF       R0,MOBSC90      SAVE REGS
         ABM       15,MXSEQ        INCREMENT SEQ. NO. EXPECTED
         LW        R5,MCBUF+1W     CARD SEQUENCE NUMBER
         SRL       R5,16           POSITION
*!!!!!!!!CAMH!!!!!!R5,MXSEQ!!!!!!!!COMPARE!WITH!EXPECTED!NO.!!!!S920470
         LH        R6,MXSEQ        GET EXPECTED SEQ. NUM        S920470
         ANMW      R6,=X'0000FFFF'  CLEAR UNUSED BITS           S920470
         CAR       R5,R6           COMPARE EXPECTED W/ INPUT    S920470
         BEQ       MOBSC1          BRANCH IF EQUAL
         TBM       XLIBEDCK,XFLGS  TEST IF PROCESSING LIBRARY REC. 0270
         BNS       MOBSC.1         IF NOT CONT. ERROR PROCCESSING  0270
         LI        R6,1            WANT LONGER ERROR MESSAGE       0270
         LW        R5,XLISH94      GET PREVIOUS STORED PROG. NAME  0270
         STW       R5,MPNAM        AND STORE IT FOR ERROR PROC.    0270
         LW        R5,XLISH94+1W   GET SECOND HALF                 0270
         STW       R5,MPNAM+1W                                     0270
MOBSC.1  EQU       $                                             1.3#10
         LI        R5,-9                                         1.3#10
         LA        R6,ERRLFC-1                                   1.3#10
         BL        XTYPEF                                        1.3#10
         LI        R5,E.OUTSEQ     OUT OF SEQ. MESSAGE
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
MOBSC1   LB        R5,MCBUF+1B     OBJECT BYTE COUNT
         BZ        MOBSC1.7
         STB       R5,MBCNT        SAVE
         TRN       R5,R5
         ZR        R4
         ZR        R1
MOBSC1.5 ADMB      R4,MCBUF+6B,R1  CHECKSUM RECORD
         ADI       R1,1            INCREMENT BUFFER INDEX
         BIB       R5,MOBSC1.5
         LB        R6,MCBUF+3B     EXTRACT CHECKSUM FROM RECORD
         SRLD      R6,8
         LB        R6,MCBUF+2B
         SLLD      R6,8
         CAR       R4,R6
         BEQ       MOBSC2          BRANCH IF CHECKSUM CORRECT
MOBSC1.7 ZR        R6              GET SHORT ERROR MESSAGE        0270
         TBM       XLIBEDCK,XFLGS  TEST IF PROCESSING LIBRARY REC. 0270
         BNS       MOBSC1.8        IF NOT CONT. ERROR PROCCESSING  0270
         LI        R6,1            WANT LONGER ERROR MESSAGE       0270
         LW        R5,XLISH94      GET PREVIOUS STORED PROG. NAME  0270
         STW       R5,MPNAM        AND STORE IT FOR ERROR PROC.    0270
         LW        R5,XLISH94+1W   GET SECOND HALF                 0270
         STW       R5,MPNAM+1W                                     0270
MOBSC1.8 EQU       $                                             1.3#10
         LI        R5,-9                                         1.3#10
         LA        R6,ERRLFC-1                                   1.3#10
         BL        XTYPEF                                        1.3#10
         LI        R5,E.CHKSUM     CHECKSUM ERROR MESSAGE
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
MOBSC2   LI        R5,6
         STB       R5,MBLKX        INITIALIZE OBJ REC INDEX
MOBSC3   LB        R1,MBLKX        NEW RECORD
         LB        R1,MCBUF,R1     OBTAIN RECORD TYPE
         SRL       R1,4            EXTRACT TYPE
         CI        R1,X'D'         EXTENDED LOADER CODE
         BEQ       MOBSC0          YES
         SLL       R1,2            POS AS WORD INDEX
         TBM       31,MOBSC90+5W   FIND PROCESSING TYPE FROM CALL
         BCT       1,MOBSC7        BRANCH IF B PASS
         TBM       30,MOBSC90+5W
         BS        MOBSC8          BRANCH IF SYMTAB DATA PROCESSING
         BL        *MOBSC92,R1     A PASS JUMP TABLE
MNOOP    EQU       $               NO OPERATION
MOBSC4   EQU       $
         BL        MXNNN           OBTAIN NNNN SUBFIELD
MOBSC5   ABR       R5,31           ADD 1 FOR CONTROL BYTE
MOBSC5.1 EQU       $
         ADMB      R5,MBLKX
         STB       R5,MBLKX        NEW BLOCK INDEX
MOBSC5.2 SUI       R5,6            6 BYTE HEADER                ETCM-32
         SUMB      R5,MBCNT
         BEQ       MOBSC6          BRANCH IF ENTIRE RECORD PROCESSED
         BGT       MOBSC1.7        BR IF BYTE COUNT NOT CORRECT
         TBM       MPEND,MFLGS     LAST RECORD FLAG
         BCT       1,MOBSC6        BRANCH IF LAST
         BU        MOBSC3          NEXT RECORD
*!MOBSC6!!!TBM!!!!!!!31,MOBSC90+5W!!!WHICH!PASS!ARE!WE!DOING?!!!PR11197
*!!!!!!!!!!BS!!!!!!!!MOBSC6.1!!!!!!!!SKIP!WRITE!TO!TEMP!IF!PASS!PR11197
MOBSC6   EQU       $                                            PR11197
         LW        R1,MOBSC90+5W   GET REQUEST TYPE             PR11197
         BNZ       MOBSC6.1        SKIP FOR ALL BUT PASS A      PR11197
         LA        R1,XTEMP        TEMP OBJECT FILE FCB ADDR    ETCM-32
         BL        BB.WRIT         WRITE MCBUF TO TEMP FILE     ETCM-32
MOBSC6.1 LF        R0,MOBSC90      RESTORE REGS                 ETCM-32
         TRSW      R0              RETURN
         SPACE     2
MOBSC7   BL        *MOBSC93,R1     B PASS JUMP TABLE
         BU        MOBSC4          FINISH PROCESSING ITEM
         SPACE
MOBSC8   BL        *MOBSC94,R1     SYMTAB DATA JUMP TABLE
         BU        MOBSC4          FINISH PROCESSING ITEM
         SPACE
MOBSC90  RES       1F              REG SAVE AREA
MOBSC92  EQU       $               A PASS JUMP TABLE
         ACW       MNOOP           0 ABS DATA
         ACW       M1POR           1 PGM ORIGIN
         ACW       MNOOP           2 ABS DATA, REP
         ACW       M1TAD           3 TRANS ADDR
         ACW       MNOOP           4 REL DATA
         ACW       M1PNM           5 PGM NAME
         ACW       MNOOP           6 REL DATA, REP
         ACW       M1XDF           7 EXT DEF
         ACW       MNOOP           8 FWD REF SB
         ACW       M1XRF           9 EXT REF
         ACW       M1CDF           A COMM DEF
         ACW       MNOOP           B COMM REF
         ACW       M1DPL           C DATAPOOL REFERENCE
         ACW       MILEG           D ESCAPE TO EXTENDED LOADER CODES
         ACW       M1COR           E COMM ORIG
         ACW       M1LST           F LAST
MOBSC93  EQU       $               B PASS JUMP TABLE
         ACW       M2ABD           0 ABS DATA
         ACW       M2POR           1 PGM ORIGIN
         ACW       M2ABR           2 ABS DATA, REP
         ACW       MNOOP           3 TRANS ADDR
         ACW       M2RLD           4 REL DATA
         ACW       M2PNM           5 PGM NAME                   ELST-33F
         ACW       M2RLR           6 REL DATA, REP
         ACW       M2XDF           7 EXT DEF
         ACW       M2FSB           8 FWD REF SB
         ACW       M2XRF           9 EXT REF
         ACW       M2CDF           A COMM DEF
         ACW       M2CRF           B COMM REF
         ACW       M2DPL           C DATAPOOL REFERENCE
         ACW       MILEG           D ESCAPE TO EXTENDED LOADER CODES
         ACW       M2COR           E COMM ORIG
         ACW       M1LST           F LAST
MOBSC94  EQU       $               SYMTAB DATA JUMP TABLE
         ACW       M3ABD           0 SYMTAB ABSOLUTE DATA
         ACW       MILEG           1
         ACW       MILEG           2
         ACW       MILEG           3
         ACW       MILEG           4
         ACW       M3PNM           5 SYMTAB SEGMENT NAME
         ACW       MILEG           6
         ACW       MILEG           7
         ACW       MILEG           8
         ACW       MILEG           9
         ACW       MILEG           A
         ACW       MILEG           B
         ACW       MILEG           C
         ACW       MILEG           D
         ACW       MILEG           E
         ACW       M1LST           F LAST
         SPACE
MOBSCREG RES       1F              A COMMON REG SAVE AREA FOR ALL
*                                  PROCESSING SUBROUTINES - A PASS,
*                                  B PASS, AND SYMTAB PROCESSING -
*                                  THESE SUBROUTINES CANNOT CALL EACH
*                                  OTHER
*
*        EXTENDED LOADER CODES
*
MOBSC0   LB        R1,MBLKX
         LB        R2,MCBUF+1B,R1  GET EXTENDED RECORD TYPE
         SLL       R2,2            POSITION AS A WORD INDEX
         TBM       31,MOBSC90+5W   FIND CORRECT TRANSFER TABLE
         BS        MOBSC0.2        B PASS
         TBM       30,MOBSC90+5W
         BS        MOBSC0.3        SYMTAB PASS
         BL        *MOBSE1,R2      DISPATCH PASS A
MOBSC0.1 EQU       $
         LB        R1,MBLKX
         LB        R5,MCBUF+2B,R1  GET SIZE OF RECORD TO UPDATE INDEX
         BU        MOBSC5.1        RETURN TO MAIN LOOP
         SPACE
MOBSC0.2 BL        *MOBSE2,R2      DISPATCH PASS B
         BU        MOBSC0.1        END OF RECORD PROCESSING
         SPACE
MOBSC0.3 BL        MILEG           ALL CODES ILLEGAL
         BU        MOBSC0.1        END OF RECORD PROCESSING
         SPACE
MOBSE1   EQU       $
         ACW       MILEG           0 UNASSN
         ACW       M1ESD           1 SECTION DEFINITION
         ACW       MOBSC0.1        2 SECTION ORIGIN
         ACW       MOBSC0.1        3 SECTION RELOCATABLE REFERENCE
         ACW       M1ESTA          4 SECTION TRANSFER ADDRESS
         ACW       M1ESED          5 SECTION EXTERNAL DEFINITION
         ACW       M1ESER          6 SECTION EXTERNAL REFERENCE
         ACW       MOBSC0.1        7 SECTION FORWARD STRINGBACK
         ACW       M1ECDF          8 LARGE COMMON DEF
         ACW       M1ECOR          9 LARGE COMMON ORIGIN
         ACW       MOBSC0.1        A LARGE COMMON REF
         ACW       M1SYMB          B SYMBOLIC DEBUG INFORMATION
         ACW       M1INFO          C MODULE INFORMATION           11005
         ACW       M1MDPR          D MULTIPLE DATAPOOL REFERENCE  11017
         ACW       M1SYMB          E NEW OBJ. FORMAT SYMDB INFO EOBJ-30
         ACW       MOBSC0.1        F BIASED ADDRESS CONSTANT    EBAC-33
MOBSE2   EQU       $               B PASS
         ACW       MILEG           0 UNASSN
         ACW       M2ESO.D         1 SECTION DEFINITION            21015
         ACW       M2ESO.D         2 SECTION ORIGIN                21015
         ACW       M2ESRR          3 SECTION RELOCATABLE REFERENCE
         ACW       MOBSC0.1        4 SECTION TRANSFER ADDRESS
         ACW       M2SXDF          5 SECTION EXTERNAL DEFINITION
         ACW       M2ESER          6 SECTION EXTERNAL REFERENCE
         ACW       M2ESFS          7 SECTION FORWARD STRINGBACK
         ACW       M2ECDF          8 LARGE COMMON DEF
         ACW       M2ECOR          9 LARGE COMMON ORIGIN
         ACW       M2ECRF          A LARGE COMMON REF
         ACW       M2SYMB          B              SYMBOLIC DEBUG SUPPORT
         ACW       M2INFO          C  MODULE INFORMATION          11005
         ACW       M2MDPR          D MULTIPLE DATAPOOL REFERENCE  11017
         ACW       M2NEWOBJ        E NEW OBJ. FORMAT SYMDB INFO EOBJ-30
         ACW       M2BACX          F BIASED ADDRESS CONSTANT    EBAC-33
         TITLE     MILEG    - UNDEFINED OBJECT RECORD
***********************************************************************
*
*                  MILEG
*
***********************************************************************
*
*        UNASSIGNED FUNCTION CODE ERROR EXIT
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
MILEG    LI        R5,E.ILLFNC     ILLEGAL FUNCTION
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
         TITLE     MXNNN    - EXTRACT 'XX' SUBFIELD FROM OBJ. REC.
***********************************************************************
*        MXNNN     - EXTRACTS THE 'NNNN' SUBFIELD FROM THE OBJECT
*                    BLOCK IN "MCBUF" AND INDEXED BY "MBLKX".
*
*        OUTPUTS:
*                  R1 = CURRENT VALUE OF "MBLKX" THE INDEX INTO "MCBUF"
*                  R5 = THE VALUE 'NNNN' IN THE RANGE 1 - 16.
***********************************************************************
         SPACE     2
MXNNN    LB        R1,MBLKX        IX TO CURRENT DATA BLOCK
         LB        R5,MCBUF,R1     OBTAIN BLOCK BYTE COUNT
         ANMW      R5,=X'F'        SAVE LENGTH OF RECORD NIBBLE.
         BNE       MXNNN1          A COUNT OF 0 MEANS
         LI        R5,16           16
MXNNN1   TRSW      R0              RETURN
         TITLE     MGETNAME - EXTRACT NAME FROM OBJECT RECORD
***********************************************************************
*
*        MGETNAME  - EXTRACT NAME AND N-BYTES FROM OBJECT RECORD.
*
*        INPUTS:
*                  R4    = NUMBER OF BYTES FOLLOWING NAME TO RETURN.
*
*        OUTPUTS:
*                  R6-R7 = LEFT JUSTIFIED ASCII NAME.
*                  R5    = N-BYTE NUMBER FOLLOWING NAME.
**********************************************************************
         SPACE 2
MGETNAME STF       R0,MSAVER       SAVE REGISTERS
         LW        R0,=C'    '     BLANK FILL RETURN VALUE.
         STW       R0,MSAVER+6W
         STW       R0,MSAVER+7W
         ZMW       MSAVER+5W       ZERO RETURN R5 (ADDRESS).
         BL        MXNNN           GET LENGTH OF THIS RECORD.
         SUR       R4,R5           SUBTRACT LENGTH OF N-BYTE FIELD.
         ZR        R2              INDEX FOR THE DESTINATION.
         TRN       R5,R5           GET NEGATIVE LENGTH OF NAME.
         BZ        MGET.3          ZERO LENGTH NAME.
MGET.1   ABR       R1,31           BUMP INDEX TO POINT TO NEXT CHARACTER
         LB        R0,MCBUF,X1     PICK UP CHARACTER.
         STB       R0,MSAVER+6W,X2 STORE NAME IN R6-R7 LEFT JUSTIFIED
         ABR       R2,31           POINT TO NEXT STORAGE POSITION.
         BIB       R5,MGET.1       PICK UP USER'S NAME.
MGET.3   TRN       R4,R2           NUMBER OF BYTES TO RETURN.
         BZ        MGET.5          EXIT IF NO VALUE IN RECORD.
MGET.4   ABR       R1,31           POINT TO NEXT BYTE IN OBJ RECORD
         LB        R5,MCBUF,X1     GET ONE BYTE OF ADDRESS
         STB       R5,MSAVER+5W+4,X2 STORE IN RETURN R5
         BIB       R2,MGET.4       COPY N-BYTES.
MGET.5   LF        R0,MSAVER
         TRSW      R0
         TITLE     M1POR    - PROGRAM ORIGIN
***********************************************************************
*
*                  M1POR
*
***********************************************************************
*
*        PROGRAM ORIGIN -1-  A PASS
*
***********************************************************************
M1POR    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LB        R1,MBLKX        IX TO DATA BLOCK
         LB        R4,MCBUF+3B,R1  EXTRACT 3 BYTE ADDRESS FIELD
         ZR        R5
         SRLD      R4,8
         LB        R4,MCBUF+2B,R1
         SRLD      R4,8
         LB        R4,MCBUF+1B,R1
         SRLD      R4,16
         ZBR       R5,8            CLEAR RELOCATABLE FLAG, IF SET
         BS        M1POR1          BRANCH IF ORIGIN RELOCATABLE
         LI        R5,E.ABSORG     ABSOLUTE ORIGIN
         BL        MBERR           EXIT WITH ERROR - NO RETURN   1.3#05
M1POR1   ADI       R5,3            ROUND ORIGIN UP TO WORD MULTIPLE
         SRL       R5,2
         SLL       R5,2
         STW       R5,MOBJC        LAST ORG IS OBJ CODE COUNT
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
         TITLE     M1TAD    - TRANSFER ADDRESS
***********************************************************************
*
*                  M1TAD
*
***********************************************************************
*
*        TRANSFER ADDRESS -3-  A PASS
*
***********************************************************************
M1TAD    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         ABM       31,M1.TADE      BUMP NUMBER OF TRANSFER ADDR ITEMS
         LW        R1,M1.TADE      GET TRAD COUNT               |84.1011
         CI        R1,1            DO WE HAVE ONE               |84.1011
         BLE       M1TAD1          CONTINUE IF NOT              |84.1011
         LW        R1,MMODW        ADDRESS OF MODULE ENTRY
         LD        R6,2W,R1        GET MODULE NAME
         LA        R3,M1TA.M1D     LOCATE IN MESSAGE            |84.1011
         BL        XST2            AND STORE                    |84.1011
         LD        R6,MPNAM        GET NAME OF CURRENT PROG     |84.1011
         LA        R3,M1TA.M3D     LOCATE                       |84.1011
         BL        XST2            AND STUFF                    |84.1011
*                                                               |84.1011
         TRR       R1,R5           WORKING MODULE TO R5         |84.1011
         NOP                       BOUNDING                     |84.1011
M1TAD0.1 EQU       $               SEARCH LOOP                  |84.1011
         SUI       R5,4W           BACK IT DOWN TO NEXT         |84.1011
         LW        R4,=X'88000000' LOOK FOR MODULES&PROGRAMS    |84.1011
         ZR        R7              ANY NAME                     |84.1011
         BL        MSSCH           S E A R C H                  |84.1011
         TRR       R5,R2           ANYTHING OUT THERE           |84.1011
         BZ        M1TAD0.2        FIX UP AND CONTINUE          |84.1011
         TBM       0,0W,X2         DID WE FIND A MODULE         |84.1011
         BS        M1TAD0.2        THEN FIX UP AND CONTINUE     |84.1011
         TBM       6,0W,X2         IS TRAD DEF'D HERE           |84.1011
         BNS       M1TAD0.1        KEEP SEARCHING               |84.1011
         LD        R6,2W,X2        ELSE GET PROGRAM NAME        |84.1011
         LA        R3,M1TA.M2D     LOCATE                       |84.1011
         BL        XST2            AND STUFF                    |84.1011
*                                                               |84.1011
         LNB       R5,M1TA.M1L                                  |84.1011
         LA        R6,M1TA.M1A                                  |84.1011
         BL        XTYPEF          ISSUE WARNING                |84.1011
         LNB       R5,M1TA.M2L                                  |84.1011
         LA        R6,M1TA.M2A                                  |84.1011
         BL        XTYPEF                                       |84.1011
         LNB       R5,M1TA.M3L                                  |84.1011
         LA        R6,M1TA.M3A                                  |84.1011
         BL        XTYPEF          PLUS ADDITIONAL INFO         |84.1011
         BU        M1TAD2          AND RETURN                   |84.1011
*                                                               |84.1011
M1TAD0.2 EQU       $      HERE IF UNEXPECTED SEARCH RESULTS     |84.1011
         LI        R1,1            INIT COUNT AGAIN             |84.1011
         STW       R1,M1.TADE                                   |84.1011
M1TAD1   LB        R1,MBLKX        OBTAIN IX
         LB        R4,MCBUF+3B,R1  EXTRACT
         SRLD      R4,8            3 BYTE
         LB        R4,MCBUF+2B,R1  ADDRESS
         SRLD      R4,8            FIELD
         LB        R4,MCBUF+1B,R1
         SRLD      R4,16           RIGHT JUSTIFY ADDRESS IN R5
         ZBR       R5,8            CLEAR RELOCATABLE FLAG, IF SET
         LW        R1,MSYMC        OBTAIN CURR SYMTAB CONT ENTRY SLOT
         SUI       R1,4W           OBTAIN PGM NAME ENTRY ADDR
*                                  ASSEMBLER RECS MUST BE OUTPUT IN
*                                  THE ORDER ADVERTISED
         SBM       6,0,R1
         ORMW      R5,1W,R1        OR LIBRARY FCB INDEX WITH XFER ADDR
         STW       R5,1W,R1        SAVE TRANS ADDR IN 2ND WORD  OF
*                                  PGM NAME ENTRY
         LW        R1,MMODW
         SBM       7,0,R1          FLAG MODULE ENTRY
M1TAD2   EQU       $                                            |84.1011
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
*
M1.TADE  DATAW     0               NUMBER OF TRANSFER ADDRESS ITEMS
M1TA.M1A DATAB     C' CATALOG(WARNING) MULTIPLE TRANSFER'       |84.1011
         DATAB     C' ADDRESSES IN LOAD MODULE:  '              |84.1011
M1TA.M1D REZ       8B              MODULE NAME                  |84.1011
         DATAB     C'.'                                         |84.1011
M1TA.M1L DATAB     $-M1TA.M1A                                   |84.1011
*                                                               |84.1011
M1TA.M2A DATAB     C'        ACTIVE TRANSFER ADDRESS IN'        |84.1011
         DATAB     C' PROGRAM: '                                |84.1011
M1TA.M2D REZ       8B              PROGRAM NAME (FROM MSSCH)    |84.1011
         DATAB     C'.'                                         |84.1011
M1TA.M2L DATAB     $-M1TA.M2A                                   |84.1011
*                                                               |84.1011
M1TA.M3A DATAB     C'               MULTIPLE DEFINED IN'        |84.1011
         DATAB     C' PROGRAM: '                                |84.1011
M1TA.M3D REZ       8B              PROGRAM NAME FROM MPNAM      |84.1011
         DATAB     C'.'                                         |84.1011
M1TA.M3L DATAB     $-M1TA.M3A                                   |84.1011
         BOUND     1W                                           |84.1011
*
*-----------------------------------------------------------------------
         TITLE     M1PNM    - PROGRAM NAME
***********************************************************************
*
*                  M1PNM
*
***********************************************************************
*
*        PROGRAM NAME -5-  A PASS
*
***********************************************************************
M1PNM    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         SBM       XNEWMOD,XFLGS   NEW MODULE FOR INFO RECORDS   11005
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS ?      12011
         BS        $+2W            IF YES, SKIP ABM               12011
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32
         ABM       31,XSYMENT      BUMP LOCAL DEBUG SYMBOLS BY 1  12011
         LI        R4,3            THREE BYTES FOLLOWING NAME.
         BL        MGETNAME        EXTRACT NAME OF PROGRAM.
         STD       R6,M1PNM91      SAVE PROGRAM NAME
         STD       R6,MPNAM        SAVE PROGRAM NAME.
         LW        R4,=X'000000FF'  OBJ. TYPE MASK              ELST-32
         TRR       R5,R3                                        ELST-32
         TRRM      R5,R5           BOUNDING FACTOR TO R5        ELST-32
         SRL       R3,8            SHIFT OUT BOUND FACTOR       ELST-32
         ZBR       R3,29           C TYPE OBJECT? (4)           CAID
         BNS       $+2W            NO...CHECK FOR OTHER TYPES   CAID
         SBM       MCOBJ,MFLAG3    SHOW C OBJECT READ           CAID
         CI        R3,3            IEEE TYPE OBJECT?            EIEE-33
         BNE       $+3W            NO...CHECK FOR OTHER TYPES   EIEE-33
         SBM       MIEOBJ,MFLAG3   SHOW IEEE OBJECT READ        EIEE-33
         BU        M1PNM.2         CONTINUE                     EIEE-33
         CI        R3,2            IS IT PURELY SECTIONED OBJ ? ELST-32
         BNE       M1PNM.1         CONTINUE IF NOT              ELST-32
         SBM       MPSOBJ,MFLAG2   ELSE FLAG AS PURELY SECTION  ELST-32
         BU        M1PNM.2         CONTINUE                     ELST-32
M1PNM.1  TRR       R3,R3           TEST FOR TYPE 0 OBJECT       ELST-32
         BNE       M1PNM.2         CONTINUE IF NOT              ELST-32
         SBM       MOSOBJ,MFLAG2   SET OLD STYLE OBJ. FLAG      ELST-32
M1PNM.2  EQU       $                                            ELST-32
         SRL       R5,3            MAKE BOUNDING DOUBLE WORD M
         TRR       R5,R5
         BNE       M1PNM2.5        BR IF BOUND GT 1W
         LI        R5,1B
M1PNM2.5 SLL       R5,3            PLACE ON DBL WD BOUNDARY
         CI        R5,33B
         BLT       M1PNM3          BOUND 32 OR LESS OK
         LI        R5,E.BOUND      GT 32 IS NOT. BOUND ERROR MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M1PNM3   LW        R1,MSYMC        CURR CONT ENTRY
         STB       R5,0+4B,R1      SAVE REQ'D BOUND IN 2ND CONT ENT WORD
         LD        R6,M1PNM91      SET CALL PARAMS
         ZR        R4
         ZR        R5              INIT 2ND WORD OF ENTRY        1.3#04
         TBM       6,0,R1
         BNS       M1PNM3.5        BR IF ELEMENT NOT FROM SYS SUB LIB
         LW        R4,MLIBL        LIBRARY LOCATION
         SRC       R4,16           POSITION FOR SYMTAB
         SRLD      R4,24
         SRL       R4,8
         SLLD      R4,24
         LW        R5,MLIBN        GET SUB-LIB INDEX             1.3#04
         SLL       R5,23           AND MOVE  TO BITS 0-6 (MOD 4) 1.3#04
M1PNM3.5 SBR       R4,4            PGM NAME ID
         BL        MSYMS           STORE PGM NAME ENTRY IN SYMTAB
         TBM       MLMDIR,MFLAG2   DIRECTIVES FROM LOAD MOD?    ETCM-32
         BS        VERIFY          VERIFY OBJECT IF SO          ETCM-32
         TBM       MDIRFIL,MFLAG2  DIRECTIVES FROM FILE?        ETCM-32
         BS        VERIFY          VERIFY OBJECT IF SO          ETCM-32
         BU        M1PNM.4         OTHERWISE RETURN             ETCM-32
VERIFY   TBM       MOPT5,MFLAG2    OBJECT CODE VERIFICATION ON? ETCM-32
         BS        M1PNM.4         BRANCH IF NOT                ETCM-32
         ZBM       MLOCF,MFLAG3    CLEAR FLAG FOR PNB           ERMS-34
         LW        R1,DIRPNV       LOAD PNB VECTOR              ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!M.LOC!!!!!DIRPNV,LIBRD!!!!GET!WORKING!DIRECTORY!RD!!!!!ERMS-34
         M.LOC     DIRPNV,LIBRD,CHKCNP   GET WORKING DIR RD     ERMS-34
         LW        R4,LIBRD+89W    GET AVAILABLE ENTRY COUNT    S910662
         BNE       VERIFY0         VERIFY OBJECT IF NON-ZERO    S910662
         LNB       R5,PNMSG.AL     OUTPUT MESSAGE IF NO ENTRIES S910662
         LA        R6,PNMSG.AA                                  S910662
         BL        XTYPEF                                       S910662
         LNB       R5,PNMSG.BL     OUTPUT SECOND PART           S910662
         LA        R6,PNMSG.BA                                  S910662
         BL        XTYPEF                                       S910662
         SBM       MOPT5,MFLAG2    TURN OFF OBJECT VERIFICATION S910662
         BU        M1PNM.4         RETURN                       S910662
VERIFY0  BL        COPYBUF                                      ETCM-32
         ZMH       SKIPNUM         CLEAR NUM OF TCM RECS SKIPED ETCM-32
         ZBM       CSIREC,CFLGS    CLEAR SI FILE FLAG           PR11087
         ZBM       CGOREC,CFLGS    CLEAR OBJECT FILE FLAG       PR11087
         TBM       XBLKSET,XFLGS   HAVE CALL BLOCKS BEEN INITED ETCM-32
         BS        VERIFY4         SKIP SET UP IF INITIALIZED   ETCM-32
         SBM       XBLKSET,XFLGS   CALL BLOCKS NOW SET UP       ETCM-32
         ZR        R7                                           ETCM-32
         M.ENVRMT                  CHECK IF WE'RE BATCHED       ETCM-32
         TBR       R7,0            ARE WE?                      ETCM-32
         BS        VERIFY2         NO...INTERACTIVE             S900575
         LI        R4,3            UT RRS WILL BE TYPE 3        S900575
         STB       R4,TCMRLST      SAVE IN RRS                  ETCM-32
         STB       R4,LIBRLST      IN LIBED BLOCK TOO           ETCM-32
         LI        R4,6            RRS LENGTH IS 6 WORDS        S900575
         STB       R4,TCMRLST+1B   SAVE IN RRS                  ETCM-32
         STB       R4,LIBRLST+1B   IN LIBED BLOCK ALSO          ETCM-32
         LI        R4,15           DEVICE WILL BE NULL          S900575
         STB       R4,TCMRLST+12B  SAVE IN ACTIVATION BLOCK     S900575
         STB       R4,LIBRLST+12B  IN LIBED BLOCK ALSO          S900575
*!!!!!!!!SBM!!!!!!!2,TCMRLST+2W!!!!TREAT!UT!AS!SLO!!!!!!!!!!!!!!S900575
*!!!!!!!!SBM!!!!!!!2,LIBRLST+2W!!!!IN!LIBED!BLOCK!TOO!!!!!!!!!!!S900575
         SBM       3,TCMPTSK       SHOW AS A BATCH TASK         ETCM-32
         SBM       3,LIBBLK        FOR LIBED TOO                ETCM-32
         LA        R4,TCMRLST+5W   GET ADDR OF FREE RRS SPACE   ETCM-32
         STW       R4,SRRSP        SAVE IN POINTER              ETCM-32
         LA        R4,LIBRLST+5W   SET UP POINTER FOR LIBED BLK ETCM-32
         STW       R4,LRRSP                                     ETCM-32
         BU        VERIFY4                                      ETCM-32
*!VERIFY1!!!M.INQUIRY!PNTERS,SLOLFC!!!!INQUIRE!ABOUT!SLO!ASSIGN!S900575
*!!!!!!!!LW!!!!!!!!R1,PNTERS+1W!!!!GET!FAT!ADDRESS!!!!!!!!!!!!!!S900575
*!!!!!!!!TBM!!!!!!!5,0,X1!!!!!!!!!!IS!IT!A!VOLUME!RESOURCE!!!!!!S900575
*!!!!!!!!BNS!!!!!!!VERIFY2!!!!!!!!!NO...LO!ASSIGNED!TO!UT!!!!!!!S900575
*!!!!!!!!LB!!!!!!!!R4,DFT.ACF,X1!!!GET!SYSTEM!FILE!FLAGS!!!!!!!!S900575
*!!!!!!!!ANMB!!!!!!R4,=X'07'!!!!!!!MASK!OFF!OTHER!JUNK!!!!!!!!!!S900575
*!!!!!!!!CI!!!!!!!!R4,3!!!!!!!!!!!!IS!IT!ASSIGNED!TO!SLO!!!!!!!!S900575
*!!!!!!!!BNE!!!!!!!VERIFY2!!!!!!!!!NO...LO!ASSIGNED!TO!UT!!!!!!!S900575
*!!!!!!!!LI!!!!!!!!R4,2!!!!!!!!!!!!LO!RRS!WILL!BE!TYPE!2!!!!!!!!S900575
*!!!!!!!!STB!!!!!!!R4,UTRS+4B!!!!!!PUT!IN!CALL!BLOCK!!!!!!!!!!!!S900575
*!!!!!!!!STB!!!!!!!R4,RLST+4B!!!!!!IN!LIBED!BLOCK!TOO!!!!!!!!!!!S900575
*!!!!!!!!ZMW!!!!!!!UTRS+2W!!!!!!!!!CLEAR!OUT!UT!LFC!!!!!!!!!!!!!S900575
*!!!!!!!!ZMW!!!!!!!RLST+2W!!!!!!!!!IN!LIBED!BLOCK!ALSO!!!!!!!!!!S900575
*!!!!!!!!SBM!!!!!!!2,UTRS+3W!!!!!!!TREAT!AS!SLO!!!!!!!!!!!!!!!!!S900575
*!!!!!!!!SBM!!!!!!!2,RLST+3W!!!!!!!IN!LIBED!BLOCK!ALSO!!!!!!!!!!S900575
VERIFY2  SBM       2,TCMPTSK       SHOW AS A TERMINAL TASK      ETCM-32
         SBM       2,LIBBLK        IN LIBED CALL BLOCK ALSO     ETCM-32
         LA        R4,TCMRLST+5W   GET ADDR OF RRS FREE SPACE   ETCM-32
         STW       R4,SRRSP        SAVE IN POINTER              ETCM-32
         LA        R4,LIBRLST+5W   FOR LIBED ALSO               ETCM-32
         STW       R4,LRRSP                                     ETCM-32
         ZMB       UTFCB           CLEAR HI BYTE OF UT LFC      ETCM-32
         M.INQUIRY PNTERS,UTFCB    INQUIRE ABOUT UT ASSIGNMENT  ETCM-32
         BS        VERIFY3      UT ASSIGNED TO NULL IF ERRORS   ETCM-32
         LW        R1,PNTERS+2W    GET UDT ADDRESS              ETCM-32
         LB        R4,UDT.DTC,X1   GET DEVICE TYPE CODE         ETCM-32
         SBR       R4,24           SHOW DEVICE TYPE SUPPLIED    ETCM-32
         STB       R4,TCMRLST+12B  SAVE IN RRS                  ETCM-32
         STB       R4,LIBRLST+12B  IN BOTH ACTIVATION BLOCKS    ETCM-32
         LB        R4,UDT.CHAN,X1  GET CHANNEL NUMBER           ETCM-32
         SBR       R4,24           SHOW CHANNEL NUM SUPPLIED    ETCM-32
         STB       R4,TCMRLST+14B  SAVE IN RRS                  ETCM-32
         STB       R4,LIBRLST+14B  IN BOTH CALL BLOCKS          ETCM-32
         LB        R4,UDT.SUBA,X1  GET SUB CHANNEL NUMBER       ETCM-32
         STB       R4,TCMRLST+15B  STORE IN RRS ENTRIES         ETCM-32
         STB       R4,LIBRLST+15B                               ETCM-32
         LI        R4,3            UT RRS WILL BE TYPE 3        ETCM-32
         STB       R4,TCMRLST      SAVE IN RRS                  ETCM-32
         STB       R4,LIBRLST      IN LIBED BLOCK ALSO          ETCM-32
         LI        R4,6            LENGTH OF RRS IS 6 WORDS     ETCM-32
         STB       R4,TCMRLST+1B   SAVE IN RRS                  ETCM-32
         STB       R4,LIBRLST+1B   IN LIBED BLOCK TOO           ETCM-32
         BU        VERIFY4         CONTINUE                     ETCM-32
VERIFY3  LI        R4,3            UT RRS WILL BE TYPE 3        ETCM-32
         STB       R4,TCMRLST      SAVE IN RRS ENTRIES          ETCM-32
         STB       R4,LIBRLST                                   ETCM-32
         LI        R4,6            LENGTH OF RRS IS 6 WORDS     ETCM-32
         STB       R4,TCMRLST+1B   SAVE IN RRS ENTRIES          ETCM-32
         STB       R4,LIBRLST+1B                                ETCM-32
         LI        R4,15           DEVICE TYPE WILL BE NULL     ETCM-32
         STB       R4,TCMRLST+12B  SAVE IN RRS ENTRIES          ETCM-32
         STB       R4,LIBRLST+12B                               ETCM-32
VERIFY4  LW        R1,MOBSCREG+1W  GET MCBUF INDEX              ETCM-32
         SRL       R1,2            BACK TO BYTE COUNT           ETCM-32
         ADI       R1,1            POSITION TO LENGTH           ETCM-32
         LB        R4,MCBUF,X1     NAME LENGTH                  ETCM-32
         ANMB      R4,=X'0F'                                    ETCM-32
         ADI       R4,1                                         ETCM-32
         ADR       R4,R1      R1 POINTER TO NEXT MCBUF RECORD   ETCM-32
         LB        R4,MCBUF,X1                                  ETCM-32
         CI        R4,X'D0'        DATE/TIME RECORD             ETCM-32
         BNE       M1PNM.4         NO...FORGET VERIFICATION     ETCM-32
         LB        R4,MCBUF+1B,X1  INFO SUB-TYPE?               ETCM-32
         CI        R4,X'0C'                                     ETCM-32
         BNE       M1PNM.4         NO...FORGET VERIFICATION     ETCM-32
         ADI       R1,4            POSITION TO DATA             ETCM-32
         ZR        R3                                           ETCM-32
PNAME.1  CI        R3,16           ALL DONE?                    ETCM-32
         BEQ       PNAME.2                                      ETCM-32
         LB        R4,MCBUF,X1     GET TIME/DATE INTO TCMDATE   ETCM-32
         STB       R4,TCMDATE,X3                                ETCM-32
         ADI       R3,1                                         ETCM-32
         ADI       R1,1                                         ETCM-32
         BU        PNAME.1                                      ETCM-32
PNAME.2  LB        R3,MBCNT        GET LENGTH OF MCBUF          ETCM-32
         SUR       R1,R3           ALL DONE WITH MCBUF?         ETCM-32
         BGT       PNAME.3         NO...KEEP GOING              ETCM-32
         BL        FILBUF          YES...FILL MCBUF WITH OBJECT ETCM-32
PNAME.3  LB        R4,MCBUF,X1     GET OBJECT BYTE              ETCM-32
         CI        R4,X'D2'        TYPE 2 RECORD                ETCM-32
         BNE       SKIPCHK         NO...RETURN                  ETCM-32
         ADI       R1,2            POSITION TO LENGTH           ETCM-32
         LB        R4,MCBUF,X1     GET LENGTH                   ETCM-32
         SUI       R4,20           SUBTRACT OUT FIXED LENGTH    ETCM-32
         STB       R4,TCMPROC      SAVE PATHNAME LENGTH         ETCM-32
         TBM       XLIBEDCK,XFLGS  OBJECT FROM LIBRARY          ETCM-32
         BNS       $+3W            BRANCH IF NOT                ETCM-32
         ADI       R1,10           BUMP POINTER PAST OPTIONS    ETCM-32
         BU        PNAME.7      GET NUMBER OF TYPE 3 RECORDS    ETCM-32
         ADI       R1,2                                         ETCM-32
         ZR        R3                                           ETCM-32
PNAME.4  CI        R3,4            DONE WITH OPTION WORD 1      ETCM-32
         BEQ       PNAME.5         YES...GET WORD 2             ETCM-32
         LB        R4,MCBUF,X1     GET BYTE                     ETCM-32
         STB       R4,TCMOPT,X3    SAVE IN ACTIVATION BLOCK     ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R3,1                                         ETCM-32
         BU        PNAME.4         CONTINUE                     ETCM-32
PNAME.5  SBM       31,TCMOPT       TURN LISTINGS OFF            ETCM-32
         SBM       29,TCMOPT       SET OPTION 3                 ETCM-32
         SBM       28,TCMOPT       SET OPTION 4                 ETCM-32
         ZR        R3                                           ETCM-32
PNAME.6  CI        R3,4            DONE WITH OPTION WORD 2?     ETCM-32
         BEQ       PNAME.7         YES...CONTINUE               ETCM-32
         LB        R4,MCBUF,X1     GET BYTE                     ETCM-32
         STB       R4,TCMOPT2,X3   SAVE BYTE IN ACTIVATION BLK  ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R3,1                                         ETCM-32
         BU        PNAME.6                                      ETCM-32
PNAME.7  ADI       R1,5            SKIP TASK REVISION LEVEL     ETCM-32
         LB        R4,MCBUF,X1     NUM OF TYPE 3 PROCESSOR RECS ETCM-32
         STB       R4,TCMRNUM      SAVE FOR LATER               ETCM-32
         ADI       R1,1                                         ETCM-32
         LB        R4,MCBUF,X1     NUM OF TYPE 3 INCLUDE RECS   ETCM-32
         STB       R4,INCLCNT      SAVE FOR LATER               ETCM-32
         ADI       R1,1                                         ETCM-32
         LB        R4,MCBUF,X1     SECOND BYTE                  ETCM-32
         STB       R4,INCLCNT+1B                                ETCM-32
         ADI       R1,1                                         ETCM-32
         TBM       XLIBEDCK,XFLGS  OBJECT FROM LIBRARY?         ETCM-32
         BNS       $+3W            PROCESS PATHNAME IF NOT      ETCM-32
         ADMB      R1,TCMPROC      ADJUST PNTR BY PATH LENGTH   ETCM-32
         BU        PNAME.B         SKIP PATHNAME PROCESSING     ETCM-32
         ZR        R3                                           ETCM-32
PNAME.A  CAMB      R3,TCMPROC      DONE WITH PATHNAME           ETCM-32
         BEQ       PNAME.B         GO PROCESS TYPE 3 RECORDS    ETCM-32
         LB        R4,MCBUF,X1     GET BYTE                     ETCM-32
         STB       R4,PATHLOC,X3   SAVE IN PATHNAME VECTOR      ETCM-32
         ADI       R3,1            ADJUST POINTERS              ETCM-32
         ADI       R1,1                                         ETCM-32
         BU        PNAME.A                                      ETCM-32
PNAME.B  LH        R7,INCLCNT      GET NUMBER OF INCLUDE FILES  ETCM-32
         ANMW      R7,=X'0000FFFF' UNSIGNED                     ETCM-32
         ADMB      R7,TCMRNUM      ADD NUMBER OF PROCESSOR RRS' ETCM-32
         LW        R2,SRRSP        ADDR OF FREE RRS SPACE       ETCM-32
         ZBM       XOUTDAT,XFLGS   CLEAR OUT OF DATE FLAG       ETCM-32
PNAME.B1 TRR       R7,R7           ANY MORE TYPE 3 RECORDS?     ETCM-32
         BZ        PNM.5           NO...REBUILD IF NECESSARY    ETCM-32
         LB        R6,MBCNT        CURRENT MCBUF LENGTH         ETCM-32
         SUR       R1,R6           ALL DONE WITH THIS OBJECT    ETCM-32
         BGT       $+2W            CONTINUE IF NOT              ETCM-32
         BL        FILBUF          FILL MCBUF FROM OBJECT FILE  ETCM-32
         LB        R4,MCBUF,X1     GET BYTE                     ETCM-32
         CI        R4,X'D3'        TYPE 3 RECORD?               ETCM-32
         BNE       SKIPCHK         RETURN IF NOT                ETCM-32
         ADI       R1,2                                         ETCM-32
         LB        R3,MCBUF,X1     RECORD LENGTH                ETCM-32
         SUI       R3,20           SUBTRACT OFF FIXED LENGTH    ETCM-32
         STB       R3,OBJPNV       SAVE PATHNAME LENGTH         ETCM-32
         ZBM       XINCRRS,XFLGS   CLEAR INCLUDE FILE FLAG      ETCM-32
         LB        R4,MCBUF+1B,X1  GET FLAG BYTE                ETCM-32
         BZ        $+4W            IF ZERO IT'S NOT AN INCLUDE  ETCM-32
         SBM       XINCRRS,XFLGS   SHOW AS AN INCLUDE RECORD    ETCM-32
         ADI       R1,18           ADJUST BUFFER POINTER        ETCM-32
         BU        PNAME.F         GET FILE PATHNAME            ETCM-32
         ADI       R1,2                                         ETCM-32
         LB        R5,MCBUF+1B,X1  GET FIRST BYTE OF LFC        ETCM-32
         SRC       R5,8            POSITION IT                  ETCM-32
         SLLD      R4,8                                         ETCM-32
         LB        R5,MCBUF+2B,X1  SECOND BYTE                  ETCM-32
         SRC       R5,8                                         ETCM-32
         SLLD      R4,8                                         ETCM-32
         LB        R5,MCBUF+3B,X1  THIRD BYTE                   ETCM-32
         SRC       R5,8                                         ETCM-32
         SLLD      R4,8                                         ETCM-32
         BL        CHKLFC          IS IT A SOURCE FILE LFC?     ETCM-32
         TBM       XLIBEDCK,XFLGS  OBJECT FROM LIBRARY?         ETCM-32
         BS        PNM.3           SKIP RRS INFO IF SO          ETCM-32
         TBM       XLOLFC,XFLGS    LO RRS RECORD?               ETCM-32
         BS        PNM.3           SKIP RRS INFO IF SO          ETCM-32
         BU        PNM.3B          GET RRS INFO IF NOT          ETCM-32
PNM.3    ADI       R1,16           MOVE MCBUF POINTER PAST RRS  ETCM-32
         BU        PNAME.F         SKIP TO FILE NAME PROCESSING ETCM-32
PNM.3B   ZR        R3                                           ETCM-32
PNAME.E  CI        R3,16           DONE WITH FIXED RRS FIELDS   ETCM-32
         BEQ       PNAME.F         YES                          ETCM-32
         LB        R4,MCBUF,X1     GET BYTE                     ETCM-32
         STB       R4,0,X2         STORE IN RRS BUFFER          ETCM-32
         CI        R3,5            PROCESSING RRS LENGTH        PR11209
         BNE       $+2W            NO...CONTINUE                PR11209
         STW       R2,LENPTR       YES...SAVE ADDRESS FOR LATER PR11209
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         ADI       R3,1                                         ETCM-32
         BU        PNAME.E                                      ETCM-32
PNAME.F  LNB       R6,OBJPNV       NEGATIVE PATHNAME LENGTH     ETCM-32
         ZR        R3                                           ETCM-32
PNM.1    LB        R4,MCBUF,X1     GET BYTE                     ETCM-32
         TBM       XLIBEDCK,XFLGS  OBJECT FROM LIBRARY          ETCM-32
         BS        PNM.2           DON'T SAVE IN RRS BUFF IF SO ETCM-32
         TBM       XINCRRS,XFLGS   INCLUDE FILE RECORD          ETCM-32
         BS        PNM.2           DON'T SAVE IN RRS BUFF IF SO ETCM-32
         TBM       XLOLFC,XFLGS    LO FILE RECORD?              ETCM-32
         BS        PNM.2           DON'T SAVE IN RRS BUFF IF SO ETCM-32
         STB       R4,0,X2         STORE BYTE IN RRS BUFFER     ETCM-32
         ADI       R2,1            ADJUST RRS BUFFER POINTER    ETCM-32
PNM.2    STB       R4,RRSBUF,X3    SAVE IN PATHNAME VECTOR ALSO ETCM-32
         TBM       XOBJLFC,XFLGS   OBJECT FILE RECORD           ETCM-32
         BNS       $+2W            NEXT BYTE IF NOT             ETCM-32
         STB       R4,PERMPATH,X3  SAVE OBJECT PATHNAME 4 LATER ETCM-32
         TBM       XSILFC,XFLGS    SI SOURCE FILE RECORD?       ETCM-32
         BNS       $+2W            NEXT BYTE IF NOT             ETCM-32
         STB       R4,SRCPATH,X3   SAVE SOURCE FILE NAME        ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R3,1                                         ETCM-32
         BIB       R6,PNM.1        CONTIUNE                     ETCM-32
         ZBM       XOBJLFC,XFLGS   CLEAR OBJECT FILE FLAG       ETCM-32
         ZBM       XSILFC,XFLGS    CLEAR SI FILE FLAG           ETCM-32
         ZBM       XLOLFC,XFLGS    CLEAR LO FILE FLAG           ETCM-32
         TBM       XSRCLFC,XFLGS   WAS THIS A SOURCE FILE REC   ETCM-32
         BS        PNM.2B          VERIFY SOURCE AGAINST OBJECT ETCM-32
         TBM       XINCRRS,XFLGS   WAS THIS AN INCLUDE FILE REC ETCM-32
         BNS       PNM.4           NEXT RECORD IF NOT           ETCM-32
PNM.2B   STW       R1,MCPNTR       SAVE POINTERS                ETCM-32
         STW       R7,RNUM                                      ETCM-32
         STW       R2,ACTVPTR                                   ETCM-32
         LW        R1,OBJPNV       GET PATHNAME VECTOR          ETCM-32
         SBM       MLOCF,MFLAG3    SET FLAG FOR PATHNAME STRING ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!LA!!!!!!!!R6,LIBRD!!!!!!!!RD!BUFFER!ADDRESS!!!!!!!!!!!!ERMS-34
*!!!!!!!!ZR!!!!!!!!R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!SVC!!!!!!!2,X'2C'!!!!!!!!!M.LOC!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!TRR!!!!!!!R7,R7!!!!!!!!!!!CHECK!STATUS!!!!!!!!!!!!!!!!!ERMS-34
         M.LOC     OBJPNV,LIBRD,CHKCNP    LOCATE FILE           ERMS-34
         LH        R7,CHKCNP+5H    LOAD RETURN STATUS           ERMS-34
         BEQ       PNM.2C          CONTINUE IF OK               ETCM-32
*
         TBM       MOPT8,MFLAG3    DID WE SET AUDIT             C011-32
         BNS       PNM.2D          SKIP ERROR MESSAGE IF NOT    C011-32
         TBM       XLIBEDCK,XFLGS   ARE WE DOING LIBS           C011-32
         BNS       PNM.2B1         REPORT IF NOT                C011-32
         LW        R5,ERRLFC+1W    GET LAST ACTIVE LFC          C011-32
         CAMW      R5,=C' LIS'     IS IT THE SYSTEM LIB         C011-32
         BEQ       PNM.2D          DON'T ERROR MESSAGE          C011-32
PNM.2B1  EQU       $               CONTINUE WITH ERROR          C011-32
*
         ZR        R2                                           ETCM-32
         LI        R5,G' '         BLANK OUT NAME AREA IN MSG   ETCM-32
PNM.2G   CI        R2,54                                        ETCM-32
         BEQ       PNM.2H                                       ETCM-32
         STB       R5,PNMSG.1N,X2                               ETCM-32
         ADI       R2,1                                         ETCM-32
         BU        PNM.2G                                       ETCM-32
PNM.2H   ZR        R2                                           ETCM-32
         LB        R7,OBJPNV       GET FILE NAME LENGTH         ETCM-32
         LW        R1,OBJPNV       GET FILE  NAME ADDRESS       ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
PNM.2E   CI        R7,0            DONE WITH NAME               ETCM-32
         BEQ       PNM.2F          YES...BRANCH                 ETCM-32
         LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         STB       R5,PNMSG.1N,X2  PUT IN MESSAGE               ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R7,1                                         ETCM-32
         BU        PNM.2E          NEXT BYTE                    ETCM-32
PNM.2F   LNB       R5,PNMSG.1L     MESSAGE LENGTH               ETCM-32
         LA        R6,PNMSG.1A     MESSAGE ADDRESS              ETCM-32
*!!!!!!!!BL!!!!!!!!XTYPEF!!!!!!!!!!PUT!OUT!MESSAGE!!!!!!!!!!!!!!ETCM-32!
         BL        XTYPE           PUT OUT MEESSAGE             C011-32
         LNB       R5,PNMSG.2L     SECOND HALF LENGTH           ETCM-32
         LA        R6,PNMSG.2A     SECOND HALF ADDRESS          ETCM-32
*!!!!!!!!BL!!!!!!!!XTYPEF!!!!!!!!!!PUT!OUT!SECOND!HALF!!!!!!!!!!ETCM-32!
         BL        XTYPE           PUT OUT MEESSAGE             C011-32
         BU        PNM.2D          NEXT RRS                     ETCM-32
PNM.2C   LW        R6,LIBRD+RD.CHDAT  GET LAST CHANGED DATE     ETCM-32
         STW       R6,FILDATE       STORE FOR LATER             ETCM-32
         LW        R6,LIBRD+RD.CHTIM  GET LAST CHANGED TIME     ETCM-32
         STW       R6,FILDATE+1W    STORE FOR LATER             ETCM-32
         LA        R1,FILDATE       TIME/DATE BUFFER ADDRESS    ETCM-32
         ORMW      R1,=X'2000000'                               ETCM-32
         LA        R2,CHNGDATE     CONVERTED TIME/DATE BUFFER   ETCM-32
         SVC       2,X'51'         CONVERT TIME TO ASCII        ETCM-32
         LW        R6,CHNGDATE+3W  GET LAST WORD OF CHNGDATE    C010-32
         SRL       R6,16           CLEAR OUT LAST BYTE OF TIME  C010-32
         SLL       R6,16                                        C010-32
         ORMW      R6,=X'00003030'  PUT BACK ASCII ZEROS        C010-32
         STW       R6,CHNGDATE+3W  STORE BACK IN CHNGDATE       C010-32
         BL        CHKDATE         CHECK SOURCE/OBJECT DATES    ETCM-32
PNM.2D   LW        R1,MCPNTR       RESTORE POINTERS             ETCM-32
         LW        R7,RNUM                                      ETCM-32
         LW        R2,ACTVPTR                                   ETCM-32
PNM.4    SUI       R7,1            ONE TYPE 3 RECORD PROCESSED  ETCM-32
         TRR       R2,R5           SAVE ACTIVATION BLOCK ADDR   PR11209
         LI        R4,8        DBL DBL WORD BOUND RRS BUFFER    PR11209
         BL        MXBOUND         BOUND RRS BUFF FOR NEXT REC  ETCM-32
         TBM       XLIBEDCK,XFLGS  OBJECT FROM LIBRARY?         PR11209
         BS        PNAME.B1        NEXT RECORD IF SO            PR11209
         TRR       R2,R6           NEXT BUFFER ADDRESS TO R6    PR11209
         SUR       R5,R6           COMPUTE DIFFERENCE           PR11209
         SRL       R6,2            CONVERT TO WORD COUNT        PR11209
         LW        R3,LENPTR       ADDRESS OF RRS LENGTH        PR11209
         ARMB      R6,0,X3         ADD TO CURRENT RRS LENGTH    PR11209
         BU        PNAME.B1        NEXT TYPE 3                  ETCM-32
PNM.5    STW       R1,MCPNTR                                    ETCM-32
         SUMW      R2,TCMOPT+2W    COMPUTE ENDING ADDRESS       ETCM-32
         STH       R2,TCMRSIZ      SAVE SIZE OF RRS ENTRIES     ETCM-32
         ABM       15,TCMPTSK      BUMP RRS COUNT FOR UT RRS    ETCM-32
         ABM       15,TCMPTSK      BUMP RRS COUNT FOR LO RRS    ETCM-32
         TBM       XOUTDAT,XFLGS   SOURCE/INCLUDE OUT OF DATE?  ETCM-32
         BNS       SKIPCHK         RETURN                       ETCM-32
         TBM       XLIBEDCK,XFLGS    OBJECT FROM LIBRARY?       PR11087
         BS        LIB.02          UPDATE LIBRARY IF SO         PR11087
         TBM       CSIREC,CFLGS    SOURCE FILE ASSIGNED         PR11087
         BNS       LIB.00          NO...DON'T UPDATE            PR11087
         TBM       CGOREC,CFLGS    OBJECT FILE ASSIGNED         PR11087
         BNS       LIB.00          NO...DON'T UPDATE            PR11087
         BU        LIB.01          CONTINUE IF BOTH ASSIGNED    PR11087
LIB.00   LNB       R5,PNMSG.8L     MESSAGE LENGTH               PR11087
         LA        R6,PNMSG.8A     MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,PNMSG.9L     SECOND HALF                  PR11087
         LA        R6,PNMSG.9A                                  PR11087
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         BU        SKIPCHK         CONTINUE                     PR11087
LIB.01   TBM       XLIBEDCK,XFLGS  OBJECT FROM LIBRARY          ETCM-32
         BNS       OBJ.B           UPDATE OBJECT FILE IF NOT    ETCM-32
LIB.02   LW        R2,MLIBN        GET LFC TABLE INDEX          ETCM-32
         LB        R5,LT.LIBS,X2   GET ENTRY TYPE               ETCM-32
         CI        R5,2            DOES IT HAVE AN FCB?         ETCM-32
         BEQ       LIB.0           GET FCB ADDRESS IF SO        ETCM-32
         LW        R1,LT.LIBS,X2   LOAD LIBRARY LFC             ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
         STW       R1,GPFCB1       SAVE LFC IN FCB              ETCM-32
         STW       R1,ACTLIB       SAVE FOR LATER               C014-32
         LA        R5,GPFCB1       SET UP R5 FOR LATER DEASSIGN ETCM-32
         BU        LIB.1           GO GET LIBRARY FILE PATHNAME ETCM-32
LIB.0    LW        R4,=X'00FFFFFF' ADDRESS MASK                 ETCM-32
         LMW       R1,LT.LIBS,X2   GET LIBRARY FILE FCB ADDRESS ETCM-32
         LMW       R5,0,X1         AND GET LFC                  C014-32
         STW       R5,ACTLIB       SAVE FOR LATER               C014-32
         TRR       R1,R5           SAVE ADDRESS FOR LATER       ETCM-32
LIB.1    LW        R4,LDPATH       PLACE TO PUT PATHNAME        ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'2F'         M.PNAM                       ETCM-32
         TRR       R5,R1                                        ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'53'         DEASSIGN LIBRARY FILE        ETCM-32
         LW        R1,LRRSP        LOAD POINTER TO RRS SPACE    ETCM-32
         TRR       R4,R5           PATHNAME VECTOR TO R5        ETCM-32
         ZR        R4                                           ETCM-32
         SLLD      R4,8            PATHNAME LENGTH TO R4        ETCM-32
         STB       R4,6B,X1        SAVE LENGTH IN CALL BLOCK    ETCM-32
         TRR       R4,R6           SAVE LENGTH FOR LATER        ETCM-32
         ADI       R6,16           ADD FIXED LENGTH STUFF       ETCM-32
         ZR        R7                                           ETCM-32
         SRLD      R6,2            CONVERT TO WORD COUNT        ETCM-32
         CI        R7,0            ANY REMAINDER                ETCM-32
         BEQ       $+2W            SKIP IF SO                   ETCM-32
         ADI       R6,1            ADD IN ANOTHER WORD          ETCM-32
         TBR       R6,31           IS ADDRESS ODD?              PR11209
         BNS       $+2W            CONTINUE IF NOT              PR11209
         ADI       R6,1            BUMP LENGTH                  PR11209
         TBR       R6,29           IS ADDRESS ON A DW BOUNDARY  PR11209
         BNS       $+2W            CONTINUE IF SO               PR11209
         ADI       R6,1            BUMP LENGTH                  PR11209
         STB       R6,5B,X1        SAVE LENGTH IN CALL BLOCK    ETCM-32
         SRL       R5,8            PATHNAME ADDRESS IN R5       ETCM-32
         TRR       R5,R2           SAVE FOR LATER               ETCM-32
         LW        R5,=G'LIB'      GET LIB LFC                  ETCM-32
         STW       R5,0,X1         PUT IN CALL BLOCK            ETCM-32
         LI        R5,1            TPYE 1 RRS                   ETCM-32
         STB       R5,4B,X1        SAVE IN CALL BLOCK           ETCM-32
         LW        R3,LRRSP        ADDRESS OF RRS BUFFER        ETCM-32
         ADI       R3,16           BUMP POINTER TO PATHNAME     ETCM-32
LIBUP1   CI        R4,0            DONE WITH PATHANME?          ETCM-32
         BEQ       LIBUP2          CONTINUE IF SO               ETCM-32
         LB        R5,0,X2         GET BYTE OF PATHNAME         ETCM-32
         STB       R5,0,X3         STORE IN CALL BUFF           ETCM-32
         ADI       R3,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R4,1                                         ETCM-32
         BU        LIBUP1          NEXT BYTE                    ETCM-32
LIBUP2   LB        R2,5B,X1        GET LIBRARY RRS LENGTH       ETCM-32
         SLL       R2,2            CONVERT TO BYTE COUNT        ETCM-32
         LW        R5,LRRSP        START ADDRESS OF RRS BUFFER  ETCM-32
         ADR       R5,R2           R2 POINTS TO NEXT ENTRY      ETCM-32
         LW        R3,MLIBN        GET LFC TABLE INDEX          ETCM-32
         LB        R5,LT.DIRS,X3   GET DIRECTORY ENTRY TYPE     ETCM-32
         CI        R5,4            IS IT IN MEMORY?             ETCM-32
         BNE       LIBUP2.1        GET LFC FROM TABLE IF NOT    ETCM-32
         LW        R3,LT.DIRS,R3   GET ABD ADDRESS              ETCM-32
         ANMW      R3,=X'00FFFFFF'                              ETCM-32
         LW        R1,2W,X3        GET DIRECTORY FILE LFC       ETCM-32
         BU        LIBUP3          DEASSIGN DIRECTORY FILE      ETCM-32
LIBUP2.1 LW        R1,LT.DIRS,X3   GET DIRECTORY FILE LFC       ETCM-32
LIBUP3   ANMW      R1,=X'00FFFFFF'                              ETCM-32
         TRR       R1,R5           SAVE LFC FOR LATER           ETCM-32
         STW       R5,ACTDIR       SAVE LFC FOR ASSIGN          C014-32
         LW        R4,LDPATH       PATHNAME BUFFER              ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'2F'         M.PNAM                       ETCM-32
         STW       R5,GPFCB2       STORE LFC IN FCB             ETCM-32
         LA        R1,GPFCB2       GENERAL PURPOSE FCB ADDR     ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'53'         DEASSIGN DIRECTORY FILE      ETCM-32
         TRR       R4,R5           PATHNAME VECTOR TO R5        ETCM-32
         ZR        R4                                           ETCM-32
         SLLD      R4,8            PATHNAME LENGTH TO R4        ETCM-32
         SRL       R5,8            PATHNAME ADDRESS TO R5       ETCM-32
         TRR       R5,R3           MOVE ADDRESS TO R3           ETCM-32
         STB       R4,6B,X2        SAVE LENGTH IN CALL BLOCK    ETCM-32
         TRR       R4,R6           MOVE LENGTH TO R6            ETCM-32
         ADI       R6,16           ADD IN FIXED LENGTH STUFF    ETCM-32
         ZR        R7                                           ETCM-32
         SRLD      R6,2            CONVERT TO WORD COUNT        ETCM-32
         CI        R7,0            ANY REMAINDER                ETCM-32
         BEQ       $+2W            SKIP IF NOT                  ETCM-32
         ADI       R6,1            ADD IN ANOTHER WORD          ETCM-32
         TBR       R6,31           IS ADDRESS ODD?              PR11209
         BNS       $+2W            CONTINUE IF NOT              PR11209
         ADI       R6,1            BUMP LENGTH                  PR11209
         TBR       R6,29           IS ADDRESS DW BOUNDED        PR11209
         BNS       $+2W            CONTINUE IF SO               PR11209
         ADI       R6,1            BUMP LENGTH                  PR11209
         STB       R6,5B,X2        SAVE RRS LENGTH IN CALL BLOCKETCM-32
         LW        R5,=G'DIR'      GET DIR LFC                  ETCM-32
         STW       R5,0,X2         STORE IN CALL BLOCK          ETCM-32
         LI        R5,1            TYPE ONE RRS                 ETCM-32
         STB       R5,4B,X2        STORE IN CALL BLOCK          ETCM-32
         ADI       R2,16           MOVE RRS BUFF PNTR TO NAME   ETCM-32
LIBUP4   CI        R4,0            DONE WITH FILE NAME          ETCM-32
         BEQ       LIBUP5          YES...BRANCH                 ETCM-32
         LB        R5,0,X3         GET BYTE OF PATHNAME         ETCM-32
         STB       R5,0,X2         SAVE IN CALL BLOCK           ETCM-32
         ADI       R3,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R4,1                                         ETCM-32
         BU        LIBUP4          NEXT BYTE                    ETCM-32
LIBUP5   SUMW      R2,LIBADR       COMPUTE CALL BLOCK SIZE      ETCM-32
         STH       R2,LBLKSIZ      SAVE IN CALL BLOCK           ETCM-32
         ZR        R1                                           ETCM-32
         LI        R7,G' '         BLANK OUT NAME IN MESSAGE    ETCM-32
LIB5.1   CI        R1,16           DONE BLANKING                ETCM-32
         BEQ       LIB5.2          YES...BRANCH                 ETCM-32
         STB       R7,PNMSG.4N,X1                               ETCM-32
         ADI       R1,1                                         ETCM-32
         BU        LIB5.1          NEXT BYTE                    ETCM-32
LIB5.2   LW        R1,LRRSP        GET POINTER TO RRS BUFFER    ETCM-32
         LB        R7,6B,X1        LIBRARY FILE NAME LENGTH     ETCM-32
         ADI       R1,4W           LIBRARY FILE NAME ADDR       ETCM-32
LIB5.3   CI        R7,0            DONE WITH NAME               ETCM-32
         BEQ       LIB5.6          YES...BRANCH                 ETCM-32
         LB        R5,0,X1         GET BYTE OF LIBRARY NAME     ETCM-32
         CI        R5,G')'         DONE WITH DIRECTORY NAME     ETCM-32
         BEQ       LIB5.4          YES...BRANCH                 ETCM-32
         ADI       R1,1            NEXT BYTE IF NOT             ETCM-32
         SUI       R7,1                                         ETCM-32
         BU        LIB5.3                                       ETCM-32
LIB5.4   ADI       R1,1            POSITION TO FILE NAME        ETCM-32
         SUI       R7,1                                         ETCM-32
         ZR        R2                                           ETCM-32
LIB5.5   LB        R5,0,X1         GET BYTE OF LIBRARY NAME     ETCM-32
         STB       R5,PNMSG.4N,X2                               ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R7,1                                         ETCM-32
         CI        R7,0            DONE WITH NAME               ETCM-32
         BEQ       LIB5.6          YES...BRANCH                 ETCM-32
         BU        LIB5.5          NEXT BYTE                    ETCM-32
*--------
LIB5.6   EQU       $                                            C012-32
         LW        R1,ALOCPATH     GET PN VECT FOR LOCAL SEARCH C012-32
         STW       R1,LIBBLK.P     AND SET INTO ACTIVATION BLK  C012-32
         M.PTSK    LIBBLK,TCMPSB   SEE IF IT FOUND LOCALLY      C012-32
         TRR       R6,R6           DID IT ACTIVATE              C012-32
         BZ        LIB5.61         CONTINUE IF IT DID           C012-32
         LW        R1,ASYSPATH     ELSE TRY IN SYSTEM           C012-32
         STW       R1,LIBBLK.P                                  C012-32
         M.PTSK    LIBBLK,TCMPSB   AND TRY                      C012-32
LIB5.61  STW       R6,ACTVPTR      SAVE STATUS FOR LATER CHECK  C012-32
*!LIB5.6!!!M.PTSK!!!!LIBBLK,TCMPSB!!!RUN!LIBED!TO!UPDATE!LIB/DI!C012-32
*!!!!!!!!!!STW!!!!!!!R6,ACTVPTR!!!!!!SAVE!R6!FOR!STATUS!CHECK!!!C012-32
*--------
         LW        R1,LRRSP        ADDRESS OF LIBRARY RRS       ETCM-32
         LW        R7,ACTLIB       RECOVER LIB LFC              C014-32
         STW       R7,0,X1         AND SET INTO RRS             C014-32
         ZR        R7                                           ETCM-32
         SVC       2,X'52'         ASSIGN LIBRARY FILE          ETCM-32
         TRR       R7,R7           ANY ERROR                    C012-32
         LB        R7,5B,X1        LENGTH OF LIBRARY RRS        ETCM-32
         SLL       R7,2            CONVERT TO BYTE COUNT        ETCM-32
         LW        R1,LRRSP        RRS BUFFER START ADDRESS     ETCM-32
         ADR       R7,R1           R1 - ADDRESS OF DIR RRS      ETCM-32
         LW        R7,ACTDIR       RECOVER ACTUAL LFC           C014-32
         STW       R7,0W,X1        UPDATE RRS                   C014-32
         ZR        R7                                           ETCM-32
         SVC       2,X'52'         ASSIGN DIRECTORY FILE        ETCM-32
         TRR       R7,R7           ANY ERROR                    C012-32
         LA        R1,GPFCB2                                    ETCM-32
         LA        R7,CNPOPN                                    ETCM-32
         SVC       2,X'42'                                      ETCM-32
         LH        R1,CNPOPN+CP.STAT                            C012-32
         LW        R1,MLIBN                                     ETCM-32
         LB        R6,LT.LIBS,X1   GET LIBRARY ENTRY TYPE       ETCM-32
         CI        R6,2            DOES IT HAVE AN FCB          ETCM-32
         BEQ       LIB.3           USE FCB IF SO                ETCM-32
         LW        R1,LT.LIBS,X1                                ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
         STW       R1,GPFCB1                                    ETCM-32
         LA        R1,GPFCB1                                    ETCM-32
         BU        LIB.4                                        ETCM-32
LIB.3    LW        R1,LT.LIBS,X1                                ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
LIB.4    LA        R7,CNPOPN                                    ETCM-32
         SVC       2,X'42'                                      ETCM-32
         LH        R6,CNPOPN+CP.STAT                            C012-32
         LW        R6,ACTVPTR      GET R6 FROM PTASK CALL       ETCM-32
         BNE       LIB5.7          LIB/DIR NOT UPDATED USE OLD  ETCM-32
         LW        R6,TCMPSB+7W    CHECK PSB FOR ABORTS         ETCM-32
         BNE       LIB5.7          LIB/DIR NOT UPDATED USE OLD  ETCM-32
         LW        R1,MLIBN        GET LFC TABLE INDEX          ETCM-32
         LB        R6,LT.DIRS,X1   GET DIRECTORY ENTRY TYPE     ETCM-32
         CI        R6,4            IS IT IN MEMORY?             ETCM-32
         BNE       LIBUP6          SEARCH LIBRARY IF NOT        ETCM-32
         BL        COMPDIRS        COMPRESS/UPDATE DIR BUFFER   ETCM-32
         BU        LIBUP6          CONTINUE                     ETCM-32
LIB5.7   LNB       R5,PNMSG.3L     MESSAGE LENGTH               ETCM-32
         LA        R6,PNMSG.3A     MESSAGE ADDRESS              ETCM-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,PNMSG.4L     SECOND HALF LENGTH           ETCM-32
         LA        R6,PNMSG.4A     SECOND HALF ADDRESS          ETCM-32
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
LIBUP6   LW        R6,CCAT30RS+6W  GET CURRENT LIBRARY SYMBOL   ETCM-32
         LW        R7,CCAT30RS+7W                               ETCM-32
         BL        XLISH           SEARCH LIBRARY FOR SYMBOL    ETCM-32
         LI        R2,-1           INIT LIBRARY READ POINTERS   ETCM-32
         STW       R2,LBB.LFCX                                  ETCM-32
         STW       R2,GPB.LFCX                                  ETCM-32
         STW       R6,MLIBL        SAVE LOGICAL RECORD NUMBER   ETCM-32
         STW       R7,MLIBN        SAVE LFC TABLE INDEX         ETCM-32
         ZR        R7                                           ETCM-32
         SRLD      R6,16                                        ETCM-32
         SRL       R7,16                                        ETCM-32
         TRR       R6,R5                                        ETCM-32
         TRR       R7,R6                                        ETCM-32
         LW        R7,MLIBN        GET LFC TABLE INDEX          ETCM-32
         BL        XLIRD           READ OBJECT FROM LIBRARY     ETCM-32
         BU        OBJ.E           PROCESS OBJECT               ETCM-32
OBJ.B    BL        SWITCH          RENAME/CREATE OBJECT FILE    ETCM-32
         ZR        R1                                           ETCM-32
         LI        R6,G' '         BLANK OUT NAMES IN MESSAGES  ETCM-32
OBJ.B0   CI        R1,16                                        ETCM-32
         BEQ       OBJ.B1                                       ETCM-32
         STB       R6,PNMSG.5N,X1                               ETCM-32
         STB       R6,PNMSG.6N,X1                               ETCM-32
         STB       R6,PNMSG.6B,X1                               ETCM-32
         ADI       R1,1                                         ETCM-32
         BU        OBJ.B0          NEXT BYTE                    ETCM-32
OBJ.B1   LB        R6,TCMPROC      SOURCE PROCESSOR NAME LENGTH ETCM-32
         LW        R1,TCMPROC      SOURCE PROCESSOR NAME ADDR   ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
OBJ.B2   CI        R6,0            DONE WITH NAME               ETCM-32
         BEQ       OBJ.B5          YES..BRANCH                  ETCM-32
         LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         CI        R5,G')'         DONE WITH DIRECTORY NAME     ETCM-32
         BEQ       OBJ.B3          YES...BRANCH                 ETCM-32
         ADI       R1,1            NEXT BYTE                    ETCM-32
         SUI       R6,1                                         ETCM-32
         BU        OBJ.B2                                       ETCM-32
OBJ.B3   ADI       R1,1            POSITION TO FILE NAME        ETCM-32
         SUI       R6,1                                         ETCM-32
         ZR        R2                                           ETCM-32
OBJ.B4   LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         STB       R5,PNMSG.5N,X2  PUT IN MESSAGE               ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R6,1                                         ETCM-32
         CI        R6,0            DONE WITH NAME               ETCM-32
         BEQ       OBJ.B5          YES...BRANCH                 ETCM-32
         BU        OBJ.B4          NEXT BYTE IF NOT             ETCM-32
OBJ.B5   LB        R6,PERMNAM      GET OBJECT FILE NAME LENGTH  ETCM-32
         LW        R1,PERMNAM      OBJECT FILE NAME ADDRESS     ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
OBJ.B6   CI        R6,0            DONE WITH NAME               ETCM-32
         BEQ       OBJ.B9          YES...BRANCH                 ETCM-32
         LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         CI        R5,G')'         DONE WITH DIRECTORY NAME     ETCM-32
         BEQ       OBJ.B7          YES...BRANCH                 ETCM-32
         ADI       R1,1            NEXT BYTE                    ETCM-32
         SUI       R6,1                                         ETCM-32
         BU        OBJ.B6                                       ETCM-32
OBJ.B7   ADI       R1,1            POSITION TO FILE NAME        ETCM-32
         SUI       R6,1                                         ETCM-32
         ZR        R2                                           ETCM-32
OBJ.B8   LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         STB       R5,PNMSG.6N,X2  PUT IN MESSAGES              ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R6,1                                         ETCM-32
         CI        R6,0            DONE WITH NAME               ETCM-32
         BEQ       OBJ.B9          YES...BRANCH                 ETCM-32
         BU        OBJ.B8          NEXT BYTE IF NOT             ETCM-32
OBJ.B9   LB        R6,SRCNAM       SOURCE FILE NAME LENGTH      ETCM-32
         LW        R1,SRCNAM       SOURCE FILE NAME ADDRESS     ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
OBJ.BA   CI        R6,0            DONE WITH SOURCE FILE NAME   ETCM-32
         BEQ       OBJ.BD          YES...BRANCH                 ETCM-32
         LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         CI        R5,G')'         DONE WITH DIRECTORY NAME     ETCM-32
         BEQ       OBJ.BF          YES...BRANCH                 ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         SUI       R6,1                                         ETCM-32
         BU        OBJ.BA          NEXT BYTE                    ETCM-32
OBJ.BF   ADI       R1,1            POSITION TO FILE NAME        ETCM-32
         SUI       R6,1                                         ETCM-32
         ZR        R2                                           ETCM-32
OBJ.BG   LB        R5,0,X1         GET BYTE OF FILE NAME        ETCM-32
         STB       R5,PNMSG.6B,X2  PUT IN MESSAGE               ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         SUI       R6,1                                         ETCM-32
         CI        R6,0            DONE WITH NAME               ETCM-32
         BEQ       OBJ.BD          YES...BRANCH                 ETCM-32
         BU        OBJ.BG          NEXT BYTE IF NOT             ETCM-32
OBJ.BD   M.PTSK    TCMPTSK,TCMPSB  REBUILD OBJECT               ETCM-32
         TRR       R6,R6           ANY ERRORS?                  ETCM-32
         BNE       M1PNM.6         USE OLD OBJECT IF SO         ETCM-32
         LW        R6,TCMPSB+7W    DID IT ABORT?                ETCM-32
         BNE       M1PNM.6         USE OLD OBJECT IF SO         ETCM-32
         TBM       MSGORD,MFLGS    READING FROM SGO OR OBJ      ETCM-32
         BNS       OBJ.BB          OBJ IF NOT SET               ETCM-32
         LA        R1,XBIRD91      GET SGO FCB ADDRESS          ETCM-32
         M.DASN                    DEASSIGN FILE                ETCM-32
         LW        R4,SGOLFC       GET SGO LFC                  ETCM-32
         ZBM       XBIRDFST,XFLGS  CLEAR SGO OPEN FLAG          ETCM-32
         BU        OBJ.BC          CONTINUE                     ETCM-32
OBJ.BB   LA        R1,XOBJECT      GET OBJ FCB ADDRESS          ETCM-32
         M.DASN                    DEASSIGN FILE                ETCM-32
         LW        R4,OBJLFC       GET OBJ LFC                  ETCM-32
         ZBM       XOBRDFST,XFLGS  CLEAR OBJ OPEN FLAG          ETCM-32
OBJ.BC   STW       R4,REPRRS       SAVE LFC IN RRS              ETCM-32
         LW        R1,TEMPNAM      GET NAME OF OLD OBJECT FILE  ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'24'         DELETE OLD OBJECT FILE       ETCM-32
         LB        R4,PERMNAM      LEN OF NEW OBJECT FILE NAME  ETCM-32
         STB       R4,REPRRS+6B    SAVE IN RRS                  ETCM-32
         ZR        R2                                           ETCM-32
OBJ.C    CI        R4,0            DONE WITH FILE NAME?         ETCM-32
         BEQ       OBJ.D           CONTINUE IF SO               ETCM-32
         LB        R5,PERMPATH,X2  GET BYTE OF FILE NAME        ETCM-32
         STB       R5,RNAME,X2     SAVE FOR RRS                 ETCM-32
         ADI       R2,1            ADJUST POINTERS              ETCM-32
         SUI       R4,1                                         ETCM-32
         BU        OBJ.C           NEXT BYTE                    ETCM-32
OBJ.D    ADI       R2,16           ADJUST FOR FIXED LENGTH STUF ETCM-32
         ZR        R3                                           ETCM-32
         SRLD      R2,2            CONVERT TO WORD COUNT        ETCM-32
         CI        R3,0            ANY REMAINDER?               ETCM-32
         BEQ       $+2W            NO ADJUSTMENT IF NOT         ETCM-32
         ADI       R2,1            ADD IN ANOTHER WORD          ETCM-32
         STB       R2,REPRRS+5B    SAVE IN RRS                  ETCM-32
         M.ASSN    REPRRS          ASSIGN NEW OBJECT FILE       ETCM-32
         LD        R6,MPNAM        GET NAME OF PROGRAM          ETCM-32
         ZR        R5                                           ETCM-32
         TBM       MSGORD,MFLGS    WHICH FILE WERE WE READING   ETCM-32
         BS        $+2W            BRANCH IF SGO                ETCM-32
         ADI       R5,1            SIGNAL READING FROM OBJ      ETCM-32
         BL        XGOPO           POSITION TO PROGRAM          ETCM-32
OBJ.E    ZMH       MXSEQ           CLEAR OBJECT SEQUENCE NUMBER ETCM-32
         BL        PNAME10         SET UP MOBSC POINTERS        ETCM-32
         LB        R6,MCBUF,X1     GET PROGRAM NAME LENGTH      ETCM-32
         ANMB      R6,=X'0F'                                    ETCM-32
         ADR       R6,R1           MOVE POINTER PAST NAME       ETCM-32
         ADI       R1,1                                         ETCM-32
M1PNM.5  STB       R1,MBLKX        SAVE NEW MCBUF POINTER       ETCM-32
         STW       R1,MOBSCREG+5W                               ETCM-32
         LF        R0,MOBSCREG                                  ETCM-32
         BU        MOBSC5.2        MERGE WITH MOBSC             ETCM-32
M1PNM.6  LNB       R5,PNMSG.5L     MESSAGE LENGTH               ETCM-32
         LA        R6,PNMSG.5A     MESSAGE ADDRESS              ETCM-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,PNMSG.6L     SECOND HALF                  ETCM-32
         LA        R6,PNMSG.6A                                  ETCM-32
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         LNB       R5,PNMSG.7L     PUT OUT THIRD PART           ETCM-32
         LA        R6,PNMSG.7A                                  ETCM-32
         BL        XTYPE                                        C013-32
         LW        R1,PERMNAM      GET PNV TO BAD OBJECT FILE   ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'24'         DELETE FILE                  ETCM-32
         LW        R1,TEMPNAM      GET NAME OF OLD OBJECT FILE  ETCM-32
         LW        R2,PERMNAM      GET NEW NAME                 ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'2D'         RENAME OLD OBJECT FILE       ETCM-32
M1PNM.6B LH        R7,SKIPNUM      GET NUM OF RECORDS SKIPPED   ETCM-32
         SUI       R7,1            MAKE IT ONE LESS             ETCM-32
         STH       R7,SKIPNUM      STORE IT BACK                ETCM-32
         LI        R2,6            POINT TO PROGRAM NAME REC    ETCM-32
         LB        R7,DUPBUF,X2    GET LENGTH OF RECORD         ETCM-32
         ANMB      R7,=X'0F'                                    ETCM-32
         ADR       R7,R2           ADD TO POINTER               ETCM-32
         TRR       R2,R4           SAVE POINTER FOR LATER       ETCM-32
         ADI       R2,21           ADD LENGTH OF TIME/DATE      ETCM-32
         ZR        R3                                           ETCM-32
OBJ.6C   CI        R3,6            SIX BYTES PUT OUT?           ETCM-32
         BEQ       OBJ.6D          YES...BRANCH                 ETCM-32
         LB        R7,SEQREC,X3    GET BYTE OF RECORD           ETCM-32
         STB       R7,DUPBUF,X2    SAVE IN OBJECT BUFFER        ETCM-32
         ADI       R3,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         BU        OBJ.6C          NEXT BYTE                    ETCM-32
OBJ.6D   TRR       R2,R6           SAVE POINTER FOR LATER       ETCM-32
         SUI       R2,6            SUBTRACT OF HEADER BYTES     ETCM-32
         STB       R2,DUPBUF+1B    SAVE LENGTH IN BUFFER        ETCM-32
         ZMH       DUPBUF+1H       CLEAR CHECKSUM               ETCM-32
         ZR        R3                                           ETCM-32
OBJ.6E   CI        R2,0            DONE CHECKSUMMING?           ETCM-32
         BEQ       OBJ.6F          YES...BRANCH                 ETCM-32
         LB        R7,DUPBUF+3H,X3 GET BYTE OF OBJECT           ETCM-32
         ARMH      R7,DUPBUF+1H    ADD TO CHECKSUM              ETCM-32
         ADI       R3,1            ADJUST POINTERS              ETCM-32
         SUI       R2,1                                         ETCM-32
         BU        OBJ.6E          NEXT BYTE                    ETCM-32
OBJ.6F   TRR       R6,R3           RESTORE BUFFER POINTER TO R3 ETCM-32
OBJ.6X   CI        R3,120          AT END OF BUFFER?            ETCM-32
         BEQ       OBJ.6G          YES...BRANCH                 ETCM-32
         ZMB       DUPBUF,X3       CLEAR BYTE IN BUFFER         ETCM-32
         ADI       R3,1            ADJUST POINTER               ETCM-32
         BU        OBJ.6X          KEEP GOING                   ETCM-32
OBJ.6G   LB        R5,MBLKX        SAVE CURRENT MCBUF POINTER   ETCM-32
         STB       R4,MBLKX        REPLACE WITH OUR POINTER     ETCM-32
         SBM       XTCMTD,XFLGS    PROCESS TIME/DATE FOR TCM    ETCM-32
         BL        M1INFO                                       ETCM-32
         STB       R5,MBLKX        RESTORE MCBUF POINTER        ETCM-32
         ZBM       XTCMTD,XFLGS    CLEAR TCM TIME/DATE FLAG     ETCM-32
         LA        R5,DUPBUF       GET ADDRESS OF BUFFER        ETCM-32
         STW       R5,XTEMP+8W     PUT IN TEMP OBJECT FCB       ETCM-32
         LA        R1,XTEMP                                     ETCM-32
         BL        BB.WRIT         WRITE REC TO TEMP OBJ FILE   ETCM-32
         LA        R5,MCBUF        RESTORE MCBUF ADDRESS        ETCM-32
         STW       R5,XTEMP+8W                                  ETCM-32
         LW        R1,MCPNTR       RESTORE POINTER TO MCBUF     ETCM-32
         BU        M1PNM.5         MERGE                        ETCM-32
M1PNM.4  LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
SKIPCHK  STW       R1,MCPNTR       SAVE MCBUF POINTER           ETCM-32
         LH        R1,SKIPNUM      DID WE SKIP ANY RECORDS?     ETCM-32
         BEQ       M1PNM.4         RETURN IF NOT                ETCM-32
         BU        M1PNM.6B        MODIFY OBJ FOR SKIPPED RECS  ETCM-32
*                                                               ETCM-32
M1PNM91  DATAD     0               TEMP STORAGE
TCMDATE  DATAD     0,0      TIME/DATE FROM TYPE 2 TCM RECORD    ETCM-32
FILDATE  DATAD     0        TIME/DATE FROM SOURCE FILE RD       ETCM-32
CHNGDATE DATAD     0,0      LAST CHANGED TIME/DATE FOR SOURCE   ETCM-32
ACTLIB   DATAW     0        HOLDS LFC OF DEASSIGNED LIB         C014-32
ACTDIR   DATAW     0        HOLDS CORRESPONDING DIR LFC         C014-32
OBJRRS   DATAW     0               OBJECT FILE RRS              ETCM-32
         DATAW     X'01000000'                                  ETCM-32
         DATAW     X'00008000'                                  ETCM-32
         DATAW     0                                            ETCM-32
OBJPATH  REZ       54B             FILE PATHNAME                ETCM-32
TCMPSB   REZ       8W              PSB FOR PTASK CALL           ETCM-32
MCPNTR   DATAW     0               MCBUF POINTER SAVE AREA      ETCM-32
ACTVPTR  DATAW     0               ACTIVATION BLOCK POINTER     ETCM-32
RNUM     DATAW     0               RRS NUMBER SAVE AREA         ETCM-32
LENPTR   DATAW     0          POINTER TO LENGTH OF CURRENT RRS  PR11209
SRRSP    DATAW     0        SOURCE PROCESSOR RRS SAVE AREA PNTR ETCM-32
LRRSP    DATAW     0        LIBED CALL BLOCK RRS SAVE AREA PNTR ETCM-32
OBJPNV   GEN       8/0,24/A(RRSBUF)  PNV FROM TYPE 3 RECORDS    ETCM-32
INCLCNT  DATAH     0               INCLUDE FILE COUNT           ETCM-32
RRSBUF   REZ       54B             TYPE 3 PATHNAME BUFFER       ETCM-32
         BOUND     1D
TCMPTSK  DATAB     0               PTASK ACTIVATION BLOCK       ETCM-32
TCMRNUM  DATAB     0               NUMBER OF RRS'S IN BLOCK     ETCM-32
         DATAH     0                                            ETCM-32
         DATAW     0                                            ETCM-32
         DATAW     0                                            ETCM-32
TCMPROC  ACW       PATHLOC         SOURCE PROCESSOR PNV         ETCM-32
         DATAW     0,0                                          ETCM-32
         DATAW     0,0                                          ETCM-32
         DATAW     0,0                                          ETCM-32
         DATAW     X'00080000'     EXPANDED BLOCK               ETCM-32
TCMOPT   DATAW     0               OPTION WORD 1                ETCM-32
         DATAW     0                                            ETCM-32
         ACW       UTRS            POINTER TO RRS LIST          ETCM-32
TCMOPT2  DATAW     0               OPTION WORD 2                ETCM-32
         DATAH     X'0050'                                      ETCM-32
TCMRSIZ  DATAH     0               RRS LIST SIZE                ETCM-32
         DATAW     0,0,0,0                                      ETCM-32
UTRS     DATAW     G'LO '          RRS LIST                     ETCM-32
         DATAW     X'04040000'                                  ETCM-32
         DATAW     G'UT '                                       ETCM-32
         DATAW     0                                            ETCM-32
         DATAW     G'UT '                                       ETCM-32
TCMRLST  REZ       185W                                         ETCM-32
*---                                                            C012-32
ALOCPATH GEN       8/5,24/A(LC.LBPTH)                           C012-32
ASYSPATH GEN       8/20,24/A(SS.LBPTH)                          C012-32
LC.LBPTH DATAB     C'LIBED'                                     C012-32
         BOUND     1W                                           C012-32
SS.LBPTH DATAB     C'@@SYSTEM(SYSTEM)LIBED'                      C012-32
         BOUND     1D                                           C012-32
*                                                               ETCM-32
LIBBLK   DATAB     0      ACTIVATION BLOCK FOR LIBRARY UPDATES  ETCM-32
         DATAB     5                                            ETCM-32
         DATAH     0                                            ETCM-32
         DATAW     0,0                                          ETCM-32
*!!!!!!!!!!GEN!!!!!!!8/5,24/A(LIBPATH)!!!!!!!!!!!!!!!!!!!!!!!!!!C012-32
LIBBLK.P DATAW     0               SET TO PATHNAME VECTOR       C012-32
         DATAW     0,0                                          ETCM-32
         DATAW     0,0                                          ETCM-32
         DATAW     0,0                                          ETCM-32
         DATAW     X'00080000'                                  ETCM-32
         DATAW     X'00000004'     OPTION 3 - UPDATE            ETCM-32
         DATAW     0                                            ETCM-32
LIBADR   ACW       RLST                                         ETCM-32
         DATAW     0                                            ETCM-32
         DATAH     X'0050'                                      ETCM-32
LBLKSIZ  DATAH     0                                            ETCM-32
         DATAW     0,0,0,0                                      ETCM-32
RLST     DATAW     G'LO '                                       ETCM-32
         DATAW     X'04040000'                                  ETCM-32
         DATAW     G'UT '                                       ETCM-32
         DATAW     0                                            ETCM-32
         DATAW     G'CTL'                                       ETCM-32
         DATAW     X'03060000'                                  ETCM-32
         DATAW     0,0                                          ETCM-32
         DATAW     X'0F000000'                                  ETCM-32
         DATAW     0
         DATAW     G'UT '                                       ETCM-32
LIBRLST  REZ       40W                                          ETCM-32
*                                                               ETCM-32
         BOUND     1W                                           ETCM-32
LDPATH   GEN       8/54,24/A(RNAME)                             ETCM-32
REPRRS   DATAW     0                                            ETCM-32
         DATAW     X'01000000'                                  ETCM-32
         DATAW     0,0                                          ETCM-32
RNAME    REZ       54B                                          ETCM-32
         BOUND     1W                                           ETCM-32
SRCNAM   GEN       8/0,24/A(SRCPATH)                            ETCM-32
SRCPATH  REZ       54B                                          ETCM-32
         BOUND     1W                                           ETCM-32
SEQREC   DATAW     X'D40C0600'     SEQUENCE OBJECT RECORD       ETCM-32
SKIPNUM  DATAH     0               NUMBER OF OBJ RECS SKIPPED   ETCM-32
         BOUND     1W
DIRPNV   GEN       8/16,24/A(PN.BLCK2)     WORKING DIR. PNV     S910662
*                                                               ETCM-32
PNMSG.1A DATAB     C' CATALOG(WARNING) FILE '                   ETCM-32
PNMSG.1N REZ       54B                                          ETCM-32
PNMSG.1L DATAB     $-PNMSG.1A                                   ETCM-32
*                                                               ETCM-32
PNMSG.2A DATAB     C' NOT LOCATED FOR VERIFICATION, EXISTING '  ETCM-32
         DATAB     C' OBJECT USED.'                             ETCM-32
PNMSG.2L DATAB     $-PNMSG.2A                                   ETCM-32
*                                                               ETCM-32
PNMSG.3A DATAB     C' CATALOG(WARNING) LIBED ERRORS OCCURRED '  ETCM-32
         DATAB     C' UPDATING'                                 ETCM-32
PNMSG.3L DATAB     $-PNMSG.3A                                   ETCM-32
*                                                               ETCM-32
PNMSG.4A DATAB     C'  LIBRARY '                                ETCM-32
PNMSG.4N REZ       16B                                          ETCM-32
         DATAB     C', EXISTING LIBRARY USED.'                  ETCM-32
PNMSG.4L DATAB     $-PNMSG.4A                                   ETCM-32
*                                                               ETCM-32
PNMSG.5A DATAB     C' CATALOG(WARNING) SOURCE PROCESSOR '       ETCM-32
         DATAB     C' ERRORS OCCURRED WHEN '                    ETCM-32
PNMSG.5N REZ       16B                                          ETCM-32
PNMSG.5L DATAB     $-PNMSG.5A                                   ETCM-32
*                                                               ETCM-32
PNMSG.6A DATAB     C' WAS UPDATING OBJECT FILE '                ETCM-32
PNMSG.6N REZ       16B                                          ETCM-32
         DATAB     C' FROM SOURCE FILE '                        ETCM-32
PNMSG.6B REZ       16B                                          ETCM-32
PNMSG.6L DATAB     $-PNMSG.6A                                   ETCM-32
*                                                               ETCM-32
PNMSG.7A DATAB     C' EXISTING OBJECT WILL BE USED.'            ETCM-32
PNMSG.7L DATAB     $-PNMSG.7A                                   ETCM-32
*                                                               ETCM-32
PNMSG.8A DATAB     C' CATALOG(WARNING) OBJECT FILE DOES NOT '   PR11087
         DATAB     C'CONTAIN REQUIRED INFORMATION TO'           PR11087
PNMSG.8L DATAB     $-PNMSG.8A                                   PR11087
*
PNMSG.9A DATAB     C'                  ENABLE REPROCESSING. '   PR11087
         DATAB     C'EXISTING OBJECT USED.'                     PR11087
PNMSG.9L DATAB     $-PNMSG.9A                                   PR11087
*
PNMSG.AA DATAB     C' CATALOG(WARNING) NO ENTRIES AVAILABLE '   S910662
         DATAB     C'IN CURRENT WORKING DIRECTORY.'             S910662
PNMSG.AL DATAB     $-PNMSG.AA                                   S910662
*
PNMSG.BA DATAB     C'                  TASK CODE MANAGEMENT '   S910662
         DATAB     C'HAS BEEN DISABLED.'                        S910662
PNMSG.BL DATAB     $-PNMSG.BA                                   S910662
*
         TITLE     FILBUF - CHECKS MCBUF FOR EMPTINESS          ETCM-32
****************************************************************ETCM-32
*                                                               ETCM-32
*        FILBUF - READS THE NEXT OBJECT RECORD FROM THE         ETCM-32
*                 APPROPRIATE OBJECT SOURCE (LIB,SGO,OBJ)       ETCM-32
*                 INTO MCBUF, CHECKSUMS IT, AND ADJUSTS THE     ETCM-32
*                 RECORD BYTE COUNT AND BUFFER POINTERS.        ETCM-32
*                                                               ETCM-32
****************************************************************ETCM-32
*                                                               ETCM-32
FILBUF   STF       R0,BUFSAVE                                   ETCM-32
         TBM       XLIBEDCK,XFLGS  READING FROM  LIBRARY        ETCM-32
         BNS       $+5W            BRANCH IF NOT                ETCM-32
         LW        R7,MLIBN        GET LFC TABLE INDEX          ETCM-32
         LI        R5,-1           NEXT SEQUENTIAL RECORD       ETCM-32
         BL        XLIRD           READ RECORD FROM LIBRARY     ETCM-32
         BU        PNAME.8         CONTINUE                     ETCM-32
         TBM       MSGORD,MFLGS    READING FROM SGO?            ETCM-32
         BNS       $+3W            BRANCH IF NOT                ETCM-32
         BL        XBIRD           READ RECORD FROM SGO FILE    ETCM-32
         BU        PNAME.8         CONTINUE                     ETCM-32
         BL        XOBRD           ELSE READ FROM OBJ FILE      ETCM-32
PNAME.8  ABM       15,SKIPNUM      INCREMENT SKIP COUNT         ETCM-32
         ABM       15,MXSEQ        INCREMENT SEQUENCE NUMBER    ETCM-32
         LW        R4,MCBUF+1W     GET OBJECT BYTE              ETCM-32
         SRL       R4,16           POSITION                     ETCM-32
*!!!!!!!!CAMH!!!!!!R4,MXSEQ!!!!!!!!COMPARE!SEQUENCE!NUMBERS!!!!!S920470
         LH        R3,MXSEQ        GET EXPECTED SEQ. NUM        S920470
         ANMW      R3,=X'0000FFFF'  CLEAR UNUSED BITS           S920470
         CAR       R3,R4           COMPARE EXPECTED W/ INPUT    S920470
         BNE       MOBSC.1         ERROR IF NOT EQUAL           ETCM-32
         LB        R4,MCBUF+1B     GET RECORD LENGTH            ETCM-32
         BZ        MOBSC1.8        ERROR IF ZERO                ETCM-32
         STB       R4,MBCNT        SAVE BYTE COUNT              ETCM-32
         TRN       R4,R4           NEGATE BYTE COUNT            ETCM-32
         ZR        R1                                           ETCM-32
         ZR        R3                                           ETCM-32
PNAME.9  ADMB      R3,MCBUF+6B,X1  COMPUTE CHECKSUM             ETCM-32
         ADI       R1,1                                         ETCM-32
         BIB       R4,PNAME.9                                   ETCM-32
         TRR       R3,R1           MOVE CHECKSUM TO R1          ETCM-32
         LB        R2,MCBUF+3B     GET CHECKSUM FROM RECORD     ETCM-32
         SRLD      R2,8            POSITION                     ETCM-32
         LB        R2,MCBUF+2B                                  ETCM-32
         SLLD      R2,8                                         ETCM-32
         CAR       R1,R2           ARE THEY EQUAL               ETCM-32
         BNE       MOBSC1.8        ERROR IF NOT                 ETCM-32
         LI        R1,6            POSITION TO FIRST DATA BYTE  ETCM-32
         STB       R1,MBLKX        SAVE POINTER TO MCBUF        ETCM-32
         STW       R1,BUFSAVE+1W                                ETCM-32
         LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
PNAME10  STF       R0,BUFSAVE                                   ETCM-32
         BU        PNAME.8                                      ETCM-32
*                                                               ETCM-32
BUFSAVE  REZ       8W                                           ETCM-32
*                                                               ETCM-32
         TITLE     CHKLFC
*                                                               ETCM-32
****************************************************************ETCM-32
*                                                               ETCM-32
*        CHKLFC - CHECKS THE LFC INPUT IN R4 TO SEE IF IT IS    ETCM-32
*                 A LFC FOR A SOURCE OR OBJECT FILE             ETCM-32
*                                                               ETCM-32
****************************************************************ETCM-32
CHKLFC   STF       R0,BUFSAVE                                   ETCM-32
         ZBM       XSRCLFC,XFLGS   CLEAR SOURCE LFC FLAG        ETCM-32
         CAMW      R4,=G'LO '      IS IT LO                     ETCM-32
         BEQ       LOFILE          PROCESS LO FILE RECORD       ETCM-32
         CAMW      R4,=G'SI '      IS IT SI                     ETCM-32
         BEQ       SRCFILE         SHOW SOURCE LFC IF SO        ETCM-32
         CAMW      R4,=G'DI '      IS IT DI                     ETCM-32
         BEQ       SRCFILE         SHOW SOURCE LFC IF SO        ETCM-32
         CAMW      R4,=G'PRE'      IS IT PRE                    ETCM-32
         BEQ       SETSRC          SET FLAG IF SO               ETCM-32
         CAMW      R4,=G'CI '      IS IT CI                     ETCM-32
         BEQ       SETSRC          SET FLAG IF SO               ETCM-32
         CAMW      R4,=G'MAC'      IS IT MAC                    ETCM-32
         BEQ       SETSRC          SET FLAG IF SO               ETCM-32
         CAMW      R4,=G'MA2'      IS IT MA2                    ETCM-32
         BEQ       SETSRC          SET FLAG IF SO               ETCM-32
         TBM       30,TCMOPT       IS OPTION 2 SET              ETCM-32
         BNS       CHK.1           CHECK FOR BO/DO IF NOT       ETCM-32
         TBM       27,TCMOPT       IS OPTION 5 SET              ETCM-32
         BNS       CHK.1           CHECK FOR BO/DO IF NOT       ETCM-32
         CAMW      R4,=G'GO '      IS IT GO                     ETCM-32
         BEQ       OBJFILE         DO PROCESSING FOR OBJ FILE   ETCM-32
         BU        CHK.2           RETURN IF NOT                ETCM-32
CHK.1    CAMW      R4,=G'BO '      IS IT BO                     ETCM-32
         BEQ       OBJFILE         DO PROCESSING FOR OBJ FILE   ETCM-32
         CAMW      R4,=G'DO '      IS IT DO                     ETCM-32
         BEQ       OBJFILE         DO PROCESSING FOR OBJ FILE   ETCM-32
CHK.2    LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
SETSRC   SBM       XSRCLFC,XFLGS   SET SOURCE LFC FLAG          ETCM-32
         LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0                                           ETCM-32
SRCFILE  SBM       XSRCLFC,XFLGS   SHOW AS SOURCE RECORD        ETCM-32
         SBM       XSILFC,XFLGS    SHOW AS SI RECORD            ETCM-32
         SBM       CSIREC,CFLGS    SHOW SI RECORD READ          PR11087
         LB        R4,OBJPNV       GET FILE NAME LENGTH         ETCM-32
         STB       R4,SRCNAM       SAVE IN SOURCE FILE PNV      ETCM-32
         LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
LOFILE   SBM       XLOLFC,XFLGS    SHOW LO FILE RECORD READ     ETCM-32
         LB        R4,TCMRNUM      GET NUMBER OF RRS' IN BLOCK  ETCM-32
         SUI       R4,1            MINUS ONE FOR LO             ETCM-32
         STB       R4,TCMRNUM      PUT BACK IN CALL BLOCK       ETCM-32
         LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
OBJFILE  TBM       XLIBEDCK,XFLGS  READING FROM LIBRARY?        ETCM-32
         BS        OBJF.1          RETURN IF LIBRARY OBJECT     ETCM-32
         SBM       XOBJLFC,XFLGS   SET OBJECT LFC FLAG          ETCM-32
         SBM       CGOREC,CFLGS    SHOW OBJECT FILE RECORD READ PR11087
         LB        R4,OBJPNV       GET OBJECT FILE NAME LENGTH  ETCM-32
         STB       R4,PERMNAM      STORE IN OBJECT FILE PNV     ETCM-32
OBJF.1   LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
*                                                               ETCM-32
         TITLE     SWITCH
****************************************************************ETCM-32
*                                                               ETCM-32
*        SWITCH - RENAMES THE CURRENT MODULES OBJECT FILE SO    ETCM-32
*                 THAT THE OBJECT IS NOT DESTROYED IF THE       ETCM-32
*                 SOURCE PROCESSOR ABORTS. A FILE IS CREATED    ETCM-32
*                 WITH THE SAME NAME AND SIZE OF THE ORIGINAL   ETCM-32
*                 OBJECT FILE. THE REPROCESSED OBJECT WILL BE   ETCM-32
*                 PLACED IN THIS FILE.                          ETCM-32
*                                                               ETCM-32
****************************************************************ETCM-32
SWITCH   STF       R0,BUFSAVE                                   ETCM-32
         M.MYID    TEMPPB          GET TASK ID NUMBER           ETCM-32
         ZR        R4                                           ETCM-32
         LW        R5,TEMPPB       GET TASK ID IN R5            ETCM-32
         SLLD      R4,8            SHIFT OUT LEFTMOST BYTE      ETCM-32
         TRR       R4,R5           PUT IT IN R5                 ETCM-32
         SVC       1,X'2A'         CONVERT TO ASCII             ETCM-32
         SLL       R7,16           POSITION NUMBER IN R7        ETCM-32
         ZR        R6                                           ETCM-32
         SLLD      R6,8            FIRST DIGIT TO R6            ETCM-32
         STB       R6,JUNKOBJ+8B   SAVE IN TEMPORARY NAME       ETCM-32
         ZR        R6                                           ETCM-32
         SLLD      R6,8            GET SECOND DIGIT             ETCM-32
         STB       R6,JUNKOBJ+9B   SAVE IN TEMP NAME            ETCM-32
         ABM       31,TEMPNUM      BUMP TEMPORARY COUNT         ETCM-32
         M.CONBAD  TEMPNUM         CONVERT TO ASCII             ETCM-32
         TRR       R6,R5           MOVE TO R5                   ETCM-32
         SLL       R5,16           POSITION NUMBER IN R5        ETCM-32
         ZR        R4                                           ETCM-32
         SLLD      R4,8                                         ETCM-32
         STB       R4,JUNKOBJ+10B                               ETCM-32
         ZR        R4                                           ETCM-32
         SLLD      R4,8                                         ETCM-32
         STB       R4,JUNKOBJ+11B                               ETCM-32
         ZR        R6                                           ETCM-32
         SLLD      R6,8                                         ETCM-32
         STB       R6,JUNKOBJ+12B                               ETCM-32
         ZR        R6                                           ETCM-32
         SLLD      R6,8                                         ETCM-32
         STB       R6,JUNKOBJ+13B                               ETCM-32
         ZR        R6                                           ETCM-32
         SLLD      R6,8                                         ETCM-32
         STB       R6,JUNKOBJ+14B                               ETCM-32
         ZR        R6                                           ETCM-32
         SLLD      R6,8                                         ETCM-32
         STB       R6,JUNKOBJ+15B                               ETCM-32
         ZR        R2                                           ETCM-32
OBJ.5    LB        R6,PERMPATH,X2  GET PATHNAME BYTE            ETCM-32
         CI        R6,G')'         DONE UP TO DIRECTORY?        ETCM-32
         BEQ       OBJ.6           GO PUT TEMP NAME IN IF SO    ETCM-32
         STB       R6,TMPPATH,X2   SAVE IN TEMP PATHNAME        ETCM-32
         ADI       R2,1            ADJUST POINTER               ETCM-32
         BU        OBJ.5           NEXT BYTE
OBJ.6    STB       R6,TMPPATH,X2   SAVE PAREN IN TEMP NAME      ETCM-32
         ADI       R2,1            BUMP POINTER                 ETCM-32
         ZR        R1                                           ETCM-32
OBJ.7    CI        R1,16           DONE WITH TEMP NAME?         ETCM-32
         BEQ       OBJ.8           SAVE LENGTH AND RETURN       ETCM-32
         LB        R6,JUNKOBJ,X1   GET BYTE OF TEMP NAME        ETCM-32
         STB       R6,TMPPATH,R2   STORE IN TEMP NAME BUFFER    ETCM-32
         ADI       R1,1            ADJUST POINTERS              ETCM-32
         ADI       R2,1                                         ETCM-32
         BU        OBJ.7           NEXT BYTE                    ETCM-32
OBJ.8    STB       R2,TEMPNAM      SAVE PATHNAME LENGTH         ETCM-32
         LW        R1,PERMNAM      GET ORIGINAL OBJ FILE NAME   ETCM-32
         LW        R2,TEMPNAM      GET NEW NAME                 ETCM-32
         ZR        R7                                           ETCM-32
         SVC       2,X'2D'         RENAME OBJECT FILE           ETCM-32
         TBM       MSGORD,MFLGS    WHICH FILE WERE WE READING   ETCM-32
         BNS       SW.1            OBJ IF NOT SET               ETCM-32
         LW        R3,SGPNTRS+1W   GET SGO FAT ADDRESS          ETCM-32
         LW        R4,DFT.EOF,X3   GET SGO SIZE                 ETCM-32
         BU        SW.2            GO SET UP RCB                ETCM-32
SW.1     M.INQUIRY PNTERS,OBJLFC   INQUIRE ABOUT OBJ FILE       ETCM-32
         LW        R3,PNTERS+1W    GET OBJ FAT ADDRESS          ETCM-32
         LW        R4,DFT.EOF,X3   GET OBJ SIZE                 ETCM-32
SW.2     STW       R4,XTMRCB+RCB.OSIZ   SAVE IN RCB             ETCM-32
         STW       R4,XTMRCB+RCB.MXEI   MAXINC = SIZE           ETCM-32
         SRL       R4,1                                         ETCM-32
         STW       R4,XTMRCB+RCB.MNEI   MININC = 1/2 SIZE       ETCM-32
         LI        R4,16            UP TO 16 SEGMENTS           ETCM-32
         STB       R4,XCT.CCNP+CP.OPTS                          ETCM-32
         M.CPERM   PERMNAM,XCT.CCNP,XTMRCB   CREATE FILE        ETCM-32
         LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
*                                                               ETCM-32
         BOUND     1W
TEMPNAM  GEN       8/0,24/A(TMPPATH)                            ETCM-32
PERMNAM  GEN       8/0,24/A(PERMPATH)                           ETCM-32
TEMPNUM  DATAW     0                                            ETCM-32
TEMPPB   REZ       11W                                          ETCM-32
TMPPATH  REZ       38B                                          ETCM-32
JUNKOBJ  DATAB     C'CATALOG_        '                          ETCM-32
PERMPATH REZ       54B                                          ETCM-32
         BOUND     1W                                           ETCM-32
*                                                               ETCM-32
         TITLE     COPYBUF
****************************************************************ETCM-32
*                                                               ETCM-32
*        COPYBUF - COPIES THE CONTENTS OF MCBUF INTO DUPBUF     ETCM-32
*                  SO THAT THE FIRST OBJECT RECORD WILL NOT BE  ETCM-32
*                  LOST AND CAN BE PROCESSED LATER.             ETCM-32
*                                                               ETCM-32
****************************************************************ETCM-32
COPYBUF  STF       R0,BUFSAVE                                   ETCM-32
         ZR        R3                                           ETCM-32
COPY.1   CI        R3,120          DONE ZEROING BUFFER          ETCM-32
         BEQ       COPY.2          COPY MCBUF IF SO             ETCM-32
         ZMW       DUPBUF,X3       CLEAR DUPBUF                 ETCM-32
         ADI       R3,4            ADJUST POINTERS              ETCM-32
         BU        COPY.1          NEXT WORD                    ETCM-32
COPY.2   ZR        R3                                           ETCM-32
COPY.3   CAMB      R3,MBCNT        AT THE END OF THIS RECORD?   ETCM-32
         BEQ       COPY.4          RETURN IF SO                 ETCM-32
         LB        R5,MCBUF,X3     GET BYTE FROM MCBUF          ETCM-32
         STB       R5,DUPBUF,X3    STORE IN DUPBUF              ETCM-32
         ADI       R3,1            ADJUST POINTER               ETCM-32
         BU        COPY.3          NEXT BYTE
COPY.4   LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
*                                                               ETCM-32
         BOUND     1D                                           ELST-32
DUPBUF   REZ       30W             DUPLICATE MCBUF BUFFER       ETCM-32
*                                                               ETCM-32
         TITLE     CHKDATE
****************************************************************ETCM-32
*                                                               ETCM-32
*        CHKDATE - COMPARES THE TIME/DATE OF OBJECT CREATION    ETCM-32
*                  (TCMDATE) WITH THE LAST CHANGED TIME/DATE    ETCM-32
*                  OF THE SOURCE FILE (CHNGDATE). IF THE        ETCM-32
*                  OBJECT IS NOT UP TO DATE WITH THE SOURCE,    ETCM-32
*                  THE XOUTDAT FLAG IS SET                      ETCM-32
*                                                               ETCM-32
****************************************************************ETCM-32
CHKDATE  STF       R0,BUFSAVE                                   ETCM-32
*!!!!!!!!!!LW!!!!!!!!R7,TCMDATE!!!!!!GET!1ST!WORD!OF!TCMDATE!!!!C010-32
*!!!!!!!!!!ZR!!!!!!!!R6!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!C010-32
*!!!!!!!!!!SLLD!!!!!!R6,16!!!!!!!!!!!SHIFT!MONTH!INTO!R6!!!!!!!!C010-32
*!!!!!!!!!!SLL!!!!!!!R7,8!!!!!!!!!!!!THROW!AWAY!"/"!!!!!!!!!!!!!C010-32
*!!!!!!!!!!SLLD!!!!!!R6,8!!!!!!!!!!!!SHIFT!IN!FIRST!DIGIT!OF!DAYC010-32
*!!!!!!!!!!LW!!!!!!!!R7,TCMDATE+1W!!!GET!SECOND!WORD!OF!TCMDATE!C010-32
*!!!!!!!!!!SLLD!!!!!!R6,8!!!!!!!!!!!!SHIFT!IN!SECOND!DIGIT!OF!DAC010-32
*!!!!!!!!!!SLL!!!!!!!R7,8!!!!!!!!!!!!THROW!AWAY!"/"!!!!!!!!!!!!!C010-32
*!!!!!!!!!!SRL!!!!!!!R7,16!!!!!!!!!!!POSITION!YEAR!BACK!!!!!!!!!C010-32
*!!!!!!!!!!CI!!!!!!!!R7,G'60'!!!!!!!!COMPARE!YEAR!WITH!60!!!!!!!C010-32
*!!!!!!!!!!BGE!!!!!!!DATE.1!!!!!!!!!!>!60!MEANS!20TH!CENTURY(19NC010-32
*!!!!!!!!!!ORMW!!!!!!R7,=X'32300000'!OTHERWISE!21ST!CENTURY(20NNC010-32
*!!!!!!!!!!BU!!!!!!!!DATE.2!!!!!!!!!!COMPARE!DATES!!!!!!!!!!!!!!C010-32
*!DATE.1!!!ORMW!!!!!!R7,=X'31390000'!MAKE!YEAR!19NN!!!!!!!!!!!!!C010-32
*!DATE.2!!!CAMW!!!!!!R6,CHNGDATE+1W!!COMPARE!MONTH!AND!DAY!!!!!!C010-32
*!!!!!!!!!!BLT!!!!!!!OUTDATE!!!!!!!!!OUT!OF!DATE!IF!LESS!THAN!!!C010-32
*!!!!!!!!!!BGT!!!!!!!DATE.3!!!!!!!!!!UP!TO!DATE!IF!GREATER!THAN!C010-32
*!!!!!!!!!!CAMW!!!!!!R7,CHNGDATE!!!!!COMPARE!YEARS!IF!EQUAL!!!!!C010-32
*!!!!!!!!!!BLT!!!!!!!OUTDATE!!!!!!!!!OUT!OF!DATE!IF!LESS!THAN!!!C010-32
*!!!!!!!!!!BGT!!!!!!!DATE.3!!!!!!!!!!UP!TO!DATE!IF!GREATER!THAN!C010-32
*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!C010-32
*!!!!!!!!!!LW!!!!!!!!R6,CHNGDATE+3W!!GET!LAST!WORD!OF!CHNGDATE!!C010-32
*!!!!!!!!!!SRL!!!!!!!R6,16!!!!!!!!!!!CLEAR!OUT!LAST!BYTE!OF!TIM!C010-32
*!!!!!!!!!!SLL!!!!!!!R6,16!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!C010-32
*!!!!!!!!!!STW!!!!!!!R6,CHNGDATE+3W!!STORE!BACK!IN!CHNGDATE!!!!!C010-32
*!!!!!!!!!!LW!!!!!!!!R7,TCMDATE+2W!!!GET!1ST!WORD!OF!TCM!TIME!!!C010-32
*!!!!!!!!!!ZR!!!!!!!!R6!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!C010-32
*!!!!!!!!!!SLLD!!!!!!R6,16!!!!!!!!!!!SHIFT!OUT!HOURS!!!!!!!!!!!!C010-32
*!!!!!!!!!!SLL!!!!!!!R7,8!!!!!!!!!!!!THROW!AWAY!":"!!!!!!!!!!!!!C010-32
*!!!!!!!!!!SLLD!!!!!!R6,8!!!!!!!!!!!!SHIFT!OUT!1ST!DIGIT!OF!MIN!C010-32
*!!!!!!!!!!LW!!!!!!!!R7,TCMDATE+3W!!!GET!2ND!WORD!OF!TCM!TIME!!!C010-32
*!!!!!!!!!!SLLD!!!!!!R6,8!!!!!!!!!!!!SHIFT!OUT!2ND!DIGIT!OF!MIN!C010-32
*!!!!!!!!!!SLL!!!!!!!R7,8!!!!!!!!!!!!THROW!AWAY!":"!!!!!!!!!!!!!C010-32
*!!!!!!!!!!CAMW!!!!!!R6,CHNGDATE+2W!!COMPARE!HOURS!AND!MINUTES!!C010-32
*!!!!!!!!!!BLT!!!!!!!OUTDATE!!!!!!!!!OUT!OF!DATE!IF!LESS!THAN!!!C010-32
*!!!!!!!!!!BGT!!!!!!!DATE.3!!!!!!!!!!O.K.!IF!GREATER!THAN!!!!!!!C010-32
*!!!!!!!!!!CAMW!!!!!!R7,CHNGDATE+3W!!COMPARE!SECONDS!!!!!!!!!!!!C010-32
*!!!!!!!!!!BLT!!!!!!!OUTDATE!!!!!!!!!OUT!OF!DATE!IF!LESS!THAN!!!C010-32
*                                                               C010-32
         LD        R6,TCMDATE      GET OBJECT DATE              C010-32
         BL        BDATE           CONVERT TO BINARY            C010-32
         LD        R6,TCMDATE+1D   GET OBJECT TIME              C010-32
         BL        BTIME           CONVERT TO BINARY            C010-32
         M.CONBBA  CENT,TCMDATE    CONVERT TO ASCII             C010-32
         LD        R6,TCMDATE      LOAD UP DATE PART            C010-32
*                                                               C010-32
         CAMD      R6,CHNGDATE     COMPARE DATE PART            C010-32
         BLT       OUTDATE         BR IF OUT OF DATE            C010-32
         BGT       DATE.3          BR IF UP TO DATE             C010-32
*                                                               C010-32
*                                                               C010-32
         LD        R6,TCMDATE+1D   LOAD UP TIME PART            C010-32
         CAMD      R6,CHNGDATE+1D  AND COMPARE                  C010-32
         BLT       OUTDATE         BR IF OUT OF DATE            C010-32
*                                                               C010-32
DATE.3   LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
OUTDATE  SBM       XOUTDAT,XFLGS   SET OUT OF DATE FLAG         ETCM-32
         LF        R0,BUFSAVE                                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
*                                                               ETCM-32
*---------------------------------------------------------------C010-32
*                                                               C010-32
*    BDATE                                                      C010-32
*                                                               C010-32
*  TAKES STRING IN R6,R7 AND RETURNS DATE IN "BYTE BINARY"      C010-32
*   FORMAT IN R7. CC1 SET IFF INPUT STRING IS NOT IN ANY        C010-32
*   RECOGNIZABLE FORMAT.                                        C010-32
*  ANY OF THE THREE STANDARD DATE FORMATS IS ACCEPTED.          C010-32
*                                                               C010-32
*   IN    R6,R7 = LEFT JUSTIFIED, BLANK FILLED DATE STRING      C010-32
*                                                               C010-32
*  OUT       R7 = BYTE BINARY FORMAT DATE                       C010-32
*                                                               C010-32
*---------------------------------------------------------------C010-32
*                                                               C010-32
BDATE    CEQU      $                                            C010-32
         STF       R0,BD.SAV                                    C010-32
         ZBM       1,BD.SAV        CLEAR FORMAT ERROR FLAG      C010-32
BD.1     CEQU      $                                            C010-32
         ZR        R3                                           C010-32
         BL        BD.NXTF         GET BINARY VALUE OF FIELD    C010-32
*---                                                            C010-32
         LB        R7,BD.REG6+2B   GET FIELD DELIMITER          C010-32
         CI        R7,G'/'         NORTH AMERICAN FORMAT        C010-32
         BEQ       BD.TYP1         YES...BRANCH                 C010-32
         CI        R7,G'-'         MILITARY FORMAT              C010-32
         BEQ       BD.TYP2         YES...BRANCH                 C010-32
         CI        R7,G'A'         CHECK FOR EUROPEAN           C010-32
         BLT       BD.ERR          FORMAT ERROR IF < A          C010-32
         CI        R7,G'S'                                      C010-32
         BLE       BD.TYP3         EUROPEAN FORMAT IF < S       C010-32
BD.ERR   SBM       1,BD.SAV        SHOW FORMAT ERROR            C010-32
BD.XIT   LF        R0,BD.SAV                                    C010-32
         TRSW      R0                                           C010-32
*                                                               C010-32
BD.TYP1  STB       R5,MONTH        MM/DD/YY                     C010-32
         LI        R3,3                                         C010-32
         BL        BD.NXTF         GET BINARY VAL OF NEXT FIELD C010-32
         STB       R7,DAY                                       C010-32
         LI        R3,6                                         C010-32
         BU        BD.MRGE         MERGE                        C010-32
*---                                                            C010-32
BD.TYP2  STB       R5,DAY          DD-MM-YY                     C010-32
         LI        R3,3                                         C010-32
         BL        BD.NXTF         GET NEXT FIELD IN BINARY     C010-32
         STB       R5,MONTH                                     C010-32
         LI        R3,6                                         C010-32
         BU        BD.MRGE         MERGE                        C010-32
*---                                                            C010-32
BD.TYP3  STB       R5,DAY          DDMMMYY                      C010-32
         SLL       R7,8                                         C010-32
         ORMB      R7,BD.REG6+3B                                C010-32
         SLL       R7,8                                         C010-32
         ORMB      R7,BD.REG6+4B                                C010-32
         LI        R3,-12W                                      C010-32
         LW        R4,=X'00FFFFFF'                              C010-32
BD.TYP31 CMMW      R7,MNTHTAB+12W,X3   DETERMINE MONTH VALUE    C010-32
         BEQ       BD.TYP32                                     C010-32
         BIW       R3,BD.TYP31                                  C010-32
         BU        BD.ERR                                       C010-32
BD.TYP32 LB        R5,MNTHTAB+12W,X3                            C010-32
         STB       R5,MONTH                                     C010-32
         LI        R3,5                                         C010-32
*---                                                            C010-32
BD.MRGE  BL        BD.NXTF         GET NEXT FIELD VALUE         C010-32
         STB       R5,YEAR                                      C010-32
         LI        R7,19                                        C010-32
         CI        R5,60                                        C010-32
         BGE       $+2W                                         C010-32
         LI        R7,20      IF YEAR < 60 - 21ST CENTURY 20NN  C010-32
         STB       R7,CENT                                      C010-32
         LW        R7,CENT                                      C010-32
         STW       R7,BD.SAV+7W                                 C010-32
         BU        BD.XIT                                       C010-32
*                                                               C010-32
*---------------------------------------------------------------C010-32
*                                                               C010-32
*   BTIME                                                       C010-32
*                                                               C010-32
*   TAKES STANDARD TIME FORMAT STRING IN R6,R7 AND              C010-32
*   CONVERTS TO BYTE BINARY FORMAT                              C010-32
*                                                               C010-32
*   IN   R6,R7 = TIME STRING                                    C010-32
*  OUT      R7 = BYTE BINARY FORMAT TIME                        C010-32
*                                                               C010-32
*---------------------------------------------------------------C010-32
*                                                               C010-32
BTIME    CEQU      $                                            C010-32
         STF       R0,BD.SAV                                    C010-32
         ZBM       1,BD.SAV        CLEAR FORMAT ERROR FLAG      C010-32
         LI        R3,0                                         C010-32
         BL        BD.NXTF         GET TIME FIELD VALUE         C010-32
         STB       R5,HOUR                                      C010-32
*                                                               C010-32
         LB        R7,BD.REG6+2B                                C010-32
         CI        R7,G':'         CHECK TIME FIELD DELIMITER   C010-32
         BNE       BD.ERR                                       C010-32
         LI        R3,3                                         C010-32
         BL        BD.NXTF         NEXT FIELD                   C010-32
         STB       5,MIN                                        C010-32
         LB        R7,BD.REG6+5B                                C010-32
         CI        R7,G':'                                      C010-32
         BNE       BD.ERR                                       C010-32
         LI        R3,6                                         C010-32
         BL        BD.NXTF                                      C010-32
         STB       R5,SEC                                       C010-32
         LW        R7,HOUR                                      C010-32
         STW       R7,BD.SAV+7W                                 C010-32
         BU        BD.XIT                                       C010-32
*                                                               C010-32
*---------------------------------------------------------------C010-32
BD.SAV   DEQU      $                                            C010-32
         DATAW     0,0,0,0,0,0                                  C010-32
BD.REG6  DATAW     0,0                                          C010-32
*                                                               C010-32
MNTHTAB  GEN       8/1,24/G'JAN'                                C010-32
         GEN       8/2,24/G'FEB'                                C010-32
         GEN       8/3,24/G'MAR'                                C010-32
         GEN       8/4,24/G'APR'                                C010-32
         GEN       8/5,24/G'MAY'                                C010-32
         GEN       8/6,24/G'JUN'                                C010-32
         GEN       8/7,24/G'JUL'                                C010-32
         GEN       8/8,24/G'AUG'                                C010-32
         GEN       8/9,24/G'SEP'                                C010-32
         GEN       8/10,24/G'OCT'                               C010-32
         GEN       8/11,24/G'NOV'                               C010-32
         GEN       8/12,24/G'DEC'                               C010-32
*                                                               C010-32
*---------------------------------------------------------------C010-32
BD.NXTF  CEQU      $                                            C010-32
*                                                               C010-32
*   IN R3 = PLACE TO START                                      C010-32
*  OUT R5 = BINARY VALUE OF TWO DIGIT FIELD                     C010-32
*                                                               C010-32
         LB        R6,BD.REG6,X3   GET FIRST BYTE               C010-32
         SLL       R6,8            POSTION                      C010-32
         ORMB      R6,BD.REG6+1B,X3    ADD IN NEXT BYTE         C010-32
         SLL       R6,16                                        C010-32
         ORMW      R6,=X'00002020'                              C010-32
         LW        R7,=X'20202020'                              C010-32
         M.CONADB                                               C010-32
         TRR       R6,R6                                        C010-32
         BZ        BD.ERR                                       C010-32
         TRR       R7,R5           SAVE VALUE FOR LATER         C010-32
         TRSW      R0                                           C010-32
*---------------------------------------------------------------C010-32
*                                                               C010-32
         BOUND  1D                                              C010-32
CENT     DATAB     0                                            C010-32
YEAR     DATAB     0                                            C010-32
MONTH    DATAB     0                                            C010-32
DAY      DATAB     0                                            C010-32
*                                                               C010-32
HOUR     DATAB     0                                            C010-32
MIN      DATAB     0                                            C010-32
SEC      DATAB     0                                            C010-32
INT      DATAB     0                                            C010-32
*
         TITLE     COMPDIRS
****************************************************************ETCM-32
*                                                               ETCM-32
*        COMPDIRS - IS CALLED WHEN AN IN MEMORY DIRECTORY HAS   ETCM-32
*                   BEEN UPDATED. COMPDIRS REMOVES THE OLD      ETCM-32
*                   COPY OF THE DIRECTORY FROM THE DIRECTORY    ETCM-32
*                   BUFFER, COMPRESSES THE REMAINING DIRECTORY  ETCM-32
*                   ENTRIES, AND UPDATES THE ABD'S FOR THE      ETCM-32
*                   REMAINING ENTRIES. THIS COMPRESSION         ETCM-32
*                   ALSO INCLUDES RETURNING THE FREED UP MEMORY ETCM-32
*                   TO THE XGETEA ALLOCATION POOL. THE UPDATED  ETCM-32
*                   DIRECTORY IS THEN READ INTO MEMORY AND THAT ETCM-32
*                   DIRECTORY'S ABD IS UPDATED.                 ETCM-32
*                                                               ETCM-32
****************************************************************ETCM-32
COMPDIRS LW        R1,MLIBN        GET LFC TABLE INDEX          ETCM-32
         LW        R1,LT.DIRS,X1   GET DIRECTORY ABD ADDR       ETCM-32
         ANMW      R1,=X'00FFFFFF'                              ETCM-32
         LW        R2,0,X1         GET START ADDR OF THIS DIR   ETCM-32
         LW        R3,1W,X1        GET END ADDR OF THIS DIR     ETCM-32
         CAMW      R3,DIREND       IS THIS THE LAST DIRECTORY?  ETCM-32
         BNE       COMP.1          GIVE BACK MEM FOR THIS DIR   ETCM-32
         SUR       R2,R3           COMPUTE LENGTH OF THIS DIR   ETCM-32
         STW       R3,ADJUST                                    ETCM-32
         BU        COMP.4          ADJUST MEMORY POINTERS       ETCM-32
COMP.1   CAMW      R3,DIREND       AT END OF DIRECTORY BUFFER   ETCM-32
         BGT       COMP.2          MODIFY ABD'S IF SO           ETCM-32
         LB        R5,0,X3         GET BYTE OF DIR DATA         ETCM-32
         STB       R5,0,X2         MOVE IT UP                   ETCM-32
         ADI       R2,1            ADJUST POINTERS              ETCM-32
         ADI       R3,1                                         ETCM-32
         BU        COMP.1          NEXT BYTE                    ETCM-32
COMP.2   LW        R2,0,X1         GET START ADDRESS            ETCM-32
         LW        R3,1W,X1        GET END ADDRESS              ETCM-32
         TRR       R3,R6           SAVE FOR LATER               ETCM-32
         SUR       R2,R3           COMPUTE LENGTH OF THIS DIR   ETCM-32
         STW       R3,ADJUST       SAVE FOR LATER               ETCM-32
         ZR        R2                                           ETCM-32
COMP.3   LB        R7,LT.DIRS,X2   GET DIRECTORY ENTRY          ETCM-32
         CI        R7,0            DONE IF ZERO                 ETCM-32
         BEQ       COMP.4                                       ETCM-32
         CI        R7,4            IS IT AN IN MEM DIRECTORY?   ETCM-32
         BNE       COMP.3B         GET NEXT ENTRY IF NOT        ETCM-32
         LW        R3,LT.DIRS,X2   GET ABD ADDRESS              ETCM-32
         ANMW      R3,=X'00FFFFFF'                              ETCM-32
         LW        R7,0,X3         GET START ADDRESS FOR DIR    ETCM-32
         CAR       R6,R7           IS THIS DIR BELOW OUR GUY    ETCM-32
         BLT       COMP.3B         NEXT DIR ENTRY IF NOT        ETCM-32
         SUMW      R7,ADJUST       MOVE START ADDRESS UP        ETCM-32
         STW       R7,0,X3         PUT BACK IN ABD              ETCM-32
         LW        R7,1W,X3        GET END ADDR OF THIS DIR     ETCM-32
         SUMW      R7,ADJUST       MOVE END ADDRESS UP          ETCM-32
         STW       R7,1W,X3        PUT BACK IN ABD              ETCM-32
COMP.3B  ADI       R2,4            BUMP DIRECTORY ENTRY POINTER ETCM-32
         BU        COMP.3          NEXT DIRECTORY ENTRY         ETCM-32
COMP.4   LW        R5,DIREND       GET CURRENT POOL END ADDR    ETCM-32
         SUMW      R5,ADJUST       SUBTRACT OUT FREE MEMORY     ETCM-32
         STW       R5,XEABEG       SAVE AS POOL BEGINNING       ETCM-32
         STW       R5,XEAOLD.B     HERE TO                      ETCM-32
         STW       R5,DIREND       AND MODIFY END ADDRESS       ETCM-32
         LW        R5,ADJUST       GET FREED UP LENGTH          ETCM-32
         ARMW      R5,XEASIZ       ADD TO CURRENT FREE SIZE     ETCM-32
         STW       R0,COMPSAV      SAVE R0                      ETCM-32
         LW        R1,MLIBN        GET LFC TABLE INDEX          ETCM-32
         LW        R2,LT.DIRS,X1   GET ABD ADDRESS              ETCM-32
         ANMW      R2,=X'00FFFFFF'                              ETCM-32
         BL        XDIRLD          READ DIRECTORY INTO MEMORY   ETCM-32
         LW        R0,COMPSAV      RESTORE R0                   ETCM-32
         TRSW      R0              RETURN                       ETCM-32
*                                                               ETCM-32
ADJUST   DATAW     0               AMOUNT OF MEMORY RELEASED    ETCM-32
COMPSAV  DATAW     0               SAVE AREA FOR R0             ETCM-32
         TITLE     M1XDF    - EXTERNAL DEFINITION
***********************************************************************
*
*                  M1XDF
*
***********************************************************************
*
*        EXTERNAL DEFINITION (DEF) -7-  A PASS
*
***********************************************************************
M1XDF    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS?     EAID-32
         BS        $+2W            IF YES, SKIP ROOT SYM INCR   EAID-32
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32
         ABM       31,XSYMENT      BUMP LOCAL SYMBOLS           EAID-32
         LI        R4,3            THREE BYTES FOLLOWING NAME
         BL        MGETNAME        GET NAME FROM OBJECT FILE.
M1XDF1   EQU       $               MERGE FROM EXTTENDED CODE TY  1.3#02+
         STD       R6,M1XDF91      SAVE EXTERNAL NAME
         STW       R5,M1XDF92      SAVE RELATIVE ADDRESS.
         LW        R4,=X'40000000' DEF ID
         LW        R5,MMODW
         BL        MSSCH           SEARCH FOR PREV DEF IN CURR MODULE
         TRR       R5,R5
         BEQ       M1XDF2.6        BR IF NOT A DUPLICATE
         LW        R1,MMODW
         CAMW      R1,MMODF
         BNE       M1XDF2.6        BR IF NOT IN CURR MODULE
         LI        R1,-8B
         ZR        R2
M1XDF2.4 EQU       $                                             1.3#10
         LA        R3,M1XD.M1D     LOCATE DATA                   1.3#10
         BL        XST2            STORE R6/R7                   1.3#10
         LNB       R5,M1XD.M1L                                   1.3#10
         LA        R6,M1XD.M1A                                   1.3#10
         BL        XTYPEF          LOG ERROR                     1.3#10
         LD        R6,MPNAM        GET NAME OF CURRENT           1.3#10
         LA        R3,M1XD.2D1     LOCATE                        1.3#10
         BL        XST2            STUFF                         1.3#10
         LW        R3,MCTLF        GET LAST CONTROL POINT        1.3#10
         SUI       R3,4W           BACK IT DOWN TO PGM           1.3#10
         LD        R6,1D,X3        GET NAME                      1.3#10
         LA        R3,M1XD.2D2     LOCATE                        1.3#10
         BL        XST2            AND STUFF                     1.3#10
         LNB       R5,M1XD.M2L                                   1.3#10
         LA        R6,M1XD.M2A                                   1.3#10
         BL        XTYPEF                                        1.3#10
         SBM       CDERR,CFLGS     INDICATE FATAL ERROR          1.3#10
*                                                                1.3#10
M1XDF2.6 LD        R6,M1XDF91      GET DEFINITION NAME          ECSV-33
         CAMW      R6,=C'CSEG'     IS IT CSEGVAL?               ECSV-33
         BNE       M1XDF2.A        NO...BRANCH                  ECSV-33
         CAMW      R7,=C'VAL '                                  ECSV-33
         BNE       M1XDF2.A        NO...BRANCH                  ECSV-33
         LW        R5,M1XDF92      GET PROGRAM RELATIVE ADDR    ECSV-33
         ANMW      R5,=X'007FFFFF'  MASK IT                     ECSV-33
         STW       R5,CREGLOC      SAVE FOR LATER               ECSV-33
M1XDF2.A LW        R5,M1XDF92      EXTERNAL ADDRESS TO R5
         LW        R4,=X'40000000' DEF ID
         LD        R6,M1XDF91
         BL        MSYMS           STORE ENTRY IN SYMTAB
*                                                                1.3#02
         BL        MESCH           IS IT IN EXTERNAL TABLE       1.3#02
         BCT       1,M1XDF3        BR IF FOUND                   1.3#02
M1XDF.X  EQU       $                                             1.3#02
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
         NOP                                                     1.3#02
M1XDF3   EQU       $                                             1.3#02
         BCT       2,M1XDF5        IF SYMBOL IS EXCLUDED         1.3#02
M1XDF31  EQU       $               RETURN HERE FROM M1XDF5       1.3#10
         CAMW      R1,MPRFFST      IS SYMBOL AN INCLUDE          1.3#02
         BGE       M1XDF4          BR IF NOT                     1.3#02
         ZMD       0,X1            ELSE JUST ZAP IT              1.3#02
         BU        M1XDF.X         AND GET OUT                   1.3#02
M1XDF4   EQU       $               HERE TO MOVE EXT              1.3#02
         LW        R2,MPNXT        GET POINTER TO NEXT           1.3#02
         SUI       R2,8            BACK IT UP                    1.3#02
         STW       R2,MPNXT        AND UPDATE                    1.3#02
         LD        R6,0,X2         GET LAST  SYMBOL              1.3#02
         STD       R6,0,X1         AND REMOVE THE ONE JUST DONE  1.3#02
         ZMD       0,X2            ZERO FOR EASE OF DUMP-LOOKIN  1.3#02
         LW        R6,MEXTS        GET CURRENT NUMBER OF EXTERN  1.3#02
         SUI       R6,1            REDUCE IT                     1.3#02
         STW       R6,MEXTS        AND UPDATE                    1.3#02
         BU        M1XDF.X         THEN RETURN                   1.3#02
M1XDF5   EQU       $               HERE TO LOG ERROR             1.3#02
*                                                                1.3#10
         TBM       XLIBEDCK,XFLGS   ARE WE COMING FROM LIBRARY   1.3#10
         BNS       M1XDF31          JUST RETURN IF WE ARE        1.3#10
         LA        R3,M1XD.3D1     LOCATE                        1.3#10
         BL        XST2            STUFF SYMBOL                  1.3#10
         LD        R6,MPNAM        GET CURRENT PROG              1.3#10
         LA        R3,M1XD.3D2     LOCATE                        1.3#10
         BL        XST2            STUFF                         1.3#10
         LNB       R5,M1XD.M3L     AND                           1.3#10
         LA        R6,M1XD.M3A     LOG                           1.3#10
         BL        XTYPE                                         1.3#10
         BU        M1XDF31         NOW RETURN                    1.3#10
*
M1XDF91  DATAD     0               TEMP STORAGE
M1XDF92  DATAW     0
CREGLOC  DATAW     0        CSEGVAL PROGRAM RELATIVE ADDRESS    ECSV-33
CREGBAS  DATAW     0        BASE DSECT IMAGE ADDR FOR CSEGVAL   ECSV-33
*
M1XD.M1A DATAB     C' CATALOG<<FATAL>> MULTIPLY DEFINED GLOBAL' 1.3#10
         DATAB     C' SYMBOL  '                                 1.3#10
M1XD.M1D REZ       8B                                           1.3#10
         DATAB     C'.'                                         1.3#10
M1XD.M1L DATAB     $-M1XD.M1A                                   1.3#10
*                                                               1.3#10
M1XD.M2A DATAB     C'   DEFINED IN PROGRAM  '                   1.3#10
M1XD.2D1 REZ       8B                                           1.3#10
         DATAB     C'  AND  '                                   1.3#10
M1XD.2D2 REZ       8B                                           1.3#10
         DATAB     C'.'                                         1.3#10
M1XD.M2L DATAB     $-M1XD.M2A                                   1.3#10
*                                                               1.3#10
M1XD.M3A DATAB     C' CATALOG(WARNING) EXCLUDED SYMBOL  '       1.3#10
M1XD.3D1 REZ       8B                                           1.3#10
         DATAB     C'  FORCED IN BY PROGRAM  '                  1.3#10
M1XD.3D2 REZ       8B                                           1.3#10
         DATAB     C'.'                                         1.3#10
M1XD.M3L DATAB     $-M1XD.M3A                                   1.3#10
*                                                               1.3#10
*---------------------------------------------------------------1.3#10
         TITLE     M1XRF    - EXTERNAL REFERENCE
***********************************************************************
*
*                  M1XRF
*
***********************************************************************
*
*        EXTERNAL REFERENCE -9- A PASS
*
***********************************************************************
M1XRF    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LI        R4,3            THREE BYTES FOLLOWING NAME.
         BL        MGETNAME        EXTRACT NAME FROM OBJECT FILE.
M1XRF4   EQU       $               ENTRY POINT FROM 'M1ESER'..
         TBM       MOPT1,MFLGS     TEST IF NO LIBRARY SEARCH
         BS        M1XRF3          IF NOT, DO NOT SAV EXTERNAL REF
M1XRF7   LW        R2,MPNXT        PICK UP ADDRESS OF THIS EXTERNAL
M1XRF8   CAMW      R2,MSYMN        TEST IF EX REF TBL IS FULL
         BGE       M1XRF9          IF YES, ERROR OUT             1.3#02
         BL        MEADD           ADD IT TO THE EXTERNAL TABLE  1.3#02
         BCT       1,M1XRF3        EXIT IF NOT ADDED             1.3#02
M1XRF2   EQU       $               HERE IF ADDED                 1.3#02
         ABM       31,MEXTS        INCREMENT NO. ENTRIES
M1XRF3   LF        R0,MOBSCREG     RESTORE REGISTERS
         TRSW      R0              RETURN.
M1XRF9   EQU       $                                             1.3#02
*         BNE       M1XRF7          BR IF AN ENTRY ELIMINATED    1.3#02
*
*                                  SLO MESSAGE
*                                  SYMBOL TABLE OVERFLOW
*
         LA        R6,MSOFMSG      MSG ADDR
         LNB       R5,MSOFMLN                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BL        XABORT
*                                                                1.3#02
*----------------------------------------------------------------1.3#02
         TITLE     M1CDF    - COMMON DEFINITION
***********************************************************************
*
*                  M1CDF
*
***********************************************************************
*
*        COMMON DEFINITION -A-  A PASS
*
***********************************************************************
M1CDF    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS?     EAID-32
         BS        $+2W            IF YES, SKIP ROOT SYM INCR   EAID-32
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32
         ABM       31,XSYMENT      BUMP LOCAL SYMBOLS           EAID-32
         LI        R4,3            THREE BYTES FOLLOWING NAME
         BL        MGETNAME        EXTRACT NAME FROM OBJECT FILE
         STD       R6,M1CDF91      SAVE COMMON BLOCK NAME.
         TRR       R5,R4           COPY BLOCK NO. AND SIZE TO R4
         SRLD      R4,16           ISOLATE BLOCK NO. IN R4
         SLL       R4,24           LEFT JUSTIFY BLOCK NO.
         TRR       R4,R3           SAVE BLOCK NUMBER IN R3
         SLLD      R4,16           BRING SIZE BACK INTO R4
         SBR       R4,2            R4 = X'2000"SIZE"'
M1CDF1   EQU       $               ENTRY FROM 'M1ECDF'...
         ZR        R5
         SRLD      R4,2            ENSURE THAT SIZE IS AN INTEGRAL
         TRR       R5,R5           NUMBER OF WORDS
         BEQ       M1CDF6.6
         ABR       R4,31           IF NOT, ROUND UP TO A WORD
M1CDF6.6 SLL       R4,2
         TRR       R3,R5           LOAD BLOCK NO. INTO R5
         LD        R6,M1CDF91      GET COMMON BLOCK'S NAME
         BL        MSYMS           STORE ENTRY IN SYMTAB
         LF        R0,MOBSCREG
         TRSW      R0              RETURN
M1CDF91  DATAD     0               TEMP STORAGE
         TITLE     M1DPL    - DATAPOOL REFERENCE
*******************************************************************
*
*                  M1DPL
*
*        ROUTINE NOW A NOP                                       1.3#15
*
*******************************************************************
*
*        DATAPOOL REFERENCE -C- A PASS
*
*******************************************************************
M1DPL    STF       R0,MOBSCREG
*
         LI        R2,100          SET INDEX FOR DATAPOOL        1.3#15
M1DPL.1  EQU       $               ENTRY FROM M1MDPR             1.3#15
         SLL       R2,4            MULTIPLY BY 16 FOR ENTRY ADDR 1.3#15
         LW        R7,DPOOLTAB+DPLFC,X2    GET LFC               1.3#15
         CI        R7,-1           IS IT DEFINED                 1.3#15
         BEQ       M1DPL.3         REPORT ERROR                  1.3#15
M1DPL.2  EQU       $               RETURN                        1.3#15
         LF        R0,MOBSCREG                                   1.3#15
         TRSW      R0                                            1.3#15
         NOP                                                     1.3#15
*                                                                1.3#15
M1DPL.3  EQU       $                                             1.3#15
         LI        R7,-2           SET TO INHIBIT MESSAGE        1.3#15
         STW       R7,DPOOLTAB+DPLFC,X2     IN ENTRY             1.3#15
         SRL       R2,4            DIVIDE BY 16                  1.3#15
         CI        R2,100          IS IT DATAPOOL                1.3#15
         BEQ       M1DPL.4         GO PROCESS                    1.3#15
         TRR       R2,R5                                         1.3#15
         M.CONBAD                  CONVERT TO ACD                1.3#15
         ANMW      R7,=X'0000FFFF' KEEP TWO DIGITS               1.3#15
         SLL       R7,8            POSITION                      1.3#15
         ORMW      R7,=G'L"@@"@@ '   ADD IN L"00"^                 1.3#15
         LW        R6,=G'DPOO'     GET REST OF IT                1.3#15
         BU        M1DPL.41                                      1.3#15
M1DPL.4  LD        R6,DPNAME       SET TO DATAPOOL               1.3#15
M1DPL.41 EQU       $                                             1.3#15
         LA        R3,M1DL.M1D     LOCATE                        1.3#15
         BL        XST2            AND STUFF                     1.3#15
         LW        R3,MMODW        ADDR OF WORKING MODULE        1.3#15
         LD        R6,2W,X3        GET NAME                      1.3#15
         LA        R3,M1DL.M2D     LOCATE                        1.3#15
         BL        XST2            AND STUFF                     1.3#15
         LD        R6,MPNAM        GET PROGRAM NAME              1.3#15
         LA        R3,M1DL.M2E     LOCATE                        1.3#15
         BL        XST2            AND STUFF                     1.3#15
         LNB       R5,M1DL.M1L                                   1.3#15
         LA        R6,M1DL.M1A                                   1.3#15
         BL        XTYPEF                                        1.3#15
         LNB       R5,M1DL.M2L                                   1.3#15
         LA        R6,M1DL.M2A                                   1.3#15
         BL        XTYPEF                                        1.3#15
         SBM       CDERR,CFLGS     FATAL PASS-A ERROR            1.3#15
         BU        M1DPL.2         RETURN                        1.3#15
*                                                                1.3#15
M1DL.M1A DATAB     C' CATALOG<<FATAL>>  DICTIONARY FOR'          1.3#15
         DATAB     C' PARTITION: '                               1.3#15
M1DL.M1D REZ       8B              PARTION NAME                  1.3#15
         DATAB     C'  NOT CONNECTED.'                           1.3#15
M1DL.M1L DATAB     $-M1DL.M1A                                    1.3#15
*                                                                1.3#15
M1DL.M2A DATAB     C'        REFERENCED IN MODULE: '             1.3#15
M1DL.M2D REZ       8B              LOAD MODULE NAME              1.3#15
         DATAB     C',  PROGRAM: '                               1.3#15
M1DL.M2E REZ       8B                                            1.3#15
         DATAB     C'.'                                          1.3#15
M1DL.M2L DATAB     $-M1DL.M2A                                    1.3#15
         BOUND     1W                                            1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     M1COR    - COMMON ORIGIN
***********************************************************************
*
*                  M1COR
*
***********************************************************************
*
*        COMMON ORIGIN -E-  A PASS
*
***********************************************************************
M1COR    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LB        R1,MBLKX        IX
         LB        R5,MCBUF+1B,R1  OBTAIN BLOCK NO.
         LB        R2,MCBUF+3B,X1  GET SECOND BYTE OF ADDR       1.3#10
         SRLD      R2,8            SAVE IT                       1.3#10
         LB        R2,MCBUF+2B,X1  GET FIRST BYTE OF ADDR        1.3#10
         SLLD      R2,8            ASSEMBLE TOTAL ADDR           1.3#10
M1COR0   EQU       $               ENTRY FROM 'M1ECOR'...
         STW       R2,M1CORVAL     AND SAVE FOR LATER            1.3#10
         LW        R1,MSYMC        OBTAIN NO. SYMTAB ENTRIES IN ELEMENT
         LB        R2,0+3B,R1
         SRLD      R2,8
         LB        R2,0+2B,R1
         SLLD      R2,8
         TRN       R2,R2           ENTRY COUNTER
*                                  SEARCH CURR BLOCK OF SYMTAB FOR
*                                  MATCHING BLOCK NO.
M1COR1   TBM       2,0,R1          COMMON ID BIT
         BCF       1,M1COR2        BR IF NOT COMMON
         CAMB      R5,0+4B,R1      MATCH ON BLOCK NOS.
*        CAMB      R5,0+1B,R1      MATCH ON BLOCK NOS.
         BEQ       M1COR4          BR IF MATCH
M1COR2   SUI       R1,4W
         BIB       R2,M1COR1
M1COR3   LI        R5,E.COMORG     ILLEGAL COMMON ORIGIN MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M1COR4   LW        R4,=X'20000000' COMMON ID
         ZR        R5
         LD        R6,2W,R1        COMMON NAME
         CAMD      R6,MGLOB00
         BLT       M1COR5
         CAMD      R6,MGLOB99
         BGT       M1COR5
         LB        R6,15B,R1       CHECK FOR CASE SUCH AS GLOBAL8H
         CI        R6,G'9'
         BGT       M1COR5          IF NOT A NUMBER, IT IS NOT GLOBAL
M1COR45  LI        R5,E.GBLCOM     GLOBAL COMMON INITIALIZED MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
*---------------------------------------------------------
*
M1COR5   EQU       $
         TBM       6,0,X1          IS THIS ENTRY ORG'D           1.3#16
         BS        M1COR6          WE'VE CHECKED LEGALITY IF SO  1.3#16
M1COR5.1 LD        R6,2W,R1
         BL        MSSCH           SEARCH FOR OTHER ENTRIES
         TRR       R5,R2
         BEQ       M1COR6          BR IF NO FIND
         CAR       R2,R1
         BEQ       M1COR5.5        BR IF ORIGINAL ENTRY FOUND
         TRR       R1,R7           SAVE R1
         LW        R3,MMODW
         CAMW      R3,MMODF
         BNE       M1COR5.3        BR IF DEF NOT IN CURRENT MODULE
         TBM       6,0,R2
         BS        M1COR3          BR IF ORGED
         TBM       7,0,R2
         BS        M1COR3          BR IF ALLOCATED (RESTORED SYMTAB)
         BU        M1COR5.4
M1COR5.3 LW        R6,1W,R3         GET LVL/SEQN OF WORKING MODULE
         BEQ       M1COR6          BR IF WORKING MODULE IS ROOT
*
         LW        R1,MMODF        GET SYMTAB ADDR OF FOUND MOD ENTRY
         LW        R5,1W,R1        GET LVL/SEQN OF FOUND MODULE
         BEQ       M1COR3          BR IF COMM DEF IN MAIN
*
         TBM       7,0,X2          IS FOUND ENTRY ALLOCATED      1.3#13
         BS        M1COR3          THEN CAN'T BE ORGD HERE       1.3#13
         TBM       6,0,X2          IS FOUND ENTRY ORGED?         1.3#13
         BNS       M1COR5.4        DON'T BOTHER IF NOT ORG'D     1.3#13
         LW        R1,MMODW        ELSE POINT TO WORKING MOD ENT 1.3#13
         BL        MLINK     AND  CHECK IF FOUND IS LINKED TO IT
         TRR       R5,R5           IS IT?
         BNE       M1COR3      ERR IF WORKING IS LINKED TO FOUND
M1COR5.4 TRR       R2,R5
         TRR       R7,R1
M1COR5.5 SUI       R5,4W           NEXT ENTRY
*!!!!!!!!!!BU!!!!!!!!M1COR5!!!!!!!!!!CONTINUE!SEARCH!!!!!!!!!!!!!1.3#16
         BU        M1COR5.1        CONTINUE SEARCH               1.3#16
M1COR6   EQU       $                                             1.3#10
         LW        R6,0W,X1        GET DEFINED SIZE              1.3#14
         ANMW      R6,=X'00FFFFFF' KEEP ONLY THE SIZE            1.3#14
         CAMW      R6,M1CORVAL     COMPARE TO OBJECT ORG         1.3#14
         BLE       M1COR3          ILLEGAL ORG IF TOO BIG        1.3#14
         SBM       6,0,X1     ELSE MARK AS ORG POINT.            1.3#10
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
         NOP
*
M1CORVAL DATAW     0               HOLDS OBJECT CODE ORG VALUE   1.3#10
*
*-----------------------------------------------------------------------
         TITLE     M1LST    - END OF MODULE RECORD
***********************************************************************
*
*                  M1LST
*
***********************************************************************
*
*        LAST -F-  A PASS
*
***********************************************************************
M1LST    STF       R0,MOBSCREG     SAVE REGISTERS
         SBM       MPEND,MFLGS     SET PGM END FLAG
         LF        R0,MOBSCREG     RESTORE REGISTERS
         TRSW      R0              RETURN
         TITLE     MXE4B    - GET 4 BYTES FROM OBJECT RECORD
**********************************************************************
*
*                MXE4B
*
*******************************************************************
*
*        EXTRACT 4 BYTES FROM MCBUF STARTING AT IX IN R2
*        RETURN 4 BYTES IN R5
*
***********************************************************************
MXE4B    STW       R1,MXE4B99
         ZR        R5
         LI        R1,-4
MXE4B1   SLL       R5,8            POSITION FOR NEXT CHARACTER
         ADMB      R5,MCBUF,R2
         ADI       R2,1
         BIB       R1,MXE4B1       LOOP FOR 4 CHAR
         LW        R1,MXE4B99
         TRSW      R0
MXE4B99  DATAW     0
         TITLE     MXENM    - GET NAME FROM OBJECT RECORD
**********************************************************************
*
*                 MXENM
*
*******************************************************************
*
*        EXTRACT 0-8 CHARACTER NAME FROM BYTE 9-17 OF
*        MCBUF RECORD
*        0-8 CHARACTER NAME IS RETURNED LEFT  JUSTIFIED IN R6,R7
*
**********************************************************************
MXENM    STW       R1,MXENM97
         STW       R2,MXENM98
         LW        R6,=C'    '
         LW        R7,=C'    '
         STD       R6,MXENM99      CLEAR NAME AREA
         LB        R1,MBLKX        IX TO RECORD
         LB        R6,MCBUF+2B,R1  GET RECORD SIZE
         SUI       R6,8B           ADJUST FOR HEADER
         ZR        R2              INDEX FOR THE DESTINATION
         TRN       R6,R6           SET LOOP COUNTER
         BZ        MXENM2          ZERO LENGTH NAME
         ADI       R1,8B           IX TO 1ST CHARACTER
MXENM1   LB        R7,MCBUF,R1     GET NEXT CHAR
         STB       R7,MXENM99,X2   STORE NAME, LEFT JUSTIFIED.
         ABR       R1,31           POINT TO NEXT INPUT CHARACTER
         ABR       R2,31           POINT TO NEXT OUTPUT POSITION.
         BIB       R6,MXENM1       LOOP THRU NAME.
MXENM2   LD        R6,MXENM99      GET NAME
         LW        R1,MXENM97      RESTORE R1,R2
         LW        R2,MXENM98
         TRSW      R0
MXENM97  DATAW     0
MXENM98  DATAW     0
MXENM99  DATAD     0
         TITLE     MXBOUND  - BOUND ADDRESS
*********************************************************************
*
*                  MXBOUND
*
*******************************************************************
*        MXBOUND - BOUND ADDRESS TO SPECIFIED BOUNDING FACTOR
*
*                  R2 - ADDRESS TO BOUND
*                  R4 - BOUND REQUIRED
*        RETURNS BOUNDED ADDRESS IN R2
*                  # BYTES FOR BOUNDING IN R4
*
**********************************************************************
MXBOUND  STW       R6,MXBND98      SAVE R6-R7
         STW       R7,MXBND99
         TRR       R2,R7
         ZR        R6
         DVR       R4,R6
         TRR       R6,R6
         BEQ       MXBND1
         ABR       R7,31
MXBND1   ZR        R6
         MPR       R4,R6
         TRR       R7,R4           CALC # WORDS FOR BOUNDING
         SUR       R2,R4
         TRR       R7,R2           RETURN BOUNDED ADDRESS
         LW        R6,MXBND98      RESTORE R6-R7
         LW        R7,MXBND99
         TRSW      R0
MXBND98  DATAW     0
MXBND99  DATAW     0
         TITLE     M1ESD    - SECTION DEFINITION
**********************************************************************
*
*                  M1ESD
*
*        SECTION DEFINITION -1- A PASS
*
*                  SECTION RECORD
*
*         WORD     CONTENTS
*           0      D00110XX   (XX = BOUND FOR SECTION)
*           1      SECT# (1 BYTE) SECTION SIZE (3 BYTES)
*           2      NAME
*           3      (8 BYTES)
*
***********************************************************************
M1ESD    STF       R0,MOBSCREG     SAVE REGS
         LI        R2,4B           EXTRACT SECTION#,SIZE
         ADR       R1,R2
         BL        MXE4B           GET SECT#,SIZE
         STW       R5,M1ESD99      SAVE
         BL        MXENM           GET NAME
         STD       R6,M1ESD98      STORE NAME
M1ESD2   EQU       $
         LW        R4,=X'FF000000'
         LMW       R5,M1ESD99      GET SECTION #
         LW        R4,=X'00FFFFFF'
         LMW       R4,M1ESD99      GET SIZE
         TBM       7,M1ESD99       SECTION ZERO ?
         BS        M1ESD1          NOT SECT ZERO
         ARMW      R4,MOBJC        ACCUMULATIVE SIZE OF PROGRAM
M1ESD1   EQU       $
         ADMW      R4,=X'10000000' ADD SECT ID
         LD        R6,M1ESD98      GET NAME
         BL        MSYMS           STORE ENTRY IN SYMTAB
         LW        R1,MSYMC        GET CONTROL ENTRY
         SBM       8,0,R1          SET SECTION FLAG
         LF        R0,MOBSCREG
         TRSW      R0
M1ESD98  DATAD     0               TEMP STORAGE
M1ESD99  DATAW     0
         TITLE     M1ESTA   - SECTION TRANSFER ADDRESS
**********************************************************************
*
*                  M1ESTA
*
*        SECTION TRANSFER ADDRESS -4- A PASS
*
**********************************************************************
M1ESTA   STF       R0,MOBSCREG     SAVE REGISTERS               PR12264
         ABM       31,M1.TADE      INCREMENT TRAN ADDR COUNT    PR12264
         LW        R2,M1.TADE      GET TRAN ADDR COUNT          PR12264
         CI        R2,1            DO WE HAVE ONE               PR12264
         BLE       M1ESTA1         CONTINUE IF NOT              PR12264
         LW        R2,MMODW        ADDRESS OF MODULE ENTRY      PR12264
         LD        R6,2W,X2        GET MODULE NAME              PR12264
         LA        R3,M1TA.M1D     LOCATION IN MESSAGE          PR12264
         BL        XST2            PUT NAME IN MESSAGE          PR12264
         LD        R6,MPNAM        GET NAME OF CURR PROGRAM     PR12264
         LA        R3,M1TA.M3D     LOCATION IN MESSAGE          PR12264
         BL        XST2            PUT NAME IN MESSAGE          PR12264
         TRR       R2,R5           MODULE ADDRESS TO R5         PR12264
M1ESTA2  SUI       R5,4W           BACK IT DOWN AN ENTRY        PR12264
         LW        R4,=X'88000000' LOOK FOR MODULES AND PROGS   PR12264
         ZR        R7                                           PR12264
         BL        MSSCH           SEARCH SYMBOL TABLE          PR12264
         TRR       R5,R2           DID WE FIND ONE?             PR12264
         BZ        M1ESTA3         FIX UP AND CONTINUE IF NOT   PR12264
         TBM       0,0W,X2         MODULE ENTRY FOUND?          PR12264
         BS        M1ESTA3         YES...FIX UP AND CONTINUE    PR12264
         TBM       6,0W,X2         IS TRAN ADDR DEF'ED HERE?    PR12264
         BNS       M1ESTA2         KEEP SEARCHING IF NOT        PR12264
         LD        R6,2W,X2        ELSE GET PROGRAM NAME        PR12264
         LA        R3,M1TA.M2D     LOCATION IN MESSAGE          PR12264
         BL        XST2            PUT NAME IN MESSAGE          PR12264
         LNB       R5,M1TA.M1L     OUTPUT ERROR MESSAGE         PR12264
         LA        R6,M1TA.M1A                                  PR12264
         BL        XTYPEF                                       PR12264
         LNB       R5,M1TA.M2L     OUTPUT SECOND PART           PR12264
         LA        R6,M1TA.M2A                                  PR12264
         BL        XTYPEF                                       PR12264
         LNB       R5,M1TA.M3L     OUTPUT THIRD PART            PR12264
         LA        R6,M1TA.M3A                                  PR12264
         BL        XTYPEF                                       PR12264
         LF        R0,MOBSCREG     RESTORE REGISTERS            PR12264
         TRSW      R0              RETURN                       PR12264
M1ESTA3  LI        R2,1            INITIALIZE COUNT AGAIN       PR12264
         STW       R2,M1.TADE                                   PR12264
M1ESTA1  TRR       R1,R2
         ADI       R2,4            IX TO SECT#,ADDRESS
         BL        MXE4B
         LW        R1,MSYMC        OBTAIN CURR SYMTAB CONT ENTRY SLOT
         SUI       R1,4W           OBTAIN PGM NAME ENTRY ADDR
*                                  ASSEMBLER RECS MUST BE OUTPUT IN
*                                  THE ORDER ADVERTISED
         SBM       6,0,R1
         STW       R5,0+1W,R1      SAVE TRANS ADDR IN 2ND WORD  OF
*                                  PGM NAME ENTRY
         LW        R1,MMODW
         SBM       7,0,R1          FLAG MODULE ENTRY
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
         TITLE     M1ESED   - SECTION EXTERNAL DEFINITION
***********************************************************************
*
*                  M1ESED
*
*        SECTION EXTERNAL DEFINITION
*
************************************************************************
M1ESED   STF       R0,MOBSCREG
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS      EAID-32D
         BS        $+2W            IF YES SKIP ROOT SYM INCR    EAID-32D
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EAID-32D
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32D
         ABM       31,XSYMENT      BUMP LOCAL SYMBOLS           EAID-32D
         LB        R2,MBLKX
         ADI       R2,4B           IX TO SECT#,ADDRESS
         BL        MXE4B
         BL        MXENM           GET NAME
         BU        M1XDF1          MERGE WITH NON-EXT CODE       1.3#02+
*                                                                1.3#02+
         TITLE     M1ESER   - SECTION EXTERNAL REFERENCE
***********************************************************************
*
*                  M1ESER
*
*        SECTION EXTERNAL REFERENCE
*
***********************************************************************
M1ESER   STF       R0,MOBSCREG     SAVE REGS
         BL        MXENM           GET SYMBOL NAME INTO R6-R7
         BU        M1XRF4          GO PROCESS IN M1XRF
         TITLE     M1ECDF   - LARGE COMMON DEFINITION
********************************************************************
*
*                  M1ECDF
*
*                  LARGE COMMON BLOCK DEFINITION
*
********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
M1ECDF   STF       R0,MOBSCREG
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS?     EAID-32
         BS        $+2W            IF YES, SKIP ROOT SYM INCR   EAID-32
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON' BUMP SYM COUNT IF SO    S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32
         ABM       31,XSYMENT      BUMP LOCAL SYMBOLS           EAID-32
         LB        R2,MBLKX
         ADI       R2,4B           IX TO SECT#,SIZE
         BL        MXE4B
         BL        MXENM           GET COMMON NAME
         STD       R6,M1CDF91      SAVE FOR NORMAL COMMON CALL
         LW        R4,=X'FF000000' MASK FOR UPPER BYTE OF R5 (BLOCK NO.)
         TRRM      R5,R3           SAVE THE BLOCK NUMBER.
         TRC       R4,R4           CHANGE MASK TO PICK UP SIZE OF BLOCK.
         TRRM      R5,R4           MOVE SIZE INTO R4.
         SBR       R4,2            R4 = X'20"SIZE"'..
         BU        M1CDF1          GO PROCESS LIKE NORMAL COMMON
         TITLE     M1ECOR   - LARGE COMMON ORIGIN
**********************************************************************
*
*        M1ECOR
*
*********************************************************************
*
*        LARGE COMMON ORIGIN
*
***********************************************************************
M1ECOR   STF       R0,MOBSCREG
         LB        R1,MBLKX
         LB        R5,MCBUF+4B,R1  GET BLOCK #
         LB        R2,MCBUF+7B,X1  GET LAST BYTE OF ADDR         1.3#10
         SRLD      R2,8            SAVE IT                       1.3#10
         LB        R2,MCBUF+6B,X1  GET MIDDLE BYTE               1.3#10
         SRLD      R2,8            SAVE IT                       1.3#10
         LB        R2,MCBUF+5B,X1  GET FIRST BYTE                1.3#10
         SLLD      R2,16           ASSEMBLE ALL 3                1.3#10
         BU        M1COR0          GO PROCESS LIKE NORMAL COMMON
         TITLE     M2ABD    - ABSOLUTE DATA
***********************************************************************
*
*                  M2ABD
*
***********************************************************************
*
*        ABSOLUTE DATA -0-  B PASS
*
***********************************************************************
M2ABD    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         BL        MXNNN           OBTAIN NNNN VALUE
         STB       R5,MTCORCL3     MTCOR CALL PARAM
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-33F
         BNS       M2ABD0          NO...PROCESS NORMALLY        ELST-33F
         LA        R2,CSCTBASE     GET CSECT BASE ADDRESS       ELST-33F
         CAMW      R2,CURRBASE     PROCESSING CSECT DATA?       ELST-33F
         BNE       M2ABD0          NO...PROCESS MORMALLY        ELST-33F
         ZR        R2              CLEAR R2                     ELST-33G
         CI        R5,4            AT LEAST FOUR BYTES OF DATA  ELST-33F
         BLT       M2ABD0          NO...CAN'T BE BRANCH,EXM     ELST-33F
         BEQ       M2ABD3          BRANCH IF EXACTLY 4 BYTES    ELST-33F
         TRR       R1,R2           MOVE BUFFER INDEX TO R2      ELST-33G
         ZR        R3              CLEAR R3                     ELST-33G
M2ABD2   LB        R7,MCBUF+1B,X2  GET A BYTE OF OBJECT DATA    ELST-33G
         ZBR       R7,30           CLEAR NON-OPCODE BITS        ELST-33G
         ZBR       R7,31                                        ELST-33G
         CI        R7,X'34'        IS IT A LA INSTRUCTION?      ELST-33G
         BEQ       M2ABD6          PROCESS 4 BYTES IF SO        ELST-33G
         ZBR       R7,28           CLEAR 2ND NIBBLE OF OPCODE   ELST-33G
         ZBR       R7,29                                        ELST-33G
         CI        R7,X'50'        IS IT A LCX/STX INSTRUCTION  ELST-33G
         BEQ       M2ABD6          PROCESS 4 BYTES IF SO        ELST-33G
         TBR       R7,24           BIT ZERO OF OPCODE SET       ELST-33G
         BS        M2ABD6          PROCESS 4 BYTES IF SO        ELST-33G
         ADI       R2,2            ELSE SKIP HALFWORD INSTR.    ELST-33G
         ADI       R3,2            INCREMENT BYTE COUNT         ELST-33G
         CAMB      R3,MTCORCL3     ALL BYTES PROCESSED?         ELST-33G
         BLT       M2ABD2          FINISH PROCESSING IF NOT     ELST-33G
         BU        M2ABD7          ELSE STORE DATA IN IMAGE     ELST-33G
M2ABD6   LI        R4,-4           GET 4 BYTES OF DATA          ELST-33G
         ZR        R6                                           ELST-33G
M2ABD6B  LB        R7,MCBUF+1B,X2  LOAD ONE BYTE                ELST-33G
         SLL       R7,24           POSITION IT                  ELST-33G
         SLLD      R6,8                                         ELST-33G
         ADI       R2,1            INCREMENT POINTER            ELST-33G
         BIB       R4,M2ABD6B      GET NEXT BYTE                ELST-33G
         LW        R4,=X'FC900000' LOAD INSTRUCTION MASK        ELST-33G
         TRRM      R6,R5           MASK OFF DATA VALUE          ELST-33G
         BL        ISBRANCH        CHECK FOR BRANCH OR EXM      ELST-33G
         BNS       M2ABD6C         BRANCH IF NOT                ELST-33G
         LW        R4,=X'FFF00000' LOAD ADDRESS MASK            ELST-33G
         TRRM      R6,R5           OPCODE AND OTHERS TO R5      ELST-33G
         LW        R4,=X'000FFFFF' LOAD OPCODE MASK             ELST-33G
         TRRM      R6,R7           ADDRESS TO R7                ELST-33G
         SRL       R7,1            SHIFT ADDRESS                ELST-33G
         ORR       R7,R5           COMBINE ADDRESS AND OPCODE   ELST-33G
         SUI       R2,4            RESET POINTER                ELST-33G
         LI        R6,-4           MOVE 4 BYTES                 ELST-33G
M2ABD6D  ZR        R4                                           ELST-33G
         SLLD      R4,8            SHIFT OUT ONE BYTE           ELST-33G
         STB       R4,MCBUF+1B,X2  SAVE IN MCBUF                ELST-33G
         ADI       R2,1            INCREMENT POINTER            ELST-33G
         BIB       R6,M2ABD6D      SAVE NEXT BYTE               ELST-33G
M2ABD6C  SUI       R2,4            RESET POINTER                ELST-33H
         ADI       R2,4            MOVE TO NEXT WORD OF DATA    ELST-33G
         ADI       R3,4            SHOW ONE WORD PROCESSED      ELST-33G
         CAMB      R3,MTCORCL3     ALL DATA PROCESSED?          ELST-33G
         BLT       M2ABD2          NO...BRANCH                  ELST-33G
         BU        M2ABD7          ELSE PUT DATA IN IMAGE       ELST-33G
M2ABD3   ADR       R1,R2           ADD IN MCBUF INDEX           ELST-33F
         ZR        R6                                           ELST-33F
         LI        R4,-4           GET 4 BYTES OF DATA          ELST-33F
M2ABD4   LB        R7,MCBUF+1B,X2  LOAD ONE BYTE                ELST-33F
         SLL       R7,24           POSITION IT                  ELST-33F
         SLLD      R6,8                                         ELST-33F
         ADI       R2,1            INCREMENT POINTER            ELST-33F
         BIB       R4,M2ABD4       GET NEXT BYTE                ELST-33F
         LW        R4,=X'FC900000' LOAD INSTRUCTION MASK        ELST-33F
         TRRM      R6,R5           MASK OFF DATA VALUE          ELST-33F
         BL        ISBRANCH        CHECK FOR BRANCH OR EXM      ELST-33F
         BNS       M2ABD7          BRANCH IF NOT                ELST-33F
         LW        R4,=X'FFF80000' LOAD ADDRESS MASK            ELST-33F
         TRRM      R6,R5           OPCODE AND OTHERS TO R5      ELST-33F
         LW        R4,=X'0007FFFF' GET OPCODE MASK              ELST-33F
         TRRM      R6,R7           ADDRESS TO R7                ELST-33F
         SRL       R7,1            SHIFT ADDRESS                ELST-33F
         ORR       R7,R5           COMBINE ADDR AND OPCODE      ELST-33F
         SUI       R2,4            RESET POINTER                ELST-33F
         LI        R6,-4           MOVE FOUR BYTES              ELST-33F
M2ABD5   ZR        R4                                           ELST-33F
         SLLD      R4,8            SHIFT OUT ONE BYTE           ELST-33F
         STB       R4,MCBUF+1B,X2  SAVE IN MCBUF                ELST-33F
         ADI       R2,1            INCREMENT POINTER            ELST-33F
         BIB       R6,M2ABD5       SAVE NEXT BYTE               ELST-33F
M2ABD7   LB        R5,MTCORCL3     RESTORE DATA LENGTH          ELST-33F
M2ABD0   TRN       R5,R2           NO. BYTES COUNTER
         ZR        R3
M2ABD1   LB        R6,MCBUF+1B,R1
         STB       R6,MTCORCL2,R3  STORE DATA IN CALL 2 LEFT JUSTIFIED
         ABR       R1,31           UPDATE SOURCE POINTER
         ABR       R3,31           UPDATE DESTINATION INDEX
         BIB       R2,M2ABD1
         LI        R1,MT.ABS       CALL TYPE-STORE ABS BYTES
         BL        MTCOR
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
         TITLE     M2POR    - PROGRAM ORIGIN
***********************************************************************
*
*                  M2POR
*
***********************************************************************
*
*        PROGRAM ORIGIN -1-  B PASS
*
***********************************************************************
M2POR    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LB        R1,MBLKX        IX
         LI        R4,X'7'
         ZMB       MTCORCL2        ZAP FIRST BYTE OF ARGUMENT    1.3#08
         LMB       R5,MCBUF+1B,R1  1ST BYTE OF ADDRESS
         STB       R5,MTCORCL2+1B  MTCOR CALL 2
         LB        R5,MCBUF+2B,R1  2ND
         STB       R5,MTCORCL2+2B
         LB        R5,MCBUF+3B,R1  3RD
         STB       R5,MTCORCL2+3B
         LI        R1,MT.SORG      CALL TYPE-SET ORIGIN
         BL        MTCOR
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
         TITLE     M2ABR    - ABSOLUTE DATA / REPEAT
***********************************************************************
*
*                  M2ABR
*
***********************************************************************
*
*        ABSOLUTE DATA AND REPEAT LOAD -2-  B PASS
*
***********************************************************************
M2ABR    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         BL        MXNNN           OBTAIN NNNN VALUE
         SUI       R5,1            FOR REPT COUNT
         STW       R5,M2ABR91      SAVE
         LB        R2,MBLKX
         LB        R1,MCBUF+1B,R2  REPT COUNT
         TRN       R1,R1
M2ABR1   STW       R1,M2ABR92      SAVE
         LW        R6,M2ABR91      NNNN VALUE
         STB       R6,MTCORCL3     MTCOR CALL
         TRN       R6,R6
         ZR        R3              STORE REG
         LB        R2,MBLKX        IX
M2ABR2   ADI       R2,1            INCREMENT BUFFER INDEX
         LB        R5,MCBUF+1B,R2
         STB       R5,MTCORCL2,R3  MTCOR CALL
         ADI       R3,1            INCREMENT OUTPUT INDEX
         BIB       R6,M2ABR2
         LI        R1,MT.ABS       CALL TYPE-STORE ABS DATA
         BL        MTCOR           STORE
         LW        R1,M2ABR92      NO. REPT
         BIB       R1,M2ABR1
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
M2ABR91  DATAW     0               NNNN VALUE
M2ABR92  DATAW     0               REPT COUNT, NEG
         TITLE     M2RLD    - RELOCATABLE DATA
***********************************************************************
*
*                  M2RLD
*
***********************************************************************
*
*        RELOCATABLE DATA -4-  B PASS
*
***********************************************************************
M2RLD    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         BL        MXNNN           OBTAIN NNNN VALUE
         TRR       R5,R4
         ZR        R5
         SRLD      R4,2
         TRN       R4,R4
         TRR       R5,R5
         BEQ       M2RLD1          BR IF A WORD MULTIPLE
         LI        R5,E.BOUND      BOUND ERROR MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M2RLD1   LB        R2,MBLKX        IX
M2RLD2   LB        R5,MCBUF+1B,R2
         STB       R5,MTCORCL2     MTCOR CALL
         LB        R5,MCBUF+2B,R2
         STB       R5,MTCORCL2+1B
         LB        R5,MCBUF+3B,R2
         STB       R5,MTCORCL2+2B
         LB        R5,MCBUF+4B,R2
         STB       R5,MTCORCL2+3B
         LI        R1,MT.REL       CALL TYPE-REL WD
         BL        MTCOR           STORE DATA
         ADI       R2,1W           NEXT WORD
         BIB       R4,M2RLD2
         LF        R0,MOBSCREG     RESTORE REGS
         TRSW      R0              RETURN
*
************************************************************************
*
*        M2PNM - SAVES NAME OF PROGRAM BEING PROCESSED FOR      ELST-33F
*                OUTPUT IN ERROR MESSAGES.                      ELST-33F
*
************************************************************************
M2PNM    STF       R0,M2PNMSAV     SAVE REGISTERS               ELST-33F
         LI        R4,3                                         ELST-33F
         BL        MGETNAME        GET PROGRAM NAME FROM RECORD ELST-33F
         STD       R6,PROGNAM      SAVE PROGRAM NAME FOR LATER  ELST-33F
         LF        R0,M2PNMSAV     RESTORE REGISTERS            ELST-33F
         TRSW      R0              RETURN                       ELST-33F
*
M2PNMSAV REZ       8W                                           ELST-33F
PROGNAM  DATAD     C'        '                                  ELST-33F
*
         TITLE     M2RLR    - RELOCATABLE DATA / REPEAT
***********************************************************************
*
*                  M2RLR
*
***********************************************************************
*
*        RELOCATABLE DATA AND REPEAT LOAD -6-  B PASS
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
M2RLR    STF       R0,MOBSCREG     SAVE REGS
         BL        MXNNN           EXTRACT NNNN VALUE
         SUI       R5,1
         LI        R4,3
         TRRM      R5,R6           NO. BYTES A MULTIPLE OF 4
         BNE       M2RLR1          BR IF SO
         LI        R5,E.BOUND      BOUND ERROR MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M2RLR1   TRN       R5,R6
         LB        R1,MBLKX
         ZR        R2
M2RLR2   LB        R7,MCBUF+1B,R1  EXTRACT NNNN BYTES OF DATA
         STB       R7,M2RLR91,R2
         ABR       R1,31           INCREMENT BUFFER INDEX
         ABR       R2,31           INCREMENT OUTPUT INDEX
         BIB       R6,M2RLR2
         LB        R1,MBLKX
         LB        R4,MCBUF+1B,R1  REPT COUNT
         TRN       R4,R6           IN R6
M2RLR5   TRN       R5,R7           R7 NNNN WD COUNTER
         ZR        R2
M2RLR6   LW        R4,M2RLR91,R2
         STW       R4,MTCORCL2     MTCOR CALL
         LI        R1,MT.REL       CALL TYPE-STORE REL WD
         BL        MTCOR
         ADI       R2,1W           INCREMENT BUFFER INDEX
         BIW       R7,M2RLR6
         BIB       R6,M2RLR5
         LF        R0,MOBSCREG
         TRSW      R0              RETURN
M2RLR91  RES       4W              TEMP STORAGE
         PAGE
*
         TITLE     M2XDF
***********************************************************************
*                                                               EAID-32
*                  M2XDF                                        EAID-32
*                                                               EAID-32
***********************************************************************
*                                                               EAID-32
*        EXTERNAL DEF -7-  B PASS                               EAID-32
*                                                               EAID-32
***********************************************************************
M2XDF    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA     EAID-32
         LI        R4,3            THREE BYTES FOLLOWING NAME   EAID-32
         BL        MGETNAME        GET THE PROG NAME INTO R7-R6 EAID-32
*                                                               EAID-32
* OUTPUT SYMBOLIC DEBUGGER ITEM TO TEMP FILE                    EAID-32
*                                                               EAID-32
         STD       R6,XSYMBUF      STORE PROG NAME IN WORDS 0,1 EAID-32
*                                                               EAID-32
*  AID MOD TO SEARCH FOR PROGRAM ID IN CURRENT SEGMENT FIRST    EAID-32
*                                                               EAID-32
         LW        R5,MMODW        ADDR IN SYM TBL OF CUR SEG   EAID-32
         LW        R4,=X'40000000' LOOK FOR PROG ID IN SYM TAB  EAID-32
         BL        MSSCH                                        EAID-32
         TRR       R5,R1                                        EAID-32
         BNZ       AID.XDF            BRANCH IF FOUND           EAID-32
*                                                               EAID-32
*  END OF AID MOD                                               EAID-32
*                                                               EAID-32
         ZR        R5                                           EAID-32
         LW        R4,=X'40000000' LOOK FOR PROG ID IN SYM TAB  EAID-32
         BL        MSSCH                                        EAID-32
         TRR       R5,R1                                        EAID-32
*                                                               EAID-32
AID.XDF  LW        R4,=X'000FFFFF'                              EAID-32
         LMW       R5,1W,X1        . BUILD ADDRESS OF PROGRAM   EAID-32
         ORMW      R5,=X'0F000000'  INDICATE TYPE 15 (PROCEDURE)EAID-32
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE           EAID-32
         BNS       M2XDF.1         BR IF NOT ABSOLUTE           EAID-32
         ADMW      R5,MPABS        ADD IN ABSOLUTE BASE         EAID-32
M2XDF.1  STW       R5,XSYMBUF+2W   . STORE IN RECORD WORD THREE EAID-32
         ZMW       XSYMBUF+3W      . WORD FOUR IS EQUAL TO ZERO EAID-32
         TBM       3,XSYMFLGS      IS THIS AN ABSOLUTE MODULE ? EAID-32
         BNS       M2XDF.2         BR IF MODULE NOT ABSOLUTE    EAID-32
         SBM       31,XSYMBUF+3W   SET ABSOLUTE BIT             EAID-32
M2XDF.2  BL        XDBGSYM                                      EAID-32
M2XDF.3  LF        R0,MOBSCREG                                  EAID-32
         TRSW      R0              RETURN                       EAID-32
         TITLE     M2FSB    - FORWARD STRING BACK
***********************************************************************
*
*                  M2FSB
*
***********************************************************************
*
*        FORWARD REFERENCE STRING BACK -8-  B PASS
*
***********************************************************************
M2FSB    STF       R0,MOBSCREG     SAVE REGS
         ZR        R6
         ZR        R7
         LI        R4,-6           ITN CNTR
         LB        R1,MBLKX        IX
M2FSB1   ADI       R1,1            INCREMENT BUFFER INDEX
         LB        R5,MCBUF,R1     EXTRACT ADDRESSES
         ADR       R5,R7
         SLLD      R6,8
         BIB       R4,M2FSB1
         SRL       R7,8            RT JUST ADDR 2
         TBR       R6,8            IS THIS DATA ABSOLUTE
         BNS       M2FSB2          BR IF ABSOLUTE
         LW        R2,CURRBASE     SET DOPE VECTOR BASE          1.3#05
         ADMW      R6,MDSTORG,X2       ADD IN PROGRAM BASE
         LA        R5,CSCTBASE     GET ADR OF CSECT DOPE VECTOR  1.3#05
         CAR       R2,R5           ARE WE IN CSECT               1.3#05
         BEQ       M2FSB2          SKIP IF WE ARE                1.3#05
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BNS       M2FSB2          BR IF NOT ABSOLUTE
         ADMW      R6,MPABS        ADD ABSOLUTE BASE
M2FSB2   BL        M2E.STRB        STRING ADDR BACK
         LF        R0,MOBSCREG
         TRSW      R0              RETURN
         TITLE     M2XRF    - EXTERNAL REFERENCE
***********************************************************************
*
*                  M2XRF
*
***********************************************************************
*
*        EXTERNAL REFERENCE -9-  B PASS
*
***********************************************************************
M2XRF    STF       R0,MOBSCREG     SAVE REGISTERS
         LI        R4,3            THREE BYTES FOLLOWING NAME
         BL        MGETNAME        EXTRACT NAME FROM OBJECT FILE
         TRR       R5,R3           STRING BACK ADDRESS TO R3
         BU        M2ESER0         JOIN SECTION EXTERNAL REFERENCE
         PAGE
*
         TITLE     M2CDF
***********************************************************************
*                                                               EAID-32
*                  M2CDF                                        EAID-32
*                                                               EAID-32
***********************************************************************
*                                                               EAID-32
*        COMMON   DEF -A-  B PASS                               EAID-32
*                                                               EAID-32
***********************************************************************
M2CDF    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA     EAID-32
         LI        R4,3            THREE BYTES FOLLOWING NAME   EAID-32
         BL        MGETNAME        GET THE PROG NAME INTO R7-R6 EAID-32
*                                                               EAID-32
* OUTPUT SYMBOLIC DEBUGGER ITEM TO TEMP FILE                    EAID-32
*                                                               EAID-32
         STD       R6,XSYMBUF      STORE PROG NAME IN WORDS 0,1 EAID-32
         LI        R3,X'20'                                     EAID-32
*                                                               EAID-32
         ZR        R5                                           EAID-32
AID.CDF0 LW        R4,=X'21000000'  LOOK FOR PROG ID IN SYM TAB EAID-32
         BL        MSSCH                                        EAID-32
         TRR       R5,R1                                        EAID-32
*                                                               EAID-32
AID.CDF  LW        R4,=X'000FFFFF'                              EAID-32
         CAMB      R3,0,X1         IS THIS A X'20'              EAID-32
         BNE       AID.CDF1        NO, IT'S OK                  EAID-32
         SUI       R1,4W           POINT TO NEXT ENTRY          EAID-32
         TRR       R1,R5                                        EAID-32
         BU        AID.CDF0        TRY AGAIN                    EAID-32
AID.CDF1 EQU       $                                            EAID-32
         LW        R4,=X'00FFFFFF' LOAD ADDRESS MASK            C023-34
         LMW       R5,1W,X1        . BUILD ADDRESS OF PROGRAM   EAID-32
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE           EAID-32
         BNS       M2CDF.1         BR IF NOT ABSOLUTE           EAID-32
         ADMW      R5,MPABS        ADD IN ABSOLUTE BASE         EAID-32
M2CDF.1  STW       R5,XSYMBUF+2W   . STORE IN RECORD WORD THREE EAID-32
         ZMW       XSYMBUF+3W      . WORD FOUR IS EQUAL TO ZERO EAID-32
         LI        R4,X'10'                                     EAID-32
         STB       R4,XSYMBUF+2W     COMMON IS TYPE 16          EAID-32
         TBM       3,XSYMFLGS      IS THIS AN ABSOLUTE MODULE ? EAID-32
         BNS       M2CDF.2         BR IF MODULE NOT ABSOLUTE    EAID-32
         SBM       31,XSYMBUF+3W   SET ABSOLUTE BIT             EAID-32
M2CDF.2  BL        XDBGSYM         OUTPUT BUFFER AND CLEAR      EAID-32
M2CDF.3  LF        R0,MOBSCREG                                  EAID-32
         TRSW      R0              RETURN                       EAID-32
         TITLE     M2CRF    - COMMON REFERENCE
***********************************************************************
*
*                  M2CRF
*
***********************************************************************
*
*        COMMON REFERENCE -B-  B PASS
*
***********************************************************************
M2CRF    STF       R0,MOBSCREG     SAVE REGS
         LB        R2,MBLKX
         LB        R5,MCBUF+1B,R2  GET BLOCK #
         STB       R5,M2CRF89      SAVE BLOCK #
         STB       R2,M2CRF88      SAVE IX TO DATA -2B
         BL        MXNNN           GET # BYTES OF DATA
         SUI       R5,1B
         STB       R5,M2CRF87      SAVE # BYTES OF DATA
M2CRF0   EQU       $               ENTRY FROM 'M2ECRF'..
         ZMB       M2CRF90
M2CRF1   LW        R4,=X'FFFF'
         LW        R1,MSYMC        ADDR OF CONT ENTRY
         LMW       R2,0,R1         OBTAIN NO. ENTRIES FOR ELEMENT
         TRN       R2,R6           PREP TO SCH FOR MATCHING BLOCK NO.
M2CRF2   TBM       2,0,R1          COMMON ID BIT
         BS        M2CRF4          BRANCH IF 'COMMON' ENTRY.
M2CRF3   SUI       R1,4W           NEXT SYMTAB ENTRY
         BIB       R6,M2CRF2
         LI        R5,E.COMREF     REFERENCE TO UNDEFINED COMMON BLK
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M2CRF4   LB        R5,M2CRF89      GET BLOCK #
         CAMB      R5,4B,R1        DO THE BLOCK NUMBERS MATCH?
         BNE       M2CRF3          CONTINUE SEARCHING IF NOT.
M2CRF5   LW        R4,=X'03000000'
         LMW       R5,0,X1         FLAGS FROM SYMTAB ENTRY
         BNE       M2CRF6          BRANCH IF ADDRESS IS THE ENTRY.
         LW        R1,1W,X1        LOAD POINTER INTO R1
M2CRF6   LW        R4,=X'00FFFFFF' LOAD MASK INTO R4
         LMW       R7,1W,R1
         TBM       3,0,R1          IS THIS ENTRY GLOBAL?
         BNS       M2CRF7          BR IF NOT GLOBAL
         SBM       7,M2CRF90
M2CRF7   LB        R2,M2CRF88      GET INDEX TO THE DATA.
         LB        R5,M2CRF87      GET # BYTES OF DATA
         ZR        R4
         DVI       R4,4B
         TRN       R5,R3
         TRR       R4,R4
         BEQ       M2CRF7.5        BR IF REF A WORD MULTIPLE
         LI        R5,E.BOUND      BOUND ERROR MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M2CRF7.5 LI        R0,-4
         ZR        R5
M2CRF8   SLL       R5,8
         LB        R4,MCBUF+2B,R2  COMM REF TO R5
         ADR       R4,R5
         ABR       R2,31
         BIB       R0,M2CRF8
         LW        R4,=X'0007FFFC'
         TRRM      R5,R6           EXTRACT THE ADDRESS REFERENCED
         ADR       R7,R6           ADD THE LOC OF THE COMMON BLOCK
         TRRM      R6,R6           IN CASE OF OVERFLOW FROM ADDR FIELD
         TRC       R4,R4           FFF80003 MASK
         ANR       R4,R5           ELIM ADDR
         ADR       R6,R5           REF IN R5
         STW       R5,MTCORCL2     MTCOR CALL
         LI        R1,MT.COM       STORE COMMON REFERENCE
         TBM       7,M2CRF90
         BNS       M2CRF9          BR IF NOT GLOBAL
         LI        R5,4B           4 BYTES OF IMMEDIATE DATA
         STB       R5,MTCORCL3
         LI        R1,MT.ABS       STORE ABS BYTES
M2CRF9   BL        MTCOR           STORE WORD
         BIB       R3,M2CRF7.5
         LF        R0,MOBSCREG
         TRSW      R0              RETURN
M2CRF87  DATAB     0               # BYTES OF DATA
M2CRF88  DATAB     0               IX TO 1ST BYTE -2B
M2CRF89  DATAB     0               BLOCK #
M2CRF90  DATAB     0               SET TO 1 IF REF TO GLOBAL COMMON
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     M2DPL    - DATAPOOL REFERENCE
***********************************************************************
*
*                  M2DPL
*
***********************************************************************
*
*        DATAPOOL REFERENCE -C-
*
***********************************************************************
M2DPL    STF       R0,MOBSCREG     SAVE REGS
         TBM       XMDPR,XFLGS     SEE IF MULT. DATAPOOL         11017
         BNS       M2DPL2          IF NOT BRANCH                 11017
         LB        R1,MBLKX        GET INDEX INTO OBJECT         11017
         LB        R3,MCBUF+2B,X1  GET LENGTH OF OBJECT CODE     11017
         SUI       R3,9            CALCULATE NAME SIZE           11017
         ADI       R1,4            LINE UP WITH NAME             11017
         TRN       R3,R3                                         11017
         ZR        R2                                            11017
M2DPL1.7 LB        R5,MCBUF,X1     GET NAME                      11017
         STB       R5,M2DPL91,X2   AND STORE                     11017
         ABR       R2,31           INCREMENT INDEX               11017
         ABR       R1,31                                         11017
         BIB       R3,M2DPL1.7                                   11017
         SUI       R2,8            SEE IF FULL 8 CHARACTERS      11017
         BEQ       M2DPLINS        IF SO BRANCH                  11017
         LI        R5,X'20'        BLANK FILL REST               11017
         LI        R3,8                                          11017
         ADR       R2,R3                                         11017
M2DPL1.8 STB       R5,M2DPL91,X3                                 11017
         ABR       R3,31                                         11017
         BIB       R2,M2DPL1.8                                   11017
         ZR        R2                                            11017
M2DPLINS LI        R3,-4           LENGTH OF REFERENCE           11017
M2DPL1.9 LB        R5,MCBUF,X1     GET REFERENCE                 11017
         STB       R5,M2DPL92,X2   AND STORE                     11017
         ABR       R2,31                                         11017
         ABR       R1,31                                         11017
         BIB       R3,M2DPL1.9                                   11017
         LB        R5,MCBUF,X1     GET DPOOL NUMBER              11017
         STB       R5,M2DPL93      STORE DPOOL NUM.              11017
         BU        M2DPL3                                        11017
M2DPL2   EQU       $                                             11017
         LI        R4,4            FOUR BYTES FOLLOW DATAPOOL NAME.
         BL        MGETNAME        EXTRACT NAME FROM OBJECT FILE
         STD       R6,M2DPL91      SAVE DATAPOOL NAME.
         STW       R5,M2DPL92      SAVE DATAPOOL ITEM REFERENCE.
         LI        R4,100          SET FOR "DATAPOOL"            1.3#15
         STB       R4,M2DPL93                                    1.3#15
*
*    COMMON PROCESSING FOR BOTH DATAPOOL AND DPOOLNN
*
M2DPL3   EQU       $                                             1.3#15
         LD        R6,M2DPL91
*                                                                1.3#15
         LB        R5,M2DPL93      GET NUMBER                    1.3#15
         BL        XGETDP          FIND SYMBOL                   1.3#15
         BNS       M2DPL12         BR IF NAME FOUND
*                                                                1.3#05
*   UNDEFINED DATAPOOL REFERENCES ARE NOW LOGGED ON THE FLY      1.3#05
*                                                                1.3#05
*                                                                1.3#05
M2DPL7   EQU       $                                             1.3#05
         LW        R2,CURRBASE     GET PNTERS FOR CURR REGION    1.3#15
         LW        R4,MDSTNXT,X2   GET ADDR OF NEXT LOCATION     1.3#15
         SUMW      R4,MDSTPEB,X2   MINUS START OF PROGRAM        1.3#15
         LB        R5,M2DPL93      GET POOL NUMBER               1.3#05
         BL        XUNDFLOG        AND ISSUE MESSAGE             1.3#05
         SBM       XABORTFL,XFLGS  SET FLAG TO FORCE ABORT       1.3#15
*                                                                1.3#05
M2DPL8   LI        R1,MT.ABS       CODE FOR ABS DATA
         LW        R3,M2DPL8.6     LOAD VALUE TO STORE           1.3#15
         STW       R3,MTCORCL2
         LI        R4,4B           BYTE COUNT FOR ABS DATA
         STB       R4,MTCORCL3
         BL        MTCOR           STORE NOP NOP INTO MEMORY
M2DPL8.5 LF        R0,MOBSCREG
         TRSW      R0              RETURN
         NOP                       BOUNDING                      1.3#15
M2DPL8.6 M.DEBUG                   CALL DEBUGER IF VAR REF'D     1.3#15
*--------
*
M2DPL12  LW        R3,M2DPL92
         SLL       R5,13           CLEAR OFF DPOOL NUM.          11017
         SRL       R5,13                                         11017
         LB        R1,M2DPL93      GET POOL NUMBER               1.3#15
         SLL       R1,4            CONVERT TO TABLE INDEX        1.3#15
         ADMW      R5,DPOOLTAB+PRTSTRT,X1    ADD PARTITION STRT  1.3#15
         CAMW      R5,DPOOLTAB+PRTEND,X1     COMPARE TO END      1.3#15
         BLT       M2DPL13         SKIP IF OK                    1.3#15
         LD        R6,M2DPL91      GET SYMBOL                    1.3#15
         LA        R3,M2DL.M1D     LOCATE                        1.3#15
         BL        XST2            AND STUFF                     1.3#15
         LB        R5,M2DPL93      GET PARTITION NUMBER          1.3#15
         CI        R5,100          IS IT DATAPOOL                1.3#15
         BEQ       M2DPL121        SKIP IF IT IS                 1.3#15
         M.CONBAD                  CONVERT                       1.3#15
         ANMW      R7,=X'0000FFFF'  KEEP TWO DIGITS              1.3#15
         SLL       R7,8            POSITION                      1.3#15
         ORMW      R7,=G'L"@@"@@ '   AND ADD IN   L"00"^           1.3#15
         LW        R6,=G'DPOO'     PLUS TOP HALF                 1.3#15
         BU        M2DPL122                                      1.3#15
M2DPL121 EQU       $                                             1.3#15
         LD        R6,DPNAME                                     1.3#15
M2DPL122 EQU       $                                             1.3#15
         LA        R3,M2DL.M1E     LOCATE                        1.3#15
         BL        XST2            AND STUFF                     1.3#15
         LNB       R5,M2DL.M1L                                   1.3#15
         LA        R6,M2DL.M1A                                   1.3#15
         BL        XTYPE                                         1.3#15
         LW        R2,CURRBASE     GET PNTERS FOR CURR REGION    1.3#15
         LW        R7,MDSTNXT,X2   GET ADDR OF NEXT LOCATION     1.3#15
         SUMW      R7,MDSTPEB,X2   MINUS START OF PROGRAM        1.3#15
         BL        XREFINFO        AND ISSUE MESSAGE             1.3#05
         SBM       XABORTFL,XFLGS  FORCE ABORT EXIT              1.3#15
         BU        M2DPL8          AND PLUG CATCHER VALUE        1.3#15
M2DPL13  EQU       $                                             1.3#15
         SLLD      R2,13
         SRL       R3,13
         ADR       R5,R3           ADD ADDRESS TO REFERENCE
         SLL       R3,13
         SRLD      R2,13
         LI        R1,MT.ABS       CODE FOR ABS DATA
         STW       R3,MTCORCL2
         LI        R4,4B
         STB       R4,MTCORCL3
         BL        MTCOR           STORE DATA
         BU        M2DPL8.5
M2DPL91  DATAD     0
M2DPL92  DATAW     0               DATAPOOL REFERENCE
M2DPL93  DATAB     0               DPOOL NUMBER                  11017
*                                                                1.3#15
M2DL.M1A DATAB     C' CATALOG(WARNING) VARIABLE: '               1.3#15
M2DL.M1D REZ       8B              DATAPOOL SYSMBOL              1.3#15
         DATAB     C', OUTSIDE LIMITS OF PARTITION: '            1.3#15
M2DL.M1E REZ       8B              PARTITION NAME                1.3#15
         DATAB     C'.'                                          1.3#15
M2DL.M1L DATAB     $-M2DL.M1A                                    1.3#15
         BOUND     1W                                            1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
         TITLE     M2COR    - COMMON ORIGIN
***********************************************************************
*
*                  M2COR
*
***********************************************************************
*
*        COMMON ORIGIN -E- B PASS
*
***********************************************************************
M2COR    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LB        R1,MBLKX
         LB        R4,MCBUF+1B,R1  GET BLOCK #
         STB       R4,M2COR99      SAVE BLOCK #
         LB        R6,MCBUF+3B,R1  EXTRACT DISPLACEMENT (NO. BYTES)
         SRLD      R6,8
         LB        R6,MCBUF+2B,R1
         SLLD      R6,8
         STW       R6,M2COR98      SAVE ORIGIN
M2COR0   EQU       $               ENTRY POINT FROM M2ECOR
         LW        R4,=X'20000000' COMMON ID
         LW        R5,MSYMC
         ZR        R7
M2COR1   EQU       $
         BL        MSSCH           SCH FOR PGM ELEMT'S COMM ENTRIES
         TRR       R5,R2
         SUI       R5,4W           NEXT ENTRY
         LB        R3,4B,R2
         CAMB      R3,M2COR99
         BNE       M2COR1          BR IF NOT CORRECT BLOCK #
         LW        R5,1W,R2        GET MODULE RELATIVE ADDR OF COMMON
         ANMW      R5,=X'FFFFFF'   STRIP OFF COMMON BLOCK NUMBER
         ADMW      R5,M2COR98      ADD ORIGIN TO COMMON'S ADDRESS
         LW        R1,MSYMC        GET ADDRESS OF CONTROL ENTRY
         SUMW      R5,3W,R1        SUBTRACT ADDRESS OF PROGRAM ELEMENT
         STW       R5,MTCORCL2
         LA        R1,DSCTBASE     MAKE SURE WE'RE IN DSECT      1.3#07
         STW       R1,CURRBASE                                   1.3#07
         LI        R1,MT.RORG      RESET ORIGIN
         BL        MTCOR           RESET ORIGIN
         LF        R0,MOBSCREG
         TRSW      R0
M2COR99  DATAB     0               BLOCK #
M2COR98  DATAW     0               ORIGIN
         PAGE
*
         TITLE     M2ECDF
***********************************************************************
*                                                               EAID-32
*                  M2ECDF                                       EAID-32
*                                                               EAID-32
***********************************************************************
*                                                               EAID-32
*        COMMON   DEF -A-  B PASS                               EAID-32
*                                                               EAID-32
***********************************************************************
M2ECDF   STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA     EAID-32
*        LI        R4,3            THREE BYTES FOLLOWING NAME   EAID-32
*        BL        MGETNAME        GET THE PROG NAME INTO R7-R6 EAID-32
         LB        R2,MBLKX                                     EAID-32
         ADI       R2,4B                                        EAID-32
         BL        MXE4B                                        EAID-32
         BL        MXENM                                        EAID-32
*                                                               EAID-32
* OUTPUT SYMBOLIC DEBUGGER ITEM TO TEMP FILE                    EAID-32
*                                                               EAID-32
         STD       R6,XSYMBUF      STORE PROG NAME IN WORDS 0,1 EAID-32
         LI        R3,X'20'        WE DON'T WANT X'20' (S)      EAID-32
*                                                               EAID-32
         ZR        R5                                           EAID-32
         LW        R4,=X'21000000'  LOOK FOR PROG ID IN SYM TAB EAID-32
AID.EDF0 BL        MSSCH                                        EAID-32
         TRR       R5,R1                                        EAID-32
*                                                               EAID-32
AID.ECDF LW        R4,=X'000FFFFF'                              EAID-32
         CAMB      R3,0,X1         IS THIS A X'20'              EAID-32
         BNE       AID.EDF1        NO, IT'S OK                  EAID-32
         SUI       R1,4W           POINT TO NEXT ENTRY          EAID-32
         TRR       R1,R5                                        EAID-32
         BU        AID.EDF0        TRY AGAIN                    EAID-32
AID.EDF1 EQU       $                                            EAID-32
         LW        R4,=X'00FFFFFF' LOAD ADDRESS MASK            C023-34
         LMW       R5,1W,X1        . BUILD ADDRESS OF PROGRAM   EAID-32
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE           EAID-32
         BNS       M2ECDF1         BR IF NOT ABSOLUTE           EAID-32
         ADMW      R5,MPABS        ADD IN ABSOLUTE BASE         EAID-32
M2ECDF1  STW       R5,XSYMBUF+2W   . STORE IN RECORD WORD THREE EAID-32
         ZMW       XSYMBUF+3W      . WORD FOUR IS EQUAL TO ZERO EAID-32
         LI        R4,X'10'                                     EAID-32
         STB       R4,XSYMBUF+2W     COMMON IS TYPE 16          EAID-32
         TBM       3,XSYMFLGS      IS THIS AN ABSOLUTE MODULE ? EAID-32
         BNS       M2ECDF2         BR IF MODULE NOT ABSOLUTE    EAID-32
         SBM       31,XSYMBUF+3W   SET ABSOLUTE BIT             EAID-32
M2ECDF2  BL        XDBGSYM         OUTPUT BUFFER AND CLEAR      EAID-32
M2ECDF3  LF        R0,MOBSCREG                                  EAID-32
         TRSW      R0              RETURN                       EAID-32
         TITLE     M2ESO.D  - SECTION ORIGIN / DEFINITION
*********************************************************************
*
*                  M2ESO.D
*
*******************************************************************
*
*        SECTION ORIGIN / SECTION DEFINITION
*
********************************************************************
M2ESO.D  STF       R0,MOBSCREG     SAVE REGS
         LB        R2,MBLKX
         ADI       R2,4B           POINT TO SECTION#,ADDRESS
         BL        MXE4B
         LI        R1,MT.CORG      ASSUME CSECT ORIGIN
         ZBR       R5,7            CLEAR SECTION NUMBER
         BS        M2ESO1          BRANCH IF CSECT
         LI        R1,MT.SORG      SET ORIGIN (DSECT)
*GKB.5T  ADMW      R5,MSEC1        BIAS SECTION 0 STORAGE BY SECTION 1 S
M2ESO1   STW       R5,MTCORCL2
         BL        MTCOR
         LF        R0,MOBSCREG
         TRSW      R0
         TITLE     M2SXDF   - SECTION EXTERNAL DEFINITION
************************************************************************
*
*                  M2SXDF
*
*        SECTION EXTERNAL DEFINITION
*
************************************************************************
M2SXDF   STF       R0,MOBSCREG     SAVE REGISTERS               EAID-32D
         LW        R5,XBLANK       CLEAR NAME IN BUFFER         EAID-32D
         STW       R5,XSYMBUF                                   EAID-32D
         STW       R5,XSYMBUF+1W                                EAID-32D
         ZMW       XSYMBUF+3W      CLEAR FLAG WORD IN BUFFER    EAID-32D
         LB        R1,MBLKX        GET MCBUF INDEX              EAID-32D
         ADI       R1,2            POSITIO TO RECORD LENGTH     EAID-32D
         LB        R5,MCBUF,X1     GET RECORD LENGTH            EAID-32D
         SUI       R5,8            DETERMIE SYMBOL NAME LENGTH  EAID-32D
         ADI       R1,6            POSITION TO SYMBOL NAME      EAID-32D
         LA        R2,XSYMBUF      PLACE TO PUT NAME            EAID-32D
M2SXDF.1 CI        R5,0            DONE WITH NAME               EAID-32D
         BEQ       M2SXDF.2        YES...BRANCH                 EAID-32D
         LB        R6,MCBUF,X1     GET BYTE OF SYMBOL NAME      EAID-32D
         STB       R6,0,X2         SAVE IN BUFFER               EAID-32D
         ADI       R1,1            ADJUST POINTERS              EAID-32D
         ADI       R2,1                                         EAID-32D
         SUI       R5,1                                         EAID-32D
         BU        M2SXDF.1        NEXT BYTE                    EAID-32D
M2SXDF.2 LW        R5,MMODW        SYMTAB ADDR OF CURR SEGMENT  EAID-32D
         LD        R6,XSYMBUF      LOAD SYMBOL NAME             EAID-32D
         CAMW      R6,=C'CSEG'     IS SYMBOL CSEGVAL?           ECSV-33
         BNE       M2SXDF.A        NO...BRANCH                  ECSV-33
         CAMW      R7,=C'VAL '                                  ECSV-33
         BNE       M2SXDF.A        NO...BRANCH                  ECSV-33
         LW        R2,MSYMC        GET SYMBOL TABLE ADDR        ECSV-33
         LW        R4,=X'00FFFFFF'  LOAD MASK VALUE             ECSV-33
         LMW       R6,1W,X2        GET MODULE RELATIVE ADDR     ECSV-33
         ADMW      R6,DSCTBASE+MDSTPEB   ADD BASE IMAGE ADDR    ECSV-33
         STW       R6,CREGBAS      SAVE FOR LATER               ECSV-33
         SBM       MSEGR,MFLAG3    SHOW CSEGVAL DEF READ        ECSV-33
         LD        R6,XSYMBUF      RESTORE SYMBOL NAME          ECSV-33
M2SXDF.A LW        R4,=X'40000000' SEARCH FOR DEF SYMTAB REC    EAID-32D
         BL        MSSCH           SEARCH                       EAID-32D
         TRR       R5,R1           MOVE ADDRESS TO R1           EAID-32D
         BNZ       M2SXDF.3        CONTINUE IF FOUND            EAID-32D
         ZR        R5              SEARCH ENTIRE SYMTAB IF NOT  EAID-32D
         LW        R4,=X'40000000'                              EAID-32D
         BL        MSSCH           SEARCH                       EAID-32D
         TRR       R5,R1           MOVE ADDRESS TO R1           EAID-32D
M2SXDF.3 LB        R5,1W,X1        GET SECTION NUM FROM RECORD  EAID-32D
         BEQ       $+3W            SKIP IF IN DSECT             EAID-32D
         SBM       29,XSYMBUF+3W   SET CSECT FLAG BIT           EAID-32D
         SBM       31,XSYMBUF+3W   SET ABSOLUTE ADDR BIT        EAID-32D
         LW        R4,=X'000FFFFF'                              EAID-32D
         LMW       R5,1W,X1        GET SYMBOL ADDRESS           EAID-32D
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       PR12226
         BNS       M2SXDF.6        NO...BRANCH                  PR12226
         TBM       29,XSYMBUF+3W   IS THIS A CSECT SYMBOL       PR12226
         BNS       M2SXDF.6        BRANCH IF NOT                PR12226
         LW        R4,DEBIAS       GET CSECT ORIGIN ADDRESS     PR12226
         ADR       R4,R5           ADD TO SYMBOL ADDRESS        PR12226
M2SXDF.6 ORMW      R5,=X'0F000000' MAKE IT A TYPE F RECORD      EAID-32D
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE           EAID-32D
         BNS       M2SXDF.4        SKIP IF NOT                  EAID-32D
         ADMW      R5,MPABS        ADD IN ABSOLUTE BIAS         EAID-32D
M2SXDF.4 STW       R5,XSYMBUF+2W   SAVE SYMBOL ADDR IN BUFFER   EAID-32D
         TBM       3,XSYMFLGS      ABSOLUTE MODULE              EAID-32D
         BNS       M2SXDF.5        SKIP IF NOT                  EAID-32D
         SBM       31,XSYMBUF+3W   SET ABSOLUTE FLAG BIT        EAID-32D
M2SXDF.5 BL        XDBGSYM         PUT OUT SYMBOL               EAID-32D
         LF        R0,MOBSCREG     RESTORE REGISTERS            EAID-32D
         TRSW      R0              RETURN                       EAID-32D
         TITLE     M2ESRR   - SECTION RELOCATABLE REFERENCE
************************************************************************
*
*                  M2ESRR
*
*        SECTION RELOCATABLE REFERENCE
*
************************************************************************
M2ESRR   STF       R0,MOBSCREG     SAVE REGS
         LB        R1,MBLKX        IX TO RECORD
         ZMW       M2ESRR97        CLEAR CSECT FLAG
         LB        R2,MCBUF+4B,R1  GET SECTION NUMBER
         BEQ       M2ESRR1         SECTION ZERO
         SBM       0,M2ESRR97      SET CSECT FLAG
*                                                                1.3#05
*      NOW PROCESS DATA ACCORDINGLY                              1.3#05
*                                                                1.3#05
M2ESRR1  LNB       R7,MCBUF+5B,R1  GET REPEAT COUNT
         BNE       M2ESRR5         COUNT NOT ZERO
         SUI       R7,1B           SET FOR ONE REPEAT
M2ESRR5  EQU       $
         LB        R2,MCBUF+2B,R1  GET RECORD SIZE
         SUI       R2,6B           ADJUST FOR HEADER
         LI        R4,3
         TRRM      R2,R5
         BEQ       M2ESRR2         WORD BOUNDARY
         LI        R5,E.BOUND      BOUND ERROR MESSAGE
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M2ESRR2  EQU       $
         SRL       R2,2            MAKE WORD COUNT
         TRN       R2,R6           NEG COUNT
         STW       R6,M2ESRR98     SAVE WORD COUNT
M2ESRR3  LB        R2,MBLKX
         ADI       R2,6B           POINT TO 1ST DATA BYTE
         LW        R6,M2ESRR98     GET # WORDS COUNT
M2ESRR4  BL        MXE4B           EXTRACT NEXT WORD
         TBM       0,M2ESRR97      CSECT ?
         BS        M2ESRR6         YES
         STW       R5,MTCORCL2     SAVE FOR MTCOR
         LI        R1,MT.REL       CALL TYPE- STORE REL WORD
M2ESRR41 EQU       $
         BL        MTCOR
         ADI       R2,4B           IX TO NEXT WORD
         BIB       R6,M2ESRR4      LOOP FOR MORE DATA
         BIB       R7,M2ESRR3      LOOP ON REPEAT COUNT
         LF        R0,MOBSCREG
         TRSW      R0
*
*        CSECT ADDRESS
*
*!ESRR6!!ADMW!!!!!!R5,CSCTBASE+MDSTORG!!!BIAS!BY!CSECT!ORIGIN!!!ELST-32G
M2ESRR6  STW       R5,MTCORCL2     STORE OBJECT DATA            ELST-33G
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-32G
         BS        M2ESRR6A        ADJUST ADDR IF SO            ELST-32
         BU        M2ESRR61              CONTINUE               ELST-32
*!!!!!!!!LA!!!!!!!!R4,CSCTBASE!!!!!ADDR!OF!CSECT!DOPE!VECTOR!!!!ELST-32F
*!!!!!!!!CAMW!!!!!!R4,CURRBASE!!!!!PROCESSING!CSECT!OBJECT?!!!!!ELST-32F
*!!!!!!!!BEQ!!!!!!!$+2W!!!!!!!!!!!!DON'T!BIAS!ADDRESS!IF!SO!!!!!ELST-32F
*!!!!!!!!ADMW!!!!!!R5,DSCTBASE+MDINTREF!!BIAS!CSCT!ADDR!IN!DSCT!ELST-32F
M2ESRR6A LW        R4,=X'FC900000'  OPCODE AND INDIRECT MASK    PR12009
         LMW       R5,MTCORCL2     GET MASKED DATA WORD         PR12009
         BL        ISBRANCH        CHECK FOR BRANCH             PR12009
         BNS       M2ESRR63        SKIP ADJUSTMENT IF NOT       ELST-33G
         LW        R4,=X'FFF00000' MASK OFF ADDRESS             PR12009
         LMW       R5,MTCORCL2                                  PR12009
         LW        R4,=X'000FFFFF'  MASK OFF NON-ADDRESS BITS   PR12009
         LMW       R3,MTCORCL2                                  PR12009
         SRL       R3,1            ADJUST BRANCH ADDRESS        PR12009
         LW        R4,CSCTBASE+MDSTORG  GET CSECT BIAS VALUE    ELST-33G
         SRL       R4,1            SHIFT IT                     ELST-33G
         ADR       R4,R3           BIAS ADDRESS                 ELST-33G
         ORR       R3,R5           PUT ADDR BACK IN INSTRUCTION PR12009
         STW       R5,MTCORCL2     SAVE DATA                    ELST-33G
         BU        M2ESRR62                                     ELST-33G
M2ESRR63 LW        R5,MTCORCL2     RESTORE OBJECT DATA          ELST-33G
M2ESRR61 ADMW      R5,CSCTBASE+MDSTORG  BIAS ADDRESS BY CSECT   ELST-33G
         STW       R5,MTCORCL2     SAVE DATA                    PR12009
M2ESRR62 LI        R5,4B                                        PR12009
         STB       R5,MTCORCL3
         LI        R1,MT.ABS       CALL TYPE- ABS DATA
         BU        M2ESRR41
M2ESRR97 DATAW     0               CSECT FLAG
M2ESRR98 DATAW     0               DATA WORD COUNT
*
         TITLE     M2BACX  -  BIASED ADDRESS CONSTANT
************************************************************************
*                                                               EBAC-33
*                  M2BACX                                       EBAC-33
*                                                               EBAC-33
*        24 BIT BIASED ADDRESS CONSTANT                         EBAC-33
*                                                               EBAC-33
************************************************************************
M2BACX   STF       R0,MOBSCREG     SAVE REGISTERS               EBAC-33
         LB        R2,MBLKX        GET OBJECT RECORD INDEX      EBAC-33
         ADI       R2,4B           ADJUST FOR HEADER            EBAC-33
         BL        MXE4B           GET ADDRESS FROM RECORD      EBAC-33
         TBR       R5,7            IS ADDRESS IN CSECT?         EBAC-33B
         BNS       M2BACX2         NO...RELOCATE IN DSECT       EBAC-33B
         ADMW      R5,CSCTBASE+MDSTORG   RELOCATE IN CSECT      EBAC-33B
         ZBR       R5,7            CLEAR CSECT BIT              EBAC-33B
         BU        M2BACX3         CONTINUE                     EBAC-33B
M2BACX2  ADMW      R5,DSCTBASE+MDSTORG   RELOCATE IN DSECT      EBAC-33
M2BACX3  TBM       M2.5MB,MFLAG2   GENERATING  2.5MB TASK       EBAC-33
         BNS       $+2W            SKIP BIAS IF NOT             EBAC-33
         ADMW      R5,C31.7T       BIAS ADDR BY CSECT ORIGIN    EBAC-33
         STW       R5,MTCORCL2     SAVE DATA                    EBAC-33
         LI        R5,4B           PROCESS 4 BYTES              EBAC-33
         STB       R5,MTCORCL3                                  EBAC-33
         LI        R1,MT.ABS       DATA IS ABSOLUTE             EBAC-33
         BL        MTCOR           PROCESS DATA                 EBAC-33
         LF        R0,MOBSCREG     RESTORE REGISTERS            EBAC-33
         TRSW      R0              RETURN                       EBAC-33
*
         TITLE     M2ESER   - SECTION EXTERNAL REFERENCE
************************************************************************
*
*                  M2ESER
*
*        SECTION EXTERNAL REFERENCE
*
************************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
M2ESER   STF       R0,MOBSCREG     SAVE REGS
         BL        MXENM           GET SYMBOL NAME
         LB        R2,MBLKX
         ADI       R2,4B           POINT TO SECT#,STRINGBACK
         BL        MXE4B
         TRR       R5,R3           R3=SECT#,STRINGBACK R6-7 NAME
M2ESER0  LI        R5,4W           ENTRY POINT FROM "M2XRF"
         STW       R5,M2ESER91     INITIAL SYMTAB SEARCH POINT
M2ESER3  LW        R4,=X'40000000'
         LW        R5,M2ESER91
         SUI       R5,4W
         BL        MSSCH           SEARCH FOR A MATCHING DEFINITION
         TRR       R5,R2
         BEQ       M2ESER8         BRANCH IF EXTERNAL IS UNDEFINED.
         STW       R5,M2ESER91     SAVE SEARCH RESUME ADDRESS
         LW        R1,MMODF
         LW        R4,1W,R1
         BEQ       M2ESER5         BR IF DEFINITION IS IN MAIN
         LW        R1,MMODW
         CAMW      R4,1W,R1
         BEQ       M2ESER5         BR IF DEFINITION IS IN CURR MODULE
         SRLD      R4,16
         CAMH      R4,1W,R1
         BLT       M2ESER4         BR IF DEF IS IN LOWER LEVEL MODULE
         BGT       M2ESER41        BR IF DEF IS IN HIGHER LEVEL  12007
         BU        M2ESER3
M2ESER4  SRLD      R4,16
         BU        M2ESER42        CHECK LINKAGE                 12007
M2ESER41 TBM       MOPT3,MFLGS     NEW LINKBACK USAGE ?          12010
         BNS       M2ESER5         OLD LINKBACK                  12010
         LW        R5,1W,R1        OVERLAY LEVEL/SEQ OF REFMOD   12010
         BZ        M2ESER5         BRANCH IF REF IS IN MAIN      12007
*!!!!!!!!!!TBM!!!!!!!0,0,R1!!!!!!!!!!MODULE!ENTRY!?!!!!!!!!!!!!!!12007
*!!!!!!!!!!BS!!!!!!!!M2ESER5!!!!!!!!!YES,BRANCH!!!!!!!!!!!!!!!!!!12007
*!   THE ABOVE TWO LINES NULLIFY THE EFFECT OF THE CODE         |86.0375
*!   INSERTED @@12007 AND DEFEAT THE INTENDED EFFECT             |86.0375
*!   THEY ARE REMOVED TO CORRECT REFERENCED SPR                 |86.0375
         LW        R1,MMODF        DEF MODULE                    12007
M2ESER42 BL        MLINK                                         12007
         TRR       R5,R5
         BEQ       M2ESER3         BR IF CURR NOT LINKED TO LOWER MODL
M2ESER5  LW        R1,M2ESER91
         LW        R6,1W,R1        DEFINITION ADDRESS
         LW        R4,=X'00FFFFFF'
         TRR       R3,R7
         TRRM      R3,R0           IS STRINGBACK ADDRESS ZERO ?
         BEQ       M2ESER7         YES - DONE
         SBR       R6,8            THIS IS RELOCATABLE DATA
         TBR       R6,7            IS TARGET ADDRESS IN CSECT
         BS        M2ESER6         BR IF IN CSECT
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BNS       M2ESER6         BR IF NOT ABSOLUTE
         ADMW      R6,MPABS        ADD ABSOULTE BASE
M2ESER6  BL        M2E.STRB        STRING BACK ADDRESS
M2ESER7  LF        R0,MOBSCREG
         TRSW      R0
         SPACE
M2ESER91 DATAW     4W
         SPACE
*                                                                1.3#05
*   NEW PROCESSING FOR UNDEFINED EXTERNAL                        1.3#05
*                                                                1.3#05
*  UNSTRING ALL THE REFERENCES, REPLACE WHATS THERE WITH:        1.3#05
*    NOP/NOP   AND LOG ERROR MESSAGE FOR EACH REFERENCE          1.3#05
*  ON THE FLY                                                    1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
M2ESER8  EQU       $                                             1.3#05
         TRR       R3,R4                                         1.3#05
         BZ        M2ESER7         EXIT IF STRING BACK IS ZERO   1.3#05
         LW        R1,MSYMC        GET ADDR OF ACTIVE COTROL     1.3#15
         ADMW      R4,3W,X1        ADD BASE ADDR OF PROGRAM      1.3#15
         LW        R5,1W,X1        GET CAT ALLOCATION            1.3#15
         ANMW      R5,=X'00FFFFFF' KEEP THAT PART ONLY           1.3#15
         ADR       R5,R4           FORM ACTUAL VALUE OF POINTER  1.3#15
         SBM       XABORTFL,XFLGS  AND ABORT FLAG                1.3#10
         LI        R5,-1           SET TYPE AS EXTERNAL          1.3#05
         BL        XUNDFLOG        LOG IT                        1.3#05
         TRR       R3,R7           SET UP SB POINTER             1.3#15
         ZR        R6              FORCE NO RELOCATION IN SB     1.3#15
         LW        R5,M2ESER81     LOAD REPLACEMENT VALUE        1.3#15
         SBM       XREPMODE,XFLGS  FORCE SB TO DO REPLACEMENT    1.3#15
         BL        M2E.STRB        UNRAVEL SB LIST               1.3#15
         ZBM       XREPMODE,XFLGS   RESET REPLACE MODE           1.3#15
         BU        M2ESER7         EXIT
M2ESER81 M.DEBUG                   INSTR. TO PLUG INTO UNDEF'D   1.3#15
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     M2E.STRB - STRING BACK SUBROUTINE
***********************************************************************
*        M2E.STRB  - STRING BACK SUBROUTINE
*
*        R6        = DATA TO BE STRUNG BACK IN BITS 12 - 31
*        R6 (BIT8) = SET IF DATA IS RELOCATABLE
*        R6 (BIT7) = SET IF DATA IS IN CSECT
*        R7        = PROGRAM ELEMENT ADDRESS OF THE END OF THE
*                    STRINGBACK (LINKED) LIST.
*        R7 (BIT7) = SET IF LIST IS IN CSECT
***********************************************************************
         SPACE
M2E.STRB STF       R0,M2ESBSB9     SAVE REGS
         LW        R1,CURRBASE     GET CURRENT DV POINTER        1.3#05
         STW       R1,M2ESBSB7
         ZBR       R7,8            CLEAR RELOCATION BIT
         STW       R7,M2ESBSB8     SAVE THE SECTION OFFSET
         LA        R1,MSETR        ADDRESS OF SET RELOC. BIT ROUTINE
         TBR       R6,8            IS DATA RELOCATABLE
         BNS       M2E.SB0         BR IF DATA IS ABSOLUTE
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BS        M2E.SB0         BR IF ABSOLUTE, CLEAR RELOC. MATRIX
         TBR       R6,7            SYMBOL DEFINED IN SECTION ONE?
         BNS       M2E.SB1         BRANCH IF NO
M2E.SB0  LA        R1,MCLRR        ADDRESS OF CLEAR RELOC. BIT ROUTINE
M2E.SB1  STW       R1,M2ESBSB0
         ZBM       MDEFADR,MFLAG2                               ELST-32
         TBR       R6,7            IS DATA IN CSECT?            ELST-32
         BNS       $+2W                                         ELST-32
         SBM       MDEFADR,MFLAG2                               ELST-32
*!!!!!!!!ANMW!!!!!!R6,=X'7FFFF'!!!!MAKE!OBJECT!ADDRESS!19!BITS!!ELST-32
*!!!!!!!!ANMW!!!!!!R6,=X'FFFFF'!!!!KEEP!20!BITS!OF!OBJECT!ADDR.!ELST-32G
         ANMW      R6,=X'001FFFFF'  KEEP 21 BITS OF OBJ ADDR    ELST-33G
*
*  ESTABLISH CORRECT DOPE VECTOR BASED ON LOCATION OF LIST
*
         LB        R1,M2ESBSB8     GET SECTION #
         BNE       M2E.SB2         BR IF LIST IS IN CSECT
*
         ZBM       MSBADR,MFLAG2   STRINGBACK START IN DSECT    ELST-32
         LA        R1,DSCTBASE     GET ADDR OF DSECT DV          1.3#05
         STW       R1,CURRBASE     AND MAKE IT CURRENT           1.3#05
         BU        M2E.SB3
*
M2E.SB2  EQU       $
         SBM       MSBADR,MFLAG2   STRINGBACK START IN CSECT    ELST-32
         LA        R1,CSCTBASE     GET ADDR OF CSECT DV          1.3#05
         STW       R1,CURRBASE     AND MAKE IT CURRENT           1.3#05
M2E.SB3  EQU       $
         LW        R1,MDSTPEB,X1     GET ADR OF PROG IMAGE       1.3#05
         ZBR       R7,7            IS THIS SECTION ONE (CSECT)   1.3#05
         BS        M2E.SB5         BR IF CSECT (DON'T ADD COMM DEL)21005
         LW        R2,MSYMC
         LW        R5,1W,X2        LOAD THIS ELEMENT OFFSET
         ANMW      R5,=X'00FFFFFF' CAT ALLOCATION OLNY
         ADR       R5,R1
         NOP
M2E.SB5  EQU       $
         TRR       R1,R3           R3 := COM DELTA + 1ST BUILD ADDR
         SRL       R7,2            INSURE ADDRESS IS WORD BOUNDARY
         SLL       R7,2
         ADR       R7,R1           R1:=ABS TAIL+COM DELTA+1ST BUILD ADDR
*        ADMW      R1,M2ESBSB8     ADD IN SECTION OFFSET
*
*    UPDATE NEXT IN LIST
*
M2E.SB6  LW        R5,0,X1         GET OBJECT DATA              EBAC-33C
         CAMW      R5,=X'0008FFFF' IS THIS A BACX TERMINATOR    EBAC-33C
         BNE       $+3W            NO...BRANCH                  EBAC-33C
         SBM       MTERM,MFLAG3    SHOW TERMINATOR FOUND        EBAC-33C
         ZMW       0,X1            CLEAR OUT OBJECT WORD        EBAC-33C
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-32
         BNS       M2E.SB6A        SKIP THIS CODE IF NOT        ELST-32
         LW        R4,=X'00FFFFFF' GET MASK                     ELST-32
         LMW       R5,0,X1         GET OBJECT DATA              ELST-32
         CAMW      R5,C31.7T       OBJECT ADDR > CSECT ORIGIN?  ELST-32
         BLT       M2E.SB60        SKIP ADJUSTMENT IF NOT       ELST-32
         SBM       MPREBA,MFLAG2   SET PREBIAS FLAG             ELST-32
         SUMW      R5,C31.7T       SUBTRACT OUT BIAS            ELST-32
         LW        R4,=X'FF000000' MASK FOR NON ADDRESS BITS    ELST-32
         LMW       R3,0,X1                                      ELST-32
         ORR       R3,R5                                        ELST-32
         STW       R5,0,X1         PUT OBJECT DATA BACK         ELST-32
M2E.SB60 LW        R4,=X'FC900000' MASK FOR OPCODE AND INDIR    ELST-32
         LMW       R5,0,X1         GET DATA WORD                ELST-32
         BL        ISBRANCH        CHECK FOR BRANCH INSTR.      ELST-32
         BNS       M2E.SB6A        NO ADJUSTMENT IF NOT         ELST-32
         LW        R4,=X'FFF00000' MASK FOR OPCODE AND OTHERS   ELST-32
         LMW       R5,0,X1         GET WORD                     ELST-32
         SRL       R6,1            ADJUST ADDRESS               ELST-32
         ORR       R6,R5           COMBINE INSTR AND ADDR       ELST-32
         SLL       R6,1            SHIFT BACK IN CASE OF OTHERS ELST-32
         LW        R4,=X'000FFFFE' COMPLEMENT MASK (000FFFFF)   ELST-32
         LMW       R7,0,R1         ADDR OF NEXT LINK            ELST-32
         SLL       R7,1            RESTORE CORRECT ADDRESS      ELST-32
         BU        M2E.SB6B                                     ELST-32
M2E.SB6A LW        R4,=X'FFF80003' MASK FOR OPCODE, F & C BITS  ELST-32
         LMW       R5,0,R1         PICK UP INSTRUCTION LEAVING ADDRESS
         TBM       M2.5MB,MFLAG2   2.5 MB TASK?                 ELST-32B
         BNS       M2E.SB6E        SKIP IF NOT                  ELST-32B
         TBM       MSBADR,MFLAG2   IS STRINGBACK ADDR IN CSECT  ELST-32
         BS        M2E.SB6D        NO BIAS IF SO                ELST-32
         TBM       MDEFADR,MFLAG2  IS DEFINITION ADDR IN CSECT  ELST-32
         BNS       M2E.SB6C        NO BIAS IF IN DSECT          ELST-32
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-33F
         BS        M2E.SB6D        SKIP ADDRESS BIAS IF SO      ELST-33F
         ORMW      R5,C31.7T       BIAS ADDRESS                 ELST-32
M2E.SB6C ZBM       MPREBA,MFLAG2   NO FURTHER BIASING           ELST-32
M2E.SB6D TBM       MPREBA,MFLAG2   PREBIASED ADDRESS?           ELST-32
         BNS       $+3W            SKIP IF NOT                  ELST-32
         ORMW      R5,C31.7T       PUT BIAS BACK IN             ELST-32
         ZBM       MPREBA,MFLAG2                                ELST-32
M2E.SB6E ORR       R6,R5           MOVE OBJ ADDR INTO INSTR.    ELST-32B
         TBM       M2.5MB,MFLAG2   GENERATING 2.5 MB TASK?      EBAC-33C
         BNS       M2E.SB6F        NO...BRANCH                  EBAC-33C
         TBM       MTERM,MFLAG3    IS THIS A BACX TERMINATOR?   EBAC-33C
         BNS       M2E.SB6F        NO...BRANCH                  EBAC-33C
         ADMW      R5,C31.7T       ELSE ADD IN CSECT ORIGIN     EBAC-33C
M2E.SB6F TRC       R4,R4           COMPLEMENT MASK (0007FFFC)   EBAC-33C
         LMW       R7,0,R1         ADDR OF NEXT LINK
         CAMW      R7,C31.7T       IS NEXT > CSECT ORIGIN       ELST-33F
         BLT       M2E.SB6B        NO...BRANCH                  ELST-33F
         SUMW      R7,C31.7T       ELSE SUBTRACT OUT ORIGIN     ELST-33F
         SBM       MBADR,MFLAG3    SHOW ADDRESS WAS BIASED      ELST-33G
*                                                                1.3#15
M2E.SB6B TBM       XREPMODE,XFLGS  ARE WE IN REPLACE MODE        1.3#15
         BNS       M2E.SB61        SKIP IF NOT                   1.3#15
         CI        R7,0            IS NEXT =0                    1.3#15
         BEQ       $+2W            DONT REPORT IF LIST END       1.3#15
         BL        XREFINFO        REPORT                        1.3#15
         LW        R5,M2ESBSB9+5W  RECOVER REPLACEMENT VALUE     1.3#15
M2E.SB61 EQU       $                                             1.3#15
*                                                                1.3#15
         STW       R5,0,R1         RESTORE CORRECTED WORD
         TRR       R1,R5
         BL        *M2ESBSB0       SET/CLEAR RELOCATION BIT
*
*   LIST END OR MORE GUYS
*
         TBM       MTERM,MFLAG3    WAS BACX TERMINATOR READ     EBAC-33C
         BNS       $+3W            NO...BRANCH                  EBAC-33C
         ZBM       MTERM,MFLAG3    ELSE CLEAR FLAG              EBAC-33C
         BU        M2E.SB9         AND RETURN                   EBAC-33C
         CI        R7,0            IS NEXT LINK ZERO
         BNZ       M2E.SB7         CONTINUE IF NOT ZERO          1.3#05
         TBR       R0,1            OR IF LAST WAS RELOCATABLE    1.3#05
         BNS       M2E.SB9         ELSE BR TO EXIT
M2E.SB7  EQU       $
         TBM       BSECTS,BFLGS    IS THIS PROG SECTIONED        1.3#05
         BNS       M2E.SB71        SKIP IF NOT                   1.3#05
*!!!!!!!!TBM!!!!!!!M2.5MB,MFLAG2!!!GENERATING!2.5MB!TASK?!!!!!!!ELST-32F
*!!!!!!!!BNS!!!!!!!M2E.SBA!!!!!!!!!SKIP!IF!NOT!!!!!!!!!!!!!!!!!!ELST-32F
         LA        R1,DSCTBASE     ARE WE IN THE DSECT          ELST-32
         CAMW      R1,CURRBASE                                  ELST-32
         BEQ       M2E.SB71        CONTINUE DSECT PROCESSING    ELST-32
         BU        M2E.SBB         CONTINUE CSECT PROC IF NOT   ELST-32
M2E.SBA  CAMW      R7,BSP.CORG     IS NEXT IN CSECT              1.3#05
         BLT       M2E.SB71        SKIP IF NOT                   1.3#05
M2E.SBB  LA        R1,CSCTBASE     ELSE SET DV BASE TO CSECT     1.3#05
         STW       R1,CURRBASE                                   1.3#05
         SBM       MSBADR,MFLAG2   STRINGBACK ADDR IN CSECT     ELST-32
*!!!!!!!!TBM!!!!!!!M2.5MB,MFLAG2!!!GENERATING!2.5!MB!TASK?!!!!!!ELST-32F
*!!!!!!!!BS!!!!!!!!$+2W!!!!!!!!!!!!DON'T!ADJUST!ADDRESS!IF!SO!!!ELST-32F
         TBM       MBADR,MFLAG3    WAS ADDRESS BIASED           ELST-33G
         BNS       M2E.SBC         NO...REMOVE SECTION ORIGIN   ELST-33G
         LW        R4,MDSTORG,X1   LOAD SECTION ORIGIN          ELST-33G
         SUMW      R4,C31.7T       REMOVE CSECT ORIGIN          ELST-33G
         SUR       R4,R7           SUBTRACT OUT RELOCATION VAL  ELST-33G
         ZBM       MBADR,MFLAG3    RESET FLAG                   ELST-33G
         BU        M2E.SBD                                      ELST-33G
M2E.SBC  SUMW      R7,MDSTORG,X1   REMOVE SECTION ORIGIN         1.3#05
M2E.SBD  ADMW      R7,MDSTPEB,X1   AND ADD BUFFER OFFSET         1.3#05
         TRR       R7,R1           SET UP FOR BUFFER UPDATE      1.3#05
         BU        M2E.SB6         AND LOOP TO DO IT             1.3#05
*                                                                1.3#05
M2E.SB71 EQU       $               HERE IF IN DSECT              1.3#05
         LA        R1,DSCTBASE     SO ESTABLISH THIS AS BASE     1.3#05
         STW       R1,CURRBASE                                   1.3#05
         ZBM       MSBADR,MFLAG2   STRINGBACK ADDR IN DSECT     ELST-32
         TBM       MABS,MFLGS      IS THIS AN ABS DSECT          1.3#05
         BNS       M2E.SB72        SKIP IF NOT                   1.3#05
         SUMW      R7,MPABS        REMOVE ABS OFFSET             1.3#05
M2E.SB72 EQU       $               HERE IF NOT ABSOLUTE          1.3#05
         SUMW      R7,MDSTORG,X1   REMOVE RELOCATION FACTOR      1.3#05
M2E.SB73 EQU       $               MERGE POINT                   1.3#05
         LW        R1,MDSTPEB,X1   GET DSECT PRG ELE BASE        1.3#05
         LW        R2,MSYMC        GET ADDR OF THIS CONTROL      1.3#05
         LW        R5,1W,X2        GET CAT ALLOCATION            1.3#05
         ANMW      R5,=X'00FFFFFF'                               1.3#05
         ADR       R5,R1           ADDED TO PRG BASE             1.3#05
         ADR       R7,R1           PLUS THIS LIST POINTER        1.3#05
         BU        M2E.SB6         AND GO DO UPDATE              1.3#05
*
M2E.SB9  EQU       $
         LW        R1,M2ESBSB7     RESTORE SECTION ORIGIN
         STW       R1,CURRBASE     REESTABLISH BASE AT ENTRY     1.3#05
         LF        R0,M2ESBSB9
         TRSW      R0              RETURN
         SPACE
M2ESBSB9 RES       1F
M2ESBSB8 DATAW     0
M2ESBSB7 DATAW     0               SAVED SECTION ORIGIN
M2ESBSB0 DATAW     0               RELOCATION BIT SET/CLEAR ROUTINE
*
*-----------------------------------------------------------------------
         TITLE     M2ESFS   - SECTION FORWARD STRING BACK
*******************************************************************
*
*                  M2ESFS
*
*        SECTION FORWARD REFERENCE STRINGBACK
*
********************************************************************
M2ESFS   STF       R0,MOBSCREG     SAVE REGS
         LB        R2,MBLKX
         ADI       R2,4B           POINT TO DEF WORD
         BL        MXE4B           GET SECT#,ADDRESS
         LW        R4,=X'00FFFFFF'
         TRRM      R5,R6
         LB        R2,MBLKX
         LB        R4,MCBUF+4B,R2  GET SECTION #
         BNE       M2ESFS1         SECTION ONE
         ADMW      R6,DSCTBASE+MDSTORG ADD IN SECTION ZERO ORIGIN
         BU        M2ESFS2
M2ESFS1  ADMW      R6,CSCTBASE+MDSTORG  ADD SECTION 1 ORIGIN     1.3#05
M2ESFS2  LB        R2,MBLKX
         ADI       R2,8B
         BL        MXE4B           GET STRING BACK SECT#,ADDRESS
         TRR       R5,R7
         SBR       R6,8            DATA IS RELOCATABLE
         TBR       R6,7            IS ADDRESS IN CSECT
         BS        M2ESFS3         BR IF ADDRESS IN CSECT
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BNS       M2ESFS3         BR IF NOT ABSOLUTE
         ADMW      R6,MPABS        ADD ABSOLUTE BASE
M2ESFS3  BL        M2E.STRB        STRING ADDR BACK
         LF        R0,MOBSCREG
         TRSW      R0
         TITLE     M2ECOR   - LARGE COMMON ORIGIN
*****************************************************************
*
*        M2ECOR
*
****************************************************************
*
*        LARGE COMMON ORIGIN
*
****************************************************************
M2ECOR   STF       R0,MOBSCREG
         LB        R2,MBLKX
         ADI       R2,4B
         BL        MXE4B           GET BLOCK#,ORIGIN
         LW        R4,=X'FFFFFF'
         TRRM      R5,R3           ORIGIN TO R3
         STW       R3,M2COR98      SAVE FOR M2COR
         SRL       R5,24
         STB       R5,M2COR99      SAVE BLOCK #
         BU        M2COR0
         TITLE     M2ECRF   - LARGE COMMON REFERENCE
**********************************************************************
*
*        M2ECRF
*
*********************************************************************
*
*        LARGE COMMON BLOCK REFERENCE
*
********************************************************************
M2ECRF   STF       R0,M2ECRF99
         LB        R2,MBLKX
         LB        R5,MCBUF+4B,R2  GET BLOCK #
         STB       R5,M2CRF89      SAVE BLOCK #
         LB        R5,MCBUF+5B,R2  GET REPEAT COUNT
         BNE       M2ECRF1
         LI        R5,1B
M2ECRF1  STB       R5,M2ECRF98     SAVE REPEAT COUNT
         LB        R5,MCBUF+2B,R2  GET # BYTES OF DATA
         SUI       R5,6B           ADJUST FOR HEADER
         STB       R5,M2CRF87      SAVE FOR M2CRF
         ADI       R2,4B
         STB       R2,M2CRF88      SAVE IX TO DATA -2B
         LA        R0,M2ECRF2      DUMMY UP RETURN FROM M2CRF
         STW       R0,MOBSCREG
M2ECRF3  EQU       $
         BL        M2CRF0          GO PROCESS DATA
M2ECRF2  EQU       $
         LB        R1,M2ECRF98     GET REPEAT COUNT
         SUI       R1,1B
         STB       R1,M2ECRF98
         TRR       R1,R1
         BGT       M2ECRF3         GO REPEAT AGAIN
         LF        R0,M2ECRF99
         TRSW      R0
M2ECRF98 DATAB     0               REPEAT COUNT
         BOUND     8W
M2ECRF99 RES       8W
         TITLE     M1SYMB   - DEBUG SYMBOL RECORD
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*
*     M1SYMB   -    SYMBOLIC DEBUG INFORMATION (PASS A)
*                   COUNT UP THE NUMBER OF ITEMS IN SGO FILE
*
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*
M1SYMB   TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS ?       12011
         BS        $+2W            IF YES, SKIP ABM                12011
         ABM       31,XSYML        COUNT LOCAL SYMBOLS FOR ROOT EAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32
         ABM       31,XSYMENT      INCREMENT NUMBER OF THESE LOADER ITEM
*--------------------------------------------------------------------
*                                                               EAID-32
*  ACCUMULATE NUMBER OF SOURCE CHARACTERS IN LOAD MODULE        EAID-32
*                                                               EAID-32
         LA        R1,MCBUF        ADDRESS OF OBJECT BUFFER     EAID-32
         ADMB      R1,MBLKX        INDEX TO DATA BLOCK          EAID-32
         LB        R4,4B,X1        TYPE?                        EAID-32
         CI        R4,32           IS IT A PARAMETER?           EPSR-33
         BGE       M1SYM.5         YES...BRANCH                 EPSR-33
         CI        R4,14           STATEMENT?                   EAID-32
         BNE       M1SYM.1         BRANCH IF NOT                EAID-32
         LB        R4,1B,X1        GET SUB TYPE FIELD           PR11750
         CI        R4,X'0B'        IS IT TYPE D00B RECORD?      PR11750
         BNE       M1SYM.3         NO...CHECK TYPE D00E         PR11750
         LB        R4,2B,X1        LENGTH                       EAID-32
         SUI       R4,18           SUB OFF 'S.' STANDARD LENGTH EAID-32
*!!!!!!!!BNZ!!!!!!!$+2W!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR11750
         BZ        M1SYM.1         NO SOURCE IF ZERO            PR11750
         BU        M1SYM.4         ADD SOURCE TO COUNT          PR11750
M1SYM.3  CI        R4,X'0E'        IS IT TYPE D00E RECORD?      PR11750
         BNE       M1SYM.1         BRANCH IF NOT                PR11750
         LB        R4,2B,X1        GET LENGTH OF RECORD         PR11750
         SUI       R4,22           SUB OFF TYPE 0E S. LENGTH    EAID-32F
*!!!!!!!!BNP!!!!!!!M1SYM.1!!!!!!!!!BRANCH!IF!NO!SOURCE!!!!!!!!!!S900698
         BLT       M1SYM.1         BRANCH IF NO SOURCE          S900698
         BGT       M1SYM.4         BRANCH IF REAL SOURCE        S900698
         LI        R4,6            ELSE..ADD CARET SOURCE COUNT S900698
M1SYM.4  ARMW      R4,AID.SLEN     UPDATE COUNT OF SOURCE CHARS EAID-32
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS ?    EAID-32
         BS        $+2W            IF YES, SKIP ABM             EAID-32
         ARMW      R4,XSRCRT       ADD TO CNT OF SOURCE FOR ROOTEAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T ADD TO SYM COUNT IF SO S920275
         ARMW      R4,*XSRCOV1                                  EAID-32
         TRSW      R0              RETURN                       EAID-32
M1SYM.1  EQU       $                                            EAID-32
*-------------------------------------------------------------------
         LB        R4,1B,X1        GET SUB TYPE                 EAID-32
         CI        R4,X'0E'        NEW DEBUG INFO?              EAID-32
         BEQ       M1SYM.N                                      EAID-32
         LI        R5,18           SIZE OF SYMBOL               EAID-32
         TBM       6,,X1           SYMBOL IN COMMON             EAID-32
         BNS       $+2W            BRANCH IF NOT                EAID-32
         ADI       R5,8            R5 CONTAINS LEN OF REG INFO  EAID-32
         TBM       7,,X1           SYMBOL IN DATAPOOL           EAID-32
         BNS       $+2W            BRANCH IF NOT                EAID-32
         ADI       R5,8            R5 CONTAINS LEN OF REG INFO  EAID-32
         TBM       4,3B,X1         ARRAY INFO PRESENT?          EAID-32
         BU        M1SYM.M                                      EAID-32
M1SYM.N  LI        R5,20           SIZE OF SYMBOL               EAID-32
         TBM       MCOBJ,MFLAG3    IS THIS C OBJECT?            CAID
         BNS       M1SYM.P         NO, DO NORMAL PROCESSING     CAID
* PROCESS A STRUCTURE REFERENCE IF BIT 4 SET                    CAID
         TBM       4,3B,X1         SYMBOL A STRUCTURE REF?      CAID
         BNS       M1SYM.Q         NO, CHECK FOR ARRAY INFO     CAID
* TWO SYMBOLS ARE OUTPUT FOR STRUCTURE REFERENCES               CAID
         TBM       FLAGO,CATFLAGS  OVERLAY SYMBOLS?             CAID
         BS        $+2W            SKIP ABM IF SO               CAID
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   CAID
         TBM       MOPT2,MFLGS     OPTION 2 SET?                CAID
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   CAID
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYM COUNT CAID
         ABM       31,XSYMENT      INCREMENT TOTAL NUMBER       CAID
         ADI       R5,8B           INCLUDE STRUCT NAME SIZE     CAID
M1SYM.Q  TBM       1,3B,X1         ARRAY INFO PRESENT?          CAID
         BU        M1SYM.M         PROCESS ARRAY INFO           CAID
*CAID    TBM       4,3B,X1         SYMBOL IN COMMON?            EAID-32
M1SYM.P  TBM       4,3B,X1         SYMBOL IN COMMON?            CAID
         BNS       $+2W                                         EAID-32
         ADI       R5,8B           YES,INCLUDE COMMON NAME SIZE EAID-32
         TBM       5,3B,X1         SYMBOL IN DATAPOOL?          EAID-32
         BNS       $+2W                                         EAID-32
         ADI       R5,8B           YES,INCLUDE COMMON NAME SIZE EAID-32
         TBM       1,3B,X1         ARRAY INFO PRESENT?          EAID-32
M1SYM.M  BNS       M1SYM.2         BRANCH IF NO ARRAY INFO PRES EAID-32
         LB        R4,2B,X1        LENGTH                       EAID-32
         SUR       R5,R4           DIFFERENCE IS ARRAY INFO     EAID-32
         SUI       R4,4            1 CONTROL WORD               EAID-32
         BLE       M1SYM.2         BRANCH IF NEGATIVE           EAID-32
         SRL       R4,2            CONVERT TO # OF BOUND WORDS  EAID-32
         ARMW      R4,XSYMENT      1 SYMBOL FOR EACH BOUND      EAID-32
         TBM       FLAGO,CATFLAGS  TEST IF OVERLAY SYMBOLS ?       12011
         BS        $+2W            IF YES, SKIP ABM                12011
         ARMW      R4,XSYML        COUNT LOCAL SYMBOLS FOR ROOT EAID-32
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ARMW      R4,*XSYMI1      BUMP OVERLAY LOCAL SYMBOL    EAID-32
M1SYM.2  EQU       $                                            EAID-32
         TRSW      R0              RETURN
         NOP
M1SYM.5  CI        R4,39           IS IT A COMPLEX*16 PARAMETER EPSR-33
         BEQ       M1SYM.6         YES...BRANCH                 EPSR-33
         CI        R4,43           IS IT A CHARACTER PARAMETER  EPSR-33
         BNE       M1SYM.7         BRANCH IF NOT                EPSR-33
         LB        R4,6B,X1        GET SIZE OF CHARACTER DATA   EPSR-33
         BNE       M1SYM.6                                      EPSR-33
         LB        R4,7B,X1                                     EPSR-33
         CI        R4,8            GREATER THAN TWO WORDS       EPSR-33
         BGT       M1SYM.6         YES...BRANCH                 EPSR-33
M1SYM.7  TBM       FLAGO,CATFLAGS  OVERLAY SYMBOLS?             EPSR-33
         BS        $+2W            SKIP ABM IF SO               EPSR-33
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EPSR-33
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM COUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYM COUNT EPSR-33
         ABM       31,XSYMENT      INCREMENT TOTAL NUMBER       EPSR-33
         BU        M1SYM.2         RETURN                       EPSR-33
M1SYM.6  TBM       FLAGO,CATFLAGS  OVERLAY SYMBOLS?             EPSR-33
         BS        $+2W            SKIP ABM IF SO               EPSR-33
         ABM       31,XSYML        BUMP SYMBOL COUNT FOR ROOT   EPSR-33
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+2W            DON'T BUMP SYM SOUNT IF SO   S920275
         ABM       31,*XSYMI1      BUMP OVERLAY LOCAL SYM COUNT EPSR-33
         ABM       31,XSYMENT      INCREMENT TOTAL NUMBER       EPSR-33
         BU        M1SYM.7         ADD ANOTHER SYMBOL           EPSR-33
*
         TITLE     MGETBYTS
************************************************************************
*
*        MGETBYTS - EXTRACTS UP TO 8 BYTES FROM OBJECT RECORD   EOBJ-30
*                                                               EOBJ-30
*                   INPUT : R1 ADDRESS TO LOAD BYTES FROM       EOBJ-30
*                           R4 NEGATIVE BYTE COUNT              EOBJ-30
*                                                               EOBJ-30
*                   OUTPUT : R6,R7 BYTES OUT RIGHT JUSTIFIED    EOBJ-30
*
************************************************************************
*
MGETBYTS EQU       $                                            EOBJ-30
         STF       R0,MGBSAVER     SAVE REGISTERS               EOBJ-30
         ZR        R6              CLEAR R6 AND R7              EOBJ-30
         ZR        R7                                           EOBJ-30
MGB.1    SLLD      R6,8            SHIFT BYTES OUT 8 BITS       EOBJ-30
         LB        R5,0,X1         LOAD BYTE FROM OBJECT CODE   EOBJ-30
         ORR       R5,R7           PUT IT IN BYTE STREAM        EOBJ-30
         ADI       R1,1            NEXT BYTE                    EOBJ-30
         BIB       R4,MGB.1        LOOP                         EOBJ-30
         STD       R6,MGBSAVER+6W  SAVE BYTES OUT               EOBJ-30
         LF        R0,MGBSAVER     RESTORE REGISTERS            EOBJ-30
         TRSW      R0              RETURN                       EOBJ-30
         BOUND     1W                                           EOBJ-30
MGBSAVER REZ       1F              SAVE AREA                    EOBJ-30
         TITLE     M2NEWOBJ  - NEW OBJECT FORMAT SYMDB RECORD   EOBJ-30
************************************************************************
*
*        M2NEWOBJ  -  PROCESSES NEW FORMAT OBJECT RECORDS INTO  EOBJ-30
*                     DEBUG SYMBOL TABLE RECORDS DURING PASS B  EOBJ-30
*
************************************************************************
*
M2NEWOBJ EQU       $                                            EOBJ-30
         TBM       MOPT19,MFLGS    IS SYMBOL GENERATION ON      EOBJ-30
         BNS       M2SYMB.X        RETURN IF NOT                EOBJ-30
         STF       R0,M2SAVREG     SAVE REGISTERS               EOBJ-30
         LA        R1,MCBUF        ADDRESS OF OBJECT BUFFER     EOBJ-30
         ADMB      R1,MBLKX        ADD IN INDEX                 EOBJ-30
         ADI       R1,12B          POINT TO SYMBOL NAME         EOBJ-30
         LI        R4,-8           GET 8 BYTES                  EOBJ-30
         BL        MGETBYTS        GET THE NAME                 EOBJ-30
         STD       R6,XSYMBUF      SAVE NAME IN BUFFER          EOBJ-30
         LB        R2,MBLKX        INDEX INTO MCBUF             EOBJ-30
         ADI       R2,3B           POINT TO RECORD FLAGS        EOBJ-30
         LB        R5,MCBUF,X2     GET LENGTH OF RECORD         EOBJ-30
         SLL       R5,2            POSITION FLAGS               EOBJ-30
         STB       R5,SYMFLAGS     SAVE FLAGS                   EOBJ-30
         TBM       COMFLG,SYMFLAGS COMMON BLOCK TYPE RECORD     EOBJ-30
         BS        M2NOBJ.0        GET NAME IF SO               EOBJ-30
         TBM       MCOBJ,MFLAG3    IS THIS C OBJECT             CAID
         BS        M2NOBJ.1        YES, IGNORE DP FLAG          CAID
         TBM       DPLFLG,SYMFLAGS DATAPOOL TYPE RECORD         EOBJ-30
         BNS       M2NOBJ.1        SKIP NAME IF NOT             EOBJ-30
M2NOBJ.0 ADI       R1,8B           POINT TO COMMON NAME         EOBJ-30
         BL        MGETBYTS        GET COMMON NAME              EOBJ-30
         STD       R6,BLKNAM       SAVE COMMON BLOCK NAME       EOBJ-30
M2NOBJ.1 LB        R1,MBLKX        INDEX INTO MCBUF             EOBJ-30
         ADI       R1,1W           POINT TO TYPE CODE           EOBJ-30
         LB        R5,MCBUF,X1     GET TYPE CODE                EOBJ-30
         CI        R5,32           IS IT A PARAMETER RECORD     EPSR-33
         BLT       M2NOBJ.2        NO...BRANCH                  EPSR-33
         CI        R5,43           IS IT A CHARACTER PARAMETER  EPSR-33
         BGT       M2NOBJ.2        NO...BRANCH                  EPSR-33
*                                  PROCESS ENUM DEFINITION      CAID
         BU        M2NOBJ.3        PROCESS CHARACTER PARAMETER  EPSR-33
M2NOBJ.2 SRC       R5,8            POSITION FOR MERGE           EOBJ-30
         LA        R1,MCBUF        ADDRESS OF OBJECT BUFFER     EOBJ-30
         ADMB      R1,MBLKX        INDEX INTO MCBUF             EOBJ-30
         ADI       R1,6B           POSITION TO SIZE             EOBJ-30
         LI        R4,-2                                        EOBJ-30
         BL        MGETBYTS        GET SIZE                     EOBJ-30
         STH       R7,M2TEMPLN     SAVE SIZE                    EOBJ-30
         ADI       R1,2B           POINT TO ADDRESS             EOBJ-30
         LI        R4,-4                                        EOBJ-30
         BL        MGETBYTS        GET ADDRESS                  EOBJ-30
         TRR       R7,R6           ADDRESS TO R6                EOBJ-30
         ZR        R7                                           EOBJ-30
         SRLD      R6,3            SHIFT OUT BIT NUMBER         EOBJ-30
         SRL       R7,1            ALIGN FOR MERGE              EOBJ-30
         ORR       R5,R7           COMBINE TYPE AND BIT NUMBER  EOBJ-30
         LW        R4,=X'FFFFFF'   ADDRESS MASK                 EOBJ-30
         TRRM      R6,R6           PURE ADDRESS                 EOBJ-30
         ORR       R7,R6           BIT NUM,TYPE,AND ADDRESS     EOBJ-30
         STW       R6,XSYMBUF+2W   STORE IN BUFFER              EOBJ-30
         BU        M2SYM.NO        MERGE                        EOBJ-30
M2NOBJ.3 SUI       R5,32           CHANGE TYPE TO NON-PARAMETER EPSR-33
         ZMW       XSYMBUF+2W      CLEAR SYMBOL BUFFER          EPSR-33
         ZMW       XSYMBUF+3W                                   EPSR-33
         STB       R5,XSYMBUF+8B   SAVE TYPE IN SYMBOL RECORD   EPSR-33
         LA        R1,MCBUF        GET OBJECT BUFFER ADDRESS    EPSR-33
         ADMB      R1,MBLKX        ADD CURRENT INDEX            EPSR-33
         ADI       R1,6B           POSITION TO SIZE             EPSR-33
         LI        R4,-2           GET TWO BYTES                EPSR-33
         BL        MGETBYTS        GET SIZE FROM RECORD         EPSR-33
         STH       R7,M2TEMPLN     SAVE SIZE                    EPSR-33
         STH       R7,XSYMBUF+6H   SAVE SIZE IN BUFFER          EPSR-33
         SBM       28,XSYMBUF+3W   SET PARAMETER FLAG IN BUFFER EPSR-33
         BL        XDBGSYM         OUTPUT SYMBOL RECORD         EPSR-33
         ZMW       XSYMBUF+2W      CLEAR 2ND WORD OF SYM BUFF   EPSR-33
         ZMW       XSYMBUF+3W        ''  3RD  ''  ''  ''  ''    EPSR-33
         CI        R5,8            IS THIS A BIT TYPE PARAM     EPSR-33
         BNE       M2NOBJ.4        NO...BRANCH                  EPSR-33
         ADI       R1,14B          POSITION TO VALUE            EPSR-33
         LI        R4,-1           GET ONE BYTE                 EPSR-33
         BL        MGETBYTS                                     EPSR-33
         SLL       R7,24           POSITION DATA FOR SAVE       EPSR-33
         STW       R7,XSYMBUF+2W   SAVE BIT DATA IN BUFFER      EPSR-33
         BL        XDBGSYM         OUTPUT SYMBOL RECORD         EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.4 CI        R5,7            COMPLEX*16 PARAMETER?        EPSR-33
         BEQ       M2NOBJ.A        YES...BRANCH                 EPSR-33
         CI        R5,11           CHARACTER PARAMETER?         EPSR-33
         BEQ       M2NOBJ.B        YES...BRANCH                 EPSR-33
         LH        R5,M2TEMPLN     GET DATA SIZE                EPSR-33
         TRN       R5,R4           NEGATE IT                    EPSR-33
         ADI       R1,14B          POSITION TO DATA             EPSR-33
         BL        MGETBYTS        GET DATA VALUE FROM RECORD   EPSR-33
         CI        R5,1            ONE BYTE OF DATA             EPSR-33
         BNE       M2NOBJ.6        NO...CONTINUE                EPSR-33
         SLL       R7,24           POSITION BYTE FOR RECORD     EPSR-33
         STW       R7,XSYMBUF+2W   SAVE VALUE IN BUFFER         EPSR-33
         BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.6 CI        R5,2            TWO BYTES OF DATA            EPSR-33
         BNE       M2NOBJ.7        NO...CONTINUE                EPSR-33
         SLL       R7,16           POSITION TWO BYTES           EPSR-33
         STW       R7,XSYMBUF+2W   SAVE VALUE IN RECORD         EPSR-33
         BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.7 CI        R5,4            FOUR BYTES OF DATA           EPSR-33
         BNE       M2NOBJ.8        NO...CONTINUE                EPSR-33
         STW       R7,XSYMBUF+2W   SAVE VALUE IN RECORD         EPSR-33
         BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.8 STW       R6,XSYMBUF+2W   SAVE 8 BYTES OF DATA         EPSR-33
         STW       R7,XSYMBUF+3W                                EPSR-33
         BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.A LI        R4,-8           GET 8 BYTES OF DATA          EPSR-33
         ADI       R1,14B          POSITION TO DATA VALUE       EPSR-33
         BL        MGETBYTS        GET DATA FROM RECORD         EPSR-33
         STW       R6,XSYMBUF+2W   SAVE DATA VALUE IN BUFFER    EPSR-33
         STW       R7,XSYMBUF+3W                                EPSR-33
         BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         ZMW       XSYMBUF+2W      CLEAR BUFFER                 EPSR-33
         ZMW       XSYMBUF+3W                                   EPSR-33
         ADI       R1,8B           GET NEXT TWO WORDS OF DATA   EPSR-33
         BL        MGETBYTS                                     EPSR-33
         STW       R6,XSYMBUF+2W   SAVE VALUE IN BUFFER         EPSR-33
         STW       R7,XSYMBUF+3W                                EPSR-33
         BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.B ADI       R1,14B          POSITION TO DATA IN RECORD   EPSR-33
         LH        R5,M2TEMPLN     GET DATA LENGTH              EPSR-33
         CI        R5,16           GREATER THAN 16 BYTES        EPSR-33B
         BLE       $+2W            NO...BRANCH                  EPSR-33B
         LI        R5,16           ELSE FORCE TO 16 BYTES       EPSR-33B
         ZR        R2                                           EPSR-33
M2NOBJ.C CI        R5,0            ALL DONE WITH DATA           EPSR-33
         BEQ       M2NOBJ.D        YES...BRANCH                 EPSR-33
         CI        R2,8            8 BYTES OF DATA READ?        EPSR-33
         BEQ       M2NOBJ.E        YES...OUTPUT FIRST RECORD    EPSR-33
         LI        R4,-1                                        EPSR-33
         BL        MGETBYTS        GET ONE BYTE OF DATA         EPSR-33
         STB       R7,XSYMBUF+2W,X2    SAVE DATA IN BUFFER      EPSR-33
         ADI       R1,1            INCREMENT POINTERS           EPSR-33
         ADI       R2,1                                         EPSR-33
         SUI       R5,1            DECREMENT DATA LENGTH        EPSR-33
         BU        M2NOBJ.C        NEXT BYTE OF DATA            EPSR-33
M2NOBJ.D BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         BU        M2SYMB.Q        RETURN                       EPSR-33
M2NOBJ.E BL        XDBGSYM         OUTPUT RECORD                EPSR-33
         ZR        R2                                           EPSR-33
         ZMW       XSYMBUF+2W      CLEAR BUFFER                 EPSR-33
         ZMW       XSYMBUF+3W                                   EPSR-33
         BU        M2NOBJ.C        PROCESS MORE DATA            EPSR-33
*
         TITLE     M2SYMB   - DEBUG SYMBOL RECORD
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*
*     M2SYMB   -    SYMBOLIC DEBUG INFORMATION (PASS B)
*                   OUTPUT TO TEMP FILE (#SY) RESOLVED 4 WORD ITEM
*                   TO BE USED BY THE SYMBOLIC DEBUGGER
*
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
M2SYMB   EQU       $
         TBM       MOPT19,MFLGS    IS SYMBOL GENERATION ON       1.3#05
         BNS       M2SYMB.X        RETURN IF NOT                 1.3#05
         STF       R0,M2SAVREG     SAVE REGISTERS
*!!!!!!!!LB!!!!!!!!R1,MBLKX!!!!!!!!LOAD!INDEX!TO!MCBUF!!!!!!!!!!EOBJ-30
         LA        R1,MCBUF        ADDRESS OF OBJECT BUFFER     EOBJ-30
         ADMB      R1,MBLKX        ADD IN INDEX INTO MCBUF      EOBJ-30
         ADI       R1,10B          POSITION TO NAME
*
*!!!!!!!!LI!!!!!!!!R4,-7!!!!!!!!!!!LENGTH-1!TO!ASSEMBLE!!1.3#05!EOBJ-30
         LI        R4,-8           GET 8 BYTE NAME              EOBJ-30
         BL        MGETBYTS                                     EOBJ-30
*!!!!!!!!ZR!!!!!!!!R6!!!!!!!!!!!!!!INIT!R6!!!!!!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ZR!!!!!!!!R7!!!!!!!!!!!!!!AND!R7!!!!!!!!!!!!!!!!1.3#05!EOBJ-30
*!M2SYM.1!!LB!!!!!!!!R5,MCBUF,X1!!!GET!THE!BYTE!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R7!!!!!!!!!!!INTO!ASSEMBLY!REGISTER1.3#05!EOBJ-30
*!!!!!!!!SLLD!!!!!!R6,8!!!!!!!!!!!!AND!POSITION!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ADI!!!!!!!R1,1!!!!!!!!!!!!BUMP!INPUT!INDEX!!!!!!1.3#05!EOBJ-30
*!!!!!!!!BIB!!!!!!!R4,M2SYM.1!!!!!!AND!!LOOP!!!!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R5,MCBUF,X1!!!!!GET!THE!LAST!BYTE!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R7!!!!!!!!!!!AND!ADD!IN!!!!!!!!!!!!1.3#05!EOBJ-30
         STD       R6,XSYMBUF      SET SYMBOL INTO BUFFER        1.3#05
         LB        R2,MBLKX        INDEX INTO MCBUF             EOBJ-30
         LB        R5,MCBUF,X2     LOAD RECORD LENGTH           EOBJ-30
         TBR       R5,30           IS THIS COMMON TYPE RECORD?  EOBJ-30
         BS        M2SYM.A         GET NAME IF SO               EOBJ-30
         TBR       R5,31           IS THIS DATAPOOL TYPE RECORD EOBJ-30
         BNS       M2SYM.0         SKIP NAME IF NOT             EOBJ-30
M2SYM.A  ADI       R1,8B           POINT TO COMMON BLOCK NAME   EOBJ-30
         BL        MGETBYTS        GET NAME                     EOBJ-30
         STD       R6,BLKNAM       STORE COMMON BLOCK NAME      EOBJ-30
*
*!!!!!!!!LB!!!!!!!!R1,MBLKX!!!!!!!!RESET!INDICIES!!!!!!!!1.3#05!EOBJ-30
M2SYM.0  LA        R1,MCBUF        ADDRESS OF OBJECT BUFFER     EOBJ-30
         ADMB      R1,MBLKX        ADD IN INDEX INTO MCBUF      EOBJ-30
         ADI       R1,1W           BUMP TO 2ND WORD (WORD ONE)
*!!!!!!!!LB!!!!!!!!R6,MCBUF,X1!!!!!LOAD!TYPE!CODE!!!!!!!!1.3#05!EOBJ-30
         LI        R4,-4           GET TYPE CODE AND ADDRESS    EOBJ-30
         BL        MGETBYTS                                     EOBJ-30
         STW       R7,M2SYMTMP     SAVE TYPE AND ADDRESS        EOBJ-30
*                                                                1.3#05
*!!!!!!!!LI!!!!!!!!R4,15!!!!!!!!!!!SET!UP!TYPE!CODE!MASK!1.3#05!EOBJ-30
*!!!!!!!!TRRM!!!!!!R6,R3!!!!!!!!!!!MOVE!THE!TYPE!CODE!!!!1.3#05!EOBJ-30
*!!!!!!!!SLL!!!!!!!R3,1!!!!!!!!!!!!CONVERT!TO!HW!INDEX!!!1.3#05!EOBJ-30
*!!!!!!!!LH!!!!!!!!R5,M2LENTAB,X3!!GET!LENGTH!OF!THIS!TYP1.3#05!EOBJ-30
         ADI       R1,4            POSITION TO NEXT WORD IN OBJ.EOBJ-30
         LI        R4,-2           GET SIZE                     EOBJ-30
         BL        MGETBYTS                                     EOBJ-30
*!!!!!!!!STH!!!!!!!R5,M2TEMPLN!!!!!SAVE!CONVERSION!LENGTH!FOUND!EOBJ-30
         STH       R7,M2TEMPLN     SAVE SIZE                    EOBJ-30
*2SYM.11 CI        R6,8            IS THIS BIT VARIABLE ?       EOBJ-30
*!!!!!!!!BNE!!!!!!!M2SYM.2!!!!!!!!!NO!-!DON'T!SET!UP!BIT!POSITIOEOBJ-30
*!!!!!!!!SBM!!!!!!!0,M2TEMPLN!!!!!!SET!FLAG!TO!INDICATE!BIT!(08)EOBJ-30
*!!!!!!!!LI!!!!!!!!R4,7!!!!!!!!!!!!LOAD!MASK!!!!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!LMB!!!!!!!R5,MCBUF+3B,X1!!!LOAD!THE!BIT!NUMBER!!1.3#05!EOBJ-30
*!!!!!!!!SLL!!!!!!!R5,4!!!!!!!!!!!!ALLIGN!FOR!MERGE!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R6!!!!!!!!!!!R6-->BIT!NR!(24-27)!TY1.3#05!EOBJ-30
*!M2SYM.2!!!EQU!!!!!!$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R7,MCBUF+1,X1!!!GET!FIRST!BYTE!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!SLL!!!!!!!R7,8!!!!!!!!!!!!POSITION!!!!!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R5,MCBUF+2,X1!!!GET!NEXT!BYTE!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R7!!!!!!!!!!!ASSEMBLE!!!!!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!SLL!!!!!!!R7,8!!!!!!!!!!!!AND!POSITION!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R5,MCBUF+3,X1!!!GET!LAST!BYTE!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R7!!!!!!!!!!!AND!ASSEMBLE!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!SRL!!!!!!!R7,3!!!!!!!!!!!!DELETE!BIT!NUM!FIELD!!1.3#05!EOBJ-30
*                                                                1.3#05
         LB        R5,M2SYMTMP     LOAD TYPE CODE               EOBJ-30
         SRC       R5,8            POSITION TO SECOND BYTE      EOBJ-30
         ZR        R7              CLEAR R7                     S881693
         LW        R6,M2SYMTMP     LOAD TYPE AND ADDRESS        EOBJ-30
         SRLD      R6,3            SHIFT OUT BIT NUMBER         EOBJ-30
         SRL       R7,1            POSITION IN FIRST BYTE       EOBJ-30
         ORR       R5,R7           OR IN TYPE CODE              EOBJ-30
         LW        R4,=X'1FFFFF'   MASK FOR ADDRESS             EOBJ-30
         TRRM      R6,R6           PURE ADDRESS                 EOBJ-30
         ORR       R7,R6           OR IN TYPE AND BIT NUMBER    EOBJ-30
         STW       R6,XSYMBUF+2W   SAVE BIT NUM.,TYPE, AND ADDR.EOBJ-30
*!!!!!!!!STD!!!!!!!R6,M2SYMTMP!!!!!SAVE!R6!AND!R7!FOR!BUILDING!PEOBJ-30
*!!!!!!!!SUI!!!!!!!R1,1W!!!!!!!!!!!ADJUST!TO!BEGINNING!OF!ITEM!AEOBJ-30
         LB        R1,MBLKX        INDEX INTO MCBUF             EOBJ-30
         LI        R4,15           SET MASK
         LMB       R5,MCBUF,X1     LOAD FLG FIELD FROM OBJ REC.
         SLL       R5,2            POSITION FLG BITS            EOBJ-30
         ADI       R1,3B           POSITION TO FLAG FIELD       EOBJ-30
         LI        R4,3            LOAD MASK                    EOBJ-30
         LMB       R6,MCBUF,X1     GET FLAG BITS                EOBJ-30
         ORR       R5,R6           COMBINE FLG AND FLAG BITS    EOBJ-30
         SLL       R6,2                                         EOBJ-30
         STB       R6,SYMFLAGS     SAVE FLG AND FLAG BITS       EOBJ-30
*!!!!!!!!STB!!!!!!!R5,XSYMFLGS+3B!!SAVE!FLAGS!!!!!!!!!!!!!!!!!!!EOBJ-30
M2SYM.NO TBM       MCOBJ,MFLAG3    IS THIS C OBJECT             CAID
         BS        M2SYM.8         YES, DO STRUCT/UNION REF     CAID
*CAID M2SYM.NO TBM  COMFLG,SYMFLAGS IS THIS COMMON TYPE RECORD? CAID
         TBM       COMFLG,SYMFLAGS IS THIS COMMON TYPE RECORD?  CAID
         BS        M2SYM.52        PROCESS COMMON RECORD        EOBJ-30
         TBM       DPLFLG,SYMFLAGS IS THIS DATAPOOL TYPE RECORD EOBJ-30
         BS        M2SYM.52        PROCESS DATAPOOL RECORD      EOBJ-30
         BU        M2SYM.8         FINISH PROCESSING IF NOT     EOBJ-30
*!!!!!!!!TBM!!!!!!!30,MCBUF,X1!!!!!IS!THIS!SYMBOL!ABSOLUTE?!!!!!EOBJ-30
*!!!!!!!!BS!!!!!!!!M2SYM.31!!!!!!!!BRANCH!IF!SO!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!TBM!!!!!!!31,MCBUF,X1!!!!!IS!THIS!SYMBOL!IN!CSECT!?!!!!EOBJ-30
*!!!!!!!!BNS!!!!!!!M2SYM.F!!!!!!!!!NO!-!CONTINUE!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!LW!!!!!!!!R4,MSEC1O!!!!!!!LOAD!UP!CSECT!ORIGIN!ADDRESS!EOBJ-30
*!!!!!!!!ARMW!!!!!!R4,M2SYMTMP+1W!!ADD!TO!MODULE!RELATIVE!ADDRESEOBJ-30
*!M2SYM.31!!SBM!!!!1,XSYMFLGS!!!!!!SET!ABSOLUTE!ADDRESS!FLAG!!!!EOBJ-30
*!M2SYM.F!!!TBM!!!!!!28,XSYMFLGS!!!CK!FOR!EXPANDED!MEM!PARAM!WOREOBJ-30
*!!!!!!!!BNS!!!!!!!$+2W!!!!!!!!!!!!NO!-!CONTINUE!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!SBM!!!!!!!8,M2SYMTMP+1W!!!SET!INDIRECTION!BIT!!!!!!!!!!EOBJ-30
*!!!!!!!!TBM!!!!!!!29,XSYMFLGS!!!!!CK!FOR!FORMAL!PARAMETER!!!!!!EOBJ-30
*!!!!!!!!BNS!!!!!!!$+2W!!!!!!!!!!!!NO!-!CONTINUE!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!SBM!!!!!!!8,M2SYMTMP+1W!!!SET!INDIRECTION!BIT!!!!!!!!!!EOBJ-30
*!!!!!!!!TBM!!!!!!!30,XSYMFLGS!!!!!IS!DATUM!IN!COMMON!!!!!!!!!!!EOBJ-30
*!!!!!!!!BS!!!!!!!!M2SYM.4!!!!!!!!!YES!FIND!BLOCK!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!TBM!!!!!!!31,XSYMFLGS!!!!!IS!DATUM!IN!DATAPOOL!!!!!!!!!EOBJ-30
*!!!!!!!!BS!!!!!!!!M2SYM.4!!!!!!!!!YES!LOOK!UP!DATAPOOL!DICTIONAEOBJ-30
*!!!!!!!!BU!!!!!!!!M2SYM.8!!!!!!!!!COMPLETE!BUILD!PROCESS!!!!!!!EOBJ-30
*!M2SYM.4!!!LB!!!!!!!R1,MBLKX!!!!!!LOAD!INDEX!!!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!ADI!!!!!!!R1,18B!!!!!!!!!!POSITION!TO!COMMON!BLOCK!NAMEEOBJ-30
*!!!!!!!!LI!!!!!!!!R4,-7!!!!!!!!!!!ASSEMBLY!LENGTH-1!!!!!1.3#05!EOBJ-30
*!!!!!!!!ZR!!!!!!!!R6!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!ZR!!!!!!!!R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!EOBJ-30
*!M2SYM.5!!!LB!!!!!!!R5,MCBUF,X1!!!GET!A!BYTE!!!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!SLLD!!!!!!R6,8!!!!!!!!!!!!SHIFT!FOR!NEXT!MOVE!!!!!!!!!!EOBJ-30
*!M2SYM.51!!!ADI!!!!!!R1,1!!!!!!!!!INCREMENT!INDEX!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!BIB!!!!!!!R4,M2SYM.5!!!!!!BUILD!FULL!NAME!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!LB!!!!!!!!R5,MCBUF,X1!!!!!GET!LAST!BYTE!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R7!!!!!!!!!!!AND!ASSEMBLE!!!!!!!!!!1.3#05!EOBJ-30
*                                                                1.3#05
M2SYM.52 LD        R6,BLKNAM       LOAD COMMON NAME             EOBJ-30
         TBM       COMFLG,SYMFLAGS IS THIS A COMMON BLOCK?      EOBJ-30
*2SYM.52 TBM       30,XSYMFLGS     IS THIS A COMMON BLOCK ?     EOBJ-30
         BNS       M2SYM.7         NO - MUST BE A DATAPOOL BLOCK
         ZR        R5              SEARCH ENTIRE SYMBOL TABLE
         LW        R4,=X'21000000' SEARCH FOR COMMON BLOCK
M2SYM.K  EQU       $
         BL        MSSCH           S E A R C H
         TRR       R5,R1
         BNE       M2SYM.K1        BRANCH IF COMMON ENTRY FOUND
         LI        R5,E.COMREF     REFERENCE TO UNDEFINED COMMON BLK
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
M2SYM.K1 TBM       6,0W,X1         IS COMMON ORIGINED THIS MODULE ?
         BS        M2SYM.L         YES - USE SYMBOL TABLE ENTRY FOUND
         TBM       7,0W,X1         IS COMMON ALLOCATED IN THIS ELEMENT
         BS        M2SYM.L         YES - USE SYMBOL TABLE ENTRY FOUND
*                                                                1.3#05
*   WHEN NOT PLACED IN THIS PROG. ADDR FEILD POINTS TO SYMTAB    1.3#05
*   ENTRY WHERE IT IS ORGED. SO USE IT!                          1.3#05
         LW        R1,1W,X1        GET ORGED PLACE               1.3#05
         ANMW      R1,=X'00FFFFFF' DROP THE BLOCK NUMBER         1.3#05
M2SYM.L  TBM       3,0W,X1         IS THIS A GLOBAL COMMON BLOCK
         BNS       $+2W            NO - THEN ADDRESS IS RELATIVE
*!!!!!!!!SBM!!!!!!!1,XSYMFLGS!!!!!!SET!ABSOLUTE!FLAG!!!!!!!!!!!!EOBJ-30
         SBM       ABSFLG,SYMFLAGS SET ABSOLUTE FLAG            EOBJ-30
*!!!!!!!!LD!!!!!!!!R6,M2SYMTMP!!!!!RESTORE!R6!AND!R7!!!!!!!!!!!!EOBJ-30
         LW        R7,XSYMBUF+2W   LOAD BIT NUM.,TYPE, AND ADDR EOBJ-30
         LW        R4,=X'00FFFFFF' LOAD MASK
         LMW       R5,1W,R1        LOAD ADDRESS OF COMMON BASE
         ADR       R5,R7           COMBINE BASE PLUS OFFSET TO R7
         TBM       MABS,MFLGS      ARE WE IN ABS MODE           |85.0949
         BNS       $+3W            SKIP IF NOT                  |85.0949
         ADMW      R7,MPABS        ELSE ADD ABS BASE            |85.0949
*!!!!!!!!SBM!!!!!!!1,XSYMFLGS!!!!!!AND!SET!ABS!FLAG!!!!!85.0949!EOBJ-30
         SBM       ABSFLG,SYMFLAGS AND SET ABS FLAG             EOBJ-30
*!!!!!!!!SLL!!!!!!!R6,24!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!EOBJ-30
*!!!!!!!!ORR!!!!!!!R6,R7!!!!!!!!!!!R7-->!BIT,TYPE!AND!ADDRESS!!!EOBJ-30
         BU        M2SYM.9         BUILD AND OUTPUT ITEM
M2SYM.7  EQU       $               DATAPOOL EXTRACTION LOGIC
*!!!!!!!!SBM!!!!!!!1,XSYMFLGS!!!!!!SET!ABSOLUTE!FLAG!!!!!!!!!!!!EOBJ-30
         SBM       ABSFLG,SYMFLAGS SET ABSOLUTE FLAG            EOBJ-30
         CAMD      R6,DPNAME       SEE IF DATAPOOL             1.2.3
         BEQ       M2SYM.73        IF SO BRANCH                1.2.3
         LW        R6,BLANKS       MUST BE DPOOL00-DPOOL99     1.2.3
         SLL       R7,8            STRIP OFF 'L'               1.2.3
         SRL       R7,16           LEFT JUSTIFIED              1.2.3
         SBR       R7,2            BLANK FILL                  1.2.3
         SBR       R7,10                                       1.2.3
         M.CONADB                  CONVERT TO BINARY           1.2.3
         TRR       R7,R5           MOVE TO PROPER REGESTER       1.3#15
         LD        R6,XSYMBUF      LOAD DATUM NAME FROM BUFFER   1.3#05
         STW       R5,M2SYM.DN     SAVE NUMBER                   1.3#15
         BL        XGETDP          LOOK UP IN DICTIONARY         1.3#15
         BS        M2SYMB.Q        ABANDON THIS SYMBOL           1.3#15
         BU        M2SYM.75        CONTINUE                    1.2.3
M2SYM.73 EQU       $                                           1.2.3
         LD        R6,XSYMBUF      LOAD DATUM NAME FROM OUTPUT   1.3#05
         LI        R5,100          SET FOR DATAPOOL              1.3#15
         STW       R5,M2SYM.DN     SAVE NUMBER                   1.3#15
         BL        XGETDP          LOOK UP IN DATAPOOL DICTIONARY
         BS        M2SYMB.Q        ABANDON THIS SYMBOL           1.3#15
*2SYM.75 LD        R6,M2SYMTMP     RESTORE R6 AND R7            EOBJ-30
M2SYM.75 LW        R7,XSYMBUF+2W   LOAD BIT NUM.,TYPE, AND ADDR EOBJ-30
         LW        R4,=X'00FFFFFF' LOAD ADDRESS MASK
*!!!!!!!!TRRM!!!!!!R5,R7!!!!!!!!!!!GET!PURE!ADDRESS!!!!!!!!!!!!!EOBJ-30
         TRRM      R5,R5           GET PURE ADDRESS             EOBJ-30
         LW        R4,=X'FF000000' EXTRACT BIT NUM. AND TYPE    EOBJ-30
         TRRM      R7,R7                                        EOBJ-30
         ORR       R5,R7           COMBINE ADDRESS,BIT NUM,TYPE EOBJ-30
         LW        R1,M2SYM.DN     RECOVER POOL NUMBER           1.3#15
         SLL       R1,4            CONVERT TO TABLE INDEX        1.3#15
         ADMW      R7,DPOOLTAB+PRTSTRT,X1   ADD DEFINED START    1.3#15
         LW        R4,=X'00FFFFFF' ADDRESS MASK                 EOBJ-30
         TRRM      R7,R5                                        EOBJ-30
*!!!!!!!!CAMW!!!!!!R7,DPOOLTAB+PRTEND,X1!!!COMPARE!TO!END1.3#15!EOBJ-30
         CAMW      R5,DPOOLTAB+PRTEND,X1   COMPARE TO END       EOBJ-30
         BGE       M2SYMB.Q        ABANDON IF TOO HIGH           1.3#15
*!!!!!!!!SLL!!!!!!!R6,24!!!!!!!!!!!PREPARE!TO!COMBINE!!!!!!!!!!!EOBJ-30
*!!!!!!!!ORR!!!!!!!R6,R7!!!!!!!!!!!R7==>BIT,TYPE,!AND!ADDRESS!!!EOBJ-30
         BU        M2SYM.9         CONTINUE BUILD PROCESS
*2SYM.8  LD        R6,M2SYMTMP     RESTORE R6 AND R6            EOBJ-30
*!!!!!!!!TBM!!!!!!!1,XSYMFLGS!!!!!!IS!THIS!ADDRESS!IN!CSECT!!!!!EOBJ-30
*!!!!!!!!BS!!!!!!!!M2SYM.81!!!!!!!!BRANCH!IF!IN!CSECT!!!!!!!!!!!EOBJ-30
M2SYM.8  TBM       ADRFLG,SYMFLAGS IS SYMBOL ABSOLUTE           EOBJ-30
         BS        M2SYM.80                                     EOBJ-30
         TBM       CSCFLG,SYMFLAGS IS SYMBOL IN CSECT           EOBJ-30
         BNS       M2SYM.82                                     EOBJ-30
*!!!!!!!!LW!!!!!!!!MSEC1O!!!!!!!!!!LOAD!CSECT!ORIGIN!ADDRESS!!!!ELST-32
         LW        R4,DEBIAS       LOAD CSECT ORIGIN ADDRESS    ELST-32
         ADMW      R4,CSCTBASE+MDSTORG                          ELST-32
         ARMW      R4,XSYMBUF+2W   ADD TO SYMBOL ADDRESS        EOBJ-30
M2SYM.80 SBM       ABSFLG,SYMFLAGS SET ABSOLUTE ADDRESS FLAG    EOBJ-30
         ZBM       ADRFLG,SYMFLAGS   CLEAR ABSOLUTE SYMBOL FLAG PR12230
         BU        M2SYM.91                                     EOBJ-30
M2SYM.82 LW        R7,XSYMBUF+2W   LOAD SYMBOL ADDRESS          EOBJ-30
         ADMW      R7,XCOMRELO     ADD OFFSET FOR BLANK COMMON
*2SYM.81 SLL       R6,24           PREPARE TO COMBINE           EOBJ-30
*!!!!!!!!ORR!!!!!!!R6,R7!!!!!!!!!!!R7-->BIT,TYPE!AND!ADDRESS!!!!EOBJ-30
M2SYM.9  EQU       $
         STW       R7,XSYMBUF+2W    STORE ADDRESS VARIABLE       1.3#05
M2SYM.91 LB        R6,XSYMBUF+2W   GET TYPE CODE                EOBJ-30
         TBM       MCOBJ,MFLAG3    IS THIS C OBJECT             CAID
         BS        M2SYM.G1        YES, SIZE IS CORRECT         CAID
         LI        R4,15           TYPE CODE MASK               EOBJ-30
         TRRM      R6,R6                                        EOBJ-30
         CI        R6,11           IS IT CHARACTER TYPE SYMBOL  EOBJ-30
         BEQ       M2SYM.G0        ALREADY HAVE LENGTH          EOBJ-30
*!!!!!!!!LH!!!!!!!!R6,M2TEMPLN!!!!!GET!TYPE!GENERATED!LEN1.3#05!EOBJ-30
*!!!!!!!!BNZ!!!!!!!M2SYM.G!!!!!!!!!USE!IT!IF!NOT!ZERO!!!!1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R1,MBLKX!!!!!!!!ELSE!GET!LENGTH!FROM!O1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R6,MCBUF+8,X1!!!TOP!BYTE!OF!SIZE!FIELD1.3#05!EOBJ-30
*!!!!!!!!LB!!!!!!!!R5,MCBUF+9,X1!!!BOTTOM!BYTE!OF!FIELD!!1.3#05!EOBJ-30
*!!!!!!!!SLL!!!!!!!R6,8!!!!!!!!!!!!POSITION!!!!!!!!!!!!!!1.3#05!EOBJ-30
*!!!!!!!!ORR!!!!!!!R5,R6!!!!!!!!!!!ASSEMBLE!!!!!!!!!!!!!!1.3#05!EOBJ-30
         TRR       R6,R7           TYPE TO R7                   EOBJ-30
         TRR       R6,R3           PUT TYPE IN R3               EOBJ-30
         SLL       R3,1            CHANGE TO HALFWORD INDEX     EOBJ-30
         LH        R6,M2LENTAB,R3  GET LENGTH FROM TABLE        EOBJ-30
         CI        R7,8            BIT TYPE VARIABLE?           EOBJ-30
         BNE       M2SYM.G         CONTINUE IF NOT              EOBJ-30
         SBR       R6,16           SET BIT TYPE VARAIBLE FLAG   EOBJ-30
         BU        M2SYM.G                                      EOBJ-30
M2SYM.G0 CI        R6,8            BIT TYPE VARIBLE?            EOBJ-30
         BNE       M2SYM.G1        CONTINUE IF NOT              EOBJ-30
         SBM       0,M2TEMPLN      SET BIT TYPE VARIABLE FLAG   EOBJ-30
M2SYM.G1 LH        R6,M2TEMPLN     LOAD SIZE                    EOBJ-30
M2SYM.G  EQU       $               MERGE                         1.3#05
         SLL       R6,16           POSITION DATA                 1.3#05
         LA        R1,MCBUF        OBJECT BUFFER ADDRESS        CAID
         ADMB      R1,MBLKX        INDEX TO DEBUG INFO RECORD   CAID
         LB        R5,5B,X1        GET POINTER LEVEL            CAID
*CAID1   SLL       R5,8            POSITION TO BITS 16-23       CAID1
         SLL       R5,12           POSITION TO BITS 16-19       CAID1
         ORR       R5,R6           COMBINE WITH SIZE            CAID
         LB        R5,SYMFLAGS     LOAD SYMBOL FLAGS            EOBJ-30
         ORR       R5,R6           COMBINE WITH SIZE            EOBJ-30
         TBM       3,XSYMFLGS      IS ENTIRE MODULE ABSOLUTE
         BNS       $+2W            NO - CONTINUE
         SBR       R6,31           SET ABSOLUTE BIT ON
         STW       R6,XSYMBUF+3W    STORE DATUM LENGTH,0,0,FLG   1.3#05
*                                                               EAID-32
*  INSERT CORRECT ADDRESS FOR EXTENDED MEMORY VARIABLES         EAID-32
*                                                               EAID-32
         LA        R1,MCBUF                                     EAID-32
         ADMB      R1,MBLKX        INDEX TO DEBUG INFO RECORD   EAID-32
         LB        R4,1B,X1        GET SUBTYPE                  EAID-32
         CI        R4,X'0E'        NEW DEBUG INFO?              EAID-32
         BEQ       AID.0           YES, SKIP CHEK FOR AID FIX   EAID-32
         TBM       5,3B,X1         EXTENDED MEMORY VARIABLE?    EAID-32
         BS        EM.VAR          BRANCH IF SO                 EAID-32
*                                                               EAID-32
*  THIS (INSUFFICIENT) TEST IS KEPT FOR COMPATIBILITY WITH OLD VERSION
*  (PRE E.2B FINAL) OF COMPILER THAT DID NOT SET BIT 5 TO INDICATE
*  AN EXTENDED MEMORY VARIABLE WITH A CORRECTED ADDRESS
*                                                               EAID-32
         LB        R4,2,X1         FETCH LENGTH                 EAID-32
         CI        R4,X'16'        EXT MEM VARIABLE?(LENTH TEST)EAID-32
         BNE       AID.0           BRANCH IF NOT                EAID-32
         LB        R4,4,X1         FETCH TYPE                   EAID-32
         CI        R4,X'0E'        STATEMENT?                   EAID-32
         BEQ       AID.0           BRANCH IF SOURCE STATEMENT   EAID-32
EM.VAR   EQU       $               GET HERE IF EXT MEM VARIABLE EAID-32
         LA        R3,X'12',X1     POINT TO CORRECT EM ADDRESS  EAID-32
         TRR       R2,R6           SAVE R2                      EAID-32
         BL        GETWX3          FETCH CORRECT ADDRESS        EAID-32
         SLL       R7,8            CLEAR 1ST BYTE               EAID-32
         SRL       R7,8                                         EAID-32
         TRR       R6,R2           RESTORE R2                   EAID-32
         LB        R4,XSYMBUF+2W   FETCH BYTE 0 OF ADDRESS WORD EAID-32
         SLL       R4,24           MOVE TO BYTE 0               EAID-32
         ORR       R4,R7           MERGE WITH CORRECT ADDRESS   EAID-32
         STW       R7,XSYMBUF+2W   ...AND PUT BACK              EAID-32
*-------------------------------------------------------------  EAID-32
*  CHECK FOR SOURCE IN TYPE 15 SUB-BLOCKS                       EAID-32
*                                                               EAID-32
AID.0    EQU       $                                            EAID-32
         LA        R1,MCBUF                                     EAID-32
         ADMB      R1,MBLKX        INDEX TO DEBUG INFO RECORD   EAID-32
         LB        R4,4B,X1        FETCH TYPE                   EAID-32
         CI        R4,14           STATEMENT?                   EAID-32
         BNE       AID.1           NO                           EAID-32
         LB        R6,2B,X1        GET LENGTH OF RECORD         EAID-32F
         CI        R6,20           COMPARE AGAINST 20 BYTES     EAID-32F
         BLE       AID.1           IF 20 OR LESS, NO SOURCE     EAID-32F
         BL        AID_SREC        YES, GO PROCESS              EAID-32
         TRR       R6,R6           ANY SOURCE FOR THIS SYMBOL   EAID-32B
         BZ        AID.1           SKIP SOURCE ADDR SAVE        EAID-32B
         LB        R5,XSYMBUF+15B  GET FLAGS                    EAID-32B
         ZBR       R5,28           CLEAR ABS. BIT, NOW RESERVED EAID-32B
         ORR       R5,R6           OR IN WITH SOURCE INFO       EAID-32B
         STW       R6,XSYMBUF+3W   STORE REL ADDR OF SRCE STMT  EAID-32
         STB       R4,XSYMBUF+2W   STORE TYPE BYTE SECT # >1024 EAID-32
*                                  WE BORROW BITS 0-2 IN BYTE   EAID-32
AID.1    EQU       $                                            EAID-32
*                                                               EAID-32
*--------------------------------------------------------------------
*  CHECK FOR ARRAY INFO AND SET UP 'XSYMAID' BUFFER IF PRESENT  EAID-32
*                                                               EAID-32
         LI        R5,1            COUNT OF ENTRIES TO OUTPUT   EAID-32
         LB        R4,1B,X1        GET SUB TYPE                 EAID-32
         CI        R4,X'0E'        NEW DEBUG INFO?              EAID-32
         BNE       AID.1O                                       EAID-32
* Do processing for struct/union reference                      CAID
         TBM       COMFLG,SYMFLAGS IS THIS A STRUCT/UNION REF   CAID
         BNS       CAID.0          NO, NORMAL PROCESSING        CAID
         ZBM       COMFLG,SYMFLAGS CLEAR FLAG                   CAID
         LD        R6,XSYMBUF      SAVE CURRENT INFO            CAID
         STD       R6,XSYMAID                                   CAID
         LD        R6,XSYMBUF+1D                                CAID
         STD       R6,XSYMAID+1D                                CAID
         LD        R6,BLKNAM       GET REFERENCED STRUCT/UNION  CAID1
         STD       R6,XSYMBUF      SET NAME                     CAID1
         LI        R5,19           CHANGE TYPE TO STRUCT REF    CAID
         STB       R5,XSYMBUF+8B   SET NEW TYPE                 CAID
         TBM       3,XSYMFLGS      ABSOLUTE?                    CAID
         BNS       $+2W            IF SO...                     CAID
         SBM       31,XSYMBUF+3W   TELL THE DEBUGGER            CAID
         BL        XDBGSYM         OUTPUT RECORD                CAID
*CAID1   LD        R6,BLKNAM       GET REFERENCED STRUCT/UNION  CAID1
*CAID1   STD       R6,XSYMBUF      SET NAME                     CAID1
*CAID1   BL        XDBGSYM         OUTPUT RECORD                CAID1
         LD        R6,XSYMAID      RESTORE INFORMATION          CAID
         STD       R6,XSYMBUF                                   CAID
         LD        R6,XSYMAID+1D                                CAID
         STD       R6,XSYMBUF+1D                                CAID
         TBM       3,XSYMFLGS      ABSOLUTE?                    CAID1
         BNS       $+2W            IF SO...                     CAID1
         SBM       31,XSYMBUF+3W   TELL THE DEBUGGER            CAID1
         LA        R1,MCBUF        OBJECT BUFFER ADDRESS        CAID1
         ADMB      R1,MBLKX        INDEX TO DEBUG INFO RECORD   CAID1
         TBM       1,3B,X1         ARRAY INFO PRESENT?          CAID1
         BS        $+2W            YES, OUTPUT RECORD LATER     CAID1
         BL        XDBGSYM         OUTPUT RECORD                CAID1
         LI        R5,1            COUNT OF ENTRIES TO OUTPUT   CAID
         LB        R4,1B,X1        GET SUB TYPE                 CAID
         TBM       1,3B,X1         ARRAY INFO PRESENT?          CAID
         BS        CAID.1          YES, GO OUTPUT ARRAY INFO    CAID1
         BU        AID.19          NO, ALL DONE                 CAID1
CAID.0   TBM       1,3B,X1         ARRAY INFO PRESENT?          CAID
         BNS       AID.14          NO, CONTINUE                 EAID-32
CAID.1   TRR       R1,R3                                        CAID1
         ADI       R3,20           POINT TO ARRAY INFO          EAID-32
         TBM       4,3B,X1         SYMBOL IN COMMON?            EAID-32
         BNS       $+2W                                         EAID-32
         ADI       R3,8            YES, SKIP COMMON NAME ALSO   EAID-32
         TBM       MCOBJ,MFLAG3    IS THIS C OBJECT             CAID
         BS        AID.1M          YES, IGNORE DP FLAG          CAID
         TBM       5,3B,X1         SYMBOL IN DATAPOOL?          EAID-32
         BNS       $+2W                                         EAID-32
         ADI       R3,8            YES, SKIP COMMON NAME ALSO   EAID-32
         BU        AID.1M                                       EAID-32
AID.1O   TBM       4,3B,X1         ARRAY INFO PRESENT?          EAID-32
         BNS       AID.14          BRANCH IF INFO NOT PRESENT   EAID-32
         TRR       R1,R3                                        EAID-32
         ADI       R3,18B          POINT TO ARRAY INFO          EAID-32
         ZBM       5,3B,X1         EXT MEM SYM WITH CORRECT ADR EAID-32
         BNS       $+2W                                         EAID-32
         ADI       R3,4B           ACCOUNT FOR WORD WITH ADDR   EAID-32
         LI        R4,3            MASK FOR BITS 6 & 7          EAID-32
         ANMB      R4,,X1          IS SYM IN COMMON OR DATAPOOL EAID-32
         BZ        $+2W            BRANCH IF NOT COMMON OR DATA EAID-32
         ADI       R3,8B           POINT TO ARRAY INFO          EAID-32
AID.1M   LB        R5,,X3          FETCH NUMBER OF DIMENSIONS   EAID-32
         BZ        AID.14          SHOULD NEVER BE ZERO!        EAID-32
AID.12   EQU       $                                            EAID-32
         ANMW      R5,=X'0F'       JUST BITS 20-23, MAX 16      CAID1
         SLL       R5,8            POSITION TO BITS 20-23       EAID-32
         ZBM       21,XSYMBUF+3W   CLEAR GOULD DATAPOOL BIT     EAID-32
         ZBM       22,XSYMBUF+3W   CLEAR GOULD ABSOLUTE BIT     EAID-32
         ZBM       23,XSYMBUF+3W   CLEAR GOULD CSECT BIT        EAID-32
         ORMW      R5,XSYMBUF+3W   MERGE                        EAID-32
         SBR       R5,30           TELL DEBUG ARRAY INFO PRES   EAID-32
         STW       R5,XSYMBUF+3W   AND PUT BACK                 EAID-32
         LB        R5,2B,X3        FETCH 1ST BYTE OF BOUND INFO EAID-32
         SLL       R5,8                                         EAID-32
         ORMB      R5,3B,X3        FETCH BYTE 2                 EAID-32
         STW       R5,BND.INFO     SAVE LOWER/UPPER BOUND INFO  EAID-32
         LB        R5,6B,X3        FETCH 1ST BYTE OF SYM BOUND  EAID-32
         SLL       R5,8                                         EAID-32
         ORMB      R5,7B,X3        MERGE WITH 2 BYTE            EAID-32
         STW       R5,SYM.INFO     SAVE                         EAID-32
*                                                               EAID-32
*  NOW COPY ENTRY (AS PROTOTYPE) TO XSYMAID                     EAID-32
*                                                               EAID-32
         LD        R6,XSYMBUF                                   EAID-32
         STD       R6,XSYMAID                                   EAID-32
         LD        R6,XSYMBUF+1D                                EAID-32
         STD       R6,XSYMAID+1D                                EAID-32
*                                                               EAID-32
*  SET LOOP COUNT (# SYMBOL ENTRIES) AND SET X3 TO POINT TO 1ST BOUND
*                                                               EAID-32
         LB        R5,1B,X3        SET # OF BOUNDS              EAID-32
         ADI       R5,1            PLUS REGULAR SYMBOL ENTRY    EAID-32
         ADI       R3,8B           POINT TO 1ST BOUND           EAID-32
AID.14   EQU       $                                            EAID-32
         TBM       3,XSYMFLGS      ABSOLUTE?                    EAID-32
         BNS       $+2W            IF SO...                     EAID-32
         SBM       31,XSYMBUF+3W   TELL THE DEBUGGER            EAID-32
         BL        XDBGSYM         OUTPUT BUFFER AND CLEAR      EAID-32
*                                                               EAID-32
*  NOW CHECK FOR ANY MORE SYMBOLS (ARRAY BOUNDS) TO OUTPUT      EAID-32
*                                                               EAID-32
         SUI       R5,1                                         EAID-32
         BNP       AID.19          LEAVE IF NO BOUNDS TO OUTPUT EAID-32
*                                                               EAID-32
         LW        R7,SYM.INFO     FETCH SYMBOLIC BOUND INFO    EAID-32
         SRC       R7,1            CURRENT BOUND BIT TO BIT 0   EAID-32
         STW       R7,SYM.INFO     SAVE FOR NEXT PASS           EAID-32
         TBR       R7,0            IS THIS A SYMBOLIC BOUND?    EAID-32
         BNS       NOT.SYM         BRANCH IF NOT                EAID-32
         BL        GETWX3          GET WORD 1 OF SYMBOLIC BOUND EAID-32
         TRR       R7,R6                                        EAID-32
         BL        GETWX3          GET WORD 2 OF SYMBOLIC BOUND EAID-32
         SLLD      R6,1            BIT 31 IS ABSOLUTE BIT       EAID-32
         STW       R6,XSYMAID+2W   STORE WORD 1                 EAID-32
         LI        R4,1            BIT 31 MASK                  EAID-32
         LMW       R6,XSYMAID+3W   FETCH BIT 31                 EAID-32
         ORR       R6,R7           MERGE WITH WD 2 OF SYM BOUND EAID-32
         STW       R7,XSYMAID+3W   STORE WORD 2                 EAID-32
         BU        AID.16          MERGE WITH NON-SYMBOLIC CODE EAID-32
*                                                               EAID-32
*                                                               EAID-32
*  FETCH BOUND TO R7                                            EAID-32
*                                                               EAID-32
NOT.SYM  EQU       $                                            EAID-32
         BL        GETWX3          GET 4 BYTES POINTED TO BY R3 EAID-32
         SLL       R7,1            POSITION TO BITS 0-30        EAID-32
         LI        R4,1                                         EAID-32
         LMW       R6,XSYMAID+3W   GET PROTOTYPE WORD 3         EAID-32
         ORR       R6,R7           MERGE WITH BOUND             EAID-32
         STW       R7,XSYMAID+3W   AND PUT BACK                 EAID-32
AID.16   ZBM       0,XSYMAID+2W    CLEAR UP/LOW BOUND INDICATOR EAID-32
         LW        R7,BND.INFO     LOWER/UPPER BOUND INFO       EAID-32
         TBR       R7,31           IS THIS A LOWER BOUND        EAID-32
         BNS       $+2W            BRANCH IF NOT A LOWER BOUND  EAID-32
         SBM       0,XSYMAID+2W    INDICATE LOWER BOUND         EAID-32
         SRL       R7,1            SHIFT BOUND INFO             EAID-32
         STW       R7,BND.INFO     ...PUT BACK FOR NEXT BOUND   EAID-32
*                                                               EAID-32
*  MOVE BOUND ENTRY TO 'XSYMBUF'                                EAID-32
*                                                               EAID-32
         LD        R6,XSYMAID                                   EAID-32
         STD       R6,XSYMBUF                                   EAID-32
         LD        R6,XSYMAID+1D                                EAID-32
         STD       R6,XSYMBUF+1D                                EAID-32
*                                                               EAID-32
*  NOW GO OUTPUT ENTRY                                          EAID-32
*                                                               EAID-32
         BU        AID.14                                       EAID-32
*                                                               EAID-32
AID.19   EQU       $                                            EAID-32
M2SYMB.Q EQU       $                                             1.3#15
         ZBM       1,XSYMFLGS      RESET ABS BIT                EAID-32
         LF        R0,M2SAVREG     RESTORE REGISTERS
M2SYMB.X EQU       $                                             1.3#05
         TRSW      R0              RETURN
*                                                               EAID-32
*  ROUTINE TO RETURN IN R7 THE NEXT 4 BYTES POINTED TO BY R3    EAID-32
*                                                               EAID-32
GETWX3   EQU       $                                            EAID-32
         LI        R4,-4           LOOP CONTROL                 EAID-32
         ZR        R7                                           EAID-32
GET.NB   EQU       $                                            EAID-32
         LB        R2,,X3                                       EAID-32
         ADI       R3,1B                                        EAID-32
         ORR       R2,R7                                        EAID-32
         BIB       R4,GET.SHFT                                  EAID-32
         TRSW      R0                                           EAID-32
GET.SHFT SLL       R7,8                                         EAID-32
         BU        GET.NB                                       EAID-32
*                                                               EAID-32
         BOUND     1W                                           EAID-32
SYM.INFO REZ       1W              SYMBOLIC BOUND INDICATORS    EAID-32
BND.INFO REZ       1W              WORD FOR UP/LOW ARRAY BOUND  EAID-32
         BOUND     1D
XSYMAID  REZ       2D         PROTOTYPE ARRAY BOUND SYM ENTRY   EAID-32
M2SYMTMP DATAD     0               TEMP SAVE AREA
BLKNAM   DATAD     0               COMMON BLOCK/DATAPOOL NAME   EOBJ-30
M2TEMPLN DATAH     0               TEMP AREA FOR LENGTH CONVERSION
M2LENTAB DATAH     X'0001'    TYPE  0 = I*1                      1.3#05
         DATAH     X'0002'    TYPE  1 = I*2                      1.3#05
         DATAH     X'0004'    TYPE  2 = I*4                      1.3#05
         DATAH     X'0008'    TYPE  3 = I*8                      1.3#05
         DATAH     X'0004'    TYPE  4 = R*4                      1.3#05
         DATAH     X'0008'    TYPE  5 = R*8                      1.3#05
         DATAH     X'0008'    TYPE  6 = C*8                      1.3#05
         DATAH     X'0010'    TYPE  7 = C*16                    |1.3.21A
         DATAH     X'0000'    TYPE  8 = BIT LOGICAL              1.3#05
         DATAH     X'0001'    TYPE  9 = L*1                      1.3#05
         DATAH     X'0004'    TYPE 10 = L*4                      1.3#05
         DATAH     X'0000'    TYPE 11 = CHARACTER                1.3#05
         DATAH     X'0000'    TYPE 12 = UNDEFINED                1.3#05
         DATAH     X'0000'    TYPE 13 = UNDEFINED                1.3#05
         DATAH     X'0004'    TYPE 14 = STATEMENT LABEL          1.3#05
         DATAH     X'0004'    TYPE 15 = PROGRAM NAME             1.3#05
*
M2SYM.DN DATAW     0               HOLDS DATAPOOL NUMBER         1.3#15
SYMFLAGS REZ       1B              FLAGS FOR SYMBOL PROCESSING  EOBJ-30
EXMFLG   EQU       0               EXTD. MEM. BIT OF SYMFLAGS   EOBJ-30
DUMFLG   EQU       1               DUMMY PARAM. BIT OF SYMFLAGS EOBJ-30
COMFLG   EQU       2               COMMON BLOCK BIT OF SYMFLAGS EOBJ-30
DPLFLG   EQU       3               DATAPOOL BIT OF SYMFLAGS     EOBJ-30
ADRFLG   EQU       4               ABSOLUTE ADDR BIT IN SYMFLGS EOBJ-30
CSCFLG   EQU       5               SYMB IN CSECT BIT IN SYMFLGS EOBJ-30
ABSFLG   EQU       7               ABSOLUTE ADDR BIT IN SYMFLGS EOBJ-30
*                                  AND DEBUG SYM TABL RECORD    EOBJ-30
         BOUND     1F
M2SAVREG REZ       8W              REGISTER SAVE AREA
         TITLE     M1INFO MODULE INFO RECORD
***********************************************************************
*
*                  M1INFO
*
***********************************************************************
*
*        MODULE INFORMATION RECORD (PASS A)
*        COUNTS UP THE NUMBER OF NEEDED BLOCKS
*        FOR RECORDS
*
***********************************************************************
         SPACE     2
M1INFO   EQU       $                                             1.3#05
         TBM       MOPT15,MFLGS    IS INFO REQUESTED             1.3#05
         BNS       M1INFO00        BR IF SET                    |86.0662
         TBM       FLAGO,CATFLAGS  ARE WE PROCESSING AN OVERLAY |86.0662
         BNS       M1INFO0         ENTER IF NOT                 |86.0662
         BU        M1INFO01        ELSE RETURN                  |86.0662
M1INFO00 EQU       $                                            |86.0662
         ZBM       XNEWMOD,XFLGS                                 1.3#05
         ZMW       XINFOENT                                      1.3#05
M1INFO01 EQU       $                                            |86.0662
         TRSW      R0              RETURN                        1.3#05
         NOP                                                     1.3#05
M1INFO0  EQU       $                                             1.3#05
         STF       R0,M1INFSAV                                   1.3#05
         SBM       6,AID.FLGS      INDICATE DATE/TIME INFO PRES EAID-32
         SBM       XINFOFST,XFLGS  SET FIRST ACTUAL RECORD       |1.3Q39
         BS        $+2W            SKIP IF NOT FIRST             |1.3Q39
         ABM       31,XINFOENT     INDICATE ONE BLOCK NEEDED     |1.3Q39
*
         LB        R1,MBLKX        GET INDEX                      11005
         TBM       XTCMTD,XFLGS    PROCESSING TIME/DATE 4 TCM   ETCM-32
         BNS       $+4W            PROCESS FROM MCBUF IF NOT    S900745
         ADI       R1,1            BUMP INDEX BY 1 BYTE         S900745
         LB        R2,DUPBUF,X1    GET SUB TYPE FROM DUPBUF     ETCM-32
         BU        $+2W            CONTINUE                     ETCM-32
         LB        R2,MCBUF,X1     GET SUB TYPE CODE FROM MCBUF ETCM-32
         ANMB      R2,=X'0F'                                    ETCM-32
         CI        R2,2            TCM RECORD?                  ETCM-32
         BGE       M1INFO7         RETURN IF SO                 ETCM-32
         TBM       XTCMTD,XFLGS    PROCESSING TIME/DATE 4 TCM?  ETCM-32
         BNS       $+3W            PROCESS NORMALLY IF NOT      ETCM-32
         LB        R2,DUPBUF+2B,X1   GET LENGTH FROM DUPBUF     ETCM-32
         BU        $+2W                                         ETCM-32
         LB        R2,MCBUF+2B,X1  GET LENGTH OF RECORD           11005
         TBM       XNEWMOD,XFLGS   SEE IF NEW RECORD              11005
         BNS       M1INFO1         IF NOT SKIP                    11005
         ADI       R2,12           ELSE ADD 12 FOR NAME           11005
M1INFO1  TRR       R2,R3           SAVE R2                        11005
         ADMW      R2,NEWINSZ      ADD IN SIZE OF CURRENT RECORD  11005
         CI        R2,192W         IS SIZE OVER 1 SECTOR          11005
         BGT       M1INFO4         IF SO BRANCH                   11005
         TBM       XNEWMOD,XFLGS   SEE IF NEW MODULE              11005
         BS        M1INFO3         IF NEW BRANCH                  11005
         STW       R2,NEWINSZ      ELSE SAVE CURRENT SIZE         11005
         ABM       7,NEWINCT       ADD 1 TO NEW BLK COUNTER       11005
         BU        M1INFO6         CONTINUE                       11005
*
M1INFO3  STW       R2,NEWINSZ      STORE CURRENT SIZE             11005
         SUR       R3,R2           THE END OF THE LAST RECORD     11005
         STW       R2,OLDINSZ      AND STORE                      11005
         LB        R2,NEWINCT      GET NEW RECORD COUNT           11005
         STB       R2,OLDINCT      AND STO IN OLD COUNT           11005
         ABM       7,NEWINCT       AND ADD TO NEW COUNT         11005
         BU        M1INFO6         CONTINUE                       11005
*
M1INFO4  TBM       XNEWMOD,XFLGS   SEE IF ALSO NEW MODULE         11005
         BS        M1INFO5         IF SO BRANCH                   11005
         LW        R2,NEWINSZ      ELSE FIGURE OUT OLD SIZE       11005
         SUMW      R2,OLDINSZ      FROM LAST BLOCK                11005
         ADR       R3,R2                                          11005
         STW       R2,NEWINSZ      AND STORE AS NEW SIZE          11005
         ZMW       OLDINSZ         AND ZERO OUT OLD SIZE          11005
         ABM       31,XINFOENT     AND INCREMENT BLOCK COUNT      11005
         LB        R2,NEWINCT      GET REC. COUNT                 11005
         SUMB      R2,OLDINCT      AND FIGURE REC COUNT FOR NEXT  11005
         ADI       R2,1            BLOCK                          11005
         STB       R2,NEWINCT      AND STORE                      11005
         LB        R2,OLDINCT      GET OLD CNT.                   11005
         LW        R3,RPBX         GET INDEX                      11005
         STB       R2,RECPERBL,X3        AND STORE                11005
         ABM       31,RPBX         INCREMENT COUNT                11005
         ZMB       OLDINCT         ZERO OUT OLD CNT               11005
         BU        M1INFO6         CONTINUE                       11005
*
M1INFO5  ZMW       OLDINSZ         ZERO OLD SIZE                  11005
         STW       R3,NEWINSZ      STORE NEW SIZE                 11005
         LB        R2,NEWINCT      GET RECORD COUNT OF LAST BLK   11005
         LW        R3,RPBX         GET INDEX                      11005
         STB       R2,RECPERBL,X3        AND STORE IN TABLE       11005
         ZMB       OLDINCT                                        11005
         ZMB       NEWINCT                                        11005
         SBM       7,NEWINCT       START WITH ONE                 11005
         ABM       31,XINFOENT     AND INCREMENT BLOCK COUNT      11005
         ABM       31,RPBX         AND INCREMENT INDEX            11005
*
M1INFO6  ZBM       XNEWMOD,XFLGS   ZERO OUT NEWMOD FLAG           11005
M1INFO7  LF        R0,M1INFSAV                                  ETCM-32
         TRSW      R0
*
*!XINFOENT DATAW     1               NUMBER OF BLOCKS NEEDED     |1.3Q39
XINFOENT DATAW     0               NUMBER OF BLOCKS NEEDED       |1.3Q39
NEWINSZ  DATAW     0               SIZE OF CURRENT RECORD IN BLOC 11005
OLDINSZ  DATAW     0               SIZE OF OLD RECORD IN BLOCK    11005
NEWINCT  DATAB     0               COUNT OF RECORDS PER BLOCK     11005
OLDINCT  DATAB     0               OLD COUNT OF R. P. B.          11005
M1INFSAV RES       1F                                             11005
         TITLE     M2INFO MODULE INFO RECORD                      11005
***********************************************************************
*
*            M2INFO   -   MODULE INFORMATION (PASS B)
*                         OUTPUT TO TEMP FILE (#ID)
*
***********************************************************************
         SPACE     2
M2INFO   EQU       $                                             1.3#05
         TBM       MOPT15,MFLGS    INFO REQUESTED                1.3#05
         BS        M2INFO0         BR IF SET                     1.3#05
         STF       R0,M2INFSAV                                  ETCM-32
         LB        R1,MBLKX        INDEX INTO MCBUF             ETCM-32
         LB        R2,MCBUF,X1     GET BYTE OF RECORD           ETCM-32
         ANMB      R2,=X'0F'                                    ETCM-32
         CI        R2,4            IS IT A TYPE 4 INFO RECORD   ETCM-32
         BNE       M2INF.1         NO RETURN                    ETCM-32
         ZR        R2                                           ETCM-32
         LB        R3,MCBUF+4B,X1  GET FIRST BYTE OF SKIPNUM    ETCM-32
         SRC       R3,8                                         ETCM-32
         SLLD      R2,8            POSITION IT                  ETCM-32
         LB        R3,MCBUF+5B,X1  SECOND BYTE OF SKIPNUM       ETCM-32
         SRC       R3,8                                         ETCM-32
         SLLD      R2,8            COMBINE 1ST AND 2ND HALVES   ETCM-32
         ARMH      R2,MXSEQ        BUMP EXPECTED SEQUENCE NUM   ETCM-32
M2INF.1  LF        R0,M2INFSAV                                  ETCM-32
         TRSW      R0              RETURN                        1.3#05
         NOP                                                     1.3#05
M2INFO0  EQU       $                                             1.3#05
         STF       R0,M2INFSAV                                   1.3#05
         SBM       3,AID.FLGS      NEED TO FLUSH AN ENTRY       EAID-32
         SBM       3,XIDFLGS       SET INFO FLAG                  11005
         SBM       1,XIDFLGS       IS THIS THE FIRST ROUND  ?     11005
         BS        M2INFO.2        IF NOT BRANCH                  11005
         LW        R2,RPBX         GET INDEX                   11005
         LB        R3,NEWINCT      GET LAST BLOCK COUNT        11005
         STB       R3,RECPERBL,X2       AND STO LATEST BLOCK SIZE 11005
         ZMW       RPBX            AND ZERO OUT INDEX             11005
M2INFO.2 LB        R1,MBLKX                                       11005
         LB        R2,MCBUF,X1     GET SUB TYPE CODE            ETCM-32
         ANMB      R2,=X'0F'                                    ETCM-32
         CI        R2,4            IS IT A TYPE 4 TCM RECORD    ETCM-32
         BNE       M2INFO.3        TEST FOR OTHER TYPES         ETCM-32
         ZR        R2                                           ETCM-32
         LB        R3,MCBUF+4B,X1  GET 1ST BYTE OF SKIP COUNT   ETCM-32
         SRC       R3,8            POSITION                     ETCM-32
         SLLD      R2,8                                         ETCM-32
         LB        R3,MCBUF+5B,X1  GET 2ND BYTE OF SKIP COUNT   ETCM-32
         SRC       R3,8            POSITION                     ETCM-32
         SLLD      R2,8                                         ETCM-32
         ARMH      R2,MXSEQ   BUMP EXPECTED SEQUENCE BY COUNT   ETCM-32
         BU        M2INFO10        RETURN                       ETCM-32
M2INFO.3 CI        R2,2            TYPE 2 OR TYPE 3 TCM RECORD  ETCM-32
         BGE       M2INFO10        IGNORE IF SO                 ETCM-32
         TBM       XNEWMOD,XFLGS   IS THIS A NEW MODULE           11005
         BS        M2INFO3         IF SO BRANCH                   11005
M2INFO.1 LB        R2,MCBUF+2B,X1  GET LENGTH OF RECORD           11005
         ARMH      R2,IDRECLEN     ADD TO THE MAIN RECORD LENGTH  11005
         LW        R3,XINFOCNT     GET BUFFER INDEX               11005
         STH       R2,XINFOBUF+1H,X3  STORE LENGTH OF REC.        11005
         LW        R4,=X'0000000F'   GET MASK                     11005
         LMB       R5,MCBUF,X1     GET FLAG OFF OF OBJECT         11005
         STB       R5,XINFOBUF+1B,X3  AND STORE INTO BUFFER       11005
         STH       R3,LAST.ID      HOLD INCASE IF LAST RECORD     11005
         ADI       R1,4B           INCREMENT INDEX                11005
         TRN       R2,R2                                          11005
         ADI       R2,4B           IGNORE HEADER                  11005
         ADI       R3,4B                                          11005
M2INFO1  LB        R5,MCBUF,X1     GET DATA                       11005
         ABR       R1,31                                          11005
         STB       R5,XINFOBUF,X3  AND STORE INTO BUFFER          11005
         ABR       R3,31                                          11005
         BIB       R2,M2INFO1      GO GET ALL DATA                11005
         STW       R3,XINFOCNT     SAVE BUFFER COUNTER            11005
         LW        R2,RPBX         GET INDEX                      11005
         LB        R3,RECPERBL,X2    GET NUMBER OF RECORDS ALLOWED11005_
         SUI       R3,1            DECREASE                       11005
         STB       R3,RECPERBL,X2                                 11005
         CI        R3,0            SEE IF ZERO                    11005
         BEQ       M2INFO6         IF SO BRANCH                   11005
         BU        M2INFO10        CONTINUE IF NOT                11005
*
M2INFO3  EQU       $                                              11005
         ZBM       XNEWMOD,XFLGS   RESET FLAG                     11005
         LH        R2,LAST.ID      GET LAST RECORD POINTER        11005
         SBM       0,XINFOBUF,X2       SET LAST-REC FLAG IN OUTPUT 11005
         LH        R5,IDRECLEN     PREVIOUS RECORD LENGTH         11005
         LW        R2,L.REC        GET ADDR. OF LAST MAJOR RECORD 11005
         STH       R5,XINFOBUF+5H,X2  AND STORE FOR OUTPUT        11005
         LI        R3,12           START RECORD LENGTH WITH 12    11005
         STH       R3,IDRECLEN     DUE TO NAME AND HEADER         11005
         LW        R3,XINFOCNT     GET BUFFER INDEX               11005
         STW       R3,L.REC        UPDATE ADDR.                   11005
         LI        R4,-8           SET UP LOOP                    11005
         ZR        R2                                             11005
M2INFO4  LB        R5,MPNAM,X2     TRANSFER PROGRAM NAME          11005
         ADI       R2,1                                           11005
         STB       R5,XINFOBUF,X3   TO OUTPUT                     11005
         ADI       R3,X1                                          11005
         BIB       R4,M2INFO4                                     11005
         ADI       R3,4            LEAVE ROOM FOR HEADER          11005
         STW       R3,XINFOCNT     STO INDEX                      11005
         BU        M2INFO.1        RETURN FOR RECORD PROCESSING   11005
*
M2INFO6  EQU       $                                              11005
         ABM       31,RPBX         INCERMENT INDEX OF TABLE       11005
         LW        R3,RPBX         GET INDEX                      11005
         LB        R2,RECPERBL,X3    GET NEXT ENTRY               11005
         LW        R3,L.REC        GET LAST REC ADDR              11005
         CI        R2,0            SEE IF LAST BLOCK WAS END      11005
         BNE       M2INFO7         IF NOT END THEN BRANCH         11005
         SBM       1,XINFOBUF+2W,X3    SET LAST RECORD FLAG       11005
         SBM       2,XIDFLGS       SET FLAG                       11005
M2INFO7  SBM       0,XINFOBUF+2W,X3 SET END OF BLOCK FLAG         11005
         LH        R2,IDRECLEN     GET LATEST RECORD LENGTH       11005
         STH       R2,XINFOBUF+5H,X3  AND STORE IN OUTPUT         11005
         ZMH       IDRECLEN        ZERO OUT RECORD LENGTH         11005
         LH        R2,LAST.ID      GET LAST RECORD POINTER        11005
         SBM       0,XINFOBUF,X2       SET LAST SUB-REC FLAG       11005
         LI        R2,11                                           11005
         STH       R2,LAST.ID      START ID.REC WITH 11           11005
         ZMW       XINFOCNT        ZERO OUT INDEX                 11005
         TBM       MOPT15,MFLGS     SEE IF MODULE INFO WANTED    11005
         BNS       M2INFO10        IF NOT BRANCH                 11005
         BL        WRTINFO         WRITE TO TEMP FILE             11005
         TBM       2,XIDFLGS       SEE IF LAST RECORD             11005
         BNS       M2INFO10        IF NOT CONTINUE                11005
         M.RWND    INFOFCB         ELSE REWIND FILE               11005
         M.READ    INFOFCB         AND READ FIRST BLOCK           11005
*
M2INFO10 EQU       $                                              11005
         LF        R0,M2INFSAV                                    11005
         TRSW      R0              RETURN                         11005
LAST.ID  DATAH     11                                             11005
IDRECLEN DATAH     0                                              11005
XINFOCNT DATAW     0               INDEX FOR BUFFER               11005
L.REC    DATAW     0               ADDR. OF LAST MAJOR RECORD     11005
M2INFSAV RES       1F
         TITLE     M1MDPR     - MULTIPLE DATAPOOL REFERENCE
************************************************************************
*
*                  M1MDPR
*
*        ROUTINE IS NOW A NOP                                    1.3#15
*
************************************************************************
*
*        MULTIPLE DATAPOOL REFERENCE (PASS A)
*          SEE IF DATAPOOL IS CONNECTED TO
*          A DATAPOOL DICTIONARY.
*
************************************************************************
         SPACE     2
M1MDPR   STF       R0,MOBSCREG     SAVE REGISTERS                1.3#15
         LB        R1,MBLKX        GET OBJ RECORD INDEX          1.3#15
         LB        R3,MCBUF+2B,X1  GET LENGTH OF ITEM            1.3#15
         ADR       R1,R3           ABSOLUTE INDEX                1.3#15
         SUI       R3,1            TO DPOOL NUMBER               1.3#15
         LB        R2,MCBUF,X3     GET POOL NUMBER               1.3#15
         BU        M1DPL.1         MERGE WITH DATAPOOL PROC.     1.3#15
*                                                                1.3#15
         BOUND     1F
M1MDPSAV REZ       1F
*
*-----------------------------------------------------------------------
         TITLE     M2MDPR    - MULTIPLE DATAPOOL REFERENCE
***********************************************************************:
*
*                  M2MDPR
*
************************************************************************
*
*        MULTIPLE DATAPOOL REFERENCE (PASS B)
*
************************************************************************
         SPACE     2
M2MDPR   EQU       $
         STF       R0,M1MDPSAV
         SBM       XMDPR,XFLGS     SET FLAG FOR MULT. DP PROCESS.11017
         BL        M2DPL           AND GO PROCESS                11017
         ZBM       XMDPR,XFLGS     CLEAR FLAG                    11017
         LF        R0,M1MDPSAV                                   11017
         TRSW      R0              RETURN
         TITLE     M3ABD    - SYMTAB ABSOLUTE DATA
***********************************************************************
*
*                  M3ABD
*
***********************************************************************
*
*        SYMTAB ABSOLUTE DATA -0-
*
***********************************************************************
M3ABD    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LI        R5,-16B
         LB        R1,MBLKX
         LW        R2,MSYND
         BNZ       M3ABD.5         BR IF PREVIOUS DATA STORED
         LW        R2,MPLST
         ADI       R2,1W
M3ABD.5  SUI       R2,4W
         TRR       R2,R6
         SUI       R6,4W
         STW       R6,MSYMN
         STW       R2,MSYND
         CAMW      R2,MPFST
         BGT       M3ABD1          BR IF GEN TABLE AREA NOT FILLED
         LA        R6,MSOFMSG      SYMTAB OVERFLOW MSG
         LNB       R5,MSOFMLN                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BL        XABORT
M3ABD1   LB        R6,MCBUF+1B,R1  EXTRACT DATA
         STB       R6,0,R2
         ABR       R1,31
         ABR       R2,31
         BIB       R5,M3ABD1
         LF        R0,MOBSCREG
         TRSW      R0
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     M3PNM    - SYMTAB SEGMENT NAME
***********************************************************************
*
*                  M3PNM
*
***********************************************************************
*
*        SYMTAB SEGMENT NAME -5-
*
***********************************************************************
M3PNM    STF       R0,MOBSCREG     SAVE REGS IN COMMON AREA
         LI        R4,0            ZERO BYTES FOLLOW SEGMENT NAME.
         BL        MGETNAME        EXTRACT NAME FROM OBJECT FILE.
         STD       R6,MPNAM        SAVE SEGMENT NAME
         STW       R6,MPBUF+1W
         STW       R7,MPBUF+2W
         LI        R5,16B
         LA        R6,MPBUF
         BL        XPRNT           PRINT SEGMENT NAME
         LF        R0,MOBSCREG
         TRSW      R0
         TITLE     MSETR    - SET BIT IN RELOCATION MATRIX (MCLRR)
***********************************************************************
*
*                  MSETR / MCLRR
*
***********************************************************************
*
*        SETS/ZEROS BIT IN CORE RELOCATION MATRIX (FF MDRLM)
*        R5 THE WORD CORE ADDRESS OF THE RELATIVE WORD OF DATA WHOSE  *
*           CORRESPONDING BIT IS TO BE SET IN THE RELOCATION MATRIX
*
***********************************************************************
MCLRR    SBM       5,MSETCLR9      SET UP ZBM INSTRUCTION SHELL
         BU        MSETR2          COMMON HANDLING
MSETR    ZBM       5,MSETCLR9      SET UP SBM INSTRUCTION SHELL
*!MSETR2!!STF!!!!!!!R0,MSETR90!!!!!!SAVE!REGISTERS!!!!!!!!!!!!!!S8501481
MSETR2   EQU       $                                            S8501481
         STF       R0,MSETR90      SAVE REGISTERS               S8501481
         SBM       1,MSETR90       INIT CC1 TO INDICATE RELOC. BIT SET
         LW        R3,CURRBASE     SET UP ACTIVE DOPE VECTOR     1.3#05
         LW        R4,MDSTFST,X3       REMOVE BASE OF ASSEM AREA 1.3#05
         SUR       R4,R5           ADDR REL SAME
         ADMW      R5,MDSTBOUT,X3       PLUS BYTES OUT COUNT     1.3#05
         ZR        R4
         DVI       R4,32W          R4 BIT NO.
         SLL       R5,2
         SRL       R4,2
         LW        R2,MDSTRMAD,X3       GET MATRIX AREA BASE
         ADR       R5,R2           R2 ADDR REL MATRIX
         ZR        R5
         SRLD      R4,3            BIT IN BYTE TO R5, BYTE NO TO R4
         SRL       R5,6            POSITION BIT NUMBER
         ORR       R5,R4           MERGE BIT NUMBER AND BYTE NUMBER
         ORMW      R4,MSETCLR9     BUILD INSTRUCTION IN R4
         EXR       R4              EXECUTE INSTRUCTION
         BS        MSETR1          EXIT IF ADDRESS ALREADY RELOCATABLE
         ZBM       1,MSETR90       ADDRESS AT END OF STRINGBACK
MSETR1   LF        R0,MSETR90
         TRSW      R0              RETURN
         SPACE
MSETR90  RES       1F
MSETCLR9 DATAW     X'98480000'     SHELL OF SET/ZERO BIT INSTRUCTION
         TITLE     MRRSCONV - CONVERT OLD RRS TO NEW RRS
*
         TITLE     MRRSCONV
* ROUTINE TO CONVERT AN OLD RRS ENTRY (MRRS.OLD) TO NEW FORMAT
* INTO AN RRS BUFFER (MRRS)
*
* INPUT:
*        R6 = SIZE IN WORDS OF THE NEW ENTRY
*
* OUTPUTS:
*        NONE
*
MRRSCONV STF       R0,MRRSC90
         CAMW      R6,MRRSFREE     ENOUGH ROOM FOR NEW ENTRY??
         BGT       CARDERR4        BRANCH IF NO ROOM
         M.NEWRRS  MRRS.OLD,*MRRSNEXT
         ZBM       XSYSPART,XFLGS  IS THIS A SYSTEM STATIC PART.?84-0209
         BNS       MRRSCV.5        IF NOT BRANCH                 84-0209
         TRR       R5,X2           PUT ADDRESS INTO INDEX REG.   84-0209
         LW        R6,=C'SYST'     IF SO GET SYSTEM PATH FOR RRS 84-0209
         STW       R6,RR.NAME1+1W,X2 STORE INTO RRS ENTRY        84-0209
         STW       R6,RR.NAME1+3W,X2                             84-0209
MRRSCV.5 LW        R2,MRRSNEXT     GET ACTUAL LENGTH .....
         LB        R6,5B,R2        ..... OF ENTRY CREATED
         BL        CMODRRS         UPDATE RRS POINTERS
         LF        R0,MRRSC90
         TRSW      R0
*
MRRSC90  RES       1F
         PAGE
         TITLE     CHK4SYS - CHECK FOR @@SYSTEM(SYSTEM) FILENAME
************************************************************************
*
*        CHK4SYS   CHECKS THE INPUT PATHNAME OR PATHNAME BLOCK  ERMS-34
*                  TO SEE IF IT SPECIFIES @@SYSTEM(SYSTEM).      ERMS-34
*                  IF @@SYSTEM(SYSTEM) IS SPECIFIED, BIT 0 OF    ERMS-34
*                  THE OPTION FIELD (WORD 2) OF CHKCNP IS SET.  ERMS-34
*                  THIS FORCES M.LOC TO ONLY DO A LOCAL FILE    ERMS-34
*                  SEARCH.                                      ERMS-34
*
*        IN : R1 - PATHNAME OR PATHNAME BLOCK VECTOR            ERMS-34
*             MLOCF FLAG BIT 0 - PNB VECTOR, 1 - PATHNAME       ERMS-34
*                                                VECTOR         ERMS-34
*
************************************************************************
CHK4SYS  STF       R0,CHKREGS      SAVE REGS.                   ERMS-34
         ZMW       CHKCNP+2W       CLEAR CNP OPTIONS AND STATUS ERMS-34
         TRR       R1,R2           COPY VECTOR TO R2            ERMS-34
         SLL       R2,8            CLEAR BYTE COUNT             ERMS-34
         SRL       R2,8                                         ERMS-34
         TBM       MLOCF,MFLAG3    PNB OR PATHNAME VECTOR?      ERMS-34
         BNS       CHKPNB          NOT SET...PNB VECTOR         ERMS-34
         ZBM       MLOCF,MFLAG3    CLEAR FLAG                   ERMS-34
         ZR        R3                                           ERMS-34
CHKSYS1  ADI       R2,1            SKIP @@ IN PATHNAME           ERMS-34
         LB        R5,0,X2         GET PATHNAME CHARACTER       ERMS-34
         CAMB      R5,SYSTRNG,X3   COMPARE WITH SYSTEM(SYSTEM)  ERMS-34
         BNE       NOTSYS          NOT SYSTEM(SYSTEM)...BRANCH  ERMS-34
         ADI       R3,1            INCREMENT POINTER            ERMS-34
         CI        R3,14           AT THE END?                  ERMS-34
         BEQ       ITSYS           YES...SET BIT IN CNP         ERMS-34
         BU        CHKSYS1         NEXT CHARACTER               ERMS-34
CHKPNB   ADI       R2,1W           MOVE TO VOLUME NAME FIELD    ERMS-34
         LW        R5,0,X2         LOAD VOLUME NAME             ERMS-34
         CAMW      R5,SYST         IS IT SYST?                  ERMS-34
         BNE       NOTSYS          NO...RETURN                  ERMS-34
         ADI       R2,2W           MOVE POINTER TO DIRECTORY    ERMS-34
         LW        R5,0,X2         LOAD DIRECTORY NAME          ERMS-34
         CAMW      R5,SYST         IS IT SYST?                  ERMS-34
         BNE       NOTSYS          NO...RETURN                  ERMS-34
ITSYS    SBM       0,CHKCNP+2W     SET BIT IN CNP               ERMS-34
NOTSYS   LF        R0,CHKREGS      RESTORE REGS.                ERMS-34
         TRSW      R0              RETURN                       ERMS-34
*
CHKREGS  REZ       1F                                           ERMS-34
CHKCNP   REZ       6W              CNP FOR M.LOC SERVICE CALLS  ERMS-34
SYSTRNG  DATAB     C'SYSTEM(SYSTEM)'                            ERMS-34
*
         TITLE     C        - VARIABLES
***********************************************************************
*
*        C VARIABLES
*
***********************************************************************
*        CFLGS EQUS
CCTRD    EQU       0               FLAG INDICATING CATALOG CARD HAS
*                                  BEEN READ
CDERR    EQU       1               ERR(S)  IN DIRECTIVE  CARD(S) FLAG
CUDIG    EQU       2               UNPROCESSED DIRECTIVE IN BUFFER
CORGP    EQU       3               VALUE IS PRESENT IN CORGN
CPRED    EQU       4               PROGRAM DIRECTIVE READ
CLBIL    EQU       5               LINKBACK DIRECTIVE ILLEGAL
CEXIL    EQU       6               EXCLUDE DIRECTIVE ILLEGAL     1.3#02
CINIL    EQU       7               INCLUDE DIRECTIVE ILLEGAL
CINPR    EQU       8               INCLUDE DIRECTIVE PROCESSED
CEXPR    EQU       9               EXCLUDE DIRECTIVE PROCESSED   1.3#02
CTSM     EQU       10              SET INDICATES INTERACTIVE     1.3#04
CPTH     EQU       11              SET INDICATES LMPATH USED     1.3#05
CRES     EQU       12              LMPATH SUPPLIED FILENAME      1.3#05
CSLOUT   EQU       13              SLO AND UT ARE SAME PLACE     1.3#10
CPXRED   EQU       14              PROGRAMX DIRECTIVE READ      ENCD-32
CSCAN    EQU       15              PRE-SCAN OF PROGRAM NAME     ENCD-32
CCISYC   EQU       16              CONTROL IN IS SYC FILE       PR11085
CLOSLO   EQU       17              LIST OUT FILE IS SLO         PR11085
CSIREC   EQU       18              SI TCM RECORD READ FLAG      PR11087
CGOREC   EQU       19              GO,BO TCM RECORD READ FLAG   PR11087
*  NEXT - 31 RESERVED                                           PR11085
*!CLFGS!!DATAH!!!!!0!!!!!!!!!!!!!!!C!AREA!FLAGS!!!!!!!!!!!!!!!!!PR11085
CFLGS    DATAW     0               C AREA FLAGS                 PR11085
*
CCFLD    DATAB     0               CARD FIELD CURRENTLY BEING
*                                  PROCESSED.  FIRST FIELD IS ONE
CCHRS    DATAB     0               NO. CHARS IN CARD FIELD BEING PROCSD
CCPTR    DATAB     0               PTR IN MCBUF TO 1ST COL OF CCFLD
CCDLIM   DATAB     0               LAST ENCOUNTERED DELIMITTER
         BOUND     1W
COVLV    DATAH     1               CURR OVERLAY LEVEL-MUST PRECEDE COSEQ
COSEQ    DATAH     0               SEQ NO. OF CURRENT OVERLAY
CORGN    DATAW     0               ENTRY OR VALUE FROM ORIGIN CARD
CCSTRT   RES       1W              START ADDRESS OF STRING RECOGNISED
CCENT    REZ       2D              16 CHARS FROM CURR CARD LEFT JUST.
CMORG    DATAW     0               CURRENT MODULE ORIGIN
CLCO     DATAW     0               LAST CALCULATED MODULE ORIGIN
CMSIZ    DATAW     0               END ADDR OF LARGEST OVERLAY IN LEVEL
CLGC     DATAW     256             LOWEST GC PAGE #
CHGC     DATAW     0               HIGHEST GC PAGE REQUIRED
         BOUND     1F
CARD90   RES       1F              GENERAL REGISTER SAVE AREA
CANSI1   DATAD     C'@@ANSITAP'     ANSI PATHNAME PART1           1.3#11
CANSI2   DATAD     C'E       '                   PART2           1.3#11
*
* SIZE IN WORDS OF REFORMATTED RRS ENTRIES
*
CASSA.NW EQU       4               ASSIGN 1
CASSB.NW EQU       4               ASSIGN 2
CASSC.D1 EQU       4               ASSIGN 3 (TEMP FILE ANY DEVICE)
CASSC.D2 EQU       8               ASSIGN 3 (TEMP FILE SPEC. DEV)
CASSC.DV EQU       6               ASSIGN 3 (DEVICE)
CASSD.NW EQU       4               ASSIGN 4
XCORE.NW EQU       6               CORE PARTITION
         TITLE     CATSTART - START OF CATALOGER
***********************************************************************
*
*        PROGRAM   C
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
*!CINV!!!!!DATA!!!!!!C'INVALID!MODULE!FILE'
*!CPWO!!!!!DATA!!!!!!C'PASSWORD!TABLE!OVERFLOW'
         SPACE     1
         SPACE     1
         BOUND     1D
C        EQU       $
CATSTART EQU       $                                               11012
         SEA                       SET EXTENDED MODE             1.3#03
         BL        LFCSUB          SUBSTITUTE ASSIGNED LFC'S    ELFC-31
         SBM       XLMFBAD,XFLGS   INDICATE NO LOAD MODULE FILE  1.3#10
         ZBM       CTSM,CFLGS      RESET INTERACTIVE MODE        1.3#04
         M.MYID    PARAMBLK        FIND OUT IF 'TSM.'          11012
         LW        R1,PARAMBLK+5W  GET FIRST HALF OF PSEUDONYM 11012
         CAMW      R1,=C'TSM.'     IS IS TSM ??                11012
         BNE       C0.2            NO - DON'T 'GREET'          11012
         SBM       CTSM,CFLGS      INDICATE INTERACTIVE          1.3#04
C0.2     EQU       $                                           11012
         M.PGOW                    GET PROGRAM OPTIONS           1.3#14
         TBR       R7,31           TEST IF OPTION 1 SPECIFIED    1.3#14
         BNS       C1.B            IF NOT, TEST FOR NEXT OPTION  1.3#14
         SBM       MOPT1,MFLGS     SUPRESS AUTO LIB SEARCHING    1.3#14
C1.B     TBR       R7,30           TEST IF OPTION 2 SPECIFIED    1.3#14
         BNS       C1.A            IF NOT, TEST FOR NEXT OPTION  1.3#14
         SBM       MOPT2,MFLGS     SEPARATE OVERLAY MODULE FILES 1.3#14
C1.A     TBR       R7,13           TEST IF OPTION 19 SPECIFIED   1.3#14
         BNS       C1.C            IF NOT, TEST FOR NEXT OPTION  1.3#14
         SBM       MOPT19,MFLGS    SYMBOLIC DEBUG INFO ON        1.3#14
C1.C     TBR       R7,17           TEST IF OPTION 15 SPECIFIED   1.3#14
         BNS       C1.D            TEST NEXT OPTION              1.3#14
         SBM       MOPT15,MFLGS    OUTPUT MODULE INFO RECORDS    1.3#14
C1.D     TBR       R7,29           OPTION 3 SET ?                1.3#14
         BNS       C1.E            TEST NEXT                     1.3#14
         SBM       MOPT3,MFLGS     SET OPTION 3 FLAG             1.3#14
C1.E     TBR       R7,12           IS OPTION 20 SET              1.3#14
         BNS       C1.F            NEXT OPTION                   1.3#14
         SBM       MOPT20,MFLGS    ELSE SHOW OPTION 20           1.3#14
C1.F     TBR       R7,14           TEST FOR OPTION 18            1.3#14
         BNS       C1.G            GO TEST NEXT                  1.3#14
         SBM       MOPT18,MFLGS    ELSE SET THIS OPTION          1.3#14
C1.G     TBR       R7,15           TEST FOR OPTION 17            1.3#14
         BNS       C1.H            GO TEST NEXT                  1.3#14
         SBM       MOPT17,MFLGS    ELSE SET THIS ONE             1.3#14
C1.H     TBR       R7,16           TEST FOR OPTION 16            1.3#14
         BNS       C1.I            END OF OPTION TESTING         1.3#14
         SBM       MOPT16,MFLGS    ELSE SET THIS OPTION          1.3#14
C1.I     EQU       $                                             1.3#14
         TBR       R7,9            IS OPTION TEXT SET            1.3#14
         BNS       C1.J            SKIP IF NOT                   1.3#14
         SBM       MOPTTXT,MFLGS   ELSE SET INDICATOR            1.3#14
C1.J     EQU       $                                             1.3#14
         TBR       R7,14           IS OPTION 18 SET              |1.3Q19
         BNS       C1.K            SKIP IF NOT                   |1.3Q19
         SBM       MOPT18,MFLGS    ELSE SET INDICATOR            |1.3Q19
C1.K     EQU       $                                             |1.3Q19
         TBR       R7,26           TEST FOR OPTION 6            ELST-32
         BNS       C1.L            SKIP IF NOT                  ELST-32
         SBM       MOPT6,MFLAG2    ELSE SET INDICATOR           ELST-32
C1.L     EQU       $                                            ELST-32
         TBR       R7,25           TEST FOR OPTION 7            ELST-32C
         BNS       C1.M            SKIP IF NOT                  ELST-32C
         SBM       MOPT7,MFLAG2    ELSE SET INDICATOR           ELST-32C
C1.M     EQU       $                                            ELST-32C
         TBR       R7,28           TEST FOR OPTION 4            ETCM-32
         BNS       C1.N            SKIP IF NOT                  ETCM-32
         SBM       MOPT4,MFLAG2    ELSE SET INDICATOR           ETCM-32
C1.N     TBR       R7,27           TEST FOR OPTION 5            ETCM-32
         BNS       C1.O            SKIP IF NOT                  ETCM-32
         SBM       MOPT5,MFLAG2    ELSE SET INDICATOR           ETCM-32
C1.O     TBR       R7,24           TEST FOR OPTION 8            C011-32
         BNS       C1.P            SKIP IF NOT                  C011-32
         SBM       MOPT8,MFLAG3    ELSE SET THE INDICATOR       C011-32
C1.P     EQU       $                                            C011-32
         TBR       R7,23           TEST FOR OPTION 9            EUIC-32
         BNS       C1.Q            SKIP IF NOT                  EUIC-32
         SBM       MOPT9,MFLAG3    ELSE SET THE INDICATOR       EUIC-32
C1.Q     EQU       $                                            EUIC-32
*                                                                1.3#14
*                                                                1.3#14
         M.INQUIRY PNTERS,SLOLFC   SEE IF SLO IS ASSIGNED TO SLO   1100A
         LI        R6,G'1'         ASSUME HDR L1 IS EJECT          11012
         LI        R5,G' '         ASSUME HDR L2 IS SINGLE SPACE   11012
         LW        R1,PNTERS+1W    GET FAT ADDR.                   1100A
         LW        R7,0W,X1        GET FAT WORD 1               PR11085
         ZBM       CLOSLO,CFLGS    RESET LO=SLO INDICATOR       PR11085
         ZBM       CSLOUT,CFLGS    RESET SLO=UT INDICATOR        1.3#10
         TBM       7,DFT.STB,X1    IS SLO A TSM DEVICE           1.3#10
         BNS       $+2W            SKIP IF NOT                   1.3#10
         SBM       CSLOUT,CFLGS    ELSE INDICATED SLO=UT         1.3#10
         LB        R7,DFT.ACF,X1   GET SYSTEM FILE CODE            1100A
         ANMW      R7,=X'7'        MASK ALL BUT SYS FILE           11012
         CI        R7,3            IS IT SLO ??                    11012
         BNE       C0.4            NO - CONTINUE
         LI        R6,G'-'         ASSUME HDR L1 IS TITLE          11012
         LI        R5,G'-'         ASSUME HDR L2 IS TITLE          11012
         SBM       7,SLOCNP+2W     MODIFY UPDATE MODE TO APPEND    11012
         SBM       CLOSLO,CFLGS    SET LO=SLO FLAG              PR11085
C0.4     EQU       $                                               11012
         STB       R6,HD1.CC       SAVE HDR L1 CARR CNTRL          11012
         STB       R5,HD2.CC       SAVE HDR L2 CARR CNTRL          11012
*                                                                1.3#06
*    ALLOCATE BLOCKING BUFFERS FOR SLO & SGO                     1.3#06
*    SLO ALWATS GETS A 10 SECTOR BLOCKING BUFFER                ENCD-32
*
         TBM       5,DFT.STB,X1    IS SLO A VOLUME RESOURCE      1.3#06
         BNS       C0.41           SKIP IF NOT                   1.3#06
*!!!!!!!!TBM!!!!!!!MOPT20,MFLGS!!!!SLOW!MODE!ENABLED!!!!!!!!!!!!ENCD-32
*!!!!!!!!BS!!!!!!!!C0.41!!!!!!!!!!!JUST!USE!TSA!SPACE!IF!SET!!!!ENCD-32
         LI        R1,SLOBUFSB     GET DEFAULT SIZE              1.3#06
         BL        XGETEA          GET THE SPACE FOR SLO BBUF    1.3#06
         TRR       R2,R2           DID WE GET IT                 1.3#06
         BZ        C0.41           JUST USE TSA BUFFER IF NOT    1.3#06
         LI        R1,SLOBUFSS     GET SECTOR COUNT AGAIN        1.3#06
         SLL       R1,24           POSITION                      1.3#06
         ORR       R1,R2           FORM WORD 15                  1.3#06
         LA        R1,XPRNT91      GET FCB ADDR                  1.3#06
         STW       R2,15W,X1       AND SET BLOCKING BUFFER       1.3#06
C0.41    EQU       $                                             1.3#06
*                                                                1.3#06
C0.42    EQU       $                                             1.3#06
         LA        R1,XPRNT91      FCB ADDR                      1.3#13
         ZR        R3              INDICATE WAIT FOR IT          1.3#13
         LA        R7,SLOCNP       CNP ADDR                      1.3#13
         BL        XOPENR          DO POLITE OPEN                1.3#13
*
C0.44    EQU       $                                             1.3#13
         M.INQUIRY PNTERS,UTFCB    FIND ADDR OF FAT              1.3#13
         LW        R1,PNTERS+1W                                  1.3#13
         LI        R7,4            DEFAULT IS UPDATE MODE        1.3#13
         TBM       5,DFT.STB,X1    IS IT A VOLUME RESOURCE       1.3#13
         BNS       C0.441          SKIP IF NOT VOLUME            1.3#13
         LI        R4,X'F'         SYS CODE MASK                 1.3#13
         LMB       R3,DFT.ACF,X1   GET POSSIBLE SYS FILE CODE    1.3#13
         CI        R3,3            IS IT SLO                     1.3#13
         BNE       C0.441          SKIP IF NOT SLO               1.3#13
         LI        R7,5            ELSE SET MODE TO APPEND       1.3#13
C0.441   EQU       $                                             1.3#13
         STB       R7,UTCNP+8B     SET OPTIONS                   1.3#13
         M.OPENR   UTFCB,UTCNP     EXPLICIT OPEN UT AS REQUIRED  1.3#13
*                                  TO HANDLE PROBLEM IN MPX AT   1.3#13
*                                  RELEASES PRIOR TO 3.3.        1.3#13
         LB        R7,PRODREVL     GET MESSAGE LENGTH            |1.3Q32
         STW       R7,UTFCB+FCB.EQTY         INTO FCB            |1.3Q32
         LA        R7,CATITLE      GET MESSAGE ADDR              |1.3Q32
         STW       R7,UTFCB+FCB.ERWA         INTO FCB            |1.3Q32
         M.WRIT    UTFCB           WRITE TO UT                   1.3#10
         LB        R7,CPYR.LNG     GET MESSAGE LENGTH            |1.3Q32
         STW       R7,UTFCB+FCB.EQTY         INTO FCB            |1.3Q32
         LA        R7,CPYR.MSG     GET MESSAGE ADDR              |1.3Q32
         STW       R7,UTFCB+FCB.ERWA         INTO FCB            |1.3Q32
         M.WRIT    UTFCB           WRITE TO UT                   1.3#10
*
         TBM       CSLOUT,CFLGS    SLO=UT?                       1.3#10
         BS        C0.6            SKIP HEADER STUFF IF IT IS    1.3#10
*                            ELSE                                1.3#10
         LB        R5,HD1.CC       USE HEADER 1 CODE             1.3#09
         STB       R5,MPCCC+7B     PUT IN CARR CNTRL BYTE          11014
         LB        R5,PRODREVL     GET LENGTH OF HDR LINE 1      1.3#10
         LA        R6,CATITLE      GET ADDRESS OF TITLE
         BL        XPRNT           PRINT TITLE TO SLO
         LB        R5,HD2.CC       USE SECOND TILE CC            1.3#09
         STB       R5,MPCCC+7B                                   1.3#09
         LB        R5,C0.TL3L      3RD LINE OF TITLE             1.3#09
         LA        R6,C0.TL3A                                    1.3#09
         BL        XPRNT                                         1.3#09
         LI        R5,G'0'         SET DOUBLE SPACE              1.3#10
         STB       R5,MPCCC+7      INTO CC                       1.3#10
         ZR        R5                                            1.3#10
         BL        XPRNT           AND ISSUE                     1.3#10
         BU        C0.6            AND CONTINUE                  1.3#09
C0.TL3A  DATAB     C'    DIRECTIVE PROCESSING'                   1.3#09
C0.TL3L  DATAB     $-C0.TL3A                                     1.3#09
         BOUND     1W
*                                                                1.3#09
C0.6     EQU       $                                               11012
*                                                                1.3#15
         M.INQUIRY PNTERS,DPDLFC   SEE IF DPD ASSIGNED           1.3#15
         BS        C0.61           CONTINUE IF NOT ASSIGNED      1.3#15
         LI        R3,1600         SET INDEX TO DPOOL TABLE      1.3#15
         LW        R7,=G'DPD'      SET LFC                       1.3#15
         STW       R7,DPOOLTAB+DPLFC,X3   SET LFC FOR NOW        1.3#15
C0.61    EQU       $               CONTINUE                      1.3#15
*                                                                1.3#15
         BL        XADRS           GET ADDRESS BOUNDS
         TBR       R7,29           IS THIS A DW                  1.3#05
         BS        $+2W            SKIP IF NOT                   1.3#05
         SUI       R7,1W           ON DOUBLEWORD BOUNDARY
         STW       R7,MPLST
         SUI       R7,3W
         STW       R7,MSYMN        INITIALIZE SYMTAB STORAGE ADDR
         ZMB       MRRSN           CLEAR RES REQ SUMM TABLE COUNTER
         BL        XLFCBLD         PROCESS STATIC ASSIGNMENTS    1.3#04
C1       ZBM       CUDIG,CFLGS
         BS        C2              BR IF DIRECTIVE IN BUFFER
         BL        XSIRD           READ A DIRECTIVE
         TRR       R5,R5
         BNE       C6              BR ON EOF
C2       EQU       $
         ZMB       CCFLD           INIT. CONTROL CARD FIELD NO.
         ZMB       CCPTR           INIT. CONTROL CARD COLUMN NO.
         BL        STRING          GET FIRST FIELD
         ZR        R1
         LI        R2,-CCOMNO
C3       CAMW      R6,C91,R1       IS FIRST FIELD A VALID DIR ?  12008
         BNE       C5
         SRL       R1,1
         BL        *C92,R1     PROCESS DIRECTIVE
         BU        C1
C5       ABR       R1,28
         BIB       R2,C3
         LI        R5,1B
         BL        CCERR           ILLEGAL DIRECTIVE MSG
         BU        C1
*
*
C6       TBM       CCTRD,CFLGS
         BS        C8              BR IF CATALOG CARD WAS READ
         LNB       R5,C6.MSL                                     1.3#10
         LA        R6,C6.MSG                                     1.3#10
         BL        XTYPEF                                        1.3#10
C7       EQU       $                                             1.3#10
         LNB       R5,C7.MSL                                     1.3#10
         LA        R6,C7.MSG                                     1.3#10
         BL        XTYPEF                                        1.3#10
         BL        XABORT           EXIT
*
C6.MSG   DATAB     C' CATALOG<<FATAL>>  EOF ON DIRECTIVE FILE'  1.3#10
         DATAB     C' WITH NO BUILD/CATALOG DIRECTIVE.'         1.3#10
C6.MSL   DATAB     $-C6.MSG                                     1.3#10
*                                                               1.3#10
C7.MSG   DATAB     C' CATALOG<<FATAL>> FATAL DIRECTIVE OR'      1.3#10
         DATAB     C' OBJECT CODE ERRORS IN PHASE ONE.'         1.3#10
C7.MSL   DATAB     $-C7.MSG                                     1.3#10
SIZEER   DATAB     C' CATALOG(WARNING) COMMON SIZE DISCREPANCY' S8600944
         DATAB     C' IN COMMON BLOCK: '                        S8600944
*!COMNAM!!!DATAD!!!!!0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!S8600944!Q003-30!
COMNAM   REZ       8B                                           Q003-30
SIZELN   DATAB     $-SIZEER                                     S8600944
SIZEEB   DATAB     C'    DEFINED IN MODULE: '                   S8600944
*!MODNAM!!!DATAD!!!!!0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!S8600944!Q003-30!
MODNAM   REZ       8B                                           Q003-30
SIZEEC   DATAB     C' PROGRAM: '                                S8600944
*!PRONAM!!!DATAD!!!!!0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!S8600944!Q003-30!
PRONAM   REZ       8B                                           Q003-30
         DATAB     C' AS: '                                     S8600944
*!COMSZE!!!DATAD!!!!!0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!S8600944!Q003-30!
COMSZE   REZ       8B                                           Q003-30
         DATAB     C' BYTES'                                    S8600944
SIZELB   DATAB     $-SIZEEB                                     S8600944
ZROFLG   DATAB     0                                            Q003-30
POINT    DATAW     0                                            S8600944
PNTR     DATAW     0                                            S8600944
HOWBIG   DATAW     0                                            S8600944
*!SAVE!!!!!DATAW!!!!!0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!C002-U01
BLANK    DATAD     C'""BLANK""'                                 S8600944
         BOUND     1F                                           S8600944
REGSAV   REZ       1F                                           S8600944
*                                                               1.3#10
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
*   THIS MARKS THE START OF PHASE 4 CODE                         1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
C8       TBM       CDERR,CFLGS
         BS        C7              BR IF DIRECTIVE ERRORS
*                                                                1.3#18
*   THE FOLLOWING LOOP TO CLOSE THE DIRECTORY LFC'S IS           1.3#18
*   IS COMMENTED OUT TO AVOID POSSIBLE PROBLEM IN MPX 3.3        1.3#18
*   WHEN DIR IS ASSIGNED TO MPXDIR SHARE=N.                      1.3#18
*                                                                1.3#18
*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!GIVE!BACK!FPT/FAT'S!USED!FOR!DIRECTORIES!BY!CLOSING!!!!!!!1.3#18
*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!LNW!!!!!!!R3,LIBCNT!!!!!!!GET!NEG!NUMBER!OF!LIBS!!!!!!1.3#18
*!!!!!!!!!!ZR!!!!!!!!R2!!!!!!!!!!!!!!INIT!THE!INDEX!!!!!!!!!!!!!!1.3#18!
*!!!!!!!!!!LW!!!!!!!!R4,=X'00FFFFFF'!!SET!UP!MASK!!!!!!!!!!!!!!!!1.3#18
*!C8.0!!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!LOOP!TOP!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!LB!!!!!!!!R1,LT.DIRS,X2!!!GET!TYPE!CODE!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!CI!!!!!!!!R1,4!!!!!!!!!!!!IS!IT!MEM!RESIDENT!!!!!!!!!!1.3#18
*!!!!!!!!!!BEQ!!!!!!!C8.02!!!!!!!!!!!GO!DO!MEM!RESIDENT!!!!!!!!!!1.3#18
*!!!!!!!!!!CI!!!!!!!!R1,8!!!!!!!!!!!!IS!IT!DISC!RESIDENT!!!!!!!!!1.3#18
*!!!!!!!!!!BEQ!!!!!!!C8.03!!!!!!!!!!!GO!DO!DISC!RESIDENT!!!!!!!!!1.3#18
*!C8.01!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!ADI!!!!!!!R2,1W!!!!!!!!!!!BUMP!R2!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BIB!!!!!!!R3,C8.0!!!!!!!!!AND!LOOP!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BU!!!!!!!!C8.05!!!!!!!!!!!CONTINUE!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!C8.02!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!HERE!FOR!MEM!!RESIDENT!!!!!!1.3#18
*!!!!!!!!!!LMW!!!!!!!R1,LT.DIRS,X2!!!GET!ADDR!OF!ARRAY!BOUND!DES!1.3#18!
*!!!!!!!!!!LW!!!!!!!!R1,2W,X1!!!!!!!!GET!THE!LFC!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BU!!!!!!!!C8.04!!!!!!!!!!!MERGE!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!C8.03!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!HERE!FOR!DISC!RESIDENT!!!!!!1.3#18
*!!!!!!!!!!LMW!!!!!!!R1,LT.DIRS,X2!!!GET!THE!LFC!!!!!!!!!!!!!!!!!1.3#18
*!C8.04!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!MERGE!BOTH!TYPES!!!!!!!!!!!!1.3#18
*!!!!!!!!!!ZMW!!!!!!!LT.DIRS,X2!!!!!!ZAP!THE!ENTRY!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!STW!!!!!!!R1,GPFCB2!!!!!!!SAVE!IN!FCB!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!SLL!!!!!!!R1,8!!!!!!!!!!!!STRIP!TOP!BYTE!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!SRL!!!!!!!R1,8!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!ABR!!!!!!!R1,2!!!!!!!!!!!!MAKE!IT!A!BLANK!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!STW!!!!!!!R1,C8.0MD2!!!!!!SAVE!IN!ERROR!MSG!INCASE!!!!1.3#18
*!!!!!!!!!!M.CLOSER!!GPFCB2!!!!!!!!!!CLOSE!DIRECTORY!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!TRR!!!!!!!R7,R5!!!!!!!!!!!ANY!ERROR!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BZ!!!!!!!!C8.01!!!!!!!!!!!BR!IF!NONE!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!M.CONBAD!!!!!!!!!!!!!!!!!!CONVERT!TO!DECIMAL!!!!!!!!!!1.3#18
*!!!!!!!!!!SLL!!!!!!!R7,16!!!!!!!!!!!REMOVE!TOP!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!SRL!!!!!!!R7,16!!!!!!!!!!!HALF!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!ORMW!!!!!!R7,=X'524D0000'!!!"RM00+STATUS"!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!STW!!!!!!!R7,C8.0MD1!!!!!!AND!PLUG!CODE!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!LNB!!!!!!!R5,C8.0ML!!!!!!!GET!LENGTH(UT+SLO)!!!!!!!!!!1.3#18
*!!!!!!!!!!LA!!!!!!!!R6,C8.0MSG!!!!!!AND!ADDRESS!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BL!!!!!!!!XTYPE!!!!!!!!!!!AND!LOG!IT!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BU!!!!!!!!C8.01!!!!!!!!!!!LOOP!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!C8.0MSG!!DATAB!!!!!C'!CATALOG(WARNING)!ERROR!'!!!!!!!!!!!!!!!!!1.3#18
*!C8.0MD1!!REZ!!!!!!!4B!!!!!!!!!!!!!!HOLDS!XXNN!STATSU!!!!!!!!!!!1.3#18
*!!!!!!!!!!DATAB!!!!!C'!!CLOSING!DIRECTORY!'!!!!!!!!!!!!!!!!!!!!!1.3#18
*!C8.0MD2!!REZ!!!!!!!4B!!!!!!!!!!!!!!HOLDS!!LFC!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!DATAB!!!!!C'.'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!C8.0ML!!!DATAB!!!!!$-C8.0MSG!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!!!!!!!!!!BOUND!!!!!1W!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*!C8.05!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#18
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
*   THE FOLLOWING SEQUENCE "GIVES BACK" TO THE MEMORY POOL       1.3#05
*   ALL MEMORY ALLOCATED TO IN-MEMORY DIRECTORIES.               1.3#05
*                                                                1.3#05
*  NOTE: THIS CODE FIDDLES THE POOL POINTERS IN A VERY RUDE      1.3#05
*        WAY-- BE CAREFUL IF YOU FIDDLE THIS CODE!!!             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
         TBM       MOPT20,MFLGS    IS OPTION 20 ON               1.3#11
         BS        C8.06           SKIP IF ON (NOTHING TO GIVE)  1.3#11
         LW        R5,LT.DABD      GET FBA OF DIRECTORY ABD ARRAY1.3#05
         STW       R5,XEABEG       AND MAKE IT THE START OF POOL 1.3#05
         STW       R5,XEAOLD.B     INHIBIT ANY LEGIT. GIVE BACK  1.3#05
         LW        R5,XEAEND       GET CURRENT END               1.3#05
         SUMW      R5,XEABEG       CALCULATE NEW SIZE            1.3#05
         STW       R5,XEASIZ       AND SAVE                      1.3#05
C8.06    EQU       $                                             1.3#11
*   END OF RUDE CODE                                             1.3#05
*
*
*ELIMINATE ALLOCATION REQUIREMENTS FOR COMMON BLOCK IN RESTORED SYMTABS
         LW        R5,MSYND
         BNZ       C8.1            BR IF SYMTABS WERE RESTORED
         LW        R5,MPLST
         SUI       R5,3W                                         1.3#05
         STW       R5,MSYND
         BU        C8.5
C8.1     EQU       $
         LW        R1,MSYND        GET VALUE LEFT BY SYMTAB LOAD 1.3#05
         SUI       R1,4W           BACK IT DOWN ONE ENTRY        1.3#05
         STW       R1,MSYND        AND UPDATE                    1.3#05
         LW        R1,MPLST
         SUI       R1,3W
C8.2     SUI       R1,4W
         LW        R4,=X'20000000'
         TRR       R1,R5
         ZR        R7
         BL        MSSCH           SEARCH FOR A COMMON ENTRY
         TRR       R5,R1
         BZ        C8.5            BR IF NONE FOUND
         CAMW      R5,MSYND
         BLT       C8.5            BR IF NOT IN RESTORED SYMTABS
         LW        R4,=X'00FFFFFF'
         LMW       R0,0,R1
         BZ        C8.2            BR IF NOT ALLOC ENTRY OR IS GLOBAL
C8.3     SUI       R5,4W
         LD        R6,2W,R1
         BL        MSSCH           SEARCH FOR DUPLICATES
         TRR       R5,R2
         BZ        C8.2            BR IF NONE FOUND
         CAMW      R5,MSYND
         BGE       C8.3            BR IF IN RESTORED SYMTABS
         LB        R4,0,R2
         ZMW       0,R2
         STB       R4,0,R2
         LB        R4,4B,R2        GET BLOCK #
         STW       R1,1W,R2        LINK TO RESTORED SYMTAB ENTRY
         STB       R4,4B,R2        PUT BLOCK # BACK
         BU        C8.3
*PROCESS COMMON ORIGINS
C8.5     LW        R5,MSYND
         STW       R5,MMODW
C9       LW        R4,=X'80000000'
         ZR        R7
         LW        R5,MMODW
         SUI       R5,4W
         BL        MSSCH           SEARCH FOR NEXT MODULE ENTRY
         TRR       R5,R5
         BEQ       C12             BR IF NO FIND
         STW       R5,MMODW
         TRR       R5,R3
C10      LW        R5,MMODW
         STW       R5,MMODF
         LW        R4,=X'20000000'
         ZR        R7
         TRR       R3,R5
         SUI       R5,4W
         ZMW       MCTLF           ZERO LAST CNTRL ENTRY FOUND  C002-U01
         BL        MSSCH           SEARCH FOR NEXT COMMON ENTRY
         TRR       R5,R3
         BEQ       C12             BR IF NO FIND
*!!!!!!!!LW!!!!!!!!R2,MCTLF!!!!!!!!POINTER!TO!CURR!CONTRL!ENTRY!C002-U01
*!!!!!!!!SUI!!!!!!!R2,2W!!!!!!!!!!!ADJUST!TO!PROGRAM!ENTRY!!!!!!C002-U01
*!!!!!!!!STW!!!!!!!R2,PNTR!!!!!!!!!SAVE!PROGRAM!ENTRY!POINTER!!!C002-U01
         LW        R2,MMODF
         CAMW      R2,MMODW
         BNE       C9              BR IF IN A DIFFERENT MODULE
         TBM       6,0,R3
         BNS       C10             BR IF NOT ORGED
         LW        R2,MCTLF        GET LAST CNTRL ENTRY FOUND   C002-U01
         BZ        C10.1           DON'T LOAD PNTR IF ZERO      C002-U01
         SUI       R2,2W           GET PROGRAM ENTRY            C002-U01
         STW       R2,PNTR         SAVE IN PNTR                 C002-U01
C10.1    EQU       $                                            C002-U01
         LW        R2,MMODW
C11      TRR       R2,R5           SEARCH MODULE'S ENTRIES FOR LIKE
         SUI       R5,4W           NAMED COMMON BLOCKS
         LW        R4,=X'20000000'
         LD        R6,1D,R3
         BL        MSSCH
         TRR       R5,R2
         BEQ       C10             BR IF NO FIND
         LW        R5,MMODW
         CAMW      R5,MMODF
         BNE       C10             BR IF IN A DIFFERENT MODULE
         CAR       R3,R2
         BEQ       C11             BR IF ORIGINAL ENTRY FOUND
         LW        R4,0,R2         GET CURRENT COMMON SIZE      S8600944
         ANMW      R4,=X'FFFFFF'                                S8600944
         LW        R1,0,R3         GET PREVIOUS COMMON SIZE     S8600944
         ANMW      R1,=X'FFFFFF'                                S8600944
         STW       R1,HOWBIG       SAVE PREVIOUS SIZE           S8600944
         CAR       R1,R4           CURRENT BIGGER THAN PREVIOUS S8600944
         BLE       C11.1           SKIP SIZE CHANGE IF NOT      S8600944
         LB        R5,0,R3         GET FLAGS FROM PREV ENTRY    S8600944
         LW        R4,0,R2         GET CURRENT COMMON SIZE      S8600944
         ANMW      R4,=X'FFFFFF'                                S8600944
         STW       R4,POINT        SAVE CURRENT SIZE            S8600944
         SRC       R5,8            PUT CURR SIZE INTO PREVIOUS  S8600944
         ORR       R5,R4           COMMON ENTRY                 S8600944
         STW       R4,0,R3                                      S8600944
         CAMW      R6,=X'20202020' IS COMMON NAME "BLANK"       S8600944
         BNE       C11.00          NO, PUT IT IN MESSAGE        S8600944
         CAMW      R7,=X'20202020'                              S8600944
         BNE       C11.00                                       S8600944
         LD        R6,BLANK        SUBSTITUTE IN NAME FOR MESSG.S8600944
*!C11.00!!!STD!!!!!!!R6,COMNAM!!!!!!!SAVE!NAME!!!!!!!!!S8600944!Q003-30!
*!C11.00!!!STW!!!!!!!R3,SAVE!!!!!!!!!SAVE!R3!!!!!!!!!!!!!!!!!!!!C002-U01
C11.00   STF       R0,REGSAV       SAVE REGS                    C002-U01
         LA        R3,COMNAM       ADDRESS OF MESSAGE AREA      Q003-30
         BL        XST2            SAVE NAME IN MESSAGE         Q003-30
         M.CONBAD  POINT           CONVERT CURRENT SIZE         S8600944
*!!!!!!!!STD!!!!!!!R6,COMSZE!!!!!!!SAVE COMMON SIZE!!!!S8600944!Q003-30!
         SBM       1,ZROFLG        FLAG TO REPLACE 0 WITH BLANK Q003-30
         LA        R3,COMSZE       ADDRESS OF SIZE AREA IN MSG. Q003-30
         BL        XST2            SAVE SIZE IN MESSAGE         Q003-30
         LW        R6,MCTLF        GET CURRENT CONTROL ENTRY    S8600944
         SUI       R6,2W           ADJUST TO PROGRAM ENTRY      S8600944
         STW       R6,POINT        SAVE POINTER                 S8600944
         LD        R6,*POINT       GET.CURRENT PROGRAM NAME     S8600944
*!!!!!!!!STD!!!!!!!R6,PRONAM!!!!!!!SAVE!IN!MESSAGE!!!!!S8600944!Q003-30!
         LA        R3,PRONAM       NAME AREA ADDRESS IN MSG.    Q003-30
         BL        XST2            SAVE NAME IN MESSAGE         Q003-30
*!!!!!!!!STF!!!!!!!R0,REGSAV!!!!!!!SAVE!REGISTERS!!!!!!!!!!!!!!!C002-U01
         LW        R6,MMODW        GET CURRENT MODULE ENTRY     S8600944
         ADI       R6,2W           GET CURRENT MODULE NAME      S8600944
         STW       R6,POINT        SAVE POINTER                 S8600944
         LD        R6,*POINT       GET MODULE NAME              S8600944
*!!!!!!!!STD!!!!!!!R6,MODNAM!!!!!!!SAVE!IN!MESSAGE!!!!!S8600944!Q003-30!
         LA        R3,MODNAM                                    Q003-30
         BL        XST2            SAVE MODULE NAME IN MSG.     Q003-30
         LA        R6,SIZEER       ADDRESS OF MESSAGE           S8600944
         LNB       R5,SIZELN       SIZE OF MESSAGE              S8600944
         BL        XTYPEF          PUT OUT MESSAGE TO USER      S8600944
         LNB       R5,SIZELB       SIZE OF SECOND HALF          S8600944
         LA        R6,SIZEEB       ADDRESS OF SECOND HALF       S8600944
         BL        XTYPEF          PUT IT OUT TO USER           S8600944
         LW        R6,MMODW        GET.CURRENT MODULE           S8600944
         ADI       R6,2W                                        S8600944
         STW       R6,POINT                                     S8600944
         LD        R6,*POINT       SAVE MODULE NAME IN MESSAGE  S8600944
*!!!!!!!!STD!!!!!!!R6,MODNAM!!!!!!!!!!!!!!!!!!!!!!!!!!!S8600944!Q003-30!
         LA        R3,MODNAM                                    Q003-30
         BL        XST2            SAVE MODULE NAME IN MSG.     Q003-30
         LD        R6,*PNTR        GET PROGRAM NAME             S8600944
*!!!!!!!!STD!!!!!!!R6,PRONAM!!!!!!!SAVE!IN!MESSAGE!!!!!S8600944!Q003-30!
         LA        R3,PRONAM                                    Q003-30
         BL        XST2            SAVE PROGRAM NAME IN MSG.    Q003-30
         M.CONBAD  HOWBIG          CONVERT SIZE                 S8600944
*!!!!!!!!STD!!!!!!!R6,COMSZE!!!!!!!SAVE!SIZE!IN!MESSAGES8600944!Q003-30!
         SBM       1,ZROFLG        FLAG TO REPLACE 0 WITH BLANK Q003-30
         LA        R3,COMSZE                                    Q003-30
         BL        XST2            SAVE SIZE IN MESSAGE         Q003-30
*!!!!!!!!LW!!!!!!!!R3,SAVE!!!!!!!!!RESTORE!R3!!!!!!!!!!!!!!!!!!!C002-U01
         LA        R6,SIZEEB       GET ADDR. OF MESSAGE         S8600944
         LNB       R5,SIZELB       GET SIZE OF MESSAGE          S8600944
         BL        XTYPEF          PUT MESSAGE OUT TO USER      S8600944
         LF        R0,REGSAV       RESTORE REGISTERS            S8600944
C11.1    EQU       $                                            S8600944
         LB        R4,0,R2
         ZMW       0,R2
         STB       R4,0,R2
*        ZMH       1H,R2           CLEAR ALLOCATION REQUIREMENT
         BU        C11
C12      LW        R5,MSYND
         STW       R5,MMODW
*ALLOCATE COMMON
C13      LW        R4,=X'80000000'
         ZR        R7
         LW        R5,MMODW
         SUI       R5,4W
         BL        MSSCH           SEARCH FOR NEXT MODULE ENTRY
         TRR       R5,R3
         BEQ       C31.0           BR IF NO FIND
         STW       R5,MMODW
         SUI       R5,4W
         LW        R4,=X'04000000'
         BL        MSSCH           FIND FIRST CONTROL ENTRY
         TRR       R5,R1
         BEQ       C7     NO CONTROL ENTRY, SHOULD NOT OCCUR  ABORT
C14      STW       R1,MSYMC
         LW        R4,=X'0000FFFF'
         LMW       R3,0,R1         NUMBER OF ENTRIES IN ELEMENT
         TRN       R3,R3
C15      TBM       2,0,R1
         STW       R1,MCOMPTR      SAVE ADDR OF COMMON ENTRY IN SYMTAB
         BS        C18             BR IF COMMON ENTRY
C16      LW        R1,MCOMPTR      GET ADDR OF COMMON ENTRY IN SYMTAB
         SUI       R1,4W           NEXT ENTRY
         BIB       R3,C15          CHECK ALL ENTRIES
         LW        R1,MSYMC        CURRENT CONTROL ENTRY
         LW        R4,=X'00FFFFFF'
         LMW       R5,1W,R1        COMMON ALLOCATED IN ELEMENT
         ADMW      R5,3W,R1        + ABS BEGINNING ADDR OF ELEMENT
         LB        R4,1W,R1        BOUND PROGRAM ELEMENT
         TRR       R5,R7
         ZR        R6
         DVR       R4,R6
         TRR       R6,R6
         BEQ       C17             BR IF BOUND IS OK
         SUR       R6,R4
         ADMW      R4,1W,R1        ADD REQUIRED DELTA TO COMMON
         STW       R4,1W,R1        ALLOCATION
C17      LW        R4,=X'0000FFFF' FIND ADDRESS OF NEXT CONTROL ENTRY
         LMW       R5,0,R1
         SLL       R5,4
         TRN       R5,R5
         ADR       R1,R5
         CAMW      R5,MSYMN
         BLE       C31.0           BR IF END OF SYMTAB
         LW        R4,=X'00FFFFFF' ABS BEGINNING ADDR OF NEXT ELEMENT
         LMW       R6,1W,R1        = COMMON ALLOCATED IN CURRENT ELEMENT
         ADMW      R6,2W,R1        + OBJECT CODE IN CURRENT ELEMENT
         ADMW      R6,3W,R1        + ABS BEGINNING OF CURRENT ELEMENT
         TRR       R5,R1
         TBM       5,0,R1
         BNS       C13             BR IF END OF MODULE
         STW       R6,3W,R1
         BU        C14
C18      LW        R4,=X'00FFFFFF'
*C18     LW        R4,=X'0000FFFF'
         LMW       R5,0,R1
         BEQ       C16             BR IF COMMON ALLOCATED ELSEWHERE
         LD        R6,2W,R1
         CAMD      R6,MGLOB00
         BLT       C24
         CAMD      R6,MGLOB99
         BGT       C24
         LB        R5,15B,R1       CHECK FOR CASE SUCH AS GLOBAL8H
         CI        R5,G'9'
         BGT       C24             IF NOT A NUMBER, IT IS NOT GLOBAL
C19      BL        XCORE           PERM FILE ADDRESS INQUIRY FOR GLOBAL
         BNS       $+2W            CONTINUE IF FOUND             1.3#15
         BL        XABORT          ELSE QUIT                     1.3#15
*                                                                1.3#15
         LB        R4,0,R1
         ZMW       0,R1            CLEAR ALLOCATION REQUIREMENT
         STB       R4,0,R1
         SBM       3,0,R1          GLOBAL ALLOCATION ENTRY FLAG
         LB        R4,4B,R1        GET BLOCK #
         STW       R7,1W,R1        STORE RELATIVE ADDRESS
         STB       R4,4B,R1        PUT BLOCK # BACK
C24      ZR        R5
C25      LW        R4,=X'20000000' COMMON ID
         LD        R6,2W,R1        NAME
         BL        MSSCH           SEARCH FOR LIKE NAMED COMMON
         TRR       R5,R2
         BNE       C27             BR IF FOUND
         SBM       7,0,R1          SET ALLOCATION FLAG
         BS        C16             EXIT IF ALREADY ALLOCATED
         LW        R4,=X'00FFFFFF'
         LMW       R5,0,R1         GET SIZE OF THIS COMMON BLOCK
         BEQ       C16             BR IF GLOBAL COMMON
         LW        R2,MSYMC        GET POINTER TO CONTROL ENTRY
         LMW       R6,1W,R2        COMMON'S ADDRESS = COMMON ALREADY
         ADMW      R6,3W,R2        ALLOCATED + ABS ADDRESS OF ELEMENT
         SRLD      R6,5            PUT LOWER 5 BITS INTO R7
         SRL       R7,27           RIGHT JUSTIFY LOWER 5 BITS OF ADDR
         TRR       R7,R7           CHECK FOR ZERO
         BEQ       C26             ADDRESS ALREADY JUSTIFIED
         LI        R4,8W           BOUNDARY OF ADDRESS
         SUR       R7,R4           SUBTRACT LOWER 5 BITS OF ADDR FROM 8W
         ADR       R4,R5           ADJUST COMMON SIZE BY DIFFERENCE
         ABR       R6,31           BOUND COMMON ADDRESS.
C26      SLL       R6,5            RESTORE COMMON'S ADDRESS
         LB        R4,4B,R1        GET BLOCK #
         STW       R6,1W,R1        STORE SIZE IN COMMON ENTRY
         STB       R4,4B,R1        PUT BLOCK # BACK
         ARMW      R5,1W,R2        ADD COMMON SIZE TO ELEMENT TOTAL
         BU        C16
C27      TRR       R3,R4           SAVE R3
         LW        R3,MMODF
         LW        R0,1W,R3        GET OVLAY LEVL & MODULE SEQ  12007
         LH        R6,1W,R3
         LW        R3,MMODW
         LH        R7,1W,R3
         TRR       R4,R3
         CAR       R6,R7
         BEQ       C31
*
         TBM       MOPT3,MFLGS     WHICH LINKBACK USAGE ?      12010
         BNS       C28             OLD LINKBACK                12010
         CI        R7,0            IS WORKING MODULE ROOT       |85.1406
         BEQ       C28             DON'T CHECK LINKBACK IF SO   |85.1406
*  ABOVE CHANGE KEEPS COMMONS DEFINED IN THE ROOT ALLOCATED IN  |85.1406
*  THE ROOT AND REMOVES 1.2 DOCUMENTED RESTICTIONS.             |85.1406
*  WHICH INHIBITED THIS CUSTOMER FROM USING OPTION 3 TO SOLVE   |85.1406
* THE PROBLEM FOR WHICH IT WAS INVENTED!                        |85.1406
         TRR       R1,R6           SAV CURRENT DEF POINTER      12007
         TRR       R5,R4           SAV DUPLICATE POINTER        12007
         TRR       R0,R5           MODULE WITH DEF              12007
         LW        R1,MMODW        POINTER TO REF MODULE        12007
         BL        MLINK           CHECK LINKBACK               12007
         TRR       R6,R1           RESTORE CURRENT DEF POINTER  12007
         XCR       R4,R5           RESTORE POINTER              12007
         BZ        C30             COMMON NOT LINK TO DEF MOD   12007
C28      LW        R4,=X'0F000000' MASK FOR COMMON FLAGS
         LMW       R6,0W,R1        CHECK R1'S ENTRY FOR BEING ORIGINED
         BNE       C28.1           BRANCH IF R1 POINTS TO ORG'ED COMMON
         LMW       R6,0W,R2        CHECK R2'S ENTRY FOR BEING ORIGINED
         BEQ       C28.1           BRANCH IF R2 POINTS TO NON-ORG'ED COM
         XCR       R1,R2           EXCHANGE REGISTERS-NOW R1 IS VALID
C28.1    LW        R4,=X'00FFFFFF' MASK FOR COMMON SIZE.
         LMW       R6,0W,X2        OBTAIN LARGEST SIZE DEFINED
         LMW       R4,0W,X1        FOR THE BLOCK
         CAR       R4,R6
         BLE       C29
         TBM       3,0,R1
         BS        C29             BR IF GLOBAL
         LB        R4,0,R1
         STW       R6,0,R1
         STB       R4,0,R1
C29      LB        R4,0,R2
         ZMW       0,R2            CLEAR ALLOC REQ. IN DUPLICATE
         STB       R4,0,R2
         LB        R4,4B,R2
         STW       R1,1W,R2        POINT DUPLICATE TO ALLOCATED ENTRY
         STB       R4,4B,R2
C30      SUI       R5,4W
         BU        C25             CONTINUE SEARCH FOR DUPLICATES
C31      TRR       R3,R4           SAVE R3
         LW        R3,MMODF
         LH        R6,3H,R3
         LW        R3,MMODW
         LH        R7,3H,R3
         TRR       R4,R3
         CAR       R6,R7
         BNE       C30             BR IF NOT IN SAME MODULE
         CAR       R2,R1
         BEQ       C30             BR IF ORIGINAL ENTRY FOUND
         BU        C28
*
*        FIND SECTION ONE ORIGINS
*
C31.0    ZMW       MMODW
         ZR        R2
         LW        R5,MSYND
C31.1    LW        R4,=X'84000000' MODULE/CONTROL ENTRY
         SUI       R5,4W
         ZR        R7
         BL        MSSCH           FIND NEXT RECORD
         TRR       R5,R3
         BEQ       C31.7           NO MORE
         TBM       0,0,R3          MODULE ENTRY
         BNS       C31.5           CONTROL ENTRY
*
*        MODULE ENTRY
*
         LW        R1,MMODW        ADDR OF LAST MODULE ENTRY
         STW       R5,MMODW        SAVE CURRENT ADDR
         TRR       R1,R1
         BEQ       C31.1           FIRST MODULE ENTRY
         CAMW      R2,CMSIZ        SAVE SIZE OF LARGEST MODULE
         BLE       C31.2
         STW       R2,CMSIZ        SAVE LARGEST SECTION OFFSET
C31.2    TBM       PR.SHR,MFLAG    IS PROGRAM SHARED?
         BS        C31.21          YES, CSECTS ARE CONCATENATED
         LH        R4,1W,R1        LAST OV LEVEL
         CAMH      R4,1W,R3        CURRENT LEVEL
         BEQ       C31.4           SAME LEVEL
*
*        NEW OV LEVEL
*
C31.21   LW        R6,CMSIZ        BOUND TO 8 WORDS
         ALIGN8W   R6              BOUND TO 8 WORDS
         STW       R6,CLCO         SAVE AS ORIGIN FOR NEW LEVEL
         ZMW       CMSIZ
C31.4    LW        R2,CLCO         LOAD ORIGIN
         BU        C31.1
*
*        CONTROL ENTRY
*
C31.5    TBM       8,0,R3          ANY SECTIONS IN THIS CONTROL
         BNS       C31.1           NO
         SUI       R3,4W
C31.6    SUI       R3,4W           FIND SECTION RECORDS
         TBM       3,0,R3          SECTION ENTRY
         BNS       C31.1           NOT A SECTION
         TBM       2,0,R3          MUST NOT BE COMMON
         BS        C31.1           NOT A SECTION
         LB        R4,4B,R3        GET SECTION #
         CI        R4,1
         BNE       C31.6           NOT SECTION ONE
*
*        FOUND SECTION ONE ENTRY
*
         ARMW      R2,1W,R3        SAVE BIAS AS ORIGIN
         LW        R4,=X'00FFFFFF'
         LMW       R4,0,R3         GET SIZE OF THIS SECTION
         ADR       R4,R2
         XCR       R5,R3           BOUND TO PRG BOUND
         LB        R4,4B,R3
         BL        MXBOUND
         XCR       R5,R3
         ARMW      R4,0,R3         ADD BOUNDING TO SIZE
         BU        C31.1
C31.7T   DATAW     0               ORIGIN OF 1ST CSECT
CSBIAS   DATAW     0               CSECT RELATIVE CSECT BIAS    ELST-32
*
*        END OF SYMTAB
*
C31.7    CAMW      R2,CMSIZ        LARGEST OV SIZE IN LAST LEVEL
         BLE       C31.8
         STW       R2,CMSIZ
*
*        DETERMINE WHAT TYPE OF TASK TO GENERATE. .5MB OR 2.5MB ELST-32
*
*!C31.8!!TBM!!!!!!!MOPT6,MFLAG2!!!!GENERATE!.5MB!TASK?!!!!!!!!!!ELST-33G
*!!!!!!!!BNS!!!!!!!C31.8B!!!!!!!!!!CONTINUE!IF!NOT!!!!!!!!!!!!!!ELST-33G
*!!!!!!!!TBM!!!!!!!MOPT7,MFLAG2!!!!OPTION!7!SET!!!!!!!!!!!!!!!!!ELST-33G
*!!!!!!!!BS!!!!!!!!C31.8C!!!!!!!!!!USE!MACHINE!TYPE!IF!BOTH!SET!ELST-33G
C31.8    ZBM       M2.5MB,MFLAG2   CLEAR 2.5MB FLAG AS DEFAULT  ELST-33G
*!!!!!!!!BU!!!!!!!!C31.9!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ELST-33G
         TBM       MOPT7,MFLAG2    WAS OPTION 7 SET             ELST-33G
         BNS       C31.9B          GENERATE .5 MB TASK IF NOT   ELST-33G
         SBM       M2.5MB,MFLAG2   2.5MB TASK IF SET            ELST-33G
*!!!!!!!!BU!!!!!!!!C31.9!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ELST-33G
*!C31.8C!ZBM!!!!!!!M2.5MB,MFLAG2!!!ASSUME!.5!MB!TASK!!!!!!!!!!!!ELST-33G
*!!!!!!!!SBM!!!!!!!MOPT6,MFLAG2!!!!MIRROR!TO!OPTION!6!!!!!!!!!!!ELST-33G
*!!!!!!!!LB!!!!!!!!R2,C.MACH!!!!!!!GET!MACHINE!TYPE!!!!!!!!!!!!!ELST-33G
*!!!!!!!!CI!!!!!!!!R2,0!!!!!!!!!!!!IS!IT!A!32/2000!MACHINE!!!!!!ELST-33G
*!!!!!!!!BNE!!!!!!!C31.9!!!!!!!!!!!.5!MB!TASK!IF!NOT!!!!!!!!!!!!ELST-33G
*!!!!!!!!SBM!!!!!!!M2.5MB,MFLAG2!!!2.5!MB!TASK!IF!SO!!!!!!!!!!!!ELST-33G
*!!!!!!!!ZBM!!!!!!!MOPT6,MFLAG2!!!!TURN!OFF!OPTION!6!!!!!!!!!!!!ELST-33G
         TBM       MOSOBJ,MFLAG2   WAS ANY OLD TYPE OBJECT READ ELST-33G
         BNS       C31.9B          CONTINUE IF NOT              ELST-33C
*!!!!!!!!ZBM!!!!!!!M2.5MB,MFLAG2!!!.5!MB!TASKS!ONLY!IF!SO!!!!!!!ELST-33G
         LNB       R5,C50.M7L      ERROR MESSAGE OUTPUT IF SO   ELST-33G
         LA        R6,C50.M7A                                   ELST-33G
         BL        XTYPEF                                       ELST-33G
         LNB       R5,C50.M7LB                                  ELST-33G
         LA        R6,C50.M7AB                                  ELST-33G
         BL        XTYPEF                                       ELST-33G
         BL        XABORT          AND ABORT                    ELST-33G
*
*        CALC BIAS OF CSECT
*
C31.9B   TBM       M2.5MB,MFLAG2   GENERATE 2.5 MB TASK ?       ELST-32
         BS        C31.10          MAKE 2.5 MB TASK,.5MB IF NOT ELST-32
         LW        R2,CLGC         LOWEST GC PAGE USED
         SUI       R2,256          MINUS # OF PAGES IN 128K
         TRN       R2,R2           GET MAX SIZE OF COMMON IN PAGES
         SLL       R2,11           CONVERT TO AN ADDRESS
         LW        R4,MPAGESZ
         BL        MXBOUND         BOUND TO A PAGE
         ADMW      R2,CMSIZ        ADD SIZE OF CSECT
         LW        R4,MPAGESZ
         BL        MXBOUND         BOUND CSECT TO A PAGE
         LW        R4,=X'00080000' 128KW
         SUR       R2,R4           R2 = BIAS OF CSECT
         STW       R4,C31.7T       SAVE BIAS OF CSECT
         STW       R4,CSBIAS       BIASES ARE EQUAL FOR .5MB    ELST-32
         LW        R2,CMSIZ        GET SIZE OF CSECT            PR10874
         STW       R2,MTOTALC      SAVE TOTAL CSECT REQUIREMENT PR10874
         ZMW       CMSIZ
         ZMW       DEBIAS                                       ELST-32
         BU        C31.11                                       ELST-32
C31.10   LW        R2,CMSIZ                                     ELST-32
         LW        R4,MPAGESZ                                   ELST-32
         BL        MXBOUND         MAP BLOCK BOUND CSECT        ELST-32
         LW        R4,=X'01000000'  512KW                       ELST-32
         SUR       R2,R4           CALCULATE 2.5MB BIAS         ELST-32
         STW       R4,C31.7T       SAVE BIAS                    ELST-32
         STW       R4,DEBIAS       SAVE SYMTAB BIAS             ELST-32
         ZMW       CSBIAS          ZERO CSECT REL CSECT BIAS    ELST-32
         LW        R2,CMSIZ        GET SIZE OF CSECT            PR10874
         STW       R2,MTOTALC      SAVE TOTAL CSECT REQUIREMENT PR10874
         ZMW       CMSIZ                                        ELST-32
*
*        END OF SECTION ONE PROCESSING
         PAGE
*
*  FIND SECTION ZERO ORIGINS
*
C31.11   EQU       $                                            ELST-32
*!!!!!!!!LW!!!!!!!!R2,C31.7T!!!!!!!GET!CSECT!ORIGIN!ADDRESS!!!!!ELST-32F
*!!!!!!!!STW!!!!!!!R2,DSCTBASE+MDINTREF!!DSECT!TO!CSECT!BIAS!!!!ELST-32F
         ZMW       MMODW
         ZMW       CLCO            INITIALIZE CURRENT LOAD ORIGIN
         ZR        R2              SIZE OF CURRENT MODULE
         LW        R5,MSYND
         SUI       R5,4W                                         1.3#05
         TBM       MTRNSFG,MFLGS   IS TRANSIENT AREA SPECIFIED
         BNS       C33.6           BR IF NO TRANSIENT AREA
         LW        R4,=X'80000000'
         BU        C33.5
C33      LW        R4,=X'A4000000'   SEGMENT,CONTROL,COMMON     PR11735C
C33.5    SUI       R5,4W
         ZR        R7
         BL        MSSCH           SEARCH FOR CONTROL OR MODULE ENTRY
C33.6    TRR       R5,R3
         BEQ       C41             BR IF NOT FOUND
*!!!!!!!!TBM!!!!!!!5,0,R3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PR11735C
*!!!!!!!!BNS!!!!!!!C34!!!!!!!!!!!!!BR!IF!NOT!CONTROL!ENTRY!!!!!!PR11735C
         TBM       0,0,X3          SEGMENT ENTRY                PR11735C
         BS        C34                                          PR11735C
         TBM       2,0,X3          COMMON ENTRY                 PR11735C
         BS        C33.8                                        PR11735C
         TBM       MMOUT,MFLGS     MAPPED OUT LOAD MODULE?      PR11735C
         BS        $+3W            YES...ADJUST ADDRESSES       PR11735C
         TBM       MSYSM,MFLAG3    SYSMAP SPECIFIED             PR11735C
         BNS       C33.7           NO...BRANCH                  PR11735C
         TBM       MADJADR,MFLAG3  ADJUST THIS SEGMENT          PR11735C
         BNS       C33.7           NO...BRANCH                  PR11735C
         LW        R4,3W,X3        GET MODULE REL ADDR          PR11735C
         ADI       R4,X'20'        ADJUST IT                    PR11735C
         STW       R4,3W,X3        STORE BACK IN CONTROL ENTRY  PR11735C
C33.7    LW        R4,=X'00FFFFFF'                              PR11735C
         LMW       R4,1W,R3        GET COMMON ALLOCATION
         ADR       R4,R2           ADD SIZE TO MODULE TOTAL
         ADMW      R2,2W,R3        ADD SIZE OF THIS ELEMENT
         BU        C33
C33.8    TBM       MMOUT,MFLGS     MAPPED OUT LOAD MODULE       PR11735C
         BS        $+3W            YES...ADJUST ADDRESS         PR11735C
         TBM       MSYSM,MFLAG3    SYSMAP SPECIFIED             PR11735C
         BNS       C33             NO...BRANCH                  PR11735C
         TBM       MADJADR,MFLAG3  ADJUST THIS SEGMENT          PR11735C
         BNS       C33             NO...CONTINUE                PR11735C
         LW        R4,0,X3         GET COMMON ENTRY SIZE        PR11735C
         ANMW      R4,=X'00FFFFFF' REMOVE FLAGS AND TYPE CODE   PR11735C
         CI        R4,0            ALLOCATED IN ANOTHER SEGMENT PR11735C
         BEQ       C33             YES...DON'T ADJUST ADDRESS   PR11735C
         LW        R4,1W,X3        GET MOD REL ADDR FOR COMMON  PR11735C
         ADI       R4,X'20'        ADJUST IT                    PR11735C
         STW       R4,1W,X3        STORE BACK IN COMMON ENTRY   PR11735C
         BU        C33                                          PR11735C
C34      ZBM       MADJADR,MFLAG3  NEXT SEGMENT...CLEAR FLAG    PR11735C
         LW        R1,MMODW
         STW       R5,MMODW
         TRR       R1,R1
         BEQ       C35             BR IF FIRST MODULE BEING PROCESSED
         ADMW      R2,5W,R1
         STW       R2,7W,R1        SET END OF PREVIOUS MODULE
         CAMW      R2,CMSIZ
         BLE       C34.2
         STW       R2,CMSIZ        MAINTAIN END ADDR OF LARGEST OVERLAY
C34.2    LH        R4,1W,R1
         CAMH      R4,1W,R3
         BEQ       C34.5           BR IF OVERLAY NOT AT NEW LEVEL
         LW        R6,CMSIZ
         ALIGN8W   R6              BOUND TO 8 WORDS
         STW       R6,CLCO
         ZMW       CMSIZ
C34.5    CAMW      R2,MTOTALL      COMPARE END OF OVERLAY WITH CURRENT
         BLE       C35             BR IF CURRENT MAX IS STILL MAX
         STW       R2,MTOTALL      SET NEW TOTAL ALLOCATION FOR LOAD MOD
C35      LW        R2,5W,R3
         TBM       6,0,R3
         BNS       C35.4           BR IF ORIGIN NOT SPECIFIED
         ZBR       R2,0
         BS        C35.5           BR IF END OF MODULE IS SPECIFIED
         TBR       R2,1
         BNS       C36             BR IF ORIGIN IS ABSOLUTE VALUE
C35.4    LW        R2,CLCO
         BU        C36
C35.5    LW        R2,7W,R2        OBTAIN END ADDRESS OF SPECIFIED MOD
         ALIGN8W   R2              BOUND TO 8 WORDS
C36      STW       R2,CMORG
         LW        R4,CMORG
         STW       R4,5W,R3        SET ORIGIN
         TBM       MMOUT,MFLGS     MAPPED OUT PROGRAM ?         PR11860
         BS        $+3W            YES...ADJUST SIZE            PR11860
         TBM       MSYSM,MFLAG3    SYSMAP SPECIFIED ?           PR11860
         BNS       C36.1           NO...SKIP SIZE ADJUST        PR11860
         CI        R4,0            WAS ORIGIN ZERO              PR11735C
         BNE       C36.1           NO...CONTINUE                PR11735C
         SUI       R3,4W           POINT TO CONTROL ENTRY       PR11735C
         LW        R4,2W,X3        GET ELEMENT SIZE             PR11735C
         ADI       R4,X'20'        ADJUST IT                    PR11735C
         STW       R4,2W,X3        STORE BACK IN CONTROL ENTRY  PR11735C
         SBM       MADJADR,MFLAG3  SET ADJUST FLAG              PR11735C
         ADI       R3,4W           POINT BACK AT SEGMENT ENTRY  PR11735C
C36.1    ZR        R2                                           PR11735C
         BU        C33
C41      LW        R1,MMODW
         BEQ       C41.2           BR IF NO PREVIOUS MODULE PROCESSED
         ADMW      R2,5W,R1
         STW       R2,7W,R1        SET ITS END ADDRESS
         CAMW      R2,MTOTALL      CMP END ADDRESS WITH CURRENT MAXIMUM
         BLE       C41.2           BR IF CURRENT MAX IS STILL MAX
         STW       R2,MTOTALL      SET NEW TOTAL ALLOCATION FOR LOAD MOD
C41.2    TBM       MTRNSFG,MFLGS   IS TRANSIENT AREA SPECIFIED
         BNS       C42             BR IF NO TRANSIENT AREA
         LW        R4,MPABS        GET ABSOLUTE BASE
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BS        C41.4           BRANCH IF ABSOLUTE
         LW        R4,MTRNS        GET TRANSIENT SIZE
C41.4    LW        R1,MSYND        ADDRESS OF END OF SYMBOL TABLE
         SUI       R1,4W           GET ADDR OF FIRST MODULE ENT  1.3#05
         STW       R4,5W,R1        SET MAIN ORIGIN
         STW       R4,CMORG
         STW       R4,MTRNS        SAVE ORIGIN IN TRANSIENT SIZE
         TRR       R1,R5
         ZR        R2
C41.5    LW        R4,=X'84000000'
         SUI       R5,4W
         ZR        R7
         BL        MSSCH           SEARCH FOR CONTROL OR MODULE ENTRY
         TRR       R5,R3
         BEQ       C41.6           BR IF NOT FOUND
         TBM       0,0,R3
         BS        C41.6           BR IF MODULE ENTRY
         LW        R4,=X'00FFFFFF'
         LMW       R4,1W,R3
         ADR       R4,R2           ADD SIZE TO MODULE TOTAL
         ADMW      R2,2W,R3
         BU        C41.5
C41.6    ADMW      R2,CMORG
         STW       R2,7W,R1        SET MAIN'S END ADDRESS
         CAMW      R2,MTOTALL      CMP END ADDRESS WITH CURRENT MAXIMUM
         BLE       C42             BR IF CURRENT MAX IS STILL MAX
         STW       R2,MTOTALL      SET NEW TOTAL ALLOCATION FOR LOAD MOD
*BIAS SYMTAB ADDRESSES
C42      LW        R5,MSYND
C43      SUI       R5,4W
         LW        R4,=X'EC000000'
         ZR        R7
         BL        MSSCH           SEARCH FOR AN ENTRY
         TRR       R5,R3
         BEQ       C50             NEXT STEP IF DONE             1.3#14
*
*
C43.3    TBM       0,0,R3          ADD THE LABEL HERE           EBRM-33
         BNS       C44             BR IF NOT MODULE ENTRY
         LW        R1,5W,R3        MODULE ORIGIN
         STW       R3,MMODW        SAVE ITS ADDRESS
         ZR        R6
         BU        C43
C44      TBM       5,0,R3
         BNS       C45             BR IF NOT CONTROL ENTRY
*
*        CONTROL ENTRY
*
         LW        R4,=X'00FFFFFF'
         LMW       R6,1W,R3
         ARMW      R1,3W,R3        BIAS ADDRESS
         ADMW      R6,3W,R3        PROGRAM BIAS ADDRESS
*
*        CHECK FOR SECTIONS AND SET SECTION ONE BIAS
*
         TBM       8,0,R3          ANY SECTIONS
         BNS       C43             NO SECTIONS
         SUI       R3,4W
C44.1    SUI       R3,4W           FIND SECTION ONE RECORD
         TBM       3,0,R3          SECTION ID
         BNS       C43             NO SECTION RECORD
         TBM       2,0,R3          MUST NOT BE COMMON
         BS        C43             NOT A SECTION
         LB        R4,4B,R3        GET SECTION NUMBER
         CI        R4,1            SECTION ONE
         BNE       C44.2           NOT SECTION ONE
*
*        FOUND SECTION ONE RECORD
*
         LW        R4,1W,R3        GET CSECT ORIGIN
         ADMW      R4,C31.7T                                    ELST-32
         ANMW      R4,=X'00FFFFFF'                              ELST-32
         LW        R4,1W,R3                                     ELST-32
         ADMW      R4,CSBIAS       ADD IN BIAS
         STW       R4,1W,R3        SAVE BACK IN SYMTAB
         ANMW      R4,=X'00FFFFFF'
         STW       R4,MSEC1O       SAVE SECTION ONE ORIGIN
         BU        C43
C44.2    LW        R4,=X'00FFFFFF'
         XCR       R3,R5
         TRR       R6,R4           SET SECTION ZERO ORIGIN
         XCR       R3,R5
         ARMW      R4,1W,R3        ADD IN ORIGIN
         BU        C44.1
C45      TBM       4,0,R3
         BNS       C46             BR IF NOT PROGRAM NAME ENTRY
*
*        PROGRAM ENTRY
*
         TBM       6,0,R3
         BNS       C43             BR IF NO TRANSFER ADDRESS IN ENTRY
         LW        R4,1W,R3
         BL        CBIAS           BIAS ADDRESS
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-32
         BNS       $+2W            SKIP BIAS IF NOT             ELST-32
         ADMW      R4,DEBIAS                                    ELST-32
         ANMW      R4,=X'01FFFFFF' CLEAR BYTE ZERO OF TRANSFER ADDRESS
*                                  LEAVING CSECT/DSECT FLAG IN BIT 7
         LW        R3,MMODW
         STW       R4,4W,R3        STORE TRANSFER ADDRESS IN MODULE ENT
         BU        C43
C46      TBM       1,0,R3
         BNS       C46.5           BR IF NOT DEFINED ENTRY POINT
*
*        DEFINED ENTRY POINT
*
         LW        R4,1W,R3        GET ADDRESS
         TBR       R4,8            SEE IF ABS OR REL
         BNS       C43             BRANCH IF ABSOLUTE (DO NOT BIAS)
         BL        CBIAS           BIAS ADDRESS
         STW       R4,1W,R3
         BU        C43
C46.5    LW        R4,=X'00FFFFFF'
         LMW       R4,0,R3
         BEQ       C43             BR IF NOT COMMON ALLOCATION ENTRY
*
*        COMMON ALLOCATION ENTRY
*
         ARMW      R1,1W,R3        BIAS ADDRESS
         BU        C43
*                                                                1.3#14
*   AS A FINAL STEP IN PASS-A  CHECK SIZES.                      1.3#14
*                                                                1.3#14
C50      EQU       $                                             1.3#14
         TBM       MIEOBJ,MFLAG3   ANY IEEE OBJECT READ?        EIEE-33
         BNS       C50.A           NO...CONTINUE                EIEE-33
         TBM       MPSOBJ,MFLAG2   PURELY SECTIONED OBJECT READ EIEE-33
         BS        C50.B           YES...BRANCH                 EIEE-33
         TBM       MOSOBJ,MFLAG2   OLD STYLE OBJECT READ        EIEE-33
         BNS       C50.A           NO...BRANCH                  EIEE-33
C50.B    LNB       R5,C50.M16L     GET ERROR MESSAGE LENGTH     EIEE-33
         LA        R6,C50.M16A     GET MESSAGE ADDRESS          EIEE-33
         BL        XTYPE           OUTPUT ERROR MESSAGE         EIEE-33
         BL        XABORT          AND ABORT                    EIEE-33
C50.A    EQU       $                                            EIEE-33
         LW        R5,MTOTALL      GET DSECT SIZE                1.3#14
         ADMW      R5,MPABS        ADD ABSOLUTE BIAS             1.3#14
         ADMW      R5,MALTD        ADD ALLOCATE SIZE             1.3#14
         STW       R5,C50.TVAL     SAVE                          1.3#14
         ZBM       C50.TOT,C50.FLG RESET TOTAL OUTPUT REQUIR.    1.3#14
         CAMW      R5,=X'80000'    COMPARE TO MAX                1.3#14
         BLT       C50.4           CONTINUE IF LESS              1.3#14
*                                                                1.3#14
         LNB       R5,C50.M1L                                    1.3#14
         LA        R6,C50.M1A                                    1.3#14
         BL        XTYPEF                                        1.3#14
         BL        C50.91          REPORT ABSOLUTE SIZE          1.3#14
         BL        C50.92          REPORT DSECT SIZE             1.3#14
         BL        C50.93          REPORT ALLOCATED AMOUNT       1.3#14
         BL        C50.94          REPORT TOTALS                 1.3#14
         BL        XABORT          AND QUIT                      1.3#14
*                                                                1.3#14
*----                                                            1.3#14
*                                                                1.3#14
C50.4    EQU       $          CHECK FOR CSECT OVERLAP            1.3#14
         LW        R5,C31.7T       GET CSECT START               1.3#14
         TBM       M2.5MB,MFLAG2   GENERATE 2.5MB TASK ?        ELST-32
         BNS       C50.41          USE .5MB LIMIT IF SO         ELST-32
         CAMW      R5,=X'1000000'  IS THERE ANY                 ELST-32
         BEQ       B               ON TO PASS B                 ELST-32
         CAMW      R5,C50.TVAL     COMPARE TO DSECT.            ELST-32
         BGT       B               ON TO PASS B, NO OVERLAP     ELST-32
         BU        C50.42          REPORT ERROR OTHERWISE       ELST-32
C50.41   EQU       $                                            ELST-32
         CAMW      R5,=X'80000'    IS THERE ANY                  1.3#14
         BEQ       B               ON TO PASS B, NO CSECT        1.3#14
         CAMW      R5,C50.TVAL     COMPARE TO DSECT              1.3#14
*!!!!!!!!BGT!!!!!!!C50.43!!!!!!!!!!PUT!OUT!.5MB!WARNING!!!!!!!!!ELST-33F
         BGT       B               ON TO PASS B                 ELST-33F
         BU        C50.42          REPORT ERROR IF OVERLAP      ELST-33F
         TRR       R5,R4           SAVE VALUE                   ELST-32
         LNB       R5,C50.M7L                                   ELST-32
         LA        R6,C50.M7A                                   ELST-32
         BL        XTYPEF          PUT OUT OBJECT MIX ERROR     ELST-32
         LNB       R5,C50.M7LB     SECOND HALF                  ELST-32
         LA        R6,C50.M7AB                                  ELST-32
         BL        XTYPEF                                       ELST-32
         TRR       R4,R5                                        ELST-32
C50.42   M.CONBAH                  CONVERT CSECT START          ELST-32
         ANMW      R6,=X'0000FFFF' KEEP SIX DIGITS               1.3#14
         LA        R3,C50.M6D      LOCATE                        1.3#14
         BL        XST2            AND STUFF                     1.3#14
         LNB       R5,C50.M6L                                    1.3#14
         LA        R6,C50.M6A                                    1.3#14
         BL        XTYPEF                                        1.3#14
         BL        C50.91          REPORT ABSOLUTE               1.3#14
         BL        C50.92          REPORT DSECT                  1.3#14
         BL        C50.93          REPORT ALLOCATE               1.3#14
         BL        C50.94          REPORT TOTAL                  1.3#14
         BL        XABORT          AND QUIT                      1.3#14
C50.43   TBM       MPSOBJ,MFLAG2   ANY PURELY SECTIONED OBJECT? PR10651
         BNS       B               ON TO PASS B IF NOT          PR10651
         TBM       MOPT6,MFLAG2    OPTION 6 SET?                PR10651
         BS        B               ON TO PASS B IF SET          PR10651
         LNB       R5,C50.M8L                                   ELST-32
         LA        R6,C50.M8A                                   ELST-32
         BL        XTYPE           PUT OUT .5MB WARNING         C013-32
         LNB       R5,C50.M8LB                                  ELST-32
         LA        R6,C50.M8AB     SECOND HALF                  ELST-32
         BL        XTYPE                                        C013-32
         BU        B               ON TO PASS B                 ELST-32
*                                                                1.3#14
*                                                                1.3#14
C50.91   EQU       $               ROUTINE TO OUTPUT ABS STUFF   1.3#14
         TBM       MABS,MFLGS      ANY ABSOLUTE                  1.3#14
         BS        $+2W            ENTER IF YES                  1.3#14
         TRSW      R0              ELSE RETURN                   1.3#14
         NOP                       BOUND                         1.3#14
         STW       R0,C50.IRET                                   1.3#14
         LW        R5,MPABS        GET AMOUNT                    1.3#14
         M.CONBAH                  CONVERT                       1.3#14
         LA        R3,C50.M2D      LOCATE IN MESSAGE             1.3#14
         BL        XST2            AND STUFF                     1.3#14
         LNB       R5,C50.M2L                                    1.3#14
         LA        R6,C50.M2A                                    1.3#14
         BL        XTYPEF                                        1.3#14
         SBM       C50.TOT,C50.FLG  INDICATE TOTAL REQUIRED      1.3#14
         BU        *C50.IRET       RETURN                        1.3#14
*                                                                1.3#14
C50.92   EQU       $               ROUTINE TO OUTPUT DSECT       1.3#14
         STW       R0,C50.IRET     SAVE RETURN                   1.3#14
         LW        R5,MTOTALL      GET DSECT SIZE                1.3#14
         M.CONBAH                  CONVERT                       1.3#14
         LA        R3,C50.M3D      LOCATE IN MESSAGE             1.3#14
         BL        XST2            AND STUFF                     1.3#14
         LI        R4,G' '         GET A BLANK                   1.3#14
         TBM       C50.TOT,C50.FLG DID WE OUTPUT ABS STUFF       1.3#14
         BNS       $+2W            SKIP IF WE DID NOT            1.3#14
         LI        R4,G'+'         ELSE GET A "+"                1.3#14
         STB       R4,C50.M3A+3B   AND SET VALUE                 1.3#14
         LNB       R5,C50.M3L                                    1.3#14
         LA        R6,C50.M3A                                    1.3#14
         BL        XTYPEF                                        1.3#14
         BU        *C50.IRET       RETURN                        1.3#14
*                                                                1.3#14
C50.93   EQU       $               ROUTINE TO OUTPUT ALLOC STUF  1.3#14
         LW        R5,MALTD        GET ALLOCATED                 1.3#14
         BNZ       $+2W            ENTER IF SOME                 1.3#14
         TRSW      R0              ELSE RETURN                   1.3#14
         NOP                       BOUND                         1.3#14
         STW       R0,C50.IRET                                   1.3#14
         M.CONBAH                  CONVERT                       1.3#14
         LA        R3,C50.M4D      LOCATE                        1.3#14
         BL        XST2            AND STUFF                     1.3#14
         LNB       R5,C50.M4L                                    1.3#14
         LA        R6,C50.M4A                                    1.3#14
         BL        XTYPEF                                        1.3#14
         SBM       C50.TOT,C50.FLG    SET TOTALS REQUIRED        1.3#14
         BU        *C50.IRET       RETURN                        1.3#14
*                                                                1.3#14
C50.94   EQU       $               ROUTINE TO OUTPUT TOTAL       1.3#14
         ZBM       C50.TOT,C50.FLG ZAP THE TOT FLAG              1.3#14
         BS        $+2W            ENTER IF IT WAS SET           1.3#14
         TRSW      R0              ELSE RETURN                   1.3#14
         NOP                       BOUND                         1.3#14
         STW       R0,C50.IRET                                   1.3#14
         LW        R5,C50.TVAL                                   1.3#14
         M.CONBAH                  CONVERT                       1.3#14
         LA        R3,C50.M5D      LOCATE                        1.3#14
         BL        XST2            AND STUFF                     1.3#14
         LNB       R5,C50.M5L                                    1.3#14
         LA        R6,C50.M5A                                    1.3#14
         BL        XTYPEF                                        1.3#14
         BU        *C50.IRET       RETURN                        1.3#14
*                                                                1.3#14
C50.IRET DATAW     0               HOLDS INTERNAL RETURN ADDR    1.3#14
C50.TVAL DATAW     0               HOLDS TOTAL DSECT             1.3#14
C50.FLG  DATAB     0               FLAG BYTE                     1.3#14
C50.TOT  EQU       0               SET INDICATES TOTAL OUTPUT    1.3#14
*                                                                1.3#14
C50.M1A  DATAB     C' CATALOG<<FATAL>> DSECT REQUIRES MORE'      1.3#14
         DATAB     C' THAN 128KW TO LOAD.'                       1.3#14
C50.M1L  DATAB     $-C50.M1A                                     1.3#14
*                                                                1.3#14
C50.M2A  DATAB     C'     ABSOLUTE BIAS       X"''               1.3#14
C50.M2D  REZ       8B                                            1.3#14
         DATAB     C'"'.'                                        1.3#14
C50.M2L  DATAB     $-C50.M2A                                     1.3#14
*                                                                1.3#14
C50.M3A  DATAB     C'   + DSECT REQUIREMENT   X"''               1.3#14
C50.M3D  REZ       8B                                            1.3#14
         DATAB     C'"'.'                                        1.3#14
C50.M3L  DATAB     $-C50.M3A                                     1.3#14
*                                                                1.3#14
C50.M4A  DATAB     C'   + ALLOCATED AMOUNT    X"''               1.3#14
C50.M4D  REZ       8B                                            1.3#14
         DATAB     C'"'.'                                        1.3#14
C50.M4L  DATAB     $-C50.M4A                                     1.3#14
*                                                                1.3#14
C50.M5A  DATAB     C'   =          TOTAL      X"''               1.3#14
C50.M5D  REZ       8B                                            1.3#14
         DATAB     C'"'.'                                        1.3#14
C50.M5L  DATAB     $-C50.M5A                                     1.3#14
*                                                                1.3#14
C50.M6A  DATAB     C' CATALOG<<FATAL>>  DSECT OVERLAPS THE'      1.3#14
         DATAB     C' CSECT STARTING AT X"''                     1.3#14
C50.M6D  REZ       6B                                            1.3#14
         DATAB     C'"'.'                                        1.3#14
C50.M6L  DATAB     $-C50.M6A                                     1.3#14
*
C50.M7A  DATAB     C' CATALOG<<FATAL>> ALL INPUT OBJECT IS NOT' ELST-32
         DATAB     C' PURELY SECTIONED.'                        ELST-32
C50.M7L  DATAB     $-C50.M7A                                    ELST-32
C50.M7AB DATAB     C'                  2.5 MB LOAD MODULE'      ELST-33G
         DATAB     C' CANNOT BE GENERATED.'                     ELST-33G
C50.M7LB DATAB     $-C50.M7AB                                   ELST-32
*
C50.M8A  DATAB     C' CATALOG(WARNING) ALL INPUT OBJECT CODE'   ELST-32
         DATAB     C' IS NOT PURELY SECTIONED.'                 ELST-32
C50.M8L  DATAB     $-C50.M8A                                    ELST-32
C50.M8AB DATAB     C'                  NON-SEGMENTED LOAD'      ELST-32
         DATAB     C' MODULE  GENERATED.'                       ELST-32
C50.M8LB DATAB     $-C50.M8AB                                   ELST-32
*                                                                1.3#14
C50.M9A  DATAB     C' CATALOG(WARNING) ASSIGNMENT OF OBJECT '   ENCD-32
         DATAB     C' FILE '                                    ENCD-32
C50.M9L  DATAB     $-C50.M9A                                    ENCD-32
*
C50.M9B  DATAB     C'                  '                        PR11087
C50.M9N  REZ       54B                                          PR11087
         DATAB     C' FAILED.'                                  PR11087
C50.M9BL DATAB     $-C50.M9B                                    PR11087
*
C50.M9C  DATAB     C'                  STATUS = RM'             PR11087
C50.M9S  REZ       2B                                           PR11087
C50.M9CL DATAB     $-C50.M9C                                    PR11087
*
C50.MAA  DATAB     C' CATALOG<<FATAL>> NO MEMORY AVAILABLE '    ENCD-32
         DATAB     C' FOR TEMPORARY OBJECT '                    ENCD-32
C50.MAL  DATAB     $-C50.MAA                                    ENCD-32
C50.MBA  DATAB     C'                  CODE FILE BLOCKING '     ENCD-32
         DATAB     C' BUFFERS.'                                 ENCD-32
C50.MBL  DATAB     $-C50.MBA                                    ENCD-32
*
C50.M11A DATAB     C' CATALOG(WARNING) LIBRARY '                PR11094
C50.M11F REZ       3B                                           PR11094
         DATAB     C' IS NOT ASSIGNED AND WILL NOT BE SEARCHED' PR11094
C50.M11L DATAB     $-C50.M11A                                   PR11094
*
C50.M12A DATAB     C' CATALOG(WARNING) DIRECTORY '              PR11094
C50.M12F REZ       3B                                           PR11094
         DATAB     C' IS NOT ASSIGNED. RELATED'                 PR11094
C50.M12L DATAB     $-C50.M12A                                   PR11094
*
C50.M13A DATAB     C'                  LIBRARY WILL NOT BE '    PR11094
         DATAB     C'SEARCHED.'                                 PR11094
C50.M13L DATAB     $-C50.M13A                                   PR11094
*
C50.M14A DATAB     C' CATALOG(WARNING) LOAD MODULES WITH '      C022-32
         DATAB     C'OVERLAYS CANNOT BE DEMAND PAGED.'          C022-32
C50.M14L DATAB     $-C50.M14A                                   C022-32
*
C50.M15A DATAB     C'                  MODE NODEMAND HAS BEEN ' C022-32
         DATAB     C'SET.'                                      C022-32
C50.M15L DATAB     $-C50.M15A                                   C022-32
*
C50.M16A DATAB     C' CATALOG<<FATAL>> COMBINING IEEE-754 '     EIEE-33
         DATAB     C'OBJECT WITH EXCESS-64 OBJECT IS ILLEGAL.'  EIEE-33
C50.M16L DATAB     $-C50.M16A                                   EIEE-33
*
*----------------------------------------------------------------1.3#14
         TITLE     DIRECTIVE CONTROL TABLES
C90      DATAW     C'DIRECTIVE ERROR(S)'
         BOUND     1D
C91      EQU       $
CATALOG  DATAD     C'CATALOG '     ILLEGAL AFTER FIRST  BUILD  DIRECTIVE
ALLOCATE DATAD     C'ALLOCATE'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
ABSOLUTE DATAD     C'ABSOLUTE'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
LORIGIN  DATAD     C'LORIGIN '
PASSWORD DATAD     C'PASSWORD'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
USERNAME DATAD     C'USERNAME'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
ENVIRONM DATAD     C'ENVIRONM'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
FILES    DATAD     C'FILES'        ILLEGAL AFTER FIRST CATALOG DIRECTIVE
BUFFERS  DATAD     C'BUFFERS'      ILLEGAL AFTER FIRST CATALOG DIRECTIVE
OPTION   DATAD     C'OPTION'       ILLEGAL AFTER FIRST CATALOG DIRECTIVE
ORIGIN   DATAD     C'ORIGIN'
ASSIGN   DATAD     C'ASSIGN'       ILLEGAL AFTER FIRST CATALOG DIRECTIVE
AS       DATAD     C'AS'           ILLEGAL AFTER FIRST CATALOG DIRECTIVE
SYMTAB   DATAD     C'SYMTAB'       ILLEGAL AFTER FIRST CATALOG DIRECTIVE
A1       DATAD     C'A1'           ILLEGAL AFTER FIRST CATALOG DIRECTIVE
A2       DATAD     C'A2'           ILLEGAL AFTER FIRST CATALOG DIRECTIVE
A3       DATAD     C'A3'           ILLEGAL AFTER FIRST CATALOG DIRECTIVE
A4       DATAD     C'A4'           ILLEGAL AFTER FIRST CATALOG DIRECTIVE
VOLUMES  DATAD     C'VOLUMES '     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
SEGFILES DATAD     C'SEGFILES'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
RECAT    DATAD     C'RECATALO'     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
MOUNT    DATAD     C'MOUNT   '     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
LMPATH   DATAD     C'LMPATH  '     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
BUILD    DATAD     C'BUILD   '     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
TSABASE  DATAD     C'TSABASE '      TSABASE DIRECTIVE           EAID-32
VERSION  DATAD     C'VERSION '      VERSION DIRECTIVE           EAID-32
MPXONLY  DATAD     C'MPXONLY '      MPXONLY DIRECTIVE           EAID-32
CONNECT  DATAD     C'CONNECT '     ILLEGAL AFTER FIRST CATALOG DIRECTIVE
EXTDMPX  DATAD     C'EXTDMPX'      ILLEGAL AFTER FIRST CATALOG DIRECTIVE
SPACE    DATAD     C'SPACE'        ILLEGAL AFTER FIRST CATALOG DIRECTIVE
OPSET    DATAD     C'SET     '     ILLEGAL AFTER 1ST CATLG DIR. ENCD-32
LIBRARY  DATAD     C'LIBRARY '     ILLEGAL AFTER 1ST CATLG DIR. ENCD-32
DIRECTRY DATAD     C'DIRECTOR'     ILLEGAL AFTER 1ST CATLG DIR. ENCD-32
FLOATMOD DATAD     C'FLOATMOD'     ILLEGAL AFTER 1ST CATLG DIR. EFLM-33
DEBUGGER DATAD     C'DEBUGGER'     ILLEGAL AFTER 1ST CATLG DIR. EDBG-34
C92      ACH       CCAT
         ACH       CALL
         ACH       CABS
         ACH       CLORG                                          21008
         ACH       CPAS
         ACH       CUSE
         ACH       CENV
         ACH       CFIL
         ACH       CBUF
         ACH       COPT
         ACH       CORG
         ACH       CASS0
         ACH       CASSG.A
         ACH       CSYM
         ACH       CASS1
         ACH       CASS1
         ACH       CASS1
         ACH       CASS1
         ACH       CVOL
         ACH       CSEG
         ACH       CRECAT
         ACH       CMOUNT
         ACH       CPATH
         ACH       CBLD
         ACH       CTSA                                         EAID-32
         ACH       CVER                                         EAID-32
         ACH       CMPX                                         EAID-32
         ACH       CCONN                                          11017
         ACH       CEXTD           ACTION ROUTINE FOR EXTDMPX   EBRM-33
         ACH       CSPCE           ACTION  SPACE ROUTINE         1.3#10
         ACH       CSET            ACTION ROUTINE FOR SET       ENCD-32
         ACH       CLIB            ACTION ROUTINE FOR LIBRARY   ENCD-32
         ACH       CDIR            ACTION ROUTINE FOR DIRECTORY ENCD-32
         ACH       CFLM            ACTION ROUTINE FOR FLOATMODE EFLM-33
         ACH       CDBUG                                        EDBG-34
CCOMNO   EQU       $-C92/4
         TITLE     CBIAS - SYMTAB BIASING ROUTINE
*        CBIAS - BIAS SYMTAB ADDRESSES DEPENDING ON SECTION NUMBER
*
*        R4 = ADDRESS TO BIAS - 1ST BYTE HAS SECTION NUMBER
* RETURN WITH R4 CONTAINING BIASED ADDRESS
*            BIT 7 SET IF CSECT ADDRESS
*
CBIAS    TBR       R4,7            SECTION ONE
         BS        CBIAS2          YES
         ADR       R6,R4           SECTION ZERO
CBIAS1   TRSW      R0
CBIAS2   ADMW      R4,MSEC1O       BIAS FOR SECTION ONE         ELST-32
         BU        CBIAS1
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     CARDERR  - REPORT ERRORS IN DIRECTIVES
*
* LABELS TO HANDLE CARD ERRORS AND EXIT TO THE CARD INPUT HANDLER
*
CARDERR1 LI        R5,1            ILLEGAL DIRECTIVE
         BU        CARDERR
CARDERR2 LI        R5,2            ILLEGAL BLANK FIELD
         BU        CARDERR
CARDERR3 LI        R5,3            ILLEGAL ENTRY
         BU        CARDERR
CARDERR4 LI        R5,4            EXCESSIVE ASSIGNMENTS
         BU        CARDERR
CARDERR5 LI        R5,5            MISSING DIRECTIVE
         BU        CARDERR
CARDERR6 LI        R5,6            ILLEGAL FILENAME
*                                OUT AT CUT 10, WHY IS IT HERE?  1.3#10
         BU        CARDERR                                       11017
CARDERR8 LI        R5,8            DUPLICATE DPOOL               11017
         BU        CARDERR                                       11017
CARDERR9 LI        R5,9            EXCESSIVE CONNECTS            11017
         BU        CARDERR                                       11017
CARDERRA LI        R5,10           DUPLICATE DICTIONARIES        11017
         BU        CARDERR                                       11017
CARDERRB LI        R5,11           UNDEFINED DATAPOOL            11017
*
CARDERR  BL        CCERR           LOG THE ERROR
*
* NORMAL AND ABNORMAL EXIT FOR CARD PROCESSING
*
CARDEXIT LF        R0,CARD90       RESTORE REGISTERS
         TRSW      R0
         TITLE     CCERR    - OUTPUT DIRECTIVE ERROR MESSAGE
***********************************************************************
*
*                  CCERR
*
***********************************************************************
*
*        PRINTS CARD ERROR MESSAGE, ERROR IN FIELD DD MESSAGE
*        CARD FIELD NUMBER IS INPUT IN CCFLD; PRINTED IN DD FIELD
*        R5 CONTAINS NUMERIC ID OF MESSAGE; PRINTED IN MESSAGE FIELD. *
*           MESSAGES ARE:
*              1 ILLEGAL DIRECTIVE
*              2 ILLEGAL BLANK FIELD
*              3 ILLEGAL ENTRY
*              4 EXCESSIVE ASSIGNMENTS
*              5 MISSING DIRECTIVE
*              6 ILLEGAL FILE NAME
*              7 MISSING FROM LIBRARY                              0200
*              8 DUPLICATE DPOOLS                                 11017
*              9 EXCESSIVE CONNECTS                               11017
*             10 DUPLICATE DP DICTIONARIES                        11017
*             11 UNDEFINED DATAPOOL                               11017
*
***********************************************************************
CCERR    STF       R0,CCERR90      SAVE REGS
         TBM       MOPTTXT,MFLGS   IS OPTION TEXT ON             1.3#14
         BS        CCERR0          SKIP OUTPUT                   1.3#14
         TBM       CSLOUT,CFLGS    IS SLO = UT                   1.3#14
         BS        CCERR0          SKIP OUTPUT                   1.3#14
         LH        R5,MDBFL        GET ACTIVE LENGTH             1.3#14
         ADI       R5,1            BUMP FOR CC                   1.3#14
         LA        R6,MDBUF-1B     ADDRES INCLUDING CC           1.3#14
         BL        XTYPEF          AND ISSUE TO UT               1.3#14
CCERR0   EQU       $                                             1.3#14
*                                                                1.3#14
         LD        R6,CCERR92      "*ERROR I
         STD       R6,MPBUF        N FIELD "
         LD        R6,CCERR92+1D   TO PRINT
         STD       R6,MPBUF+1D     BUFFER
         LB        R5,CCFLD
         BL        M0210           CONVERT CARD FIELD NO. TO DECIMAL
         LI        R4,X'7F00'
         TRRM      R7,R6
         SRL       R6,8
         LI        R1,1B
         CI        R6,G'0'         ELIMINATE LEADING ZERO IF PRESENT
         BEQ       CCERR1          BR IF ZERO IS PRESENT
         ABR       R1,31
         STB       R6,MPBUF+16B    STORE FIRST DIGIT
CCERR1   STB       R7,MPBUF+15B,R1 STORE 2ND DIGIT
         BU        CCERR1.2        SKIP OTHER ERROR PROCESSING     0200
*
CCERR1.1 STF       R0,CCERR90      SAVE REGS                       0200
         LD        R6,MBERR91      LOAD 'PROGRAM' INTO             0200
         STD       R6,MPBUF        THE ERROR BUFFER                0200
         LD        R6,CCENT        LOAD PROGRAM NAME INTO BUFFER   0200
         STD       R6,MPBUF+1D                                     0200
         LI        R1,1B                                           0200
CCERR1.2 LW        R5,CCERR90+5W   SELECTED MSG NO.
         SUI       R5,1B
         MPI       R4,24B          OBTAIN IX TO MESSAGE
         TRR       R5,R2
         LI        R3,-24B         MAX MSG LENGTH IS 24 CHARACTERS
CCERR2   LB        R5,CCERR91,R2   TRANSFER MSG TO BUFFER
         STB       R5,MPBUF+16B,R1 BUFFER IS BLANKED BY MPRNT
         ABR       R1,31
         ABR       R2,31
CCERR4   BIB       R3,CCERR2
         LA        R6,MPBUF-1      INITIAL ADDR                  1.3#10
         LI        R5,-43          LENGTH                        1.3#10
         BL        XTYPEF          AND LOG IT                    1.3#10
         SBM       CDERR,CFLGS     SET DIRECTIVE CARD ERROR FLAG
         LF        R0,CCERR90
         TRSW      R0              RETURN
         BOUND     8W
CCERR90  RES       8W
CCERR91  DATA      C': ILLEGAL DIRECTIVE*    '  MESSAGES
         DATA      C': ILLEGAL BLANK FIELD*  '
         DATA      C': ILLEGAL ENTRY*        '
         DATA      C': EXCESSIVE ASSIGNMENTS*'
         DATA      C': MISSING DIRECTIVE*    '
         DATA      C': ILLEGAL FILE NAME*    '
         DATA      C': MISSING FROM LIBRARY* '                      0200
         DATA      C': DUPLICATE DPOOLS*     '                   11017
         DATA      C': EXCESSIVE CONNECTS*   '                   11017
         DATA      C': DUPLICATE DICTIONARIES'                   11017
         DATA      C': UNDEFINED DATAPOOL*   '                   11017
CCERR92  DATAD     C'*ERROR I'
         DATAD     C'N FIELD '
*
*-----------------------------------------------------------------------
         TITLE     CDEV     - GENERATE DEVICE TYPE
*****************************************************************
*
*                  CDEV
*
*****************************************************************
*
*        PRODUCE A DEVICE-TYPE/CHANNEL/SUB-CHANNEL WORD
*        FROM AN INPUT DEVICE MNEMONIC (DEVMNC)
*
*        INPUT:    R6/R7 = DEVMNC GIVEN BY USER
*
*        OUTPUT:   R2 = ADDRESS OF DTT ENTRY FOR DEVICE
*                  R7 = DEVICE-TYPE/CHANNEL/SUB-CHANNEL WORD
*
*        ERRORS:   (1) INPUT DEVMNC IS NOT 2/4/6 CHARS LONG
*                  (2) DEVICE IS NOT IN DTT TABLE
*                  (3) NON HEX CHANNEL/SUB-CHANNEL SPECIFIED
*
*        A RETURN IS NOT MADE TO THE CALLER IF ERROR DETECTED
*
*****************************************************************
CDEV     STF       R0,CDEV90
         ZMW       CDEV91          TO BUILD OUTPUT R7 IN
         LB        R5,CCHRS        CHECK FOR VALID LENGTH
         CI        R5,2
         BEQ       CDEV.0
         CI        R5,4
         BEQ       CDEV.0
         CI        R5,6
         BNE       CARDERR3
*
* PROCESS DEVICE MNEMONIC FIRST
*
CDEV.0   TRR       R6,R4
         SRL       R4,16           DEVICE MNEMONIC IN BOTTOM OF R4
         LW        R2,C.DTTA       DEVICE TABLE ADDRESS
         LNB       R5,C.DTTN       TOTAL ENTRIES IN TABLE
CDEV.1   CAMH      R4,3H,R2        LOOK FOR MNEMONIC
         BEQ       CDEV.2          BRANCH IF FOUND
         ABR       R2,28           MOVE TO NEXT ENTRY (2 WORDS)
         BIB       R5,CDEV.1       LOOP FOR NEXT ENTRY
         BU        CARDERR3        MNEMONIC NOT IN TABLE
*
* MNEMONIC FOUND, PROCESS CHANNEL/SUB-CHANNEL IF ANY
*
CDEV.2   STW       R2,CDEV90+2W    RETURN ENTRY ADDRESS TO CALLER
         LB        R5,0B,R2        GET DEVICE TYPE FROM TABLE
         STB       R5,CDEV91       INTO RESULT WORD
         LB        R5,CCHRS        SEE IF ANY CHANNEL/SUB-CHANNEL
         CI        R5,2
         BEQ       CDEV.3          BRANCH IF NO CHAN/SUB-CHAN
         SBM       0,CDEV91        INDICATE CHANNEL PRESENT
*
         SLLD      R6,16           CHANNEL/SUB-CHANNEL INTO R6
         ADI       R7,G'  '        ALL SPACES IN R7
         SVC       1,X'29'         CONVERT CHAN/SUB-CHAN TO HEX
         TRR       R6,R6           CHECK FOR NON HEX DATA
         BZ        CARDERR3        BRANCH IF NON HEX IN INPUT
*
* SET UP THE LOW HALFWORD OF RESULT TO CONTAIN THE CHANNEL
* NUMBER AND THE SUB-CHANNEL NUMBER, IF ANY.
* THE TOP BIT OF THE CHANNEL NUMBER FIELD IS SET IF A SUB-CHANNEL
* EXISTS.
*
         LB        R5,CCHRS        CHECK FOR SUB-CHANNEL
         CI        R5,6
         BNE       CDEV.4          BRANCH IF CHANNEL ONLY
         SBR       R7,16           SET SUB-CHANNEL PRESENT BIT
         BU        CDEV.5          COMMON EXIT
CDEV.4   SLL       R7,8            CHANNEL NUMBER TO TOP BYTE OF .....
*                                  ..... HALFWORD
CDEV.5   STH       R7,CDEV91+1H    STORE IN RESULT
CDEV.3   LF        R0,CDEV90
         LW        R7,CDEV91       RETURN TYPE/CHAN/SUB-CHAN WORD
         TRSW      R0
CDEV90   RES       1F
CDEV91   RES       1W
*
*-----------------------------------------------------------------------
         TITLE     STRING   - SYNTAX SCANNER (STR.CAT)
*********************************************************************
*
*                  STRING
*
************************************************************************
*
*        SYNTAX SCANNER FOR ONLINE USERS
*
*        GET STRING OF 8 BYTES FROM LINE BUFFER AT CURRENT
*        CURSOR POSITION
*        RETURN:
*                  R6 & R7 = 1ST 8 CHARACTERS OF FIELD
*
*******************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
STR.CAT  STF       R0,STRINGSV     ENTRY POINT FOR QUOTES ALLOWED
         LI        R7,X'27'        QUOTE CHAR
         STB       R7,QUOTE        STORE INTO DELIMITER TABLE
         BU        STRING0         COMMON CODE
*
*
STRING   STF       R0,STRINGSV
         ZMB       QUOTE           DISABLE QUOTES
STRING0  LA        R3,CCENT        GET ADDR OF BUILDING INDEX
         LB        R2,CCPTR        GET CURSOR INDEX
         STW       R2,CCSTRT       FOR PATHNAME RECOGNITION
         ZMW       STR91           FLAG WORD FOR STRING ROUTINE
*
*
         LD        R6,BLANKS       GET BLANK
         STD       R6,0,R3         ZAP COLLECTION PLATE
         STD       R6,1D,R3        SECOND 8 CHARS
         LI        R4,X'20'        DUMMY TERMINATOR IN CASE E.O.B.
         ZR        R5              STRING COUNTER FLAG
         ZR        R6              BLANKS ACTIVE FLAG
         LI        R7,-72          GET NEGATIVE BUFFER LENGTH
*
         ADMB      R7,CCPTR        GET NEG COUNT OF REMAINING BYTES
         BGE       STRING4         DONE ...
STRING1  EQU       $
         LB        R4,MDBUF,R2     GET BYTE FROM COMMAND BUFFER
         LI        R1,0
STRING1A EQU       $
         CAMB      R4,DELIMS,R1    CHECK AGAINST KNOWN DELIMS
         BNE       STRING1B        OK
         SLL       R1,2            WORD ALIGN INDEX
         BU        *ACTIONS,R1     DISPATCH ROUTINE
STRING1B EQU       $
         ADI       R1,1
         CI        R1,DELIM#       AT END
         BLT       STRING1A        NOT YET
STR.4    CI        R5,16           AMASSED TOTAL STRING YET??
         BGE       $+2W            YES
         STB       R4,0,R3         MOVE TO BUILDING AREA
         ABR       R6,31           SET BLANKS NO LONGER ACTIVE FLAG
         ABR       R2,31           INPUT STRING BYTE ADDRESS
         ABR       R3,31           OUTPUT STRING BYTE ADDRESS
         ABR       R5,31           BUMP THIS STRING COUNTER
STR.5    BIB       R7,STRING1      SCAN TILL E.O.B
         BU        STR.3           FORCE TERMINATION
STRING2  EQU       $
         TBM       7,STR91         ARE WE IN QUOTES??
         BS        STR.4           BRANCH IF YES TO IGNORE DELIMITER
STR.3    ADI       R2,1            BUMP OVER LAST BYTE
STR.2    STB       R2,CCPTR        SAVE NEW CURSOR POSITION
         STB       R4,CCDLIM       REMEMBER CURRENT DELIMITER
         STB       R5,CCHRS        REMEMBER FIELD COUNTER
         ABM       7,CCFLD         INCREMENT FIELD ID
         LF        R0,STRINGSV
         LD        R6,CCENT        PASS BACK LEFT JUSTIFIED STRING
         TRSW      R0
*
*
*        SKIP LEADING BLANKS
*
STRING3  EQU       $
         CI        R6,0            ARE WE TRAVELING ACROSS LEAD BLANKS ?
         BNE       STRING2         NOPE-> THATS A DELIMITER
         ADI       R2,1B           YES--> BUMP OVER THEM
         ABM       31,CCSTRT       BUMP REAL STRING START ALSO
         BIB       R7,STRING1      KEEP SCANNING TIL EOB
         BU        STRING2         DONE AT EOB
*
STRING4  EQU       $
         LI        R2,255          FORCE END OF MEDIUM FOR NEXT CALL
         BU        STR.2           TAKE NORMAL RETURN
*
STRING5  TBM       7,STR91         IS THIS THE SECOND QUOTE??
         BS        STR.3           BR IF YES TO EXIT
         CI        R5,0            IS THE QUOTE THE FIRST SIG CHAR
         BNE       STR.4           BRANCH IF NOT TO TREAT NORMALLY
         SBM       7,STR91         SET QUOTE FOUND AS FIRST CHAR
         ADI       R2,1            SKIP THE CHAR
         BU        STR.5           PROCESS NEXT CHAR
STR91    DATAW     0               GASH FLAG VARIABLE
         PAGE
*
*        CONSTANTS AND JUNK
*
         BOUND     8W
STRINGSV RES       8W              SAVE AREA FOR REGISTERS
M19      DATAW     X'7FFFF'
M12      DATAW     X'00000FFF'
Y12      DATAW     X'FFF00000'     TCW SIZE EXTRACTOR
M24      DATAW     X'00FFFFFF'
Y8       DATAW     X'FF000000'     BYTE 0 EXTRACTION MASK
BLANKS   DATAD     C'        '     8 BYTE BLANK STRING
*
*
CR       EQU       X'0D'           ASCII CARRAIGE RETURN
NL       EQU       X'0A'           ASCII NEW LINE
*
*        DELIMITER WIDGETS
*
         BOUND     1W
DELIMS   EQU       $
         DATAB     X'20'           00 - BLANK CHAR
         DATAB     C','            02 - COMMAN CHAR
         DATAB     C'='            03 - EQUAL SIGN
         DATAB     CR              04 - CARRAIGE RETURN
         DATAB     NL              05 - NEW LINE
         DATAB     C'('            06 - LEFT PAREN
         DATAB     C')'            07 - RIGHT PAREN
QUOTE    DATAB     X'27'           08 - QUOTE
DELIM#   EQU       $-DELIMS        COUNT IN TABLE
         BOUND     1W
*
*        ROUTINES TO HANDLER ABOVE DELIMITERS
*
ACTIONS  EQU       $
         ACH       STRING3         00 - BLANKS
         ACH       STRING2         02 - COMMAS
         ACH       STRING2         03 - EQUAL SIGNS
         ACH       STRING4         04 - CARRAIGE RETURNS
         ACH       STRING2         05 - NEW LINES
         ACH       STRING2         06 - LEFT PAREN
         ACH       STRING2         07 - RIGHT PAREN
         ACH       STRING5         08 - QUOTE
*         TITLE     CEXCL    - SEARCH EXTERNALS FOR EXCLUDED NAME
         TITLE     CALL     - ALLOCATE DIRECTIVE
***********************************************************************
*
*                  CALL
*
***********************************************************************
*
*        PROCESS ALLOCATE DIRECTIVE CARD
*
***********************************************************************
CALL     STF       R0,CARD90
         BL        STRING         NUMBER OF BYTES
         LB        R5,CCHRS
         BZ        CARDERR2
         CI        R5,5
         BGT       CARDERR3        BRANCH IF > 3 CHARS
         BL        M1602           CONVERT TO BINARY
         TRR       R6,R6
         BEQ       CARDERR3        BRANCH IF A NON-NUMERIC CHAR
         STW       R7,MALTD        SAVE ALLOCATION INCREMENT
         BU        CARDEXIT
         TITLE     CFIL     - FILE DIRECTIVE
***********************************************************************
*
*                  CFIL
*
***********************************************************************
*
*        PROCESS FILE     DIRECTIVE CARD
*
***********************************************************************
CFIL     STF       R0,CARD90
         BL        STRING         NUMBER OF BYTES
         LB        R5,CCHRS
         BZ        CARDERR2        BRANCH IF NO FILES SPECIFIED
         CI        R5,5
         BGT       CARDERR3        BRANCH IF > 5 CHARS
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6
         BEQ       CARDERR3        BRANCH IF NON-NUMERIC CHAR
*!!!!!!!!TBM!!!!!!!MOPT19,MFLGS!!!!IS!OPTION!19!SET!!!!!!!!!!!!!ENCD-32
*!!!!!!!!BNS!!!!!!!CFIL6!!!!!!!!!!!BR!IF!DEBUG!OPTION!NOT!SET!!!ENCD-32
*!!!!!!!!ARMB!!!!!!R7,MFILE!!!!!!!!ADD!USER'S!FILE!REQUIREMENT!!ENCD-32
         SBM       MFILD,MFLAG2    SHOW FILE DIR. PROCESSED     ENCD-32
         ARMB      R7,MTMPFIL      ADD USER'S REQ. TO TEMP VAL  ENCD-32
         BU        CARDEXIT
*!CFIL6!!STB!!!!!!!R7,MFILE!!!!!!!!!SAVE!FILES!COUNT!!!!!!!!!!!!ENCD-32
*!!!!!!!!BU!!!!!!!!CARDEXIT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
         TITLE     TSABASE  DIRECTIVE
***********************************************************************
*                                                               EAID-32
*                  TSABASE                                      EAID-32
*                                                               EAID-32
***********************************************************************
*                                                               EAID-32
*        PROCESS TSABASE  DIRECTIVE CARD                        EAID-32
*                                                               EAID-32
***********************************************************************
CTSA     STF       R0,CARD90                                    EAID-32
         BL        STRING         NUMBER OF BYTES               EAID-32
         LB        R5,CCHRS                                     EAID-32
         BZ        CARDERR2        BRANCH IF NO FILES SPECIFIED EAID-32
         CI        R5,5                                         EAID-32
         BGT       CARDERR3        BRANCH IF > 5 CHARS          EAID-32
         BL        M1602           CONVERT TO BINARY            EAID-32
         TRR       R6,R6                                        EAID-32
         BEQ       CARDERR3        BRANCH IF NON-NUMERIC CHAR   EAID-32
         ADI       R7,X'0FFF'      ROUND UP TO EVENT X'1000'    EAID-32
         SRL       R7,12                                        EAID-32
         SLL       R7,12                                        EAID-32
         STW       R7,TXPM.ADR     SAVE DESIRED TSA START ADDR  EAID-32
         BU        CARDEXIT                                     EAID-32
         TITLE     VERSION  DIRECTIVE
***********************************************************************
*                                                               EAID-32
*        VERSION          DIRECTIVE CARD                        EAID-32
*                                                               EAID-32
***********************************************************************
CVER     STF       R0,CARD90                                    EAID-32
         BL        STRING         NUMBER OF BYTES               EAID-32
         LB        R5,CCHRS                                     EAID-32
         BZ        CARDERR2        BRANCH IF NO FILES SPECIFIED EAID-32
         STD       R6,VERNUM       SAVE VERSION NUMBER          EAID-32
         BU        CARDEXIT                                     EAID-32
         BOUND     1D                                           EAID-32
VERNUM   REZ       1D                                           EAID-32
         TITLE     MPXONLY  DIRECTIVE
***********************************************************************
*                                                               EAID-32
*                  MPXONLY                                      EAID-32
*                                                               EAID-32
***********************************************************************
*                                                               EAID-32
*        PROCESS MPXONLY  DIRECTIVE CARD                        EAID-32
*                                                               EAID-32
***********************************************************************
CMPX     STF       R0,CARD90                                    EAID-32
         SBM       29,TXPM.FLG    INDICATE MPX ONLY EXECUTION   EAID-32
         BU        CARDEXIT                                     EAID-32
*
         TITLE     CDBUG           DEBUGGER DIRECTIVE
************************************************************************
*                                                               EDBG-34
*                  CDBUG                                        EDBG-34
*                                                               EDBG-34
************************************************************************
*                                                               EDBG-34
*        PROCESS DEBUGGER DIRECTIVE                             EDBG-34
*                                                               EDBG-34
************************************************************************
CDBUG    STF       R0,CARD90                                    EDBG-34
         BL        STRING          GET DEBUGGER NAME            EDBG-34
         LB        R5,CCHRS        WAS IT THERE?                EDBG-34
         BZ        CARDERR2        NO...ERROR                   EDBG-34
         CI        R5,16           GREATER THAN MAX ALLOWED?    EDBG-34
         BGT       CARDERR3        ERROR IF SO                  EDBG-34
         LW        R2,CCSTRT       GET DIRECTIVE BUFFER POINTER EDBG-34
         ZR        R3                                           EDBG-34
CDBUG.1  LB        R6,MDBUF,X2     GET A NAME CHARACTER         EDBG-34
         STB       R6,DBNAME,X3    SAVE FOR PREAMBLE            EDBG-34
         ADI       R3,1            INCREMENT POINTERS           EDBG-34
         ADI       R2,1                                         EDBG-34
         SUI       R5,1                                         EDBG-34
         CI        R5,0            ARE WE DONE WITH NAME?       EDBG-34
         BGT       CDBUG.1         NO...NEXT CHARACTER          EDBG-34
         LI        R6,G' '         LOAD A BLANK                 EDBG-34
CDBUG.2  CI        R3,16           16 CHARACTERS PROCESSED?     EDBG-34
         BGE       CARDEXIT        YES...FINISHED               EDBG-34
         STB       R6,DBNAME,X3    BLANK FILL UNUSED NAME AREA  EDBG-34
         ADI       R3,1                                         EDBG-34
         BU        CDBUG.2                                      EDBG-34
*
DBNAME   REZ       4W              DEBUGGER NAME SAVE AREA      EDBG-34
*
         TITLE     CFLM      FLOATMODE DIRECTIVE
************************************************************************
*                                                               EFLM-33
*                  CFLM                                         EFLM-33
*                                                               EFLM-33
************************************************************************
*                                                               EFLM-33
*        PROCESS FLOATMODE DIRECTIVE                            EFLM-33
*                                                               EFLM-33
************************************************************************
CFLM     STF       R0,CARD90                                    EFLM-33
         BL        STRING          GET DIRECTIVE KEYWORD        EFLM-33
         LB        R5,CCHRS        ANY FIELD FOUND?             EFLM-33
         BNZ       CFLM.1          PROCESS FIELD                EFLM-33
         BU        CARDERR2        NO KEYWORDS...ERROR          EFLM-33
CFLM.0   BL        STRING          GET NEXT KEYWORD             EFLM-33
         LB        R5,CCHRS        WAS A KEYWORD READ?          EFLM-33
         BNZ       CFLM.1          PROCESS IF SO                EFLM-33
         BU        CARDEXIT        EXIT IF NOT                  EFLM-33
CFLM.1   ZR        R1                                           EFLM-33
         LNB       R2,CFLMEND      # OF KEYWORDS TO SEARCH      EFLM-33
CFLM.2   CAMW      R6,CFLMOPS,X1   CHECK THIS KEYWORD           EFLM-33
         BEQ       CFLM.3          GOT ONE                      EFLM-33
         ADI       R1,1D           INCREMENT INDEX              EFLM-33
         BIB       R2,CFLM.2       LOOP                         EFLM-33
         BU        CARDERR1        ERROR INVALID KEYWORD        EFLM-33
CFLM.3   BL        CFLMBIT,X1      SET BIT IN FLOAT PT. CONTEXT EFLM-33
         BU        CFLM.0          NEXT KEYWORD                 EFLM-33
*
*        FLOATMODE DIRECTIVE KEYWORD TABLE                      EFLM-33
*
         BOUND     1D                                           EFLM-33
CFLMOPS  EQU       $                                            EFLM-33
         DATAD     C'COMPDIV '                                  EFLM-33
         DATAD     C'FASTDIV '                                  EFLM-33
CFLMEND  DATAB     $-CFLMOPS/8                                  EFLM-33
*
         BOUND     1W                                           EFLM-33
CFLMBIT  SBM       MDIVM,MFLAG3                                 EFLM-33
         TRSW      R0                                           EFLM-33
         ZBM       MDIVM,MFLAG3                                 EFLM-33
         TRSW      R0                                           EFLM-33
*
         TITLE     CSET      SET DIRECTIVE
************************************************************************
*                                                               ENCD-32
*                  CSET                                         ENCD-32
*                                                               ENCD-32
************************************************************************
*                                                               ENCD-32
*        PROCESS SET DIRECTIVE CARD                             ENCD-32
*                                                               ENCD-32
************************************************************************
CSET     STF       R0,CARD90                                    ENCD-32
         BL        STRING          GET OPTION MNEMONIC          ENCD-32
         LB        R5,CCHRS        ANY FIELD FOUND              ENCD-32
         BNZ       CSET.1          PROCESS FIELD                ENCD-32
*!!!!!!!!LB!!!!!!!!R5,CCDLIM!!!!!!!GET!LAST!DELIMITER!!!!!!!!!!!PR11084
*!!!!!!!!CI!!!!!!!!R5,G','!!!!!!!!!IS!IT!A!COMMA!!!!!!!!!!!!!!!!PR11084
*!!!!!!!!BEQ!!!!!!!CSET.0!!!!!!!!!!CONTINUE,!NOT!END!OF!LINE!!!!PR11084
         BU        CARDERR2        NO MNEMONICS, ERROR          ENCD-32
CSET.0   BL        STRING          GET NEXT KEYWORD             PR11084
         LB        R5,CCHRS        WAS A KEYWORD READ           PR11084
         BNZ       CSET.1          PROCESS IF SO                PR11084
         BU        CARDEXIT        EXIT IF NOT                  PR11084
CSET.1   ZR        R1                                           ENCD-32
         LNB       R2,CSETEND      # OF OPTION MNEMONICS        ENCD-32
CSET.2   CAMD      R6,CSETOPS,R1   CHECK THIS MNEMONIC          ENCD-32
         BEQ       CSET.3          GOT ONE                      ENCD-32
         ADI       R1,1D           INCREMENT INDEX              ENCD-32
         BIB       R2,CSET.2       LOOP                         ENCD-32
         BU        CARDERR1        ERROR INVALID MNEMONIC       ENCD-32
CSET.3   BL        CSETBIT,R1      SET MATCHING BIT IN FLAG WRD ENCD-32
*!!!!!!!!LB!!!!!!!!R5,CCDLIM!!!!!!!GET!LAST!DELIMITER!!!!!!!!!!!PR11084
*!!!!!!!!CI!!!!!!!!R5,G' '!!!!!!!!!END!OF!LINE!!!!!!!!!!!!!!!!!!PR11084
*!!!!!!!!BEQ!!!!!!!CARDEXIT!!!!!!!!EXIT!IF!SO!!!!!!!!!!!!!!!!!!!PR11084
         BU        CSET.0          NEXT MNEMONIC                ENCD-32
*                                                               ENCD-32
*        SET DIRECTIVE MNEMONIC TABLE                           ENCD-32
*                                                               ENCD-32
         BOUND     1D                                           ENCD-32
CSETOPS  EQU       $                                            ENCD-32
         DATAD     C'LIBRARY '                                  ENCD-32
         DATAD     C'NOLIBRAR'                                  ENCD-32
         DATAD     C'NOMULTIF'                                  ENCD-32
         DATAD     C'MULTIFIL'                                  ENCD-32
         DATAD     C'NOSTRICT'                                  ENCD-32
         DATAD     C'STRICT  '                                  ENCD-32
         DATAD     C'DIRECTIV'                                  ENCD-32
         DATAD     C'NODIRECT'                                  ENCD-32
         DATAD     C'UPDATE  '                                  ENCD-32
         DATAD     C'NOUPDATE'                                  ENCD-32
         DATAD     C'NOHALFME'                                  PR10768
         DATAD     C'HALFMEG '                                  PR10768
         DATAD     C'NOTWOMEG'                                  ELST-32C
         DATAD     C'TWOMEG  '                                  ELST-32C
         DATAD     C'NOAUDIT '                                  C011-32
         DATAD     C'AUDIT   '                                  C011-32
         DATAD     C'ZERO    '                                  EUIC-32
         DATAD     C'NOZERO  '                                  EUIC-32
         DATAD     C'NOINFO  '                                  ENCD-32
         DATAD     C'INFO    '                                  ENCD-32
         DATAD     C'NOSUPRES'                                  ENCD-32
         DATAD     C'SUPRESS '                                  ENCD-32
         DATAD     C'NOSYMBOL'                                  ENCD-32
         DATAD     C'SYMBOLS '                                  ENCD-32
         DATAD     C'NOLIMIT '                                  ENCD-32
         DATAD     C'LIMIT   '                                  ENCD-32
         DATAD     C'NOTEXT  '                                  ENCD-32
         DATAD     C'TEXT    '                                  ENCD-32
CSETEND  DATAB     $-CSETOPS/8                                  ENCD-32
*                                                               ENCD-32
         BOUND     1W                                           ENCD-32
CSETBIT  ZBM       MSOP1,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP1,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP2,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP2,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP3,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP3,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP4,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP4,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP5,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP5,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP6,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP6,MFLAG2                                 ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP7,MFLAG2                                 ELST-32C
         TRSW      R0                                           ELST-32C
         SBM       MSOP7,MFLAG2                                 ELST-32C
         TRSW      R0                                           ELST-32C
         ZBM       MSOP8,MFLAG3                                 C011-32
         TRSW      R0                                           C011-32
         SBM       MSOP8,MFLAG3                                 C011-32
         TRSW      R0                                           C011-32
         ZBM       MSOP9,MFLAG3                                 EUIC-32
         TRSW      R0                                           EUIC-32
         SBM       MSOP9,MFLAG3                                 EUIC-32
         TRSW      R0                                           EUIC-32
         ZBM       MSOP15,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP15,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP18,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP18,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP19,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP19,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MSOP20,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MSOP20,MFLAG2                                ENCD-32
         TRSW      R0                                           ENCD-32
         ZBM       MOPTTXT,MFLGS                                ENCD-32
         TRSW      R0                                           ENCD-32
         SBM       MOPTTXT,MFLGS                                ENCD-32
         TRSW      R0                                           ENCD-32
*                                                               ENCD-32
         TITLE     CLIB            LIBRARY DIRECTIVE            ENCD-32
************************************************************************
*                                                               ENCD-32
*                  CLIB                                         ENCD-32
*                                                               ENCD-32
************************************************************************
*                                                               ENCD-32
*        PROCESS LIBRARY DIRECTIVES                             ENCD-32
*                                                               ENCD-32
************************************************************************
CLIB     STF       R0,CARD90                                    ENCD-32
         BL        STRING          GET LFC                      ENCD-32
         LB        R5,CCHRS        DID WE                       ENCD-32
         BZ        CARDERR2        NO, PUT OUT ERROR MESSG      ENCD-32
         CI        R5,3            3 CHARACTER LFC READ         PR11087
         BNE       CARDERR3        ERROR IF NOT                 PR11087
         LB        R5,CCDLIM       GET DELIMITER                PR11087
         CI        R5,G'='         WAS IT AN EQUAL SIGN         PR11087
         BNE       CARDERR3        ERROR IF NOT                 PR11087
         ANMW      R6,=X'FFFFFF00' NULL LAST BYTE               ENCD-32
         STW       R6,INPTLFC      SAVE INPUT LFC               ENCD-32
         TRR       R6,R7                                        ENCD-32
         SRL       R6,24           POSITION FIRST BYTE OF LFC   PR11087
         CI        R6,G'L'         LIBRARY LFC SPECIFIED        PR11087
         BNE       CARDERR3        ERROR IF NOT                 PR11087
         LA        R3,LFCLOC       LOCATION TO PUT LFC          ENCD-32
         BL        XSTB            PUT LFC IN CALL BLOCK        ENCD-32
         LB        R2,CCPTR                                     ENCD-32
         ZR        R3                                           ENCD-32
CLIB.1   LB        R7,MDBUF,R2     GET A BYTE FROM INPUT LINE   ENCD-32
         CI        R7,G' '         IS IT A SPACE                ENCD-32
         BNE       CLIB.3          STORE IT IF NOT              ENCD-32
         ADI       R2,1            BUMP POINTER                 ENCD-32
         BU        CLIB.1          READ ANOTHER                 ENCD-32
CLIB.2   LB        R7,MDBUF,R2     GET ANOTHER BYTE FROM INPUT  ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BEQ       CLIB.4          DONE IF SO                   ENCD-32
CLIB.3   STB       R7,PATHLOC,R3   STORE CHAR. IN CALL BLOCK    ENCD-32
         ADI       R2,1            BUMP POINTER                 ENCD-32
         ADI       R3,1            THIS ONE TOO                 ENCD-32
         BU        CLIB.2          CONTINUE                     ENCD-32
CLIB.4   EQU       $                                            ENCD-32
         ADI       R3,12           ADD LENGTH OF REST OF CHARS  ENCD-32
         STW       R3,SCOUNT       SAVE CHAR COUNT              ENCD-32
         ZR        R7                                           ENCD-32
         M.TSMPC   LIBPCB          CREATE RRS                   ENCD-32
         TRR       R7,R7           GET STATUS                   PR11087
         BNE       CARDERR3        ERROR IF NOT ZERO            PR11087
         ZR        R3                                           ENCD-32
CLIB.5   LW        R6,INPTLFC      GET INPUT LIBRARY LFC        PR11088
         SRL       R6,8            POSITION IT                  PR11088
         CAMW      R6,XLB.LIBC     IS IT LIB                    PR11088
         BEQ       CLIB.5C         YES...BRANCH                 PR11088
         LI        R3,100          SET INDEX TO LIS LFC ENTRY   PR11088
         CAMW      R6,XLB.LISC     IS IT LIS                    PR11088
         BEQ       CLIB.5B         YES...BRANCH                 PR11088
         LW        R7,XBLANK       GET SOME BLANKS              PR11088
         SRLD      R6,16           POSITION LFC DIGITS          PR11088
         TRR       R7,R6                                        PR11088
         LW        R7,XBLANK       BLANK R7                     PR11088
         SVC       1,X'28'         CONVERT TO BINARY            PR11088
         TRR       R6,R6           ANY CONVERSION ERRORS        PR11087
         BEQ       CARDERR3        YES IF ZERO                  PR11087
         TRR       R7,R3                                        PR11088
CLIB.5B  SLL       R3,2            CONVERT INDEX TO BYTE COUNT  PR11088
         ADI       R3,1W           ADD ONE WORD FOR LIB ENTRY   PR11088
CLIB.5C  LW        R7,LT.LIBS,X3   GET LFCTAB ENTRY             PR11088
         BZ        CLIB.7          NOT ASSIGNED IF ZERO         PR11088
         SRL       R7,24           GET LFC ENTRY TYPE           PR11088
         CI        R7,9            ASSIGNED BY CROSS LINK       PR11088
         BEQ       CARDEXIT        EXIT IF SO                   PR11088
         CI        R7,10           ASSIGNED BY DIRECTIVE        PR11088
         BEQ       CARDEXIT        NO OVERRIDE IF SO            PR11088
         LW        R7,LT.LIBS,X3   GET LFC                      PR11088
         ANMW      R7,=X'00FFFFFF' CLEAR TYPE CODE              PR11088
         STW       R7,GPFCB1       STORE IN FCB                 ENCD-32
         CAMW      R7,XLB.LISC     IS IT LIS                    PR11088
         BEQ       CLIB.5D         NO MESSAGE IF SO             PR11088
         TRR       R3,R1           SAVE R3                      PR11088
         LA        R3,MSG.7F       LFC STORAGE IN MESSAGE       PR11088
         BL        XSTB            PUT LFC IN MESSAGE           PR11088
         LNB       R5,MSG.7L       MESSAGE LENGTH               PR11088
         LA        R6,MSG.7A       MESSAGE ADDRESS              PR11088
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         TRR       R1,R3           RESTORE R3                   PR11088
CLIB.5D  LA        R1,GPFCB1                                    ENCD-32
         M.DASN                    DEASSIGN CURRENT LIBRARY     ENCD-32
CLIB.7   LA        R1,LIBRS                                     ENCD-32
         SBM       RR.UNBLK,RR.OPTS,R1  ASSIGN UNBLOCKED        PR10824
         ZR        R7                                           ENCD-32
         SVC       2,X'52'         ASSIGN                       ENCD-32
         TRR       R7,R7           IS STATUS ZERO?              EXL-32
         BEQ       CLIB.7B         CONTINUE IF SO               EXL-32
         TRR       R7,R5                                        EXL-32
         M.CONBAD                  CONVERT STATUS               EXL-32
         ANMW      R7,=X'0000FFFF'                              EXL-32
         LA        R3,MSG.1S                                    EXL-32
         BL        XSTB            PUT STATUS IN MESSAGE        EXL-32
         LW        R7,INPTLFC      GET INPUT LFC                PR11087
         LA        R3,MSG.1F       LOCATION IN MESSAGE          PR11087
         BL        XSTB            PUT LFC IN MESSAGE           PR11087
         LNB       R5,MSG.1L       GET MESSAGE LENGTH           EXL-32
         LA        R6,MSG.1A       MESSAGE ADDRESS              EXL-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         SBM       CDERR,CFLGS     SHOW PASS A ERROR            EXL-32
         BU        CARDEXIT        EXIT OUT                     EXL-32
CLIB.7B  LW        R1,INPTLFC      GET INPUT LIBRARY LFC        EXL-32
         SRL       R1,8            POSITION IT                  EXL-32
         ORMW      R1,=X'0A000000'                              EXL-32
         STW       R1,LT.LIBS,X3                                EXL-32
         ANMW      R1,=X'00FFFFFF'                              EXL-32
         LA        R6,LIBRD        RD BUFFER ADDR TO R6         EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'2C'         DO AN M.LOC ON LIBRARY FILE  EXL-32
         LW        R4,LIBRD+RD.USER   GET CROSS LINK LFC        EXL-32
         CAMW      R4,=G'DIR'         IS IT A DIRECTORY?        EXL-32
         BNE       CARDEXIT        EXIT IF NOT                  EXL-32
         LA        R6,LIBRD+164W   ADDR OF DIRECTORY PATHNAME   EXL-32
         STW       R6,LIBRLB       STORE IN RLB FOR M.LOGR      EXL-32
         LB        R6,LIBRD+RD.USER+6   LENGTH OF PATHNAME      EXL-32
         STB       R6,LIBRLB                                    EXL-32
         ZMW       LIBRLB+1W       CLEAR OTHER WORDS IN RLB     EXL-32
         ZMW       LIBRLB+2W                                    EXL-32
         ZMW       LIBRLB+3W                                    EXL-32
         ZMW       LIBRLB+4W                                    EXL-32
         ZMW       LIBRLB+6W                                    EXL-32
         ZMW       LIBRLB+7W                                    EXL-32
         LA        R2,LIBRLB       GET ADDR OF RLB FOR M.LOGR   EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'29'         DO AN M.LOGR ON DIR FILE     EXL-32
         TBM       4,LIBRLB+7W     WAS IT FOUND?                EXL-32
         BS        CLIB.7C         CONTINUE IF SO               EXL-32
         LNB       R5,MSG.3L       MESSAGE LENGTH               EXL-32
         LA        R6,MSG.3A       MESSAGE ADDRESS              EXL-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         ZR        R2              CLEAR R2                     PR11087
         LI        R6,G' '         GET A BLANK                  PR11087
CLIB.7D  CI        R2,54           BLANK OUT NAME IN MESSAGE    PR11087
         BEQ       CLIB.7E         DONE IF ZERO                 PR11087
         STB       R6,MSG.3N,X2    PUT BLANK IN MESSAGE         PR11087
         ADI       R2,1            ADJUST POINTER               PR11087
         BU        CLIB.7D         CONTINUE                     PR11087
CLIB.7E  ZR        R2              CLEAR R2                     PR11087
CLIB.7F  CAMB      R2,LIBRD+RD.USER+6  DONE WITH FILE NAME      PR11087
         BEQ       CLIB.7G         YES...BRANCH                 PR11087
         LB        R6,LIBRD+164W,X2  GET BYTE OF FILE NAME      PR11087
         STB       R6,MSG.3N,X2    SAVE IN MESSAGE              PR11087
         ADI       R2,1            ADJUST POINTER               PR11087
         BU        CLIB.7F         NEXT CHARACTER               PR11087
CLIB.7G  LNB       R5,MSG.3BL      MESSAGE LENGTH               PR11087
         LA        R6,MSG.3B       MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LB        R6,INPTLFC+2    GET LAST BYTE OF LFC         PR11087
         CI        R6,G'B'         IS IT LIB                    PR11087
         BNE       $+3W            CONTINUE IF NOT              PR11087
         LW        R7,XLB.DIRC     GET DIR LFC                  PR11087
         BU        CLIB.7H         PUT IN MESSAGE               PR11087
         CI        R6,G'S'         IS IT LIS                    PR11087
         BNE       $+3W            CONTINUE IF NOT              PR11087
         LW        R7,XLB.LIDC     GET LID LFC                  PR11087
         BU        CLIB.7H         PUT IN MESSAGE               PR11087
         LW        R7,INPTLFC      GET INPUT LFC                PR11087
         ZBR       R7,4            CONVERT TO Dnn LFC           PR11087
CLIB.7H  LA        R3,MSG.3F       LFC LOCATION IN MESSAGE      PR11087
         BL        XSTB            PUT LFC IN MESSAGE           PR11087
         LNB       R5,MSG.3CL      MESSAGE LENGTH               PR11087
         LA        R6,MSG.3C       MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         BU        CARDEXIT        EXIT OUT                     EXL-32
CLIB.7C  LW        R7,LT.DIRS,X3   IS DIRECTORY ASSIGNED?       EXL-32
         BNZ       CLIB.11         CHECK HOW IT WAS ASSIGNED    EXL-32
         LB        R7,INPTLFC+2    GET INPUT LIBRARY LFC        EXL-32
         CI        R7,G'S'         IS IT LIS?                   EXL-32
         BNE       CLIB.8          CONTINUE IF NOT              EXL-32
         LW        R7,=X'094C4944'  MAKE LID LFC TABLE ENTRY    EXL-32
         STW       R7,LT.DIRS,X3    STORE IN DIR LFC TABLE      EXL-32
         BU        CLIB.12         GO ASSIGN CROSS LINKED DIR   EXL-32
CLIB.8   CI        R7,G'B'         IS IT LIB?                   EXL-32
         BNE       CLIB.9          CONTINUE IF NOT              EXL-32
         LW        R7,=X'09444952' MAKE DIR LFC TABLE ENTRY     EXL-32
         STW       R7,LT.DIRS,X3   STORE IN DIR LFC TABLE       EXL-32
         BU        CLIB.12         GO ASSIGN CROSS LINKED DIR   EXL-32
CLIB.9   LW        R7,INPTLFC      GET INPUT LIB LFC            EXL-32
         SLL       R7,8            CLEAR FIRST BYTE             EXL-32
         SRL       R7,16           REPOSITION                   EXL-32
         ORMW      R7,=X'09440000'  MAKE A Dnn DIR LFC ENTRY    EXL-32
         STW       R7,LT.DIRS,X3    STORE IN DIR LFC TABLE      EXL-32
         BU        CLIB.12          GO ASSIGN CROSS LINKED DIR  EXL-32
CLIB.11  ZR        R6                                           EXL-32
         SLLD      R6,8            GET TYPE BYTE                EXL-32
         CI        R6,10           ASSIGNED BY DIRECTIVE?       EXL-32
         BEQ       CARDEXIT        EXIT OUT IF SO               EXL-32
         LI        R6,9            CROSS LINK TYPE              EXL-32
         SRLD      R6,8            PUT IN LFC TABLE ENTRY       EXL-32
         STW       R7,LT.DIRS,X3   PUT INTO TABLE               EXL-32
         LW        R4,=X'00FFFFFF'  CLEAR TYPE BYTE FROM LFC    EXL-32
         TRRM      R7,R7                                        EXL-32
         STW       R7,GPFCB2       PUT LFC INTO FCB             EXL-32
         LA        R1,GPFCB2                                    EXL-32
         M.DASN                    DEASSIGN CURRENT DIRECTORY   EXL-32
         LW        R7,LT.DIRS,X3   GET DIR LFC TABLE ENTRY      EXL-32
CLIB.12  LW        R1,LIBRLB       GET PNV OF DIRECTORY         EXL-32
         SBM       MLOCF,MFLAG3    SET FLAG FOR PATHNAME STRING ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!LA!!!!!!!!R6,XLNKRD!!!!!!!RD!BUFFER!ADDRESS!!!!!!!!!!!!ERMS-34
*!!!!!!!!ZR!!!!!!!!R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!SVC!!!!!!!2,X'2C'!!!!!!!!!M.LOC!ON!DIRECTORY!FILE!!!!!!ERMS-34
         M.LOC     LIBRLB,XLNKRD,CHKCNP   M.LOC ON DIRECTORY    ERMS-34
         LW        R4,XLNKRD+RD.USER   GET CROSS LINK LFC       EXL-32
         CAMW      R4,=G'LIB'      DIRECTORY LINKED TO LIB?     EXL-32
         BNE       CLIB.15         ERROR IF NOT                 EXL-32
         LW        R1,INPTLFC      GET INPUT LIBRARY LFC        EXL-32
         SRL       R1,8            POSITION                     EXL-32
         LW        R4,XLPNV        PATHNAME BUFFER VECTOR       EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'2F'         M.PNAM ON LIBRARY FILE       EXL-32
         TRR       R4,R2                                        EXL-32
         SRL       R4,24           POSITION FILE NAME LENGTH    EXL-32
         CAMB      R4,XLNKRD+RD.USER+6   LENGTHS EQUAL          EXL-32
         BNE       CLIB.15         ERROR IF NOT                 EXL-32
         ANMW      R2,=X'00FFFFFF'   MASK PATHNAME ADDRESS      EXL-32
         ZR        R1                                           EXL-32
CLIB.12A CI        R4,0            DONE COMPARING PATHNAMES     EXL-32
         BEQ       CLIB.12B        YES...BRANCH                 EXL-32
         LB        R6,0,X2         GET BYTE OF INPUT FILE NAME  EXL-32
         CAMB      R6,XLNKRD+164W,X1  COMPARE TO X LINK NAME    EXL-32
         BNE       CLIB.15         ERROR IF NOT EQUAL           EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         ADI       R2,1                                         EXL-32
         SUI       R4,1                                         EXL-32
         BU        CLIB.12A        NEXT BYTE                    EXL-32
CLIB.12B LW        R7,LT.DIRS,X3   GET DIRECTORY ENTRY          EXL-32
         ANMW      R7,=X'00FFFFFF'                              EXL-32
         LA        R3,LFCLOC       SAVE DIR LFC IN CALL BLOCK   EXL-32
         BL        XSTB                                         EXL-32
         ZR        R2                                           EXL-32
         LB        R6,LIBRD+RD.USER+6  LENGTH OF DIR PATHNAME   EXL-32
         LA        R3,LIBRD+164W       ADDR OF DIR PATHNAME     EXL-32
CLIB.13  CI        R6,0            ANY MORE CHARS IN PATHNAME   EXL-32
         BEQ       CLIB.14         NO...BRANCH                  EXL-32
         LB        R7,0,X3         GET CHARACTER                EXL-32
         STB       R7,PATHLOC,X2   PUT IN CALL BLOCK            EXL-32
         SUI       R6,1            ADJUST POINTERS              EXL-32
         ADI       R3,1                                         EXL-32
         ADI       R2,1                                         EXL-32
         BU        CLIB.13         CONTINUE                     EXL-32
CLIB.14  ADI       R2,12           ADD LENGTH OF REST OF CHARS  EXL-32
         STW       R2,SCOUNT       SAVE CHAR CNT IN CALL BLOCK  EXL-32
         ZR        R7                                           EXL-32
         M.TSMPC   LIBPCB          GET RRS                      EXL-32
         LA        R1,LIBRS                                     EXL-32
         SBM       RR.UNBLK,RR.OPTS,R1   ASSIGN UNBLOCKED       EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'52'         ASSIGN CROSS LINKED DIR      EXL-32
         TRR       R7,R7           CHECK STATUS                 EXL-32
         BEQ       CARDEXIT        EXIT IF OK                   EXL-32
         TRR       R7,R5                                        EXL-32
         M.CONBAD                  CONVERT STATUS               EXL-32
         ANMW      R7,=X'0000FFFF'                              EXL-32
         LA        R3,MSG.5S                                    EXL-32
         BL        XSTB            PUT STATUS IN MESSAGE        EXL-32
         LW        R7,LIBRS        GET CROSS LINK DIR LFC       PR11087
         LA        R3,MSG.5F       LFC LOCATION IN MESSAGE      PR11087
         BL        XSTB            PUT LFC IN MESSAGE           PR11087
         LNB       R5,MSG.5L       MESSAGE LENGTH               EXL-32
         LA        R6,MSG.5A       MESSAGE ADDRESS              EXL-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,MSG.5BL      SECOND HALF                  PR11087
         LA        R6,MSG.5B                                    PR11087
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         SBM       CDERR,CFLGS     SHOW PASS A ERROR            EXL-32
         BU        CARDEXIT                                     ENCD-32
CLIB.15  ZMW       LT.DIRS,X3      CLEAR DIRECTORY ENTRY        EXL-32
         LW        R7,INPTLFC      GET INPUT LIBRARY LFC        EXL-32
         LA        R3,MSG.8F       LFC LOCATION IN MESSAGE      EXL-32
         BL        XSTB            PUT LFC IN MESSAGE           EXL-32
         LI        R5,G' '         GET A BLANK                  EXL-32
         ZR        R1                                           EXL-32
CLIB.16  CI        R1,54           DONE BLANKING MESSAGES       EXL-32
         BEQ       CLIB.17         YES...BRANCH                 EXL-32
         STB       R5,MSG.8LN,X1   BLANK OUT MESSAGES           EXL-32
         STB       R5,MSG.8DN,X1                                EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         BU        CLIB.16                                      EXL-32
CLIB.17  LB        R4,XLPNV        GET LIBRARY FILENAME LENGTH  EXL-32
         LW        R2,XLPNV        FILENAME ADDRESS             EXL-32
         ANMW      R2,=X'00FFFFFF'                              EXL-32
         ZR        R1                                           EXL-32
CLIB.18  CI        R4,0            DONE MOVING NAME             EXL-32
         BEQ       CLIB.19         YES...CONTINUE               EXL-32
         LB        R5,0,X2         GET BYTE OF FILE NAME        EXL-32
         STB       R5,MSG.8LN,X1   SAVE IN MESSAGE              EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         ADI       R2,1                                         EXL-32
         SUI       R4,1                                         EXL-32
         BU        CLIB.18         NEXT BYTE                    EXL-32
CLIB.19  LB        R4,XLNKRD+RD.USER+6   LENGTH OF X LINK NAME  EXL-32
         ZR        R1                                           EXL-32
CLIB.20  CI        R4,0            DONE MOVING NAME             EXL-32
         BEQ       CLIB.21         YES...BRANCH                 EXL-32
         LB        R5,XLNKRD+164W,X1  GET BYTE OF FILE NAME     EXL-32
         STB       R5,MSG.8DN,X1   SAVE IN MESSAGE              EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         SUI       R4,1                                         EXL-32
         BU        CLIB.20         NEXT BYTE                    EXL-32
CLIB.21  LNB       R5,MSG.8L       PUT OUT ERROR MESSAGE        EXL-32
         LA        R6,MSG.8A                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8CL                                   EXL-32
         LA        R6,MSG.8C                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8DL                                   EXL-32
         LA        R6,MSG.8D                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8EL                                   EXL-32
         LA        R6,MSG.8E                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8GL                                   EXL-32
         LA        R6,MSG.8G                                    EXL-32
         BL        XTYPE                                        C013-32
         BU        CARDEXIT                                     EXL-32
LIBPCB   ACW       CALLBUF         CALL BLOCK FOR TSM PROCEDURE ENCD-32
SCOUNT   DATAW     0               CALL.  CALL BLOCK SIZE       ENCD-32
         ACW       LIBRS                                        ENCD-32
PCBEND   DATAH     0,88                                         ENCD-32
CALLBUF  DATAB     C'$RRS '                                     ENCD-32
LFCLOC   DATAB     C'    '                                      ENCD-32
         DATAB     C'TO '                                       ENCD-32
PATHLOC  REZ       51B             PATHNAME                     ENCD-32
         BOUND     1D                                           ENCD-32
LIBRS    REZ       22W             RRS UPON RETURN              ENCD-32
INPTLFC  DATAW     0                                            ENCD-32
         BOUND     1D
LIBRD    REZ       96D                                          EXL-32
XLNKRD   REZ       96D                                          EXL-32
LIBRLB   REZ       5W                                           EXL-32
         GEN       8/1,24/A(RLBUFF)                             EXL-32
         REZ       2W                                           EXL-32
RLBUFF   REZ       1W                                           EXL-32
XLPNV    GEN       8/54,24/A(XLBUF)                             EXL-32
XLBUF    REZ       54B                                          EXL-32
*                                                               ENCD-32
MSG.1A   DATA      C' CATALOG(WARNING) ASSIGNMENT OF OBJECT '   EXL-32
         DATAB     C'LIBRARY TO LFC = '                         EXL-32
MSG.1F   REZ       3B                                           EXL-32
         DATAB     C' FAILED. STATUS = RM'                      PR11087
MSG.1S   REZ       2B                                           PR11087
MSG.1L   DATAB     $-MSG.1A                                     EXL-32
*
MSG.2A   DATA      C' CATALOG(WARNING) ASSIGNMENT OF OBJECT '   EXL-32
         DATAB     C'DIRECTORY TO LFC = '                       EXL-32
MSG.2F   REZ       3B                                           EXL-32
         DATAB     C' FAILED.'
MSG.2L   DATAB     $-MSG.2A                                     EXL-32
*
MSG.2B   DATAB     C'                  STATUS = RM'             PR11087
MSG.2S   REZ       2B                                           PR11087
MSG.2BL  DATAB     $-MSG.2B                                     PR11087
*
MSG.3A   DATA      C' CATALOG(WARNING) CANNOT LOCATE CROSS '    EXL-32
         DATA      C' LINKED DIRECTORY '                        EXL-32
MSG.3L   DATAB     $-MSG.3A                                     EXL-32
*
MSG.3B   DATAB     C'                  '                        PR11087
MSG.3N   REZ       54B                                          PR11087
MSG.3BL  DATAB     $-MSG.3B                                     PR11087
*
MSG.3C   DATAB     C'                  FOR ASSIGNMENT TO LFC = ' PR11087
MSG.3F   REZ       3B                                           PR11087
MSG.3CL  DATAB     $-MSG.3C                                     PR11087
*
MSG.4A   DATA      C' CATALOG(WARNING) CANNOT LOCATE CROSS '    EXL-32
         DATA      C' LINKED LIBRARY '                          EXL-32
MSG.4L   DATAB     $-MSG.4A                                     EXL-32
*
MSG.4B   DATAB     C'                  '                        PR11087
MSG.4N   REZ       54B                                          PR11087
MSG.4BL  DATAB     $-MSG.4B                                     PR11087
*
MSG.4C   DATAB     C'                  FOR ASSIGNMENT TO LFC = ' PR11087
MSG.4F   REZ       3B                                           PR11087
MSG.4CL  DATAB     $-MSG.4C                                     PR11087
*
MSG.5A   DATA      C' CATALOG(WARNING) ASSIGNMENT OF CROSS '    EXL-32
         DATA      C' LINKED DIRECTORY TO LFC = '               EXL-32
MSG.5F   REZ       3B                                           EXL-32
         DATAB     C' FAILED.'                                  PR11087
MSG.5L   DATAB     $-MSG.5A                                     EXL-32
*
MSG.5B   DATAB     C'                  STATUS = RM'             PR11087
MSG.5S   REZ       2B                                           PR11087
MSG.5BL  DATAB     $-MSG.5B                                     PR11087
*
MSG.6A   DATA      C' CATALOG(WARNING) ASSIGNMENT OF CROSS '    EXL-32
         DATA      C' LINKED LIBRARY TO LFC = '                 EXL-32
MSG.6F   REZ       3B                                           EXL-32
         DATAB     C' FAILED.'                                  PR11087
MSG.6L   DATAB     $-MSG.6A                                     EXL-32
*
MSG.6B   DATAB     C'                  STATUS = RM'             PR11087
MSG.6S   REZ       2B                                           PR11087
MSG.6BL  DATAB     $-MSG.6B                                     PR11087
*
MSG.7A   DATAB     C' CATALOG(WARNING) STATIC ASSIGNMENT TO '   PR11088
         DATAB     C'LFC = '                                    PR11088
MSG.7F   REZ       3B                                           PR11088
         DATAB     C' HAS BEEN OVERRIDDEN.'                     PR11088
MSG.7L   DATAB     $-MSG.7A                                     PR11088
*
MSG.8A   DATAB     C' CATALOG(WARNING) CROSS LINK INFORMATION ' EXL-32
         DATAB     C'IN FILE ASSIGNED TO '                      EXL-32
MSG.8F   REZ       3B                                           EXL-32
         DATAB     C' INVALID.'                                 EXL-32
MSG.8L   DATAB     $-MSG.8A                                     EXL-32
*
MSG.8C   DATAB     C'                  LIBRARY ASSIGNED TO :'   EXL-32
MSG.8CL  DATAB     $-MSG.8C                                     EXL-32
*
MSG.8D   DATAB     C'                  '                        EXL-32
MSG.8LN  REZ       54B                                          EXL-32
MSG.8DL  DATAB     $-MSG.8D                                     EXL-32
*
MSG.8E   DATAB     C'                  DIRECTORY LINKED TO :'   EXL-32
MSG.8EL  DATAB     $-MSG.8E                                     EXL-32
*
MSG.8G   DATAB     C'                  '                        EXL-32
MSG.8DN  REZ       54B                                          EXL-32
MSG.8GL  DATAB     $-MSG.8G                                     EXL-32
*
MSG.8H   DATAB     C'                  DIRECTORY ASSIGNED TO :' EXL-32
MSG.8HL  DATAB     $-MSG.8H                                     EXL-32
*
MSG.8I   DATAB     C'                  LIBRARY LINKED TO :'     EXL-32
MSG.8IL  DATAB     $-MSG.8I                                     EXL-32
         TITLE     CDIR            DIRECTORY DIRECTIVE          ENCD-32
************************************************************************
*                                                               ENCD-32
*                  CDIR                                         ENCD-32
*                                                               ENCD-32
************************************************************************
*                                                               ENCD-32
*        PROCESS DIRECTORY DIRECTIVES                           ENCD-32
*                                                               ENCD-32
************************************************************************
CDIR     STF       R0,CARD90                                    ENCD-32
         BL        STRING          GET LFC                      ENCD-32
         LB        R5,CCHRS        DID WE                       ENCD-32
         BZ        CARDERR2        NO, PUT OUT ERROR MESSG      ENCD-32
         CI        R5,3            3 CHARACTER LFC READ         PR11087
         BNE       CARDERR3        ERROR IF NOT                 PR11087
         LB        R5,CCDLIM       GET DELIMITER                PR11087
         CI        R5,G'='         WAS IT AN EQUAL SIGN         PR11087
         BNE       CARDERR3        ERROR IF NOT                 PR11087
         ANMW      R6,=X'FFFFFF00' NULL LAST BYTE               ENCD-32
         STW       R6,INPTLFC      SAVE INPUT LFC               ENCD-32
         TRR       R6,R7                                        ENCD-32
         LA        R3,LFCLOC       ADDRESS TO PUT LFC           ENCD-32
         BL        XSTB            PUT IT THERE                 ENCD-32
         LB        R2,CCPTR                                     ENCD-32
         ZR        R3                                           ENCD-32
CDIR.1   LB        R7,MDBUF,R2     READ BYTE FROM INPUT LINE    ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BNE       CDIR.3          STORE CHAR                   ENCD-32
         ADI       R2,1            BUMP POINTER                 ENCD-32
         BU        CDIR.1          GET ANOTHER                  ENCD-32
CDIR.2   LB        R7,MDBUF,R2     READ FROM INPUT              ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BEQ       CDIR.4          DONE IF SO                   ENCD-32
CDIR.3   STB       R7,PATHLOC,R3   STORE CHARACTER              ENCD-32
         ADI       R2,1            BUMP POINTERS                ENCD-32
         ADI       R3,1                                         ENCD-32
         BU        CDIR.2          CONTINUE                     ENCD-32
CDIR.4   EQU       $                                            ENCD-32
         ADI       R3,12           ADD LENGTH OF REST OF CHARS  ENCD-32
         STW       R3,SCOUNT       SAVE SIZE                    ENCD-32
         ZR        R7                                           ENCD-32
         M.TSMPC   LIBPCB          GET RRS                      ENCD-32
         TRR       R7,R7           GET STATUS                   PR11087
         BNE       CARDERR3        ERROR IF NOT ZERO            PR11087
         ZR        R3                                           ENCD-32
CDIR.5   LW        R6,INPTLFC      GET INPUT DIR LFC            PR11088
         SRL       R6,8            POSITION IT                  PR11088
         CAMW      R6,XLB.DIRC     IS IT DIR                    PR11088
         BEQ       CDIR.5C         PUT IN MESSAGE IF SO         PR11088
         LI        R3,100          LID ENTRY INDEX              PR11088
         CAMW      R6,XLB.LIDC     IS IT LID                    PR11088
         BEQ       CDIR.5B         PUT IN MESSAGE IF SO         PR11088
         LW        R7,XBLANK       GET SOME BLANKS              PR11088
         SRLD      R6,16           SHIFT IN DIRECTORY NUMBER    PR11088
         TRR       R7,R6                                        PR11088
         LW        R7,XBLANK       BLANK OUT R7                 PR11088
         SVC       1,X'28'         CONVERT TO ASCII             PR11088
         TRR       R6,R6           ANY CONVERSION ERRORS        PR11087
         BEQ       CARDERR3        YES...BRANCH                 PR11087
         TRR       R7,R3                                        PR11088
CDIR.5B  SLL       R3,2            CONVERT INDEX TO BYTE COUNT  PR11088
         ADI       R3,1W           ADJUST FOR DIR ENTRY         PR11088
CDIR.5C  LW        R7,LT.DIRS,X3   GET LFC TABLE ENTRY          PR11088
         BZ        CDIR.7          NOT ASSIGNED IF ZERO         PR11088
         SRL       R7,24           GET ENTRY TYPE BYTE          PR11088
         CI        R7,9            ASSIGNED BY CROSS LINK       PR11088
         BEQ       CARDEXIT        NO OVERRIDE IF SO            PR11088
         CI        R7,10           ASSIGNED BY DIRECTIVE        PR11088
         BEQ       CARDEXIT        NO OVERRIDE IF SO            PR11088
         LW        R7,LT.DIRS,X3   GET INPUT DIR LFC            PR11088
         ANMW      R7,=X'00FFFFFF' MASK OFF TYPE BYTE           PR11088
         STW       R7,GPFCB2       SAVE IN FCB                  PR11088
         CAMW      R7,XLB.LIDC     IS IT LID                    PR11088
         BEQ       CDIR.5D         NO MESSAGE IF SO             PR11088
         TRR       R3,R1           SAVE R3                      PR11088
         LA        R3,MSG.7F       LFC LOCATION IN MESSAGE      PR11088
         BL        XSTB            PUT LFC IN MESSAGE           PR11088
         LNB       R5,MSG.7L       MESSAGE LENGTH               PR11088
         LA        R6,MSG.7A       MESSAGE ADDRESS              PR11088
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         TRR       R1,R3           RESTORE R3                   PR11088
CDIR.5D  LA        R1,GPFCB2       ADDR OF DIR FCB              PR11088
         M.DASN                    DEASSIGN DIRECTORY           PR11088
CDIR.7   LA        R1,LIBRS                                     ENCD-32
         SBM       RR.UNBLK,RR.OPTS,R1   ASSIGN UNBLOCKED       PR10824
         ZR        R7                                           ENCD-32
         SVC       2,X'52'         ASSIGN                       ENCD-32
         TRR       R7,R7           IS STATUS ZERO               EXL-32
         BEQ       CDIR.7B         CONTINUE IF SO               EXL-32
         TRR       R7,R5                                        EXL-32
         M.CONBAD                  CONVERT STATUS               EXL-32
         ANMW      R7,=X'0000FFFF'                              EXL-32
         LA        R3,MSG.2S                                    EXL-32
         BL        XSTB            PUT STATUS IN MESSAGE        EXL-32
         LW        R7,INPTLFC      GET INPUT LFC                PR11087
         LA        R3,MSG.2F       LFC LOCATION IN MESSAGE      PR11087
         BL        XSTB            PUT LFC IN MESSAGE           PR11087
         LNB       R5,MSG.2L       MESSAGE LENGTH               EXL-32
         LA        R6,MSG.2A       MESSAGE ADDRESS              EXL-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,MSG.2BL      MESSAGE LENGTH               PR11087
         LA        R6,MSG.2B       MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         SBM       CDERR,CFLGS     SHOW PASS A ERROR            EXL-32
         BU        CARDEXIT        EXIT OUT                     EXL-32
CDIR.7B  LW        R1,INPTLFC      GET INPUT DIR LFC            EXL-32
         SRL       R1,8            POSITION IT                  EXL-32
         ORMW      R1,=X'0A000000'  SHOW ASSIGNED BY DIRECTIVE  EXL-32
         STW       R1,LT.DIRS,X3   SAVE IN LFC TABLE            EXL-32
         ANMW      R1,=X'00FFFFFF'                              EXL-32
         LA        R6,LIBRD        GET RD BUFFER ADDRESS        EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'2C'         DO AN M.LOC ON DIR FILE      EXL-32
         LW        R4,LIBRD+RD.USER  GET CROSS LINKED LFC       EXL-32
         CAMW      R4,=G'LIB'      IS IT A LIBRARY?             EXL-32
         BNE       CARDEXIT        EXIT IF NOT                  EXL-32
         LA        R6,LIBRD+164W   GET ADDR OF LIB PATHNAME     EXL-32
         STW       R6,LIBRLB       SAVE IN RLB FOR M.LOGR       EXL-32
         LB        R6,LIBRD+RD.USER+6  GET PATHNAME LENGTH      EXL-32
         STB       R6,LIBRLB       SAVE IN RLB                  EXL-32
         ZMW       LIBRLB+1W       CLEAR OTHER WORDS IN RLB     EXL-32
         ZMW       LIBRLB+2W                                    EXL-32
         ZMW       LIBRLB+3W                                    EXL-32
         ZMW       LIBRLB+4W                                    EXL-32
         ZMW       LIBRLB+6W                                    EXL-32
         ZMW       LIBRLB+7W                                    EXL-32
         LA        R2,LIBRLB       ADDRESS OF RLB               EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'29'         DO AN M.LOGR ON LIB FILE     EXL-32
         TBM       4,LIBRLB+7W     WAS LIB FILE FOUND           EXL-32
         BS        CDIR.7C         CONTINUE IF SO               EXL-32
         LNB       R5,MSG.4L       MESSAGE LENGTH               EXL-32
         LA        R6,MSG.4A       MESSAGE ADDRESS              EXL-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         ZR        R2              CLEAR R2                     PR11087
         LI        R6,G' '         GET A BLANK                  PR11087
CDIR.7D  CI        R2,54           BLANK OUT NAME IN MESSAGE    PR11087
         BEQ       CDIR.7E         DONE BLANKING                PR11087
         STB       R6,MSG.4N,X2    PUT BLANK IN MESSAGE         PR11087
         ADI       R2,1            ADJUST POINTER               PR11087
         BU        CDIR.7D         CONTINUE                     PR11087
CDIR.7E  ZR        R2              CLEAR R2                     PR11087
CDIR.7F  CAMB      R2,LIBRD+RD.USER+6   DONE WITH FILE NAME     PR11087
         BEQ       CDIR.7G         YES...BRANCH                 PR11087
         LB        R6,LIBRD+164W,X2   GET BYTE OF FILE NAME     PR11087
         STB       R6,MSG.4N,X2    PUT IN MESSAGE               PR11087
         ADI       R2,1            ADJUST POINTER               PR11087
         BU        CDIR.7F         NEXT BYTE                    PR11087
CDIR.7G  LNB       R5,MSG.4BL      MESSAGE LENGTH               PR11087
         LA        R6,MSG.4B       MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LB        R6,INPTLFC+2    GET LAST BYTE OF INPUT LFC   PR11087
         CI        R6,G'R'         IS IT DIR                    PR11087
         BNE       $+3W            CONTINUE IF NOT              PR11087
         LW        R7,XLB.LIBC     GET LIB LFC                  PR11087
         BU        CDIR.7H         PUT IN MESSAGE               PR11087
         CI        R6,G'D'         IS IT LID                    PR11087
         BNE       $+3W            Dnn IF NOT                   PR11087
         LW        R7,XLB.LISC     GET LIS LFC                  PR11087
         BU        CDIR.7H         PUT IN MESSAGE               PR11087
         LW        R7,INPTLFC      GET INPUT DIR LFC            PR11087
         SBR       R7,4            CONVERT TO Lnn LFC           PR11087
CDIR.7H  LA        R3,MSG.4F       LFC LOCATION IN MESSAGE      PR11087
         BL        XSTB            PUT LFC IN MESSAGE           PR11087
         LNB       R5,MSG.4CL      MESSAGE LENGTH               PR11087
         LA        R6,MSG.4C       MESSAGE ADDRESS              PR11087
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         BU        CARDEXIT        EXIT OUT                     EXL-32
CDIR.7C  LW        R7,LT.LIBS,X3   GET LIB LFC TABLE ENTRY      EXL-32
         BNZ       CDIR.11         DEASSIGN CURRENT LIBRARY     EXL-32
         LB        R7,INPTLFC+2    GET LAST BYTE OF DIR LFC     EXL-32
         CI        R7,G'D'         IS IT LID?                   EXL-32
         BNE       CDIR.8          CONTINUE IF NOT              EXL-32
         LW        R7,=X'094C4953' MAKE LIS LFC TABLE ENTRY     EXL-32
         STW       R7,LT.LIBS,X3   SAVE IN LIB LFC TABLE        EXL-32
         BU        CDIR.12         GO ASSIGN CROSS LINKED LIB   EXL-32
CDIR.8   CI        R7,G'R'         IS IT DIR?                   EXL-32
         BNE       CDIR.9          CONTINUE IF NOT              EXL-32
         LW        R7,=X'094C4942' MAKE LIB LFC TABLE ENTRY     EXL-32
         STW       R7,LT.LIBS,X3   SAVE IN LIB LFC TABLE        EXL-32
         BU        CDIR.12         GO ASSIGN CROSS LINKED LIB   EXL-32
CDIR.9   LW        R7,INPTLFC      GET INPUT DIR LFC            EXL-32
         SLL       R7,8            CLEAR FIRST BYTE             EXL-32
         SRL       R7,16           REPOSITION                   EXL-32
         ORMW      R7,=X'094C0000' MAKE Lnn LFC TABLE ENTRY     EXL-32
         STW       R7,LT.LIBS,X3   SAVE IN LIB LFC TABLE        EXL-32
         BU        CDIR.12         GO ASSIGN CROSS LINKED LIB   EXL-32
CDIR.11  ZR        R6                                           EXL-32
         SLLD      R6,8            GET TYPE BYTE                EXL-32
         CI        R6,10           ASSIGNED FROM LIB DIRECTIVE  EXL-32
         BEQ       CARDEXIT        EXIT OUT IF SO               EXL-32
         LI        R6,9            CROSS LINK TYPE              EXL-32
         SRLD      R6,8            PUT IN LFC TABLE ENTRY       EXL-32
         STW       R7,LT.LIBS,X3   PUT IN TABLE                 EXL-32
         LW        R4,=X'00FFFFFF' CLEAR FIRST BYTE OF LFC      EXL-32
         TRRM      R7,R7                                        EXL-32
         STW       R7,GPFCB1       SAVE IN FCB                  EXL-32
         LA        R1,GPFCB1                                    EXL-32
         M.DASN                    DEASSIGN CURRENT LIBRARY     EXL-32
         LW        R7,LT.LIBS,X3   GET LIB LFC AGAIN            EXL-32
CDIR.12  LW        R1,LIBRLB       GET PNV FOR LIBRARY          EXL-32
         SBM       MLOCF,MFLAG3    SET FLAG FOR PATHNAME STRING ERMS-34
         BL        CHK4SYS         CHECK FOR @@SYSTEM(SYSTEM)    ERMS-34
*!!!!!!!!LA!!!!!!!!R6,XLNKRD!!!!!!!RD!BUFFER!ADDRESS!!!!!!!!!!!!ERMS-34
*!!!!!!!!ZR!!!!!!!!R7!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ERMS-34
*!!!!!!!!SVC!!!!!!!2,X'2C'!!!!!!!!!M.LOC!ON!LIBRARY!FILE!!!!!!!!ERMS-34
         M.LOC     LIBRLB,XLNKRD,CHKCNP  M.LOC ON LIBRARY       ERMS-34
         LW        R4,XLNKRD+RD.USER  GET X LINK LFC            EXL-32
         CAMW      R4,=G'DIR'      IS IT LINKED TO DIR          EXL-32
         BNE       CDIR.15         ERROR IF NOT                 EXL-32
         LW        R1,INPTLFC      GET INPUT DIRECTORY LFC      EXL-32
         SRL       R1,8            POSITION                     EXL-32
         LW        R4,XLPNV        NAME BUFFER VECTOR           EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'2F'         M.PNAM ON DIRECTORY FILE     EXL-32
         TRR       R4,R2                                        EXL-32
         SRL       R4,24           GET DIR FILE NAME LENGTH     EXL-32
         CAMB      R4,XLNKRD+RD.USER+6  COMPARE TO X LINK NAME  EXL-32
         BNE       CDIR.15         ERROR IF NOT EQUAL           EXL-32
         ANMW      R2,=X'00FFFFFF'                              EXL-32
         ZR        R1                                           EXL-32
CDIR.12A CI        R4,0            DONE COMPARING NAMES         EXL-32
         BEQ       CDIR.12B        YES...BRANCH                 EXL-32
         LB        R6,0,X2         GET BYTE OF DIRECTORY NAME   EXL-32
         CAMB      R6,XLNKRD+164W,X1  COMPARE TO X LINK NAME    EXL-32
         BNE       CDIR.15         ERROR IF NOT EQUAL           EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         ADI       R2,1                                         EXL-32
         SUI       R4,1                                         EXL-32
         BU        CDIR.12A        NEXT BYTE                    EXL-32
CDIR.12B LW        R7,LT.LIBS,X3   GET LIBRARY ENTRY            C015-32
         ANMW      R7,=X'00FFFFFF'   CLEAR OFF TYPE BYTE        EXL-32
         LA        R3,LFCLOC       PUT LFC IN CALL BLOCK        EXL-32
         BL        XSTB                                         EXL-32
         ZR        R2                                           EXL-32
         LB        R6,LIBRD+RD.USER+6  LENGTH OF PATHNAME       EXL-32
         LA        R3,LIBRD+164W   ADDRESS OF LIB PATHNAME      EXL-32
CDIR.13  CI        R6,0            ANY MORE CHARACTERS          EXL-32
         BEQ       CDIR.14         NO...BRANCH                  EXL-32
         LB        R7,0,X3         GET CHAR FROM RD BUFFER      EXL-32
         STB       R7,PATHLOC,X2   SAVE IN CALL BLOCK           EXL-32
         SUI       R6,1            ADJUST POINTERS              EXL-32
         ADI       R3,1                                         EXL-32
         ADI       R2,1                                         EXL-32
         BU        CDIR.13         CONTINUE                     EXL-32
CDIR.14  ADI       R2,12           ADD LENGTH OF REST OF CHARS  EXL-32
         STW       R2,SCOUNT       SAVE CHAR CNT IN CALL BLOCK  EXL-32
         ZR        R7                                           EXL-32
         M.TSMPC   LIBPCB          GET RRS                      EXL-32
         LA        R1,LIBRS        ADDRESS OF LIBRARY RRS       EXL-32
         SBM       RR.UNBLK,RR.OPTS,X1  ASSIGN UNBLOCKED        EXL-32
         ZR        R7                                           EXL-32
         SVC       2,X'52'         ASSIGN CROSS LINKED LIBRARY  EXL-32
         TRR       R7,R7           CHECK STATUS                 EXL-32
         BEQ       CARDEXIT        EXIT IF OK                   EXL-32
         TRR       R7,R5                                        EXL-32
         M.CONBAD                  CONVERT STATUS               EXL-32
         ANMW      R7,=X'0000FFFF'                              EXL-32
         LA        R3,MSG.6S                                    EXL-32
         BL        XSTB            SAVE STATUS IN MESSAGE       EXL-32
         LW        R7,LIBRS        GET CROSS LINK LFC           PR11087
         LA        R3,MSG.6F       LFC LOCATION IN MESSAGE      PR11087
         BL        XSTB            PUT LFC IN MESSAGE           PR11087
         LNB       R5,MSG.6L       MESSAGE LENGTH               EXL-32
         LA        R6,MSG.6A       MESSAGE ADDRESS              EXL-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,MSG.6BL      SECOND HALF                  PR11087
         LA        R6,MSG.6B                                    PR11087
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         SBM       CDERR,CFLGS     SHOW PASS A ERROR            EXL-32
         BU        CARDEXIT                                     ENCD-32
CDIR.15  ZMW       LT.LIBS,X3      CLEAR LIBRARY ENTRY          EXL-32
         LW        R7,INPTLFC      GET INPUT DIRECTORY LFC      EXL-32
         LA        R3,MSG.8F       LFC LOCATION IN MESSAGE      EXL-32
         BL        XSTB            PUT LFC IN MESSAGE           EXL-32
         LI        R5,G' '         GET A BLANK                  EXL-32
         ZR        R1                                           EXL-32
CDIR.16  CI        R1,54           DONE BLANKING MESSAGES       EXL-32
         BEQ       CDIR.17         YES...BRANCH                 EXL-32
         STB       R5,MSG.8LN,X1   BLANK NAMES IN MESSAGES      EXL-32
         STB       R5,MSG.8DN,X1                                EXL-32
         ADI       R1,1            ADJUST POINTER               EXL-32
         BU        CDIR.16         NEXT BYTE                    EXL-32
CDIR.17  LB        R4,XLPNV        GET DIRECTORY NAME LENGTH    EXL-32
         LW        R2,XLPNV        NAME ADDRESS                 EXL-32
         ANMW      R2,=X'00FFFFFF'                              EXL-32
         ZR        R1                                           EXL-32
CDIR.18  CI        R4,0            DONE MOVING NAME             EXL-32
         BEQ       CDIR.19         YES...CONTINUE               EXL-32
         LB        R5,0,X2         GET BYTE OF DIR NAME         EXL-32
         STB       R5,MSG.8LN,X1   PUT IN MESSAGE               EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         ADI       R2,1                                         EXL-32
         SUI       R4,1                                         EXL-32
         BU        CDIR.18         NEXT BYTE                    EXL-32
CDIR.19  LB        R4,XLNKRD+RD.USER+6  LENGTH OF X LINK NAME   EXL-32
         ZR        R1                                           EXL-32
CDIR.20  CI        R4,0            DONE MOVING NAME             EXL-32
         BEQ       CDIR.21         YES...PUT OUT MESSAGE        EXL-32
         LB        R5,XLNKRD+164W,X1  GET BYTE OF X LINK NAME   EXL-32
         STB       R5,MSG.8DN,X1   SAVE IN MESSAGE              EXL-32
         ADI       R1,1            ADJUST POINTERS              EXL-32
         SUI       R4,1                                         EXL-32
         BU        CDIR.20         NEXT BYTE                    EXL-32
CDIR.21  LNB       R5,MSG.8L       PUT OUT MESSAGE              EXL-32
         LA        R6,MSG.8A                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8HL                                   EXL-32
         LA        R6,MSG.8H                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8DL                                   EXL-32
         LA        R6,MSG.8D                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8IL                                   EXL-32
         LA        R6,MSG.8I                                    EXL-32
         BL        XTYPE                                        C013-32
         LNB       R5,MSG.8GL                                   EXL-32
         LA        R6,MSG.8G                                    EXL-32
         BL        XTYPE                                        C013-32
         BU        CARDEXIT                                     EXL-32
*                                                               ENCD-32
         TITLE     CBUF     - BUFFER DIRECTIVE
***********************************************************************
*
*                  CBUF
*
***********************************************************************
*
*        PROCESS BUFFERS DIRECTIVE CARD
*
***********************************************************************
CBUF     STF       R0,CARD90
         BL        STRING         NUMBER OF BYTES
         LB        R5,CCHRS
         BZ        CARDERR2        BRANCH IF NO BUFFERS SPECIFIED
         CI        R5,5
         BGT       CARDERR3        BRANCH IF > 5 CHARS
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6
         BEQ       CARDERR3        BRANCH IF NON-NUMERIC CHAR
*!!!!!!!!TBM!!!!!!!MOPT19,MFLGS!!!!IS!OPTION!19!SET!!!!!!!!!!!!!ENCD-32
*!!!!!!!!BNS!!!!!!!CBUF6!!!!!!!!!!!BR!IF!DEBUG!OPTION!NOT!SET!!!ENCD-32
*!!!!!!!!ARMB!!!!!!R7,MBUFR!!!!!!!!ADD!USER'S!BUFFER!REQ.!TO!!!!ENCD-32
         SBM       MBUFD,MFLAG2    SHOW BUFFER DIR. PROCESSED   ENCD-32
         ARMB      R7,MTMPBUF      ADD USER'S REQ. TO TEMP VAL  ENCD-32
         BU        CARDEXIT
*!CBUF6!!STB!!!!!!!R7,MBUFR!!!!!!!!SAVE!NUMBER!OF!BUFFERS!!!!!!!ENCD-32
*!!!!!!!!BU!!!!!!!!CARDEXIT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
         TITLE     CABS     - ABSOLUTE DIRECTIVE
***********************************************************************
*
*                  CABS
*
***********************************************************************
*
*        PROCESS ABSOLUTE DIRECTIVE
*
***********************************************************************
CABS     STF       R0,CARD90
         BL        STRING          PICK UP ABSOLUTE ADDRESS
         LW        R7,=X'40000'    DEFAULT ABSOLUTE ADDRESS
         LB        R5,CCHRS        WAS THERE AN INPUT
         BEQ       CABS4           BRANCH IF NO ADDRESS SUPPLIED
         LD        R6,CCENT        PICK UP ASCII INPUT
         BL        M1602           CONVERT TO BINARY
         TRR       R6,R6           R6=0 IS AN ERROR
         BEQ       CARDERR3        BRANCH IF ILLEGAL CHAR
         ADI       R7,X'7FF'       ROUND INPUT UP TO 512 WORDS
         SRL       R7,11           SHIFT OFF LOW ORDER 11 BITS
         SLL       R7,11           SHIFT BACK TO ADDRESS
CABS4    STW       R7,MPABS        STORE IN SAVE AREA
         SBM       3,XSYMFLGS      SET ABSOLUTE MODE (SYM DEBUGGER)
         SBM       MABS,MFLGS      ABSOLUTE FLAG
         BU        CARDEXIT
         TITLE     COPT     - OPTION DIRECTIVE
***********************************************************************
*
*                  COPT
*
***********************************************************************
*
*        PROCESS OPTION DIRECTIVE CARD
*
***********************************************************************
COPT     STF       R0,CARD90
COPT1    BL        STRING         NUMBER OF BYTES
         LB        R5,CCHRS
         BNE       COPT1.0         IS FIELD BLANK ?
         LB        R5,CCDLIM       SEE IF LAST DELIMITER IS A ','
         CI        R5,X'2C'         IF A ',' THEN LOOK FOR MORE
         BEQ       COPT1            FIELDS
         BU        CARDEXIT        BRANCH IF END OF OPTIONS
*
* LOOP ROUND THE ALLOWABLE OPTION NAMES LOOKING FOR A MATCH
*
COPT1.0  ZR        R1
         LI        R2,-COPTENTS    ALLOWABLE OPTIONS
COPT1.1  CAMW      R6,COPTTAB,R1   CHECK FOR VALID MNEMONIC
         BEQ       COPT4           BRANCH IF FOUND
         ABR       R1,29           NEXT ENTRY IN TABLE
         BIW       R2,COPT1.1      AND LOOP
*
* OPTION NOT RECOGNOSED BY NAME, SEE IF IT IS A VALUE
*
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6
         BEQ       CARDERR3        BRANCH IF NON-NUMERIC CHAR
         TRN       R7,R6           NEGATE
         BZ        CARDERR3        BRANCH IF ZERO
         ADI       R6,32           CONVERT TO PGOW NUMBER
*!!!!!!!!BLT!!!!!!!CARDERR3!!!!!!!!BRANCH!IF!TOO!BIG!FOR!OPTION!EOPT-32
         BLT       COPT2           MUST BE SECOND WORD          EOPT-32
COPT5    LA        R2,MOPTD        GET OPTION WORD ADDRESS
         ZR        R7              CLEAR PROTOTYPE
         SRLD      R6,3            SHIFT BITS INTO R7
         SRL       R7,6            SET INTO BIT FIELD OF SBM
         ORR       R6,R7           MERGE BIT AND BYTE ADDRESSES
         ORMW      R7,SBM.PRO      MERGE WITH SET BIT INSTRUCTION
         EXR       R7              SET THE BIT
         BU        COPT1
*
COPT2    ADI       R6,32           CONVERT TO 2ND PGOW NUMBER   EOPT-32
         BLT       CARDERR3        ERROR IF STILL TOO BIG       EOPT-32
         LA        R2,MOPTD2       GET OPTION WORD 2 ADDRESS    EOPT-32
         ZR        R7              CLEAR PROTOTYPE              EOPT-32
         SRLD      R6,3            SHIFT BITS INTO R7           EOPT-32
         SRL       R7,6            SET INTO BIT FIELD OF SBM    EOPT-32
         ORR       R6,R7           MERGE BIT AND BYTE ADDRS     EOPT-32
         ORMW      R7,SBM.PRO      MERGE WITH SET BIT INSTR.    EOPT-32
         EXR       R7              SET THE BIT                  EOPT-32
         BU        COPT1                                        EOPT-32
*
* A VALID OPTION NAME FOUND, SO LOAD (32 - OPTION NUMBER) AND
* GO ADD IT TO THE OPTION WORD BEING BUILT
*
COPT4    SRL       R1,2            BYTE INDEX
         LB        R6,COPTVAL,R1   OPTION VALUE
         BU        COPT5           GO ADD TO OPTION WORD
*
SBM.PRO  SBM       0,0,R2
*
* TABLE OF VALID MNEMONICS
*
COPTTAB  DATAW     C'PROM'         PROMPT
         DATAW     C'DUMP'         DUMP
         DATAW     C'LOWE'         LOWER
         DATAW     C'IPUB'         IPU BIAS
         DATAW     C'CPUO'         CPU ONLY
         DATAW     C'TEXT'         TEXT
COPTENTS EQU       $-COPTTAB       NUMBER OF WORDS IN TABLE
*
* TABLE OF OPTION BIT SETTINGS
*
COPTVAL  DATAB     11,8,10,6,7,9
         BOUND     1W
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     CORG     - ORIGIN / LORIGIN DIRECTIVES
***********************************************************************
*
*                  CORG
*
***********************************************************************
*
*        PROCESS ORIGIN/LORIGIN DIRECTIVE
*
***********************************************************************
         SPACE
CLORG    ABM       15,COVLV        INCREMENT OVERLAY LEVEL        21008
         ZMH       COSEQ           CLEAR OVERLAY SEQUENCE NUMBER  21008
         SPACE
CORG     STF       R0,CARD90
         ZMD       ALLOCATE        RESET LEGALITY OF ALLOCATE,
         ZMD       ASSIGN          ASSIGN,
         ZMD       SYMTAB          AND SYMTAB DIRECTIVES
*        LB        R5,MDBUF                                      21008
*        CI        R5,G'L'                                       21008
*        BNE       CORG.5          BR IF NOT LORIGIN             21008
*        ABM       15,COVLV        INCREMENT OVERLAY LEVEL       21008
*        ZMH       COSEQ           CLEAR OVERLAY SEQUENCE NUMBER 21008
CORG.5   BL        STRING         OBTAIN BYTES FIELD
         ZBM       CORGP,CFLGS
         LB        R5,CCHRS
         BNE       CORG2           BR IF ENTRY IS PRESENT
         ZMW       CORGN
         SBM       1,CORGN         SET USE CALCULATED END FLAG
         BU        CORG5
CORG2    CAMW      R6,=C'X   '
         BNE       CORG6           BR IF X NOT ENTERED
         BL        STRING         OBTAIN NUMERIC FIELD
         LB        R5,CCHRS
         BEQ       CORG6           BR IF NONE
         LD        R6,CCENT
         BL        M1602           CONVERT TO BINARY
         TRR       R6,R6
         BZ        CARDERR3        BRANCH IF NON-NUMERIC CHAR
CORG3    ALIGN8W   R7              PLACE ORIGIN ON 8-WORD BOUNDARY
         STW       R7,CORGN        SAVE ORIGIN
CORG5    SBM       CORGP,CFLGS
         BU        CARDEXIT
CORG6    LW        R4,=X'80000000'
         ZR        R5
         BL        MSSCH
         TRR       R5,R1
         BEQ       CARDERR3        BRANCH IF MODULE NOT FOUND
         LW        R4,1W,R1
         BNZ       CORG7           BR IF MAIN NOT SPECIFIED
         CAMW      R5,MSYND
         BLT       CARDERR3        BRANCH IF NOT A RESTORED SYMTAB
CORG7    STW       R5,CORGN
         SBM       0,CORGN         SET END OF MODULE FLAG
         BU        CORG5
         TITLE     CPAS     - PASSWORD DIRECTIVE
************************************************************************
*
*                  CPAS
*
************************************************************************
*
*        PROCESS PASSWORD DIRECTIVE
*
************************************************************************
CPAS     TRSW      R0              A NOP FOR MPX 2.0
         TITLE     CSEG     - SEGFILE DIRECTIVE
*****************************************************************
*
*                  CSEG
*
*****************************************************************
*
*        PROCESS SEGFILES DIRECTIVE
*
*****************************************************************
CSEG     STF       R0,CARD90
         BL        STRING          GET NUMBER OF SDA'S
         LB        R5,CCHRS        GET LENGTH OF FIELD
         BZ        CARDERR2        ERROR IF NONE SPECIFIED
         CI        R5,3            MAX IS A BYTE
         BGT       CARDERR3        BRANCH IF > 3 CHARS
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6           SEE IF NON NUMERICS
         BEQ       CARDERR3        BRANCH IF NON NUMERICS
         CI        R7,255          MAX IS A BYTE
         BGT       CARDERR3        BRANCH IF TOO BIG
         SBM       MSEGF,MFLGS     INDICATE SEGFILE DIRECTIVE USED
*!!!!!!!!TBM!!!!!!!MOPT19,MFLGS!!!!DEBUGGER!REQUIRED!!!!!!!!!!!!ENCD-32
*!!!!!!!!BNS!!!!!!!CSEG1!!!!!!!!!!!BRANCH!IF!NOT!!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!ARMB!!!!!!R7,MSEGFILE!!!!!ADD!TO!DEBUG!REQUIRED!FILES!!ENCD-32
         ARMB      R7,MTMPSEG      ADD REQ. TO TEMP HOLD VAL    ENCD-32
         BU        CARDEXIT
*!CSEG1!!STB!!!!!!!R7,MSEGFILE!!!!!SAVE!READY!FOR!PREAMBLE!!!!!!ENCD-32
*!!!!!!!!BU!!!!!!!!CARDEXIT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*
*-----------------------------------------------------------------------
         TITLE     CSPCE - PROCESS SPACE DIRECTIVE
*                                                                1.3#11
*                                                                1.3#11
*                                                                1.3#11
CSPCE    EQU       $                                             1.3#11
         STF       R0,CARD90                                     1.3#11
         BL        STRING          GET ARGUMENT                  1.3#11
         LB        R5,CCDLIM       GET DELIMITER                 1.3#11
         CI        R5,G'='         IS IT AN EQUAL                1.3#11
         BNE       CSPCE.1         ASSUME MEGABYTE FORMAT        1.3#11
         CAMW      R6,=C'MBLK'     IS KEY WORD RIGHT             1.3#11
         BNE       CSPCE.4         REPORT ERROR                  1.3#14+
         BU        CSPCE.2         ELSE GO DO MAPBLOCK FORMAT    1.3#11
*                                                                1.3#11
CSPCE.1  EQU       $               HERE FOR MBYTE FORMAT         1.3#11
         LB        R5,CCHRS        GET ARGUMENT LENGTH           1.3#11
         BZ        CSPCE.4         REPORT ERROR                  1.3#14+
         CI        R5,2            >2 CHARS                      1.3#11
         BGT       CSPCE.4         REPORT ERROR                  1.3#14+
         BL        M1002           CONVERT TO BINARY             1.3#11
         TRR       R6,R6           ILLEGAL CHARS?                1.3#11
         BZ        CSPCE.4         REPORT ERROR IF NOT DECIMAL   1.3#14+
         ES        R6                                            1.3#11
         MPI       R6,128          CONVERT TO MAPBLOCKS          1.3#11
         BU        CSPCE.3         BR TO COMMON PROCESSING       1.3#11
CSPCE.2  EQU       $               HERE FOR MAP BLOCK FORMAT     1.3#11
         BL        STRING                                        1.3#11
         LB        R5,CCHRS        GET LENGTH                    1.3#11
         BZ        CSPCE.4         GIVE ERROR                    1.3#14+
         CI        R5,4            >4 CHARS                      1.3#11
         BGT       CSPCE.4         REPORT ERROR                  1.3#14+
         BL        M1002           CONVERT                       1.3#11
         TRR       R6,R6           ANY ERROR                     1.3#11
         BZ        CSPCE.4         REPORT                        1.3#14+
CSPCE.3  EQU       $               COMMON PROCESSING             1.3#11
         CI        R7,256          COMPARE TO 2MB                1.3#11
         BLT       CSPCE.4         GO PROCESS                    1.3#11
         CI        R7,2048         COMPARE TO 16MB               1.3#11
         BGT       CSPCE.4         GO PROCESS                    1.3#11
CSPCE.X  EQU       $               RETURN TO DIRECTIVE LOOP      1.3#11
         STH       R7,MLAS         SAVE FOR PREAMBLE             1.3#11
         BU        CARDEXIT        RETURN TO DIRECTIVE LOOP      1.3#11
*                                                                1.3#11
CSPCE.4  EQU       $               HERE IF OUT OF RANGE          1.3#11
         LI        R5,3            ILLEGAL ENTRY MESSAGE         1.3#14
         BL        CCERR           REPORT ERROR                  1.3#14
         LNB       R5,CSPCE.ML                                   1.3#11
         LA        R6,CSPCE.MA                                   1.3#11
         BL        XTYPEF                                        1.3#11
         BU        CARDEXIT        BACK TO DIRECTIVE LOOP        1.3#14+
*                                                                1.3#11
CSPCE.MA DATAB     C'     RANGE IS 2-16  OR MBLK=256-2048.'      1.3#14
CSPCE.ML DATAB     $-CSPCE.MA                                    1.3#11
         BOUND     1W                                            1.3#11
*                                                                1.3#11
*----------------------------------------------------------------1.3#11
         TITLE     CVOL     - VOLUME DIRECTIVE
*****************************************************************
*
*                  CVOL
*
*****************************************************************
*
*        PROCESS VOLUMES DIRECTIVE
*
*****************************************************************
CVOL     STF       R0,CARD90
         BL        STRING          GET NUMBER OF VAT'S
         LB        R5,CCHRS        GET LENGTH OF FIELD
         BZ        CARDERR2        ERROR IF NONE SPECIFIED
         CI        R5,5            MAX IS A HALFWORD
         BGT       CARDERR3        BRANCH IF > 5 CHARS
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6           SEE IF NON NUMERICS
         BEQ       CARDERR3        BRANCH IF NON NUMERICS
         CI        R7,32767        MAX IS A HALFWORD
         BGT       CARDERR3        BRANCH IF TOO BIG
         STB       R7,MVOLUMES     SAVE READY FOR PREAMBLE
         BU        CARDEXIT
         TITLE     CRECAT   - RECATALOG DIRECTIVE
*************************************************************
*
*                     CRECAT
*
*************************************************************
*
*        PROCESS RECATALOG DIRECTIVE
*
*************************************************************
CRECAT   STF       R0,CARD90
         ZMD       RECAT           MAKE IT ILLEGAL FROM NOW ON   1.3#05
         TBM       MOPT2,MFLGS     IS THIS OLD FORMAT FOR LM?      22001
         BS        CARDERR1        "RECATALOG" ILLEGAL             22001
         SBM       MRECAT,MFLGS    SET RECATALOG FLAG
         BL        STRING          GET FILENAME                  1.3#05
         TBM       CRES,CFLGS      DID A LMPATH SET RESOURCE     1.3#05
         BS        CARDEXIT        ABANDON THIS IF IT DID        1.3#05
         LB        R5,CCHRS        ANY CHARS
         BZ        CARDERR2        BRANCH IF NO FILENAME
*
         CI        R5,8            MAKE SURE <= 8 CHARS
         BGT       CARDERR3        BRANCH IF > 8 CHARS
         STD       R6,XCREATNM     SAVE FILENAME
         BU        CARDEXIT
         TITLE     CUSE     - USERNAME DIRECTIVE
************************************************************************
*
*                  CUSE
*
************************************************************************
*
*        PROCESS USERNAME DIRECTIVE
*
************************************************************************
CUSE     TRSW      R0              A NOP
         TITLE     CMOUNT   - MOUNT DIRECTIVE
*****************************************************************
*
*                  CMOUNT
*
*****************************************************************
*
*        PROCESS MOUNT DIRECTIVE
*
*****************************************************************
CMOUNT   STF       R0,CARD90
         LI        R6,RR.9.SIZ     SIZE OF MOUNT RRS
         CAMW      R6,MRRSFREE     ROOM FOR NEW ENTRY??
         BGT       CARDERR4        BRANCH IF NO ROOM TO ERROR
*
         LW        R3,MRRSNEXT     ADDRESS OF NEXT SLOT IN RRS
         ZMW       RR.ACCS,R3      CLEAR ACCESS DEFAULTS
         ZMW       RR.OPTS,R3      CLEAR OPTION DEFAULTS
*
         LI        R7,RR.MTDEV     TYPE MOUNT DEVICE RRS
         STB       R7,RR.TYPE,R3
*
         LI        R7,RR.9.SIZ     SIZE OF RRS
         STB       R7,RR.SIZE,R3   INTO RRS
*
         BL        STRING          GET VOLUME NAME
         LB        R5,CCHRS        CHECK FOR BLANK VOLUME
         BZ        CARDERR2        BRANCH TO ERROR IF BLANK
         STW       R6,RR.NAME1,R3  16 CHAR VOLUME NAME .....
         STW       R7,RR.NAME1+1W,R3  .....
         LD        R6,CCENT+1D        .....
         STW       R6,RR.NAME1+2W,R3  .....
         STW       R7,RR.NAME1+3W,R3  ..... INTO RRS
*
         BL        STRING          GET 'ON'
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF NO 'ON'
         CAMW      R6,=C'ON  '
         BNE       CARDERR3        BRANCH IF NOT 'ON'
*
         BL        STRING          GET DEVICE MNEMONIC
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF NO DEVMNC TO ERROR
         BL        CDEV            GET TYPE/CHAN/SUB-CHAN INTO R7
         STW       R7,RR.DT9,R3    INTO RRS
*
* FINALLY GET ANY OTHER OPTIONS. LEGAL ONES ARE:
*
*                  SYSID = 3 CHAR ID
*                  OPTIONS = (PUBLIC,NOMSG)
*                  SHARED = Y OR N
*
CMOUNT.5 BL        STRING
         LB        R5,CCHRS
         BZ        CMOUNT.1        BRANCH IF NO OPTIONS TO EXIT
         LB        R4,CCDLIM       MAKE SURE DELIMITER .....
         CI        R4,G'='         ..... IS '='
         BNE       CARDERR3        BRANCH IF WRONG DELIMITER
*
         CAMW      R6,=C'SYSI'     CHECK FOR SYSID OPTION
         BEQ       CMOUNT.2        BRANCH IF SYSID OPTION
         CAMW      R6,=C'OPTI'     CHECK FOR 'OPTION' OPTION
         BEQ       CMOUNT.3        BRANCH IF 'OPTION' OPTION
         CAMW      R6,=C'SHAR'     CHECK FOR 'SHARED' OPTION
         BNE       CARDERR3        BRANCH IF ILLEGAL OPTION
*
* 'SHARED=' OPTION.  CHECK FOR 'Y' OR 'N'
*
         BL        STRING          GET THE OPTION
         SRL       R6,24           GET FIRST BYTE ONLY
         CI        R6,G'Y'         EXPLICIT SHARED??
         BNE       CMOUNT.4        BRANCH IF NOT 'Y'
         SBM       RR.SHAR,RR.ACCS,R3   SET EXPLICIT SHARED IN RRS
         BU        CMOUNT.5        LOOK FOR MORE OPTIONS
CMOUNT.4 CI        R6,G'N'         EXCLUSIVE??
         BNE       CARDERR3        BRANCH IF ILLEGAL OPTION VALUE
         SBM       RR.EXCL,RR.ACCS,R3   SET EXCLUSIVE IN RRS
         BU        CMOUNT.5        LOOK FOR MORE OPTIONS
*
* 'SYSID=' OPTION.  CHECK FOR A 3-CHAR ID NAME
*
CMOUNT.2 BL        STRING          GET THE SYSID NAME
         LB        R5,CCHRS        MUST BE 1-3 CHARS
         BZ        CARDERR2        BRANCH IF BLANK FIELD
         CI        R5,3            MAKE SURE <= 3 CHARS
         BGT       CARDERR3        BRANCH IF NAME TOO LONG
         SRL       R6,8            TO LOOK LIKE AN LFC
         STW       R6,RR.LFC,R3    INTO RRS
         BU        CMOUNT.5        LOOK FOR MORE OPTIONS
*
* 'OPTIONS=' OPTION. CHECK FOR (PUBLIC,NOMSG)
*
CMOUNT.3 BL        STRING          CHECK FOR '('
         LB        R5,CCHRS        SHOULD BE 0
         BNZ       CARDERR3        BRANCH IF NOT 'OPTIONS=('
CMOUNT.7 BL        STRING          GET FIRST SUB-OPTION
*        LB        R5,CCHRS        CHECK FOR BLANK FIELD         84-0406
*        BZ        CARDERR2        BRANCH TO ERROR IF NO SUB-OPTI84-0406
*
         CAMW      R6,=C'PUBL'     CHECK FOR 'PUBLIC'
         BEQ       CMOUNT.6
         CAMW      R6,=C'NOMS'     CHECK FOR 'NOMSG'
         BEQ       CMONT.74                                      84-0406
         LB        R4,CCDLIM       SEE IF ',' WAS PASSED         84-0406
         CI        R4,G','                                       84-0406
         BEQ       CMOUNT.7        IF SO GET NEXT PARAMETER      84-0406
         BU        CARDERR3        ELSE ERROR                    84-0406
CMONT.74 SBM       RR.NOMSG,RR.OPTS,R3  SET NOMSG OPTION
CMOUNT.8 LB        R4,CCDLIM       SEE IF ')' WAS DELIMITER
         CI        R4,G')'
         BEQ       CMOUNT.5        BRANCH IF END OF SUB-OPTIONS
         BU        CMOUNT.7        LOOP FOR NEXT SUB-OPTION
*
CMOUNT.6 SBM       RR.PUBLC,RR.OPTS,R3  SET PUBLIC OPTION
         BU        CMOUNT.8        COMMON MOVE TO NEXT SUB-OPTION
*
* END OF ALL OPTIONS, SO BUMP THE MRRS POINTERS AND EXIT COMMAND
*
CMOUNT.1 LI        R6,RR.9.SIZ     LENGTH OF ENTRY IN WORDS
         BL        CMODRRS         UPDATE POINTERS
         BU        CARDEXIT        AND EXIT COMMAND
         TITLE     CMODRRS  - UPDATE RRS POINTERS
*****************************************************************
*
*                  CMODRRS
*
*****************************************************************
*
*        UPDATE MRRS POINTERS AFTER BUILDING AN RRS
*
*        INPUT:    R6 = LENGTH OF RRS ENTRY IN WORDS
*
*        OUTPUT:   MRRSNEXT = NEXT FREE SLOT IN MRRS
*                  MRRSFREE = NUMBER OF WORDS LEFT IN MRRS
*                  MRRSN    = TOTAL ENTRIES IN MRRS
*
*****************************************************************
CMODRRS  SLL       R6,2            BYTE LENGTH
         ARMW      R6,MRRSNEXT     BUMP NEXT FREE SLOT ADDRESS
         SRL       R6,2            WORD LENGTH AGAIN
         TRN       R6,R6           SUBTRACT LENGTH FROM .....
         ARMW      R6,MRRSFREE     ..... FREE WORD COUNT
         TRN       R6,R6           RETURN REGISTERS AS INPUT
         ABM       7,MRRSN         BUMP TOTAL RRS COUNT
         TRSW      R0              AND RETURN
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     CSYM     - SYMTAB DIRECTIVE
***********************************************************************
*
*                  CSYM
*
***********************************************************************
*
*        PROCESS SYMTAB DIRECTIVE; ABNORMAL EXIT TO ABORT
*
***********************************************************************
CSYM     STF       R0,CARD90
         ZMD       SYMTAB          SYMTAB DIRECTIVE NOW ILLEGAL
CSYM1    ZMH       MXSEQ           INITIALIZE MOBSC VARIABLES
         ZBM       MPEND,MFLGS
         LW        R5,=C'    '
         STW       R5,MPNAM
         STW       R5,MPNAM+1W
CSYM2    BL        XSYRD           READ A CARD FROM SYI
         TRR       R5,R5
         BZ        CSYM4           BRANCH IF NOT EOF
*
* PREMATURE EOF ON SYMTAB, OR ILLEGAL RECORD.
*
CSYM5    LA        R6,CBADSYM      'ILLEGAL SYMTAB RECORD'
         LI        R5,27B
         BL        XPRNT
         BL        XABORT
*
CSYM4    TBM       0,MCBUF
         BNS       CSYM5           BRANCH IF ILLEGAL RECORD
         LI        R5,2B
         BL        MOBSC           PROCESS CARD
         TBM       MPEND,MFLGS
         BNS       CSYM2           BRANCH IF MORE DATA
*
         M.CLSE    XSYRD91         CLOSE SYMTAB FILE
         BU        CARDEXIT        AND EXIT
         SPACE     2
CBADSYM  DATAB     C' ILLEGAL SYMTAB FILE RECORD'
         BOUND     1W
         TITLE     CASS1-4  - A1, A2, A3, A4 DIRECTIVES
***********************************************************************
*
*                  CASS
*
***********************************************************************
*
*        PROCESS ASSIGN1-4 CARDS.  ASSOCIATED SUBROUTINES PROCESS
*        INFORMATION INTO RESOURCE REQUIREMENT SUMMARY (MRRS)
*
***********************************************************************
CASS0    STF       R0,CARD90
         SRL       R7,16           CHECK FOR 'GN'
         CI        R7,G'GN'
         BNE       CARDERR1        BRANCH IF NOT 'ASSIGN'
         LA        R3,CCENT        GET THE ASSIGN NUMBER
         LB        R6,6B,R3        MUST BE 1,2,3,4 OR SPACE
         CI        R6,G' '         CHECK FOR SPACE
         BEQ       CASSG           BRANCH IF 2.0 ASSIGN
         BU        CASSCOM         COMMON CODE FOR A1 THRU A4
*
CASS1    STF       R0,CARD90
         SLL       R6,8            GET SECOND BYTE OF .....
         SRL       R6,24           ..... DIRECTIVE FOR ASSIGN NUMBER
*
CASSCOM  CI        R6,G'0'
         BLE       CARDERR1        BRANCH IF < ASSIGN 1
         CI        R6,G'5'
         BGE       CARDERR1        BRANCH IF > ASSIGN 4
         SUI       R6,X'31'        RANGE 0 - 3
         SLL       R6,2            WORD TABLE INDEX
         STW       R6,CASS87       SAVE FOR RETURN FROM .....
*                                  ..... INDIVIDUAL ASSIGNS
*
* VALIDATE THE LFC= PART, WHICH IS COMMON TO ALL ASSIGNS
*
         BL        STRING
         LB        R1,CCHRS        NUMBER OF CHARACTERS
         BZ        CARDERR3        BRANCH IF NONE
CASSCOM1 CI        R1,4
         BGE       CARDERR3        BRANCH IF > 3
         SRL       R6,8            TOP BYTE ZERO, REST IS LFC
*
         CAMW      R6,=X'00545520' IS LEFT HALF OF LFC = 'UT '    21003
         BEQ       CARDERR3        IF SO, ERR--'UT ' RESERVE LFC  21003
         LB        R7,CCDLIM       CHECK DELIMITER WAS '='
         CI        R7,X'3D'
         BNE       CARDERR3        BRANCH IF NOT '='
*
* SPLIT TO IINDIVIDUAL ASSIGNS TO VALIDATE REST OF LINE
*
         LW        R3,CASS87       0 - 3 INDEX
         BL        *CASS91,R3
*
* RETURN HERE IF VALIDATED O.K.
* SEE IF ANY MORE ON THE SAME LINE AND PROCESS IF SO
*
         BL        STRING
         LB        R1,CCHRS
         BZ        CARDEXIT        BRANCH IF NO MORE
         BU        CASSCOM1        PROCESS THE NEXT ASSIGN
CASS91   ACW       CASSA           ASSIGN1
         ACW       CASSB           ASSIGN2
         ACW       CASSC           ASSIGN3
         ACW       CASSD           ASSIGN4
CASS87   RES       1W              ASSIGN NUMBER (0 - 3)
CASS88   RES       1W              LINK SAVE FOR INDIVIDUAL ASSIGNS
CASS89   RES       1D              WORK VARIABLE FOR ALL ASSIGNS
         TITLE     CASSA    - ASSIGN1 DIRECTIVE
***********************************************************************
*
*                  CASSA
*
***********************************************************************
*
*        ASSIGN1  CODE=FILE (PERMANENT)
*
***********************************************************************
CASSA    STW       R0,CASS88
         SBR       R6,0            SET A1 CODE
         STW       R6,MRRS.OLD     INTO BUILDING RRS
         BL        STRING          GET FILENAME
         LA        R2,CCENT        GET ADDR OF FILENAME
         LI        R5,-8           EIGHT CHARACTERS
         ZR        R6
         ZR        R7
CASSA4   EQU       $
         LB        R0,0B,R2        GET BYTE FROM FILE NAME BUCKET
         SUI       R0,X'20'
         BLT       CARDERR6        BRANCH IF TOO SMALL
         CI        R0,X'3F'        CHAR CODE TOO LARGE ??
         BGT       CARDERR6        BRANCH IF TOO LARGE
         SLLD      R6,6
         ADR       R0,R7           ADD TO ACCUMULATOR
         ABR       R2,31           NEXT BYTE
         BIB       R5,CASSA4
         STW       R6,MRRS.OLD+1W  FILENAME TO RRS
         STW       R7,MRRS.OLD+2W
         LB        R4,CCDLIM       GET LAST DELIMMITTER
         CI        R4,G','         PASSWORD FOLLOWS ?
         BNE       CASSA16         NO
         BL        STRING         GET PASSWORD
*!!!!!!!!LNB!!!!!!!R5,CCHRS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!S8702103
*!!!!!!!!BZ!!!!!!!!CASSA16!!!!!!!!!... NONE!!!!!!!!!!!!!!!!!!!!!S8702103
*!!!!!!!!CALM!!!!!!X'78'!!!!!!!!!!!COMPRESS!PASSWORD!!!!!!!!!!!!S8702103
*!!!!!!!!STH!!!!!!!R7,MRRS.OLD+1W!!COMPRESSED!PASSWORD!TO!RRS!!!S8702103
CASSA16  LB        R4,CCDLIM       GET LAST DELIMITTER
         CI        R4,G','         ANY MORE PARAMETERS
         BNE       CASSA18         NOPE, WE GOT EM ALL
         BL        STRING          SCAN NEXT FIELD
         LB        R6,CCENT        GET FIRST BYTE
         CI        R6,G'U'         IS UNBLOCK SPECIFIED?
         BNE       CARDERR3        BRANCH IF NOT 'U'
         SBM       5,MRRS.OLD      SET UNBLOCKED BIT
*
* REFORMAT THE RRS
*
CASSA18  LI        R6,CASSA.NW     SIZE OF NEW ENTRY
         BL        MRRSCONV
         BU        *CASS88     RETURN FOR NEXT ON THIS LINE
         TITLE     CASSB    - ASSIGN2 DIRECTIVE
***********************************************************************
*
*                  CASSB
*
***********************************************************************
*
*        ASSIGN2  CODE=FILE (SYSTEM)
*
***********************************************************************
CASSB    STW       R0,CASS88
         STW       R6,CASS89       LHS OF LFC=
         LW        R5,=C'    '
         STW       R5,CASS89+1W    RHS OF LFC=
         BL        STRING          GET FILE
         LB        R5,CCHRS        PICK UP NUMBER OF CHARACTERS FOUND
         CI        R5,3            MUST BE EXACTLY 3 CHAR. LONG
         BNE       CARDERR3        BRANCH IF NOT 3 CHARS
         STW       R6,CASS89+1W    INTO BUILD AREA
         CAMW      R6,=C'SYC '
         BEQ       CASSB11         BR IF ASSIGNMENT TO SYC FILE
         CAMW      R6,=C'SGO '
         BNE       CASSB16         NOT TO SGO EITHER
CASSB11  LW        R5,CASS89
         SBR       R5,2            SET SYC/SGO TYPE
         STW       R5,MRRS.OLD     TYPE AND CODE TO RRS
         SRL       R6,8
         STW       R6,MRRS.OLD+1W  FILENAME
         ZMW       MRRS.OLD+2W
CASSB12  LI        R6,CASSB.NW     SIZE OF NEW RRS ENTRY
         BL        MRRSCONV        CONVERT IT TO NEW FORMAT
         BU        *CASS88     RETURN FOR NEXT ON THIS LINE
*
CASSB16  CAMW      R6,=C'SLO '
         BEQ       CASSB23
         CAMW      R6,=C'SBO '
         BNE       CARDERR3        BRANCH IF NOT SLO/SBO/SGO/SYC
CASSB23  LW        R5,CASS89       LHS OF LFC=
         SBR       R5,1            SET SLO/SBO TYPE
         STW       R5,MRRS.OLD     TYPE AND LFC TO RRS
         SRL       R6,8
         STW       R6,MRRS.OLD+1W  'SLO'/'SBO' TO RRS
         LB        R5,CCDLIM       PICK UP LAST DELIMITER
         CI        R5,X'2C'        MUST BE ',' FOR SBO OR SLO
         BNE       CARDERR3        BRANCH IF NOT A ','
         BL        STRING          GET SIZE FIELD NOW
         LB        R2,CCHRS        GET CHARACTER COUNT
         BZ        CARDERR3        BRANCH IF NONE
         CI        R2,8B
         BGT       CARDERR3        BRANCH IF > 8 CHARS
         BL        M1002           CONVERT SIZE TO BINARY
         TRR       R6,R6
         BZ        CARDERR3        BRANCH IF NON-NUMERIC CHAR
         ZR        R6
         TRR       R7,R7
         BZ        CARDERR3        BRANCH IF ZERO ENTERED
         LW        R4,CASS89+1W    GET RHS OF LFC=
         CAMW      R4,=C'SLO '
         BEQ       CASSB20         BR IF FILE SLO
*  CONVERT SIZE TO 192 WORD RECORDS
         DVI       R6,6B           6 CARDS PER RECORD
         BU        CASSB21
CASSB20  DVI       R6,5B           5 LINES PER RECORD
CASSB21  TRR       R6,R6
         BEQ       CASSB22
         ABR       R7,31           ROUND UPWARD
CASSB22  STW       R7,MRRS.OLD+2W  CARDS OR PRINTLINES TO RRS
         BU        CASSB12
         TITLE     CASSC    - ASSIGN3 DIRECTIVE
***********************************************************************
*
*                  CASSC
*
***********************************************************************
*
*        ASSIGN3  CODE=DEVICE
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
CASSC    STW       R0,CASS88
         SBR       R6,3            SET A3 CODE
         STW       R6,MRRS.OLD     INTO RRS
         ZMW       MRRS.OLD+2W     FOR CONSISTENCY
*
* GO AND GET THE DEVICE-TYPE/CHANNEL/SUB-CHANNEL WORD
*
         BL        STRING          GET DEVMNC FIELD INTO R6/R7
         BL        CDEV            FORM TYPE/CHAN/SUB-CHAN WORD
         STW       R7,MRRS.OLD+1W  STORE IT INTO RRS
         LB        R5,5B,R2        GET FLAG WORD FROM DTT
         LB        R4,CCDLIM       GET TERMINATING CHAR
         CI        R4,G','         GOT ANOTHER FIELD FOLLOWING DTT
         BNE       CASSC18         NOPE-> ALL DONE HERE
         TBR       R5,25           IS THIS ARG LEGAL??
         BNS       CASSC17         NOPE, NOT CALLED OUT IN DTT FLAGS
         BL        STRING          GO GET EM
         TBR       R5,26           REEL NAME??
         BNS       CASSC15         MUST BE A SIZE SPEC
*
*        MOVE REEL NAME INTO RRS ENTRY
*
         STW       R6,MRRS.OLD+2W  REEL NAME TO RRS
         LB        R4,CCDLIM       GET TERMINATING CHARACTER
         CI        R4,G','         GOT VOLUME FOLLOWING ?
         BNE       CASSC17         NOPE = ALL DONE
         BL        STRING          GET SIZE FIELD
         M.CONADB                  CONVERT SIZE TO BINARY
         TRR       R6,R6           ANY CHAR PROBLEMS
         BZ        CARDERR3        BRANCH IF ILLEGAL CHAR
         STB       R7,MRRS.OLD+5B  MV # INTO RRS
         BU        CASSC17         ALL DONE W/SERIAL #'S
*
*        GET SIZE FIELD ON COMMAND
*
CASSC15  EQU       $
         M.CONADB                  CONVERT SIZE TO BINARY
         TRR       R6,R6
         BZ        CARDERR3        BRANCH IF NON-NUMERIC CHAR
CASSC16  EQU       $
         STW       R7,MRRS.OLD+2W  SIZE TO RRS
*
*        CHECK FOR UNBLOCKED SPECIFICATON
*
CASSC17  LB        R4,CCDLIM       GET TERMINATING CHARACTER
         CI        R4,G','         ANY MORE PARAMETERS ?
         BNE       CASSC18         NOPE, WE GOT EM ALL
         BL        STRING          CHECK FOR NEXT FIELD
         LB        R6,CCENT        LOOK FOR ONE LETTER
         CI        R6,G'U'         IS UNBLOCKED SPECIFIED ?
         BNE       CARDERR3        BRANCH IF NOT 'U'
CASSC5.8 SBM       5,MRRS.OLD      SET UNBLOCKED
*
CASSC18  LI        R6,CASSC.D2     *** MAX FOR NOW *******
         BL        MRRSCONV        CONVERT TO NEW FORMAT
         BU        *CASS88     RETURN FOR NEXT ON THE LINE
         TITLE     CASSD    - ASSIGN4 DIRECTIVE
***********************************************************************
*
*                  CASSD
*
***********************************************************************
*
*        ASSIGN4  CODE1=CODE2
*
***********************************************************************
CASSD    STW       R0,CASS88
         SBR       R6,4            INDICATE ASSIGN 4
         STW       R6,MRRS.OLD     INTO RRS
         BL        STRING
         LB        R4,CCHRS        MUST BE ANOTHER LFC
         BZ        CARDERR3        BRANCH IF ZERO LENGTH
         CI        R4,4
         BGE       CARDERR3        BRANCH IF > 3 CHARS
         LW        R5,CCENT        PICK UP SECOND LFC
         SRL       R5,8            RIGHT JUSTIFY
         STW       R5,MRRS.OLD+1W
         ZMW       MRRS.OLD+2W     FOR CONSISTENCY
         LI        R6,CASSD.NW     SIZE OF NEW FORMAT ENTRY
         BL        MRRSCONV        CONVERT TO NEW FORMAT
         BU        *CASS88     RETURN FOR NEXT ON THE LINE
         TITLE     CASSG    - ASSIGN DIRECTIVE
***********************************************************************
*
*                  CASSG
*
***********************************************************************
*
*        PROCESS GENERAL ASSIGN DIRECTIVE
*
***********************************************************************
CASSG.A  EQU       $
         STF       R0,CARD90       SAVE REGS
CASSG    EQU       $               REGISTERS ALREADY SAVED IN CARD90
         BL        STRING          GET LFC FIELD
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH TO ERROR IF BLANK
         CI        R5,4            CHECK FOR <4 CHARS
         BGE       CARDERR3        BRANCH IF >3 CHARS IF FIELD
         SRL       R6,8            TOP BYTE ZERO, REST IS LFC
         CAMW      R6,=X'00555420' IS LFC 'UT '(RESERVED LFC)     21003
         BEQ       CARDERR3        IF SO, ERR.                    21003
         STW       R6,CASSG91      SAVE FOR ADDITION TO RRS LATER
*
         BL        STRING          GET 'TO'
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF BLANK FIELD
         CAMW      R6,=C'TO  '
         BNE       CARDERR3        BRANCH IF NOT 'TO'
*
* THE MINIMUM SIZE FOR AN ASSIGN RRS IS 4 WORDS, MAKE SURE
* AT LEAST THIS IS AVAILABLE AND INITIALISE THE 4 WORDS WITH
* THE LFC FOLLOWED BY 3 ZEROS.
*
         LI        R6,4            MINIMUM RRS ENTRY SIZE
         CAMW      R6,MRRSFREE     SEE IF ROOM FOR IT
         BGT       CARDERR4        BRANCH IF NO ROOM
         LW        R3,MRRSNEXT     NEXT SLOT (R3 RESERVED FOR THIS)
         LW        R6,CASSG91      PUT LFC .....
         STW       R6,RR.LFC,R3    ..... INTO RRS
         ZMW       RR.TYPE,R3      ZERO THE NEXT .....
         ZMW       RR.ACCS,R3      .....
         ZMW       RR.OPTS,R3      ..... THREE WORDS
*
* NOW GET THE MAIN PART OF THE ASSIGN. THIS WILL ALSO DETERMINE
* THE TYPE OF RRS BEING PRODUCED AND THEREFORE THE SPACE
* REQUIREMENT IN THE RRS TABLE.
*
         BL        STRING          GET THE PRIMARY ASSIGN TYPE
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF BLANK FIELD
         LB        R4,CCDLIM       SEE IF DELIMITER IS '=' .....
         CI        R4,G'='         ..... AND IF SO GO AND  .....
         BEQ       CASSG.5         ..... IDENTIFY THE KEYWORD
*
         CAMW      R6,=C'SYC '     SEE IF SYC
         BEQ       CASS.SYC        BRANCH IF SYC
*
         CAMW      R6,=C'SGO '     SEE IF SGO
         BEQ       CASS.SGO        BRANCH IF SGO
*
         CAMW      R6,=C'SBO '     SEE IF SBO
         BEQ       CASS.SBO        BRANCH IF SBO
*
         CAMW      R6,=C'SLO '     SEE IF SLO
         BEQ       CASS.SLO        BRANCH IF SLO
*
         CAMW      R6,=C'TEMP'     SEE IF TEMP WITH NO VOLUME
         BNE       CASSG.6                                         21007
         CAMW      R7,=C'    '     AND NOT BEGINNING OF FILE NAME  21007
         BEQ       CASS.TP5        BRANCH IF SO
*
* KEYWORD NOT RECOGNISED SO ASSUME A PATHNAME
*
*    FIRST SEE IF IT IS THE SPECIAL PATHNAME FOR ANSI TAPES.     1.3#11
*                                                                1.3#11
*        THIS FORMS A TYPE 10 RRS WHOSE LENGTH IS 16W            1.3#11
*                                                                1.3#11
CASSG.6  EQU       $               HERE TO TEST ANSI TAPE        1.3#11
         LB        R5,CCHRS        CHECK FOR @@ANSITAPE (9 CHARS) 1.3#11
         CI        R5,9                                          1.3#11
         BNE       CASSG.61        NOT ANSI, CONTINUE WITH PATHN 1.3#11
         CAMD      R6,CANSI1       CHECK FOR '@@ANSITAP'          1.3#11
         BNE       CASSG.61        NOT ANSI, CONTINUE WITH PATHN 1.3#11
         LD        R6,CCENT+1D                                   1.3#11
         CAMD      R6,CANSI2       CHECK FOR 'E       '          1.3#11
         BNE       CASSG.61        NOT ANSI, CONTINUE WITH PATHN 1.3#11
         LB        R7,CCDLIM       CHECK FOR '( DELIMITER        1.3#11
         CI        R7,G'('                                       1.3#11
         BNE       CASSG.61        NOT ANSI, CONTINUE WITH PATHN 1.3#11
*                                                                1.3#11
* WE HAVE AN ANSI TAPE ASSIGNMENT                                1.3#11
* MAKE SURE THERE IS ENOUGH ROOM IN THE RRS TABLES AND           1.3#11
* SET UP THE RRS TYPE AND SIZE FIELDS                            1.3#11
*                                                                1.3#11
CASSGANS LI        R6,RR_10.SZ     RRS TYPE 10 SIZE              1.3#11
         CAMW      R6,MRRSFREE                                   1.3#11
         BGT       CARDERR4        BRANCH IF NO ROOM             1.3#11
         STB       R6,RR.SIZE,R3   SIZE IN WORDS INTO RRS        1.3#11
         LI        R6,RR_ANS                                     1.3#11
         STB       R6,RR.TYPE,R3   TYPE INTO RRS                 1.3#11
*                                                                1.3#11
* GET THE LOGICAL VOLID TERMINATED BY A ')'                      1.3#11
*                                                                1.3#11
         BL        STRING                                        1.3#11
         LB        R5,CCHRS                                      1.3#11
         BZ        CARDERR2        BRANCH IF BLANK FIELD         1.3#11
         CI        R5,6                                          1.3#11
         BGT       CARDERR3        BRANCH IF > 6 CHARACTERS      1.3#11
         LB        R4,CCDLIM                                     1.3#11
         CI        R4,G')'                                       1.3#11
         BNE       CARDERR3        BRANCH IF NOT ')' DELIMITER   1.3#11
*                                                                1.3#11
* STORE THE VOLUME ID INTO THE RRS                               1.3#11
*                                                                1.3#11
         SRLD      R6,16           00LVOLID                      1.3#11
         STH       R6,RR_LVID,R3                                 1.3#11
         STW       R7,RR_LVID+1H,R3                              1.3#11
*                                                                1.3#11
* GET THE FILENAME (17 CHARACTERS MAX)                           1.3#11
*                                                                1.3#11
         BL        STRING                                        1.3#11
         LB        R5,CCHRS                                      1.3#11
         BZ        CARDERR2        BRANCH IF BLANK FIELD         1.3#11
         LW        R1,BLANKS       BLANK FILL                    1.3#11
         STW       R1,RR_AFID+4W,R3 LAST WORD OF FID             1.3#11
         CI        R5,17                                         1.3#11
         BGT       CARDERR3        BRANCH IF > 17 CHARACTERS     1.3#11
         BNE       CASSG.15        BRANCH IF 1 TO 16 CHARACTERS  1.3#11
         LA        R1,MDBUF        EXTRACT THE 17TH CHARACTER .. 1.3#11
         ADMW      R1,CCSTRT       .....                         1.3#11
         LB        R5,16B,R1       .....                         1.3#11
         STB       R5,RR_AFID+16B,R3  ..... AND STORE IN RRS     1.3#11
CASSG.15 STD       R6,RR_AFID,R3   STORE THE OTHER 16 CHARACTERS 1.3#11
         LD        R6,CCENT+1D     .....                         1.3#11
         STD       R6,RR_AFID+2W,R3 ..... IN THE RRS             1.3#11
*                                                                1.3#11
* NOW HANDLE THE OPTIONS                                         1.3#11
* FIRSTLY ZERO THE FIELDS TO INDICATE DEFAULT VALUES             1.3#11
*                                                                1.3#11
         ZMH       RR_RECL,R3                                    1.3#11
         ZMH       RR_BSIZE,R3                                   1.3#11
         ZMW       RR_GENN,R3                                    1.3#11
         ZMW       RR_GENV,R3                                    1.3#11
         ZMW       RR_EXPIA,R3                                   1.3#11
         ZMH       RR_EXPIR,R3                                   1.3#11
         ZMB       RR_FORM,R3                                    1.3#11
         ZMB       RR_PROT,R3                                    1.3#11
*                                                                1.3#11
* GET EACH OPTION IN TURN READING THE CONTINUATION CARD IF REQUI 1.3#11
*                                                                1.3#11
CASSG.13 BL        STRING                                        1.3#11
         LB        R5,CCHRS                                      1.3#11
         BZ        CASSG.14        BRANCH IF NO MORE OPTIONS     1.3#11
*                                                                1.3#11
* CHECK FOR CONTINUATION ONTO ANOTHER CARD ( '-' SIGN DETECTED)  1.3#11
*                                                                1.3#11
         CAMW      R6,=C'-   '                                   1.3#11
         BNE       CASSG.12        BRANCH IF THE SAME LINE       1.3#11
         BL        XSIRD           GO READ NEXT CARD             1.3#11
         TRR       R5,R5           CHECK FOR EOF .....           1.3#11
         BNE       C6              ..... AND ERROR IF FOUND      1.3#11
         BU        CASSG.13        ELSE GO PROCESS FIRST OPTION  1.3#11
*                                                                1.3#11
CASSG.14 LI        R6,RR_10.SZ     UPDATE RRS POINTERS .....     1.3#11
         BL        CMODRRS         ..... TO NEXT FREE ENTRY      1.3#11
         BU        CASSG.7         AND EXIT                      1.3#11
*                                                                1.3#11
* THERE IS AN OPTION SO GO VALIDATE IT                           1.3#11
* CC1 IS SET IF THE OPTION WAS DETECTED                          1.3#11
* THE RRS WILL HAVE BEEN UPDATED ON RETURN                       1.3#11
* NO RETURN IS MADE IF AN ERROR WAS DETECTED                     1.3#11
*                                                                1.3#11
CASSG.12 BL        CAS.OPT4                                      1.3#11
         BU        CASSG.13        BRANCH IF OPTION FOUND        1.3#11
         PAGE                                                    1.3#11
*                                                                1.3#11
* THIS ROUTINE CHECKS TO SEE IF THE OPTION KEYWORD IN R6/R7      1.3#11
* IS ONE OF THE SET:                                             1.3#11
*                                                                1.3#11
*        GENERATION = GENNUM                                     1.3#11
*        GENVERSION = GENVNUM                                    1.3#11
*        ACCESS     = R/W/A/U                                    1.3#11
*        FORMAT     = F/D/S                                      1.3#11
*        RECLENGTH  = RECSIZE                                    1.3#11
*        BLOCKED    = Y/N                                        1.3#11
*        BSIZE      = BLOCKSIZE                                  1.3#11
*        PROTECT    = 0/A..Z                                     1.3#11
*        EXPIRE     = +DAYS OR YYDDD                             1.3#11
*                                                                1.3#11
* IF SO, THE RRS IS UPDATED ACCORDINGLY                          1.3#11
*                                                                1.3#11
* IF A FORMAT ERROR IS DETECTED AN EXIT IS TAKEN DIRECTLY TO 'CA 1.3#11
*                                                                1.3#11
* TABLES TO CONTAIN THE OPTIONS AND THE ACTION VETCOR            1.3#11
CANSOPS  DATAW     C'GENE'         GENERATION #                  1.3#11
         DATAW     C'GENV'         GENERATION VERSION #          1.3#11
         DATAW     C'RECL'         RECORD LENGTH                 1.3#11
         DATAW     C'BSIZ'         BLOCK SIZE                    1.3#11
         DATAW     C'EXPI'         EXPIRE={+DAYS|YYDDD}          1.3#11
         DATAW     C'BLOC'         BLOCK=Y|N                     1.3#11
         DATAW     C'ACCE'         ACCESS=(R|W|U|A)              1.3#11
         DATAW     C'FORM'         FORMAT=F|D|S                  1.3#11
         DATAW     C'PROT'         PROTECT='1' OR INSTALLATION V 1.3#11
CANSOPT  EQU       $                                             1.3#11
CANSOPTS EQU       $-CANSOPS                                     1.3#11
* THE ACTION TABLE FOLLOW NOW                                    1.3#11
         ACH       CAS.4.1         GEN                           1.3#11
         ACH       CAS.4.9         GENV                          1.3#11
         ACH       CAS.4.2         RECL                          1.3#11
         ACH       CAS.4.8         BSIZ                          1.3#11
         ACH       CAS.4.3         EXPIRE                        1.3#11
         ACH       CAS.4.4         BLOCK=                        1.3#11
         ACH       CAS.4.5         ACCESS                        1.3#11
         ACH       CAS.4.6         FORMAT                        1.3#11
         ACH       CAS.4.7         PROTECTION                    1.3#11
CANSACT  EQU       $                                             1.3#11
*                                                                1.3#11
CAS.OPT4 STF       R0,COPT90                                     1.3#11
         LB        R4,CCDLIM                                     1.3#11
         CI        R4,G'='                                       1.3#11
         BNE       CARDERR2        BRANCH IF ILLEGAL DELIMITER   1.3#11
         LI        R2,-CANSOPTS    TABLE LIMIT                   1.3#11
CAS.OPT0 CAMW      R6,CANSOPT,R2   IS IT ONE OF THE ENTRIES?     1.3#11
         BEQ       *CANSACT,R2     YES - GO TA ACTION IT         1.3#11
         BIW       R2,CAS.OPT0     ELSE CARRY ON LOOKING         1.3#11
         BU        CARDERR3        WE LOOKED BUT DIDN'T SEE      1.3#11
*                                                                1.3#11
CAS.OPTX LF        R0,COPT90       REGAIN REGS                   1.3#11
         TRSW      R0              AND RETURN                    1.3#11
*                                                                1.3#11
* GENE                                                           1.3#11
*                                                                1.3#11
CAS.4.1  BL        STRING          GET GENERATION NUMBER         1.3#11
         LB        R5,CCHRS                                      1.3#11
         BZ        CARDERR2        BRANCH IF BLANK FIELD         1.3#11
         CI        R5,4                                          1.3#11
         BGT       CARDERR3        BRANCH IF > 4 CHARACTERS      1.3#11
         M.CONADB                  CONVERT TO BINARY (+VALIDATE) 1.3#11
         TRR       R6,R6                                         1.3#11
         BZ        CARDERR3        BRANCH IF ILLEGAL CHARACTER   1.3#11
         TRR       R7,R5           BINARY VALUE TO R5            1.3#11
         M.CONBAD                  BACK TO ASCII FORMAT          1.3#11
         STW       R7,RR_GENN,R3   STORE IN RRS                  1.3#11
         BU        CAS.OPTX        AND EXIT                      1.3#11
*                                                                1.3#11
* CHECK FOR 'RECLENGTH'                                          1.3#11
*                                                                1.3#11
CAS.4.2  BL        STRING          GET SIZE FIELD                1.3#11
         LB        R5,CCHRS                                      1.3#11
         BZ        CARDERR2        BRANCH IF BLANK FIELD         1.3#11
         M.CONADB                  CONVERT TO BINARY (+VALIDATE) 1.3#11
         TRR       R6,R6                                         1.3#11
         BZ        CARDERR3        BRANCH IF ILLEGAL CHARACTER   1.3#11
         STH       R7,RR_RECL,R3   STORE IN RRS                  1.3#11
         BU        CAS.OPTX        AND EXIT                      1.3#11
*                                                                1.3#11
* CHECK FOR EXPIRE                                               1.3#11
*                                                                1.3#11
CAS.4.3  BL        STRING                                        1.3#11
         LB        R5,CCHRS        GET SIZE                      1.3#11
         BEQ       CARDERR2        ILL BLANK FIELD               1.3#11
         TRR       R6,R2           COPY MS WORD                  1.3#11
         SRL       R2,24           GET MS BYTE                   1.3#11
         CI        R2,G'+'         RELATIVE EXPIRY?              1.3#11
         BEQ       CAS.4.31        YUP - GO                      1.3#11
* ABS DATA YYDDD                                                 1.3#11
         CI        R5,5            THIS SIZE?                    1.3#11
         BNE       CARDERR3        NOPE - GO TELL                1.3#11
         SRLD      R6,8            MAKE ROOM FOR A BLANK         1.3#11
         SBR       R6,2            INSERT A SPACE (SIC)          1.3#11
         SRL       R7,16           RIGHT JUST LAST H/W           1.3#11
         STW       R6,RR_EXPIA,R3  INTO RRS                      1.3#11
         STH       R7,RR_EXPIA+1W,R3 DITTO                       1.3#11
         BU        CAS.OPTX        GO RETURN                     1.3#11
* REL DATE +D...                                                 1.3#11
CAS.4.31 SLLD      R6,8            LEFT JUST #                   1.3#11
         SBR       R7,26           SPACE PAD (SIC)               1.3#11
         M.CONADB                  BINARISE                      1.3#11
         TRR       R6,R6           GOOD?                         1.3#11
         BEQ       CARDERR3        NOPE - GO REPORT              1.3#11
         ZMW       RR_EXPIA,R3     CLEAR ABSOLUTE EXPIRY         1.3#11
         STH       R7,RR_EXPIR,R3  PLACE REL EXPIR               1.3#11
         BU        CAS.OPTX        GO RETURN                     1.3#11
*                                                                1.3#11
* CHECK FOR 'BLOCK'                                              1.3#11
*                                                                1.3#11
CAS.4.4  BL        STRING                                        1.3#11
         LB        R4,CCENT                                      1.3#11
         CI        R4,G'Y'                                       1.3#11
         BNE       CAS.4.41        BRANCH IF NOT 'Y'             1.3#11
         SBM       RR.BLK,RR.OPTS,R3                             1.3#11
         BU        CAS.OPTX                                      1.3#11
CAS.4.41 CI        R4,G'N'                                       1.3#11
         BNE       CARDERR3        BRANCH IF NOT 'Y' OR 'N'      1.3#11
         SBM       RR.UNBLK,RR.OPTS,R3                           1.3#11
         BU        CAS.OPTX                                      1.3#11
*                                                                1.3#11
* CHECK FOR 'ACCESS'                                             1.3#11
*                                                                1.3#11
CAS.4.5  BL        STRING          GET (                         1.3#11
         LB        R4,CCDLIM       SHOULD BE                     1.3#11
         CI        R4,G'('         THIS                          1.3#11
         BNE       CARDERR3                                      1.3#11
         LB        R4,CCHRS        SHOULD BE EMPTY               1.3#11
         BNE       CARDERR3                                      1.3#11
         BL        STRING          GET R/W/A/U                   1.3#11
         LB        R4,CCHRS        ONLY ALLOW 1                  1.3#11
         CI        R4,1            ACCESS OPTION                 1.3#11
         BNE       CARDERR3        SHOW IF NOT                   1.3#11
         ZR        R1              SCAN ACCESS OPTION TABLE      1.3#11
         LI        R2,-CASSNK2     NUMBER OF ENTRIES             1.3#11
         LB        R6,CCENT                                      1.3#11
CAS.4.51 CAMB      R6,CASSKEY2,R1                                1.3#11
         BEQ       CAS.4.52        BRANCH IF FOUND               1.3#11
         ABR       R1,31                                         1.3#11
         BIB       R2,CAS.4.51                                   1.3#11
         BU        CARDERR3        BRANCH IF NOT FOUND           1.3#11
CAS.4.52 CI        R1,2            MODIFY NOT ALLOWED            1.3#11
         BEQ       CARDERR3                                      1.3#11
         SLL       R1,2                                          1.3#11
         EXM       CASSACT2,R1     SET THE APPROPRIATE BIT       1.3#11
         LB        R4,CCDLIM       MAKE SURE DELIMITER           1.3#11
         CI        R4,G')'         WAS THIS                      1.3#11
         BNE       CARDERR3        IT WASN'T!                    1.3#11
         BU        CAS.OPTX        AND EXIT                      1.3#11
*                                                                1.3#11
* CHECK FOR 'FORMAT'                                             1.3#11
*                                                                1.3#11
CAS.4.6  BL        STRING          GET F|D|S                     1.3#11
         LB        R5,CCHRS                                      1.3#11
         CI        R5,1            LONG ENOUGH?                  1.3#11
         BNE       CARDERR3        NOPE - GO TELL                1.3#11
         SRL       R6,24           GET THE REQUEST               1.3#11
         CI        R6,G'F'         FIXED?                        1.3#11
         BEQ       CAS.4.61        YUP                           1.3#11
         CI        R6,G'D'         VARIABLE?                     1.3#11
         BEQ       CAS.4.61        YUP                           1.3#11
         CI        R6,G'S'         SPANNED?                      1.3#11
         BNE       CARDERR3        NOPE - GO INFORM              1.3#11
CAS.4.61 STB       R6,RR_FORM,R3   STUFF IN RRS                  1.3#11
         BU        CAS.OPTX        GO EXIT                       1.3#11
*                                                                1.3#11
* CHECK FOR PROT                                                 1.3#11
CAS.4.7  BL        STRING          GET A BYTE                    1.3#11
         LB        R5,CCHRS                                      1.3#11
         CI        R5,1            LENGTH OK?                    1.3#11
         BNE       CARDERR3        NOPE                          1.3#11
         STB       R4,RR_PROT,R3   STUFF IT IN BUILDING RRS      1.3#11
         BU        CAS.OPTX                                      1.3#11
*                                                                1.3#11
* CHECK FOR 'BSIZE'                                              1.3#11
*                                                                1.3#11
CAS.4.8  BL        STRING          GET SIZE FIELD                1.3#11
         LB        R5,CCHRS                                      1.3#11
         BZ        CARDERR2        BRANCH IF BLANK FIELD         1.3#11
         M.CONADB                  CONVERT TO BINARY (+VALIDATE) 1.3#11
         TRR       R6,R6                                         1.3#11
         BZ        CARDERR3        BRANCH IF ILLEGAL CHARACTER   1.3#11
         STH       R7,RR_BSIZE,R3  STORE IN RRS                  1.3#11
         BU        CAS.OPTX        AND EXIT                      1.3#11
         SPACE     3                                             1.3#11
* HANDLE 'GENV'                                                  1.3#11
CAS.4.9  BL        STRING                                        1.3#11
         LB        R5,CCHRS        GET SIZE (2 CHARS)            1.3#11
         BZ        CARDERR2        MUST BE SOME                  1.3#11
         CI        R5,2            2 CHARS MAX                   1.3#11
         BGT       CARDERR3        GO IF TOO LONG                1.3#11
         M.CONADB                  CHECK ASCII DIGITS            1.3#11
         TRR       R6,R6           VALID?                        1.3#11
         BZ        CARDERR3        BAD CHARACTERS                1.3#11
         TRR       R7,R5           REGAIN VALUE                  1.3#11
         M.CONBAD                  BACK TO ASCII                 1.3#11
         STW       R7,RR_GENV,R3   STUFF INTO RRS                1.3#11
         BU        CAS.OPTX        AND PROCEEEEED                1.3#11
*                                                                1.3#11
*        ASSUME REGULAR VOLUME RESOURCE TYPE PATH NAME           1.3#11
*                                                                1.3#11
* THIS FORMS A TYPE 1 RRS WHOS LENGTH IS 4 WORDS PLUS THE NUMBER
* OF WORDS CONSTITUTING THE PATHNAME.
*
CASSG.61 EQU       $               HERE FOR REGULAR VOLUME TYPE  1.3#11
         LI        R6,73           EVALUATE MAX POSS PATHNAME .....
         SUMW      R6,CCSTRT       ..... LENGTH AND SAVE .....
         STW       R6,CASSG91      ..... FOR ACTUAL LENGTH CALC.
         LA        R7,MDBUF        FORM PARAMETER LIST FOR .....
         ADMW      R7,CCSTRT       .....
         SLL       R7,8            .....
         SRLD      R6,8            .....
         TRR       R7,R1           .....
         LA        R5,LMOLDIND     ..... (DUMMY BUFFER FOR SVC)
         SLL       R5,8            .....
         LI        R4,254          .....
         SRLD      R4,8            .....
         TRR       R5,R4           .....
         ZR        R7              ..... H.VOMM15 CALL
         M.PNAMB                   H.VOMM,15
         BS        CARDERR3        BRANCH IF ERRORS IN FORMAT
*
* EVALUATE SIZE OF PATHNAME RECOGNISED, MAKE SURE THERE IS ROOM
* IN THE RRS TABLE FOR IT, COPY IT TO THE RRS ENTRY AND FINALLY
* UPDATE THE INPUT POINTER READY FOR PROCESSING OPTIONS.
*
         LW        R7,CASSG91      MAXIMUM POSSIBLE LENGTH
         SRL       R1,24           CHARS REMAINING ON LINE
         SUR       R1,R7           CHARS IN PATHNAME INTO R7
         LW        R6,CCSTRT       UPDATE CCPTR TO AFTER .....
         ADR       R7,R6           .....
         STB       R6,CCPTR        ..... PATHNAME
         SRL       R4,24           RIGHT JUSTIFY PATHNAME LENGTH
         TRR       R4,R7           SET UP FOR WORD ADJUSTMENT
         SRL       R7,2            EVALUATE NUMBER OF WORDS
CASS.PA1 ADI       R7,RR.1.SIZ     IN PATHNAME PLUS OVERHEAD
         CAMW      R7,MRRSFREE     SEE IF ROOM IN RRS TABLE
         BGT       CARDERR4        BRANCH IF OVERFLOW TO ERROR
         STW       R7,CASSG91      SAVE FOR RRS POINTER UPDATE LATER
*
* BUILD THE RRS ENTRY
*
         LI        R6,RR.PATH      RRS TYPE .....
         STB       R6,RR.TYPE,R3   ..... INTO RRS
*
         STB       R4,RR.PLEN,R3   PATHNAME LENGTH
*
         TRN       R4,R4           LOOP COPYING NAME TO RRS
         TRR       R3,R1           START OF RRS ENTRY
         LA        R2,LMOLDIND     START OF INPUT BUFFER
CASS.PA2 LB        R7,0B,R2        NEXT PATHNAME BYTE .....
         STB       R7,RR.NAME1,R1  ..... INTO RRS
         ABR       R1,31           NEXT RRS ENTRY
         ABR       R2,31           NEXT INPUT BYTE
         BIB       R4,CASS.PA2     AND LOOP
*
* ALL DONE, GET ANY OPTIONS AND THEN FINALLY UPDATE THE RRS POINTERS
*
* THE OPTIONS ARE THE SAME AS FOR ASSIGNING TO A TEMPORARY FILE
* SO UTILISE THE SAME CODE
*
         BU        CASS.TP2
*
* CHECK TO SEE IF A VALID KEYWORD.
* IF NOT FOUND IN THE KEYWORD TABLE ASSUME WE ARE ASSIGNING
* TO A PATHNAME BECAUSE '=' COULD APPEAR IN A PATHNAME IN QUOTES.
*
CASSG.5  ZR        R1              INDEX INTO LOCAL KEYWORD TABLE
         LI        R2,-CASSNK1     NUMBER OF KEYWORDS IN TABLE
CASSG.1  CAMD      R6,CASSKEY1,R1  CHECK FOR A MATCH
         BEQ       CASSG.2         BRANCH IF ONE FOUND
         ABR       R1,28           MOVE TO NEXT ENTRY IN TABLE
         BIB       R2,CASSG.1      AND LOOP FOR NEXT
         BU        CASSG.6         NOT THERE, GO TREAT AS PATHNAME
*
* KEYWORD FOUND SO SPLIT TO A SEPARATE ACTION ROUTINE FOR EACH
*
CASSG.2  SRL       R1,1            FORM WORD INDE TO ADDRESS TABLE
         BU        *CASSACT1,R1    AND GO TO EACH ACTION ROUTINE
*
* ASSIGNMENT TO SBO.
*
* BUILD A TYPE 2 RRS WITH BIT 3 SET IN THE OPTION WORD.
* THE CODE FOR THIS IS THE SAME AS FOR ASSIGNMENT TO SGO
* SO UTILISE COMMON CODE.
*
CASS.SBO ZR        R7              SET UP OPTION WORD .....
         SBR       R7,RR.SBO       ..... IN R7
         BU        CASS.SG1        COMMON WITH SGO
*
* ASSIGNMENT TO SLO.
*
* BUILD A TYPE 2 RRS WITH BIT 2 SET IN THE OPTION WORD.
* THE CODE FOR THIS IS THE SAME AS FOR ASSIGNMENT TO SGO
* SO UTILISE COMMON CODE.
*
CASS.SLO ZR        R7              SET UP OPTION WORD .....
         SBR       R7,RR.SLO       ..... IN R7
         BU        CASS.SG1        COMMON WITH SGO
*
* ASSIGNMENT TO SYC.
*
* BUILD A TYPE 2 RRS WITH BIT 0 SET IN THE OPTION WORD.
* THE CODE FOR THIS IS THE SAME AS FOR ASSIGNMENT TO SGO
* SO UTILISE COMMON CODE.
*
CASS.SYC ZR        R7              SET UP OPTION WORD .....
         SBR       R7,RR.SYC       ..... IN R7
         BU        CASS.SG1        COMMON WITH SGO
*
* ASSIGNMENT TO SGO.
*
* BUILD A TYPE 2 RRS WITH BIT 1 SET IN THE OPTION WORD.
* THE CODE FOR THIS IS COMMON WITH ASSIGNMENT TO SYC.
*
CASS.SGO ZR        R7              SET UP OPTION WORD .....
         SBR       R7,RR.SGO       ..... IN R7
*
CASS.SG1 EQU       $               COMMON SGO/SYC CODE
         LI        R6,RR.2.SIZ     MAKE SURE THERE IS .....
         CAMW      R6,MRRSFREE     ..... ROOM IN THE RRS TABLE .....
         BGT       CARDERR4        ..... BRANCH IF OVERFLOW
*
         STB       R6,RR.SIZE,R3   RRS SIZE
         STW       R7,RR.OPTS,R3   OPTION WORD TO RRS
         LI        R6,RR.TEMP      RRS TYPE
         STB       R6,RR.TYPE,R3
*
* UPDATE THE RRS TABLE POINTERS
*
* FINALLY MAKE SURE THERE ARE NO OPTIONS ON THE LINE
*
         LI        R6,RR.2.SIZ     SIZE OF ENTRY (FIXED PART ONLY USED)
CASSG.8  BL        CMODRRS
*
         BL        STRING          GET OPTION FIELD (IF ANY)
         LB        R5,CCHRS        ANY OPTIONS??
         BNZ       CARDERR3        BRANCH TO ERROR IF ANY OPTIONS
         BU        CASSG.7         COMMON EXIT
         PAGE
*
* ASSIGNMENT TO ANOTHER LFC RECOGNISED
*
* THE LFC MUST BE BETWEEN 1 AND 3 CHARACTERS.
*
* FORM A TYPE 4 RRS.
*
CASS.LFC EQU       $
         BL        STRING          GET LFC NAME
         LB        R5,CCHRS        NUMBER OF CHARS IN LFC
         BZ        CARDERR2        BRANCH TO ERROR IF NO LFC
         CI        R5,3            CHECK IF < 3 CHARS
         BGT       CARDERR3        BRANCH TO ERROR IF > 3 CHARS
         SRL       R6,8            FORM FIRST WORD OF RRS
*
         LI        R4,RR.4.SIZ     MAKE SURETHERE IS ROOM .....
         CAMW      R4,MRRSFREE     ..... IN THE RRS TABLE
         BGT       CARDERR4        BRANCH IF OVERFLOW TO ERROR
*
         STW       R6,RR.SFC,R3    LFC INTO RRS
         STB       R4,RR.SIZE,R3   RRS SIZE
         LI        R6,RR.LFC2      RRS TYPE
         STB       R6,RR.TYPE,R3
         LI        R6,RR.4.SIZ     SIZE OF ENTRY IN WORDS
         BU        CASSG.8         UPDATE RRS PTRS AND CHECK NO OPTIONS
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         PAGE
*
* ASSIGNMENT TO RID
*
CASS.RID EQU       $
         LI        R4,RR.6.SIZ     MAKE SURE THERE IS ROOM .....
         CAMW      R4,MRRSFREE     ..... IN RRS .....
         BGT       CARDERR4        ..... FOR ENTRY, ELSE ERROR
         STW       R4,CASSG91      SAVE FOR COMMON UPDATE LATER
*
         LI        R4,RR.RID       SET UP RRS .....
         STB       R4,RR.TYPE,R3   ..... TYPE
*
         BL        STRING          GET VOLUME NAME
         LB        R5,CCHRS        CHECK BETWEEN 1 AND 16 CHARS .....
         BZ        CARDERR3        ..... ELSE ERROR
         CI        R5,16           .....
         BGT       CARDERR3        ..... AND AGAIN
*
         STD       R6,RR.NAME1,R3  STORE 16 CHAR NAME .....
         LD        R6,CCENT+1D          .....
         STD       R6,RR.NAME1+1D,R3    ..... INTO RRS
*
* LOOP OF 4 OBTAINING BINARY DATE, TIME, BLOCK NUMBER AND RES TYPE
*
         TRR       R3,R2           RRS PTR (GETS UPDATED IN THE LOOP)
         LI        R4,-4           LOOP COUNT
CASS.RD1 BL        STRING          GET NEXT FIELD
         LB        R5,CCHRS        CHECK BETWEEN 1 AND 8 CHARS .....
         BZ        CARDERR3        ..... ELSE ERROR .....
         CI        R5,8            .....
         BGT       CARDERR3        ..... AND AGAIN
         BL        M1602           CONVERT HEX TO BINARY
         CI        R6,0            CHECK FOR ILLEGAL CHARACTERS .....
         BZ        CARDERR3        ..... AND BRANCH IF FOUND
         STW       R7,RR.DATE,R2   SAVE FIELD IN RRS .....
         ABR       R2,29           ..... AND UPDATE RRS PTR
         BIB       R4,CASS.RD1     LOOP FOR NEXT FIELD
*
* ALL DONE, GO GET OPTIONS
*
         BU        CASS.TP2
         PAGE
*
* ASSIGNMENT TO TEMP
*
* BUILD A TYPE 2 RRS WITH OPTIONAL VOLUME NAME IN PARENTHESES
*
* FORMAT IS:       TEMP{=(VOL)} OPTIONS
*             OR
*                  TEMP OPTIONS
*
* ENTRY POINT CASS.TMP IS USED FOR THE FIRST AND CASS.TP5 FOR
* THE SECOND.
*
CASS.TP5 EQU       $               TEMP {OPTIONS} ENTRY POINT
         LI        R6,RR.2.SIZ     SET UP DEFAULT SIZE .....
         STW       R6,CASSG91      ..... FOR RRS POINTER UPDATES
         BU        CASS.TP3        GO PROCESS OPTIONS
*
CASS.TMP EQU       $               TEMP=(VOL) OPTIONS ENTRY POINT
*
         BL        STRING          GET OPTIONAL VOLUME FIELD
         LB        R5,CCHRS        MUST BE 0 WITH '(' DELIMITER
         BNZ       CARDERR3        BRANCH IF FIELD PRESENT
*
         LB        R4,CCDLIM       MAKE SURE DELIMITER IS '('
         CI        R4,G'('
         BNE       CARDERR3        BRANCH IF FORMAT ERROR
*
         BL        STRING          GET VOLUME NAME
         LB        R5,CCHRS        CHECK FOR VOLUME PRESENT
         BZ        CASS.TP4        BRANCH IF NOT PRESENT
         CI        R5,16
         BGT       CARDERR3        BRANCH IF TOO LARGE
*
         LI        R4,RR.2.SIZ+4   MAKE SURE THERE IS ROOM .....
         CAMW      R4,MRRSFREE     ..... IN THE RRS TABLE AND .....
         BGT       CARDERR4        ..... BRANCH TO ERROR IF NOT
*
         STW       R4,CASSG91      SAVE RRS SIZE FOR UPDATE LATER
*
         STW       R6,RR.NAME1,R3  PUT NAME .....
         STW       R7,RR.NAME1+1W,R3    .....
         LD        R6,CCENT+1D
         STW       R6,RR.NAME1+2W,R3    .....
         STW       R7,RR.NAME1+3W,R3    ..... INTO RRS
*
CASS.TP4 LB        R4,CCDLIM       MAKE SURE DELIMITER .....
         CI        R4,G')'         ..... WAS ')'
         BNE       CARDERR3        BRANCH IF NOT ')'
*
* NOW GO AND SEE IF THERE WERE ANY OPTIONS
*
* SET UP RRS TYPE FIRST OF ALL BECAUSE THE OPTION HANDLING IS
* USED BY OTHER TYPES OF ASSIGN ALSO
*
CASS.TP3 LI        R6,RR.TEMP      RRS TYPE .....
         STB       R6,RR.TYPE,R3   ..... INTO RRS
*
CASS.TP2 BL        STRING          GET ANY OPTIONS
         LB        R5,CCHRS        CHECK FOR NONE .....
         BZ        CASS.TP6        ..... AND BRANCH IF NONE
*
* CHECK FOR CONTINUATION ON TO ANOTHER CARD ( '-' SIGN DETECTED)
*
         CAMW      R6,=C'-   '
         BNE       CASS.TP1        BRANCH IF SAME LINE
         BL        XSIRD           GO READ NEXT CARD
         TRR       R5,R5           CHECK FOR EOF AND .....
         BNE       C6              ..... ERROR IF FOUND
         BU        CASS.TP2        ELSE GO GET FIRST OPTION FIELD
*
CASS.TP6 LW        R6,CASSG91      SIZE OF RRS ENTRY
         STB       R6,RR.SIZE,R3   INTO RRS
*
         BL        CMODRRS         UPDATE RRS POINTERS
         BU        CASSG.7         COMMON EXIT
*
* THERE IS AN OPTION, CHECK FOR VALIDITY ON THIS ASSIGN
* CC1 IS SET IF IF OPTION IS DETECTED.
* THE RRS WILL HAVE BEEN UPDATED ALREADY.
* NO RETURN IS MADE IF AN ERROR IS DETECTED.
*
CASS.TP1 BL        CAS.OPT1        SEE IF SHARED/ACCESS/BLOCKED .....
         BS        CASS.TP2        ..... BRANCH IF SO
         BL        CAS.OPT2        SEE IF PRINT/PUNCH .....
         BS        CASS.TP2        ..... BRANCH IF SO
         BU        CARDERR3        ELSE ILLEGAL OPTION - ERROR
         PAGE
*
* ASSIGNMENT TO DEVICE
*
CASS.DEV EQU       $
         LI        R4,RR.3.SIZ     MAKE SURE THERE IS .....
         CAMW      R4,MRRSFREE     ..... ROOM IN THE RRS TABLE .....
         BGT       CARDERR4        ..... BRANCH IF OVERFLOW
*
         BL        STRING          GET DEVICE ASSIGNMENT .....
         BL        CDEV            ..... AND VALIDATE IT
*
* ALL IS O.K. SO SET UP RRS ENTRY
*
         STW       R7,RR.DT3,R3    DEVICE TYPE/CHAN/SUB-CHAN WORD
         STB       R4,RR.SIZE,R3   RRS SIZE
*
         LI        R6,RR.DEVC      RRS TYPE .....
         STB       R6,RR.TYPE,R3   ..... INTO RRS
*
* SEE IF ANY OPTIONS
*
CASSG.10 BL        STRING          GET FIRST OPTION STRING
         LB        R5,CCHRS        CHECK FOR NONE .....
         BZ        CASSG.11        ..... AND BRANCH IF NONE
*
* CHECK FOR CONTINUATION ON TO ANOTHER CARD ( '-' SIGN DETECTED)
*
         CAMW      R6,=C'-   '
         BNE       CASSG.9         BRANCH IF SAME LINE
         BL        XSIRD           GO READ NEXT CARD
         TRR       R5,R5           CHECK FOR EOF AND .....
         BNE       C6              ..... ERROR IF FOUND
         BU        CASSG.10        ELSE GO GET FIRST OPTION FIELD
*
CASSG.11 LI        R6,RR.3.SIZ     UPDATE RRS POINTERS .....
         BL        CMODRRS         ..... TO NEXT FREE ENTRY
         BU        CASSG.7         AND EXIT
*
* THERE IS AN OPTION, CHECK FOR VALIDITY ON THIS ASSIGN.
* CC1 IS SET IF OPTION IS DETECTED.
* THE RRS WILL HAVE BEEN UPDATED ALREADY.
* NO RETURN IS MADE IF AN ERROR IS DETECTED.
*
CASSG.9  BL        CAS.OPT1        SEE IF SHARED/ACCESS/BLOCKED .....
         BS        CASSG.10        ..... BRANCH IF SO
         BL        CAS.OPT3        SEE IF DENSITY/MULTIVOL/ID .....
         BS        CASSG.10        ..... BRANCH IF SO
         BU        CARDERR3        ELSE AN ILLEGAL OPTION - ERROR
         PAGE
*
* THIS ROUTINE CHECKS TO SEE IF THE OPTION KEYWORD IN R6/R7
* IS ONE OF THE SET:
*
*                  SHARED = Y/N
*                  SIZE   = DECIMAL VALUE
*                  ACCESS = (R,W,M,U,A)
*                  BLOCKED= Y/N
*                  BBUF= DECIMAL NUMBER (0 - 255)                1.3#11
*
* IF SO, THE APPROPRIATE BITS ARE SET IN THE CURRENT RRS ENTRY
* AND CC1 IS SET ON EXIT.
*
* IF A MATCH IS NOT FOUND, CC1 IS RESET ON EXIT.
*
* IF AN ERROR IN FORMAT IS DETECTED, AN ERROR EXIT IS TAKEN
* DIRECTLY, AND NO RETURN IS MADE TO THE CALLER.
*
CAS.OPT1 ZBR       R0,1            CLEAR CC1
         STF       R0,COPT90       SAVE CONTEXT
         LB        R4,CCDLIM       SEE IF '=' WAS DELIMITER
         CI        R4,G'='
         BNE       CAS.1.6         BRANCH TO OPTION NOT FOUND EXIT
*
         CAMW      R6,=C'SIZE'     SEE IF SIZE SPECIFICATION
         BNE       CAS.1.0         BRANCH IF NOT 'SIZE'
*
         BL        STRING          GET SIZE
         M.CONADB                  CONVERT TO BINARY
         TRR       R6,R6           NON DECIMAL CHARACTERS?
         BZ        CARDERR3        YES, ILLEGAL FORMAT
         LB        R6,RR.TYPE,R3   CHECK RRS TYPE
         CI        R6,RR.TEMP      IS THIS A TEMP FILE
         BNE       CARDERR3        NO, ILLEGAL OPTION
         STH       R7,RR.PLEN,R3   ELSE, SAVE THE SIZE
         BU        CAS.1.3         COMMON EXIT
CAS.1.0  EQU       $
         CAMW      R6,=C'SHAR'     SEE IF SHARED OPTION
         BNE       CAS.1.1         BRANCH IF NOT 'SHARED'
*
         BL        STRING          GET 'Y' OR 'N'
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF BLANK FIELD TO ERROR
         LB        R4,CCENT        GET FIRST CHAR OF FIELD
         CI        R4,G'Y'         'YES' ??
         BNE       CAS.1.2         BRANCH IF NOT 'Y'
         SBM       RR.SHAR,RR.ACCS,R3      SET SHARED BIT IN RRS
         BU        CAS.1.3         COMMON EXIT
*
CAS.1.2  CI        R4,G'N'         'NO' ??
         BNE       CARDERR3        BRANCH IF NOT 'Y' OR 'N' TO ERROR
         SBM       RR.EXCL,RR.ACCS,R3      SET EXCLUSIVE BIT IN RRS
         BU        CAS.1.3         COMMON EXIT
*
* CHECK FOR 'BLOCKED' OPTION
*
CAS.1.1  CAMW      R6,=C'BLOC'     SEE IF BLOCKED OPTION
         BNE       CAS.1.4         BRANCH IF NOT 'BLOCKED'
*
         BL        STRING          GET 'Y' OR 'N'
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF BLANK FIELD TO ERROR
         LB        R4,CCENT        GET FIRST CHAR OF FIELD
         CI        R4,G'Y'         'YES' ??
         BNE       CAS.1.5         BRANCH IF NOT 'Y'
         SBM       RR.BLK,RR.OPTS,R3       SET BLOCKED BIT IN RRS
         BU        CAS.1.3         COMMON EXIT
*
CAS.1.5  CI        R4,G'N'         'NO' ??
         BNE       CARDERR3        BRANCH IF NOT 'Y' OR 'N' TO ERROR
         SBM       RR.UNBLK,RR.OPTS,R3     SET UNBLOCKED BIT IN RRS
         BU        CAS.1.3         COMMON EXIT
*
* CHECK FOR ACCESS OPTION
*
CAS.1.4  CAMW      R6,=C'ACCE'
         BNE       CAS.2.0         BRANCH IF NOT 'ACCESS'        1.3#11
*
         BL        STRING          GET '('
         LB        R5,CCHRS        SHOULD BE A ZERO COUNT
         BNZ       CARDERR3        BRANCH IF FIELD NOT EMPTY TO ERROR
         LB        R4,CCDLIM       CHECK FOR DELIMITER '('
         CI        R4,G'('
         BNE       CARDERR3        BRANCH IF NOT '(' TO ERROR
*
CAS.1.10 BL        STRING          GET NEXT ACCESS OPTION
         LB        R5,CCHRS        CHECK IF LAST ONE
         BNZ       CAS.1.7         BRANCH IF A FIELD TO LOOK FOR
         LB        R4,CCDLIM       MAKE SURE DELIMITER WAS ')'
         CI        R4,G')'
         BNZ       CARDERR3        BRANCH TO ERROR IF NOT ')'
         BU        CAS.1.3         COMMON EXIT
*
CAS.1.7  ZR        R1              SCAN ACCESS OPTION TABLE
         LI        R2,-CASSNK2     NUMBER OF ENTRIES IN TABLE
         LB        R6,CCENT        GET FIRST CHAR OF OPTION
CAS.1.8  CAMB      R6,CASSKEY2,R1  CHECK FOR A MATCH
         BEQ       CAS.1.9         BRANCH IF A MATCH
         ABR       R1,31           NEXT ENTRY IN TABLE
         BIB       R2,CAS.1.8      ANDLOOP
         BU        CARDERR3        OPTION NOT LEGAL
*
CAS.1.9  SLL       R1,2            WORD INDEX
         EXM       CASSACT2,R1     SET THE APPROPRIATE BIT IN RRS
         LB        R4,CCDLIM       IF DELIMETER WAS ')' .....
         CI        R4,G')'         .....
         BEQ       CAS.1.3         ..... THE EXIT, OPTION FINISHED
         BU        CAS.1.10        CONTINUE PARSE
*                                                                1.3#11
*    CHECK FOR BBUF OPTION                                       1.3#11
*                                                                1.3#11
CAS.2.0  CAMW      R6,=C'BBUF'                                   1.3#11
         BNE       CAS.1.6         EXIT IF OPTION NOT RECOGNIZED 1.3#11
         LB        R5,CCDLIM       GET TERMINATOR                1.3#11
         CI        R5,G'='         IS IT?                        1.3#11
         BNE       CARDERR3        REPORT ERROR                  1.3#11
         LB        R5,RR.TYPE,X3   GET RRS BUILDING              1.3#11
         CI        R5,RR.PATH      IS IT PATHNAME TYPE           1.3#11
         BEQ       $+3W            SKIP IF EQUAL                 1.3#11
         BL        STRING          STEP OVER VALUE               1.3#11
         BU        CARDERR3        AND REPORT ERROR              1.3#11
         BL        STRING          GET ARGUMENT                  1.3#11
         LB        R5,CCHRS        LENGTH                        1.3#11
         BZ        CARDERR2        REPORT ERROR                  1.3#11
         CI        R5,3            >3                            1.3#11
         BGT       CARDERR3        REPORT ERROR                  1.3#11
         BL        M1002           CONVERT                       1.3#11
         TRR       R6,R6           ANY ERRORS                    1.3#11
         BZ        CARDERR3        REPORT ERROR                  1.3#11
         CI        R7,255          CHECK SIZE                    1.3#14
         BGT       CARDERR3        REPORT ERROR                  1.3#14
         STB       R7,7B,X3        ELSE STORE VALUE              1.3#11
         BU        CAS.1.3         AND EXIT                      1.3#11
*
* COMMON EXIT TO CALLER WHEN ALL IS O.K.
*
CAS.1.3  SBM       1,COPT90        SET CC1
*
* COMMON EXIT WHEN KEYWORD NOT RECOGNISED.
*
CAS.1.6  LF        R0,COPT90
         TRSW      R0
         PAGE
*
* THIS ROUTINE CHECKS TO SEE IF THE OPTION KEYWORD IN R6/R7
* IS ONE OF THE SET:
*
*                  SLO
*                  SBO
*
* IF SO, THE APPROPRIATE BITS ARE SET IN THE CURRENT RRS ENTRY
* AND CC1 IS SET ON EXIT.
*
* IF A MATCH IS NOT FOUND, CC1 IS RESET ON EXIT.
*
* IF AN ERROR IN FORMAT IS DETECTED, AN ERROR EXIT IS TAKEN
* DIRECTLY, AND NO RETURN IS MADE TO THE CALLER.
************************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
CAS.OPT2 ZBR       R0,1            CLEAR CC1
         STF       R0,COPT90       SAVE CONTEXT
         CAMW      R6,=C'PRIN'     PRINT ??
         BNE       CAS.2.1         BRANCH IF NOT SLO
         SBM       RR.SLO,RR.OPTS,R3    SET SLO BIT IN RRS
         SBM       RR.SEP,RR.OPTS,R3    SET SEPERATE FILE BIT      V3.1
         BU        CAS.1.3         COMMON EXIT
*
CAS.2.1  CAMW      R6,=C'PUNC'     PUNCH ??
         BNE       CAS.1.6         KEYWORD NOT RECOGNISED EXIT
         SBM       RR.SBO,RR.OPTS,R3    SET SBO BIT IN RRS
         SBM       RR.SEP,RR.OPTS,R3    SET SEPERATE FILE BIT      V3.1
         BU        CAS.1.3         COMMON EXIT
         PAGE
*
* THIS ROUTINE CHECKS TO SEE IF THE OPTION KEYWORD IN R6/R7
* IS ONE OF THE SET:
*
*                  DENSITY = N/P/G/800/1600/6250
*                  MULTIV  = NUMBER
*                  ID      = ID
*
* IF SO, THE APPROPRIATE BITS ARE SET IN THE CURRENT RRS ENTRY
* AND CC1 IS SET ON EXIT.
*
* IF A MATCH IS NOT FOUND, CC1 IS RESET ON EXIT.
*
* IF AN ERROR IN FORMAT IS DETECTED, AN ERROR EXIT IS TAKEN
* DIRECTLY, AND NO RETURN IS MADE TO THE CALLER.
*
CAS.OPT3 ZBR       R0,1            CLEAR CC1
         STF       R0,COPT90       SAVE CONTEXT
         LB        R4,CCDLIM       SEE IF '=' WAS DELIMITER
         CI        R4,G'='
         BNE       CAS.1.6         BRANCH TO OPTION NOT FOUND EXIT
*
* CHECK FOR 'DENSITY' OPTION
*
         CAMW      R6,=C'DENS'     SEE IF DENSITY OPTION
         BNE       CAS.3.1         BRANCH IF NOT 'DENSITY'
*
         BL        STRING          GET DENSITY VALUE
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        BRANCH IF BLANK TO ERROR
*
         ZR        R1              SCAN DENSITY OPTION TABLE
         LI        R2,-CASSNK3     NUMBER OF ENTRIES IN TABLE
CAS.3.3  CAMW      R6,CASSKEY3,R1  CHECK FOR A MATCH
         BEQ       CAS.3.4         BRANCH IF A MATCH
         ABR       R1,29           NEXT ENTRY IN TABLE
         BIB       R2,CAS.3.3      AND LOOP
         BU        CARDERR3        OPTION NOT LEGAL
*
CAS.3.4  SRL       R1,2            FORM BYTE INDEX
         LB        R7,CASSACT3,R1  GET DENSITY BIT VALUE AND .....
         STB       R7,RR.DENS,R3   ..... STORE INTO RRS
         BU        CAS.1.3         COMMON EXIT
*
* CHECK FOR 'MULTIVOL' OPTION
*
CAS.3.1  CAMW      R6,=C'MULT'     SEE IF MULTIVOL OPTION
         BNE       CAS.3.2         BRANCH IF NOT 'MULTIVOL'
*
         BL        STRING          GET VOLUME NUMBER
         LB        R5,CCHRS        CHECK FOR NO FIELD
         BZ        CARDERR2        BRANCH IF BLANK FIELD
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6           CHECK FOR ERROR
         BEQ       CARDERR3        BRANCH IF CONVERSION ERROR
         CI        R7,255          MAKE SURE IT FITS IN A BYTE
         BGT       CARDERR3        BRANCH IF TOO LARGE
         STB       R7,RR.VLNUM,R3  INTO RRS
         BU        CAS.1.3         COMMON EXIT
*
* CHECK FOR 'ID' OPTION
*
CAS.3.2  CAMW      R6,=C'ID  '     SEE IF ID OPTION
         BNE       CAS.1.6         OPTION NOT RECOGNISED EXIT
*
         BL        STRING          GET ID
         LB        R5,CCHRS        MAKE SURE BETWEEN 1 AND 4 CHAR
         BZ        CARDERR2        BRANC IF BLANK FIELD
         CI        R5,4
         BGT       CARDERR3        BRANCH IF >4 CHARS
         STW       R6,RR.UNFID,R3  ID INTO RRS ENTRY
         BU        CAS.1.3         COMMON EXIT
*
* COMMON EXIT FOR END OF ASSIGN COMMAND
*
CASSG.7  LF        R0,CARD90
         TRSW      R0
*
* TABLE FOR RECOGNISING PRIMARY ASSIGN KEYWORDS
*
CASSKEY1 DATAD     C'LFC     '
         DATAD     C'DEV     '
         DATAD     C'TEMP    '
         DATAD     C'RID     '
CASSNK1  EQU       $-CASSKEY1/1D   NUMBER OF ENTRIES
*
* TABLE OF ACTION ROUTINES FOR PRIMARY KEYWORDS
*
CASSACT1 EQU       $
         ACH       CASS.LFC        LFC=
         ACH       CASS.DEV        DEV=
         ACH       CASS.TMP        TEMP=
         ACH       CASS.RID        RID=
*
* TABLE FOR RECOGNISING ACCESS RIGHTS KEYBYTES
*
CASSKEY2 DATAB     C'RWMUA'        READ/WRITE/MOD/UPDATE/APPEND
CASSNK2  EQU       $-CASSKEY2      NUMBER OF ENTRIES
         BOUND     1W
CASSACT2 SBM       RR.READ,RR.ACCS,R3
         SBM       RR.WRITE,RR.ACCS,R3
         SBM       RR.MODFY,RR.ACCS,R3
         SBM       RR.UPDAT,RR.ACCS,R3
         SBM       RR.APPND,RR.ACCS,R3
*
* TABLE FOR RECOGNISING DENSITY KEYWORDS
*
CASSKEY3 DATAW     C'N   '         800
         DATAW     C'P   '         1600
         DATAW     C'G   '         6250
         DATAW     C'800 '         800
         DATAW     C'1600'         1600
         DATAW     C'6250'         6250
CASSNK3  EQU       $-CASSKEY3/1W   NUMBER OF ENTRIES
CASSACT3 DATAB     X'80'           800
         DATAB     X'40'           1600
         DATAB     X'02'           6250
         DATAB     X'80'           800
         DATAB     X'40'           1600
         DATAB     X'02'           6250
         BOUND     1W
*
COPT90   RES       1F
CASSG91  RES       1W              HOLDS 'LFC' FIELD (RRS WORD 1)
         TITLE     CPATH    - LMPATH DIRECTIVE
***********************************************************************
*
*                  CPATH
*
***********************************************************************
*
*        PROCESS LMPATH DIRECTIVE
*
***********************************************************************
CPATH    STF       R0,CARD90
         LI        R7,-XPNBSIZ     XPNB SIZE (IN BYTES)
         ZR        R1              INDEX FOR ZAPPING
CPATH.1  ZMD       XPNB,R1         ZERO NEXT DOUBLE WORD
         ABR       R1,28           NEXT DOUBLE WORD
         BID       R7,CPATH.1      AND LOOP
*
         ZBM       CPTH,CFLGS      INDICATE NO PATH YET          1.3#05
*
* CALL THE CONVERT PATHNAME TO PATHNAME BLOCK SERVICE IN ORDER
* TO VALIDATE THE INPUT.
*
         LB        R2,CCPTR        NEXT POSITION IN INPUT BUFFER
         LA        R7,MDBUF,R2     ACTUAL START ADDRESS
         SLL       R7,8            READY FOR ADDING LENGTH IN TOP BYTE
         LI        R6,72           MAX LINE LENGTH
         SUMB      R6,CCPTR        CHARS REMAINING
         SRLD      R6,8            LENGTH/ADDRESS IN R7
         TRR       R7,R1           READY FOR SVC CALL
*
         LA        R7,XPNB         ADDRESS OF PNB BUFFER
         SLL       R7,8            FOR RIGHT SHIFT LATER
         LI        R6,XPNBSIZ      SIZE IN BYTES OF PNB BUFFER
         SRLD      R6,8            LENGTH/ADDRESS IN R7
         TRR       R7,R4           READY FOR SVC CALL
*
         M.PNAMB                   H.VOMM,15
         BS        CARDERR3        BRANCH IF ERRORS IN PN FORMAT
*
*
*    INDICATE A FILENAME SUPPLIED IF PRESENT                     1.3#05
*
*
         LI        R7,-XPNBSIZ     NEGATIVE BYTES FOR LOOP CONTROL
         ZBM       CRES,CFLGS      RESET FILENAME SUPPLIED FLAG  1.3#05
         LW        R6,=C'!RES'     STRING TO SEARCH FOR
         ZR        R2              INDEX INTO XPNB BUFFER
CPATH.2  CAMW      R6,XPNB,R2      CHECK FOR A MATCH
         BEQ       CPATH.3                                       1.3#05
         ABR       R2,29           MOVE TO NEXT WORD
         BIW       R7,CPATH.2      AND LOOP
         TRR       R4,R5           GET LENGTH FROM SVC           1.3#09
         SRL       R5,24           ISOLATE THE LENGTH            1.3#09
         STW       R5,XRESPOS      AND SAVE AS PONTER TO RES     1.3#09
         STW       R5,BLCK1.PT     SAVE FOR XCORE USE            1.3#14
         BU        CPATH.4         SKIP IF NOT SUPPLIED          1.3#05
CPATH.3  SBM       CRES,CFLGS      INDICATE FILENAME SUPPLIED    1.3#05
         STW       R2,XRESPOS      AND SAVE                      1.3#09
         STW       R2,BLCK1.PT     AND STORE FOR XCORE USE       1.3#11
*
*                                                                1.3#09
*   NOW TEST IF OPTION 2 IN EFFECT AND WARN IF IT IS             1.3#09
*                                                                1.3#09
CPATH.4  EQU       $                                             1.3#09
         TBM       MOPT2,MFLGS                                   1.3#09
         BNS       CPATH.6         SKIP IF NOT SET               1.3#09
         TBM       CRES,CFLGS      DID LMPATH SET FILENAME       1.3#09
         BS        CPATH.5         ISSUE <<FATAL>> IF IT DID     1.3#09
         LNB       R5,CPAT.M1L     LENGTH                        1.3#09
         LA        R6,CPAT.M1A                                   1.3#09
         BL        XTYPEF                                        1.3#09
         LNB       R5,CPAT.M2L      SECOND LINE                  1.3#09
         LA        R6,CPAT.M2A                                   1.3#09
         BL        XTYPEF                                        1.3#09
         BU        CPATH.6         AND EXIT                      1.3#09
CPATH.5  EQU       $                                             1.3#09
         LNB       R5,CPAT.M3L     FATAL CONDITION               1.3#09
         LA        R6,CPAT.M3A                                   1.3#09
         BL        XTYPEF                                        1.3#09
         LNB       R5,CPAT.M4L     SECOND LINE                   1.3#09
         LA        R6,CPAT.M4A                                   1.3#09
         BL        XTYPEF                                        1.3#09
         BU        CARDERR3     DO OLD STYLE MSG TO SET FLAGS    1.3#09
CPATH.6  EQU       $                                             1.3#09
*
* ALL LOOKS O.K., SAVE THE LENGTH OF THE PNB IN XPATHLEN
* SO A FILE PORTION CAN BE APPENDED LATER.
* ALSO SET MPATH FLAG TO INDICATE A GOOD PATHNAME HAS BEEN DETECTED.
*
         STW       R4,XPNBDESC     SAVE VECTOR FOR LATER USE     1.3#05
         SRL       R4,24           LENGTH RETURNED BY SVC
         STW       R4,XPATHLEN     SAVE FOR LATER
         SBM       CPTH,CFLGS      INDICATE A PATH FOUND         1.3#05
         BU        CARDEXIT        AND EXIT
*                                                                1.3#09
CPAT.M1A DATAB     C' CATALOG(WARNING) LMPATH DIRECTIVE WITH'    1.3#09
         DATAB     C' OPTION 2.'                                 1.3#09
CPAT.M1L DATAB     $-CPAT.M1A                                    1.3#09
*                                                                1.3#09
CPAT.M2A DATAB     C'  OVERLAY FILES CAN ONLY BE EXECUTED FROM'  1.3#09
         DATAB     C'   @@SYSTEM(SYSTEM)  '                       1.3#09
CPAT.M2L DATAB     $-CPAT.M2A                                    1.3#09
*                                                                1.3#09
CPAT.M3A DATAB     C' CATALOG<<FATAL>> LMPATH DIRECTIVE WITH'    1.3#09
         DATAB     C' OPTION 2.'                                 1.3#09
CPAT.M3L DATAB     $-CPAT.M3A                                    1.3#09
*                                                                1.3#09
CPAT.M4A DATAB     C'  FILENAME MUST COME FROM CATALOG/BUILD'    1.3#09
         DATAB     C' DIRECTIVE.'                                1.3#09
CPAT.M4L DATAB     $-CPAT.M4A                                    1.3#09
         BOUND     1W
*                                                                1.3#09
*----------------------------------------------------------------1.3#09
         TITLE     CEXTD     - EXTDMPX DIRECTIVE                EBRM-33
************************************************************************
*
*                  CEXTD                                        EBRM-33
*
************************************************************************
*
*        PROCESS THE EXTDMPX DIRECTIVE                          EBRM-33
*
************************************************************************
CEXTD    EQU       $                                            EBRM-33
         STF       R0,CARD90       SAV REGS                     EBRM-33
         BL        STRING          GET NEXT FIELD               EBRM-33
         LB        R5,CCHRS        GET FIELD LENGTH             EBRM-33
         BZ        CARDERR2        IF NO NEXT FIELD, ERROR      EBRM-33
         CAMW      R6,TSA          WAS TSA NEXT FIELD?          ETSA-32B
         BEQ       CARDERR2        ERROR IF NO EXTDMPX VALUE    ETSA-32B
         CAMD      R6,NTSA         WAS NOTSA NEXT FIELD?        ETSA-32B
         BEQ       CARDERR2        ERROR IF NO EXTDMPX VALUE    ETSA-32B
         CAMW      R6,NOT          WAS NOTSA ABBREVIATED        ETSA-32C
         BEQ       CARDERR2        ERROR IF NO EXTDMPX VALUE    ETSA-32C
         CAMD      R6,STSA         WAS SYSTSA SPECIFIED         ETSA-32C
         BEQ       CARDERR2        ERROR IF NO EXTDMPX VALUE    ETSA-32C
         CAMW      R6,SYST         WAS SYSTSA ABBREVIATED       ETSA-32C
         BEQ       CARDERR2        ERROR IF NO EXTDMPX VALUE    ETSA-32C
         CAMD      R6,MAXADDR      "MAXADDR" SPECIFIED?         EBRM-33
         BEQ       CEXTD.1         IF YES, BRANCH CEXTD.2       EBRM-33
         CAMW      R6,MAXA         MAXA SPECIFIED               ETSA-32
         BEQ       CEXTD.1         SET VALUE IF SO              ETSA-32
         CAMD      R6,MINADDR      "MINADDR" SPECIFIED?         EBRM-33
         BEQ       CEXTD.2         IF YES, BRANCH CEXTD.3       EBRM-33
         CAMW      R6,MINA         MINA SPECIFIED               ETSA-32
         BEQ       CEXTD.2         SET VALUE IF SO              ETSA-32
*                                                                1.3#11
         LB        R5,CCDLIM       GET DELIMITER                 1.3#11
         CI        R5,G'='         IS IT?                        1.3#11
         BNE       CEXTD.00        ASSUME JUST NUMBERS IF NOT    1.3#11
         CAMW      R6,=C'MBLK'     KEY MUST BE MBLK              1.3#11
         BNE       CARDERR3        REPORT ERROR                  1.3#11
         BL        STRING          ELSE GET VALUE                1.3#11
         LB        R5,CCHRS        GET LENGTH                    1.3#11
         BZ        CARDERR2        REPORT ERROR                  1.3#11
CEXTD.00 EQU       $               MERGE UP                      1.3#11
*                                                                1.3#11
         BL        M1002           CNVT DECIMAL TO BINARY        1.3#11
         TRR       R6,R6           ANY ERROR?                   EBRM-33
         BEQ       CARDERR3        NOT A NUMERIC VALUE, ERROR   EBRM-33
         CI        R7,64           COMPARE TO BOTTOM             1.3#11
         BLT       CARDERR3        REPORT ERROR                  1.3#11
         CI        R7,2048         EXCEEDS UPPER LIMIT?         EBRM-33
         BGE       CARDERR3        IF >= 2048 MAP BLK, ERROR    EBRM-33
         BU        CEXTD.X         JOIN COMMON EXIT             EBRM-33
CEXTD.1  EQU       $               EXTDMPX MAXADDR              EBRM-33
         LI        R7,-1           "-1" MEANS MAXADDR           EBRM-33
         BU        CEXTD.X         JOIN COMMON EXIT             EBRM-33
CEXTD.2  EQU       $               EXTDMPX MINADDR              EBRM-33
         LI        R7,-2           "-2" MEANS MINADDR           EBRM-33
CEXTD.X  EQU       $               COMMON EXIT                  EBRM-33
         STW       R7,EXTDVAL      SAV THE LOG. MAP BLOCK NO.   EBRM-33
         BL        STRING          GET FIELD                    ETSA-32
         LB        R5,CCHRS        ANY CHARACTERS?              ETSA-32
         BZ        CARDEXIT        ERROR IF NOT                 ETSA-32
         CAMW      R6,TSA          IS IT TSA OPTION             ETSA-32
         BEQ       CEXTD.3         SET CORRECT BIT IF SO        ETSA-32
         CAMD      R6,NTSA         IS IT NOTSA OPTION?          ETSA-32
         BEQ       CEXTD.4         SET BIT IF SO                ETSA-32
         CAMW      R6,NOT          NOTSA ABBREVIATED?           ETSA-32C
         BEQ       CEXTD.4         SET BIT IF SO                ETSA-32C
         CAMD      R6,STSA         IS IT SYSTSA OPTION          ETSA-32C
         BEQ       CEXTD.5         SET BIT IF SO                ETSA-32C
         CAMW      R6,SYST         IS SYSTSA ABBREVIATED        ETSA-32C
         BEQ       CEXTD.5         SET BIT IF SO                ETSA-32C
         BU        CARDERR3        INCORRECT SPELLING ERROR     ETSA-32
CEXTD.3  SBM       MTSA,MFLGS      SET EXTENDED TSA BIT         ETSA-32
         BU        CARDEXIT        EXIT                         ETSA-32
CEXTD.4  SBM       MNTSA,MFLGS     SET NON-EXTENDED TSA BIT     ETSA-32
         BU        CARDEXIT        EXIT                         EBRM-33
CEXTD.5  SBM       MSYST,MFLAG3    SHOW SYSTSA OPTION READ      ETSA-32C
         BU        CARDEXIT        EXIT                         ETSA-32C
         TITLE     CCONN     - CONNECT DIRECTIVE
************************************************************************
*
*                  CCONN
*
************************************************************************
*
*        PROCESS THE CONNECT DIRECTIVE
*
************************************************************************
CCONN    STF       R0,CARD90                                      11017
         ABM       7,CCFLD         INCREMENT FIELD COUNT
         LA        R3,MDPD.PNB     GET PATH NAME BLK. BUFFER
         LI        R6,-18          AND CLEAR.
CCONN.05 ZMW       0,X3
         ADI       X3,4            NEXT WORD
         BIB       R6,CCONN.05
         LI        R6,73           EVALUATE MAX POSS PATHNAME .....
         SUMB      R6,CCPTR        ..... LENGTH AND SAVE .....
         STW       R6,CCONN90      ..... FOR ACTUAL LENGTH CALC.
         LA        R7,MDBUF        FORM PARAMETER LIST FOR .....
         ADMB      R7,CCPTR        .....
         SLL       R7,8            .....
         SRLD      R6,8            .....
         TRR       R7,R1           .....
         LA        R5,MDPD.PNB     ..... (DUMMY BUFFER FOR SVC)
         SLL       R5,8            .....
         LI        R4,254          .....
         SRLD      R4,8            .....
         TRR       R5,R4           .....
         ZR        R7              ..... H.VOMM15 CALL
         M.PNAMB                   H.VOMM,15
         BS        CARDERR3        BRANCH IF ERRORS IN FORMAT
*
*
         LW        R7,CCONN90      MAXIMUM POSSIBLE LENGTH
         SRL       R1,24           CHARS REMAINING ON LINE
         SUR       R1,R7           CHARS IN PATHNAME INTO R7
         LB        R6,CCPTR        UPDATE CCPTR TO AFTER .....
         ADR       R7,R6           .....
         STB       R6,CCPTR        ..... PATHNAME
         SRL       R4,24           RIGHT JUSTIFY PATHNAME LENGTH
         TRR       R4,R7           SET UP FOR WORD ADJUSTMENT
         LEA       R3,MDPD.RRS     GET ADDRESS OF RRS
         STB       R7,RR.PLEN,X3   STORE BYTE COUNT OF PNB INTO RRS
         SRL       R7,2            EVALUATE NUMBER OF WORDS
         ADI       R7,4            ADD THE LENGTH OF RRS
         STB       R7,RR.SIZE,X3   AND STORE INTO RRS
         BL        STRING          GET 'TO'
         LB        R5,CCHRS        CHECK FOR BLANK FIELD
         BZ        CARDERR2        IF SO ERROR
         CAMW      R6,=C'TO  '
         BNE       CARDERR3        BRANCH IF NOT TO
CCONN.2  BL        STRING          GET DATAPOOL NAME
         LB        R5,CCHRS        CHECK FOR NONE .....
         BZ        CARDERR3        ERROR IF NOT SPECIFIED
*
* CHECK FOR CONTINUATION ON TO ANOTHER CARD ( '-' SIGN DETECTED)
*
         CAMW      R6,=C'-   '
         BNE       CCONN.4         BRANCH IF SAME LINE
         BL        XSIRD           GO READ NEXT CARD
         TRR       R5,R5           CHECK FOR EOF AND .....
         BNE       C6              ..... ERROR IF FOUND
         BU        CCONN.2         ELSE GO GET FIRST OPTION FIELD
CCONN.4  STD       R6,PARTN        STORE PARTION NAME
         CAMD      R6,DPNAME       IS IT DATA POOL               1.3#15
         BNE       CCONN.41        SKIP IF NOT                   1.3#15
         LW        R5,=G'"@@DPD'    SET UP LFC                    1.3#15
         LI        R3,100          TABLE INDEX                   1.3#15
         BU        CCONN.42        AND MERGE                     1.3#15
CCONN.41 EQU       $               CHECK FOR MULTI-DPOOL         1.3#15
         CAMD      R6,MDPOOL00     SEE IF NAME IS VALID
         BLT       CARDERR3        IF NOT ERROR
         CAMD      R6,MDPOOL99
         BGT       CARDERR3
         LI        R6,G'P'         FORM LFC                      1.3#15
         SLL       R7,8            STRIP THE "L"                 1.3#15
         SLLD      R6,16           GET THE TWO DIGITS            1.3#15
         TRR       R6,R5           AND SAVE THE LFC              1.3#15
         SLL       R6,16           KEEP THE TWO DIGITS           1.3#15
         ORMW      R6,=G'"@@"@@  '   BLANK BOTTOM OF R6            1.3#15
         LW        R7,=G'" " " " ' AND ALL OF R7                 1.3#15
         M.CONADB                  CONVERT TO BINARY
         TRR       R6,R6           VALID NUMBER?                 1.3#15
         BZ        CARDERR3        REPORT ERROR                  1.3#15
         TRR       R7,R3           USE AS INDEX                  1.3#15
CCONN.42 EQU       $               MERGE DATAPOOL,MDPOOL         1.3#15
         SLL       R3,4            MULTIPLY BY 16 FOR TAB INDEX  1.3#15
         LW        R7,DPOOLTAB+DPLFC,X3      GET CONTROL ENTRY   1.3#15
         CI        R7,-1                 IS IT FREE              1.3#15
         BNE       CARDERR8        REPORT DUPLICATES             1.3#15
         STW       R5,CCON.LFC     ELSE SAVE THE LFC             1.3#15
         STW       R3,CCON.NDX            AND INDEX VALUE        1.3#15
CCONN.49 BL        STRING          GET OPTION                    1.3#15
         LB        R5,CCHRS        CHECK FOR NONE
         BZ        CCONN.8         IF NONE BRANCH
         CAMW      R6,=C'-   '     SEE IF CONTINUATION
         BNE       CCONN.5         IF NOT BRANCH
         BL        XSIRD           GO READ NEXT CARD
         TRR       R5,R5           CHECK FOR EOF
         BNE       C6              ERROR IF FOUND
         BU        CCONN.49        ELSE GO GET OPTION            1.3#15
CCONN.5  LB        R4,CCDLIM       SEE IF '=' WAS DILIMITER
         CI        R4,G'='
         BNE       CCONN.6         MUST BE JUST THE NUMBER,BR.
         CAMW      R6,=C'PROT'     SEE IF CORRECT NAME
         BNE       CARDERR3        IF NOT ERROR
         BL        STRING          GET SIZE OF DATAPOOL
CCONN.6  M.CONADB                  CONVERT TO BINARY
         TRR       R6,R6           NON DECIMAL CHARACTERS?
         BZ        CARDERR3        YES, ILLEGAL FORMAT.
         SLL       R7,11           MULTIPLY BY 512W
         STW       R7,CCON.PEA             SAVE SIZE FOR NOW     1.3#15
CCONN.61 BL        STRING          GET OPTION
         LB        R5,CCHRS        CHECK FOR NONE
         BZ        CARDERR2        IF NONE ERROR
         CAMW      R6,=C'-   '     SEE IF CONTINUATION
         BNE       CCONN.65        IF NOT BRANCH
         BL        XSIRD           GO READ NEXT CARD
         TRR       R5,R5           CHECK FOR EOF
         BNE       C6              ERROR IF FOUND
         BU        CCONN.61        ELSE GO GET OPTION
CCONN.65 LB        R4,CCDLIM       SEE IF '=' WAS DILIMITER
         CI        R4,G'='
         BNE       CCONN.7         MUST BE JUST THE NUMBER,BR.
         CAMW      R6,=C'FIRS'     SEE IF CORRECT NAME
         BNE       CARDERR3        IF NOT ERROR
         BL        STRING          GET FIRST PAGE OF DATAPOOL
CCONN.7  M.CONADB                  CONVERT TO BINARY
         TRR       R6,R6           NON DECIMAL CHARACTERS?
         BZ        CARDERR3        YES, ILLEGAL FORMAT.
         CAMW      R7,CLGC         COMPARE TO LOWEST GLOBAL PGE  1.3#15
         BGT       $+2W            SKIP IF >                     1.3#15
         STW       R7,CLGC         ELSE SET LOWEST GLOBAL        1.3#15
         SLL       R7,11           MULTIPLY BY 512 W
         STW       R7,CCON.PSA             SAVE START ADDR       1.3#15
         ADMW      R7,CCON.PEA                ADD SIZE           1.3#15
         STW       R7,CCON.PEA                AND SAVE AS END
         BU        CCONN.85
CCONN.8  EQU       $
         LD        R6,PARTN        GET PARTITION NAME
*
         SBM       XCONNECT,XFLGS  INDICATE CONNECT CALLING      1.3#15
         BL        XCORE                                         1.3#15
         BNS       CCONN.81        SKIP IF FOUND                 1.3#15
         SBM       CDERR,CFLGS     MARK DIRECTIVE ERROR          1.3#15
         BU        CCONN.95        AND RETURN TO DIRECTIVE LOOP  1.3#15
CCONN.81 EQU       $               CONTINUE                      1.3#15
         SLL       R6,11           MULTIPLY SIZE BY 512 W.
         STW       R7,CCON.PSA             STORE STARTING ADDR   1.3#15
         ADR       R6,R7                   CALC END              1.3#15
         STW       R7,CCON.PEA             AND SAVE              1.3#15
CCONN.85 EQU       $
*
         LW        R7,CCON.LFC               GET LFC             1.3#15
         STW       R7,MDPD.RRS               INTO RRS            1.3#15
         M.ASSN    MDPD.RRS        ASSIGN DICTIONARY             1.3#15
         BNS       CCONN.86        CONTINUE IF NO ERROR          1.3#15
         TRR       R7,R5           ERROR CODE                    1.3#15
         M.CONBAD                  CONVERTED TO ACD              1.3#15
         ANMW      R7,=X'0000FFFF'  KEEP TWO DIGITS              1.3#15
         ORMW      R7,=G'RM"@@"@@'   ADD IN QUALIFIER              1.3#15
         LA        R3,CCON.M1D     LOCATE                        1.3#15
         BL        XSTB            AND STUFF                     1.3#15
         LD        R6,PARTN        GET PARTITION NAME            1.3#15
         LA        R3,CCON.M1E     LOCATE                        1.3#15
         BL        XST2            AND STUFF                     1.3#15
         LNB       R5,CCON.M1L                                   1.3#15
         LA        R6,CCON.M1A                                   1.3#15
         BL        XTYPEF                                        1.3#15
         SBM       CDERR,CFLGS     SET DIRECTIVE ERROR           1.3#15
         BU        CCONN.95        AND BACK TO DIRECTIVE LOOP    1.3#15
*                                                                1.3#15
*                                                                1.3#15
CCONNOPN EQU       $               ENTRY FROM CCAT15             1.3#15
         STW       R3,CCON.NDX     SAVE INDEX                    1.3#15
         STD       R6,PARTN        SET PARTITION NAME            1.3#15
         SBM       CCONN.AR,CCONN.FL INDICATE MAGIC ENTRY        1.3#15
CCONN.86 EQU       $               CONTINUE                      1.3#15
         LW        R7,CCON.LFC            GET LFC                1.3#15
         STW       R7,GPFCB1           STORE IN FCB              1.3#15
         LI        R7,X'0A00'       SET 16W FCB & RANDOM         1.3#15
         SLL       R7,16           POSITION AND ZERO             1.3#15
         ZR        R3              AND INDICATE WAIT             1.3#15
         STW       R7,GPFCB1+2W    AND STORE INTO FCB            1.3#15
         LA        R7,MDPD.CNP     SET CNP ADDR                  1.3#15
         LA        R1,GPFCB1       FCB ADDR                      1.3#15
         BL        XOPENR          DO POLITE OPEN                1.3#15
*                           ERROR WENT TO CCONN.98               1.3#15
         LW        R3,GPFCB1+7W    GET FAT ADDR                  1.3#15
         ANMW      R3,=X'00FFFFFF' SAVE ADDR ONLY                1.3#15
         LW        R7,DFT.EOF,X3   GET SIZE                      1.3#15
         BEQ       CCONN.99        IF DPD EMPTY REPORT ERROR    S900707
         SLL       R7,3                                          1.3#15
DPA1     EQU       $                                             1.3#15
         SUI       R7,1        CALC MAX.PRIME IN DICT. FILE SIZE 1.3#15
         TRR       R7,R6                                         1.3#15
         TRN       R7,R5                                         1.3#15
         ADI       R5,2            ITERATIONS = N - 2.           1.3#15
DPA2     EQU       $                                             1.3#15
         SUI       R6,1                                          1.3#15
         TRR       R7,R3                                         1.3#15
         ZR        R2                                            1.3#15
         DVR       R6,R2           DIVIDE N BY N-1, N-2,....,2   1.3#15
         TRR       R2,R2                                         1.3#15
         BZ        DPA1            REMAINDER =ZERO, NOT PRIME    1.3#15
         BIB       R5,DPA2                                       1.3#15
         STW       R7,CCON.PRM              SAVE VALUE           1.3#15
         LW        R3,CCON.NDX     GET TABLE INDEX               1.3#15
         LD        R4,CCON.LFC     GET FIRST HALF OF VALUES      |1.3Q29
         LD        R6,CCON.LFC+1D  GET SECOND HALF OF VALUES     |1.3Q29
         STD       R4,DPOOLTAB,X3  SAVE FIRST HALF               |1.3Q29
         STD       R6,DPOOLTAB+1D,X3    AND SECOND HALF          |1.3Q29
*                                                                1.3#15
CCONN.95 EQU       $                                             1.3#15
         ZBM       CCONN.AR,CCONN.FL       DID CCAT15 CALL US    1.3#15
         BS        CIDPD.9           THEN RETURN THERE           1.3#15
         LF        R0,CARD90       ELSE USE NORMAL RETURN        1.3#15
         TRSW      R0              RETURN
CCONN.FL DATAH     0               CONNECT FLAGS                 1.3#15
CCONN.AR EQU       0     ALTERNATE RETURN, RETURN TO CCAT15      1.3#15
CCONN.98 EQU       $
         LH        R5,MDPD.CNP+5H  GET STATUS                    1.3#15
         M.CONBAD                  CONVERT                       1.3#15
         ANMW      R7,=X'0000FFFF'  KEEP TWO DIGITS              1.3#15
         ORMW      R7,=G'RM"@@"@@'   ADD IN QUALIFIER              1.3#15
         LA        R3,CCON.M2D     LOCATE                        1.3#15
         BL        XSTB            AND STUFF                     1.3#15
         LD        R6,PARTN        GET NAME                      1.3#15
         LA        R3,CCON.M2E     LOCATE                        1.3#15
         BL        XST2            AND STUFF
         LNB       R5,CCON.M2L                                   1.3#15
         LA        R6,CCON.M2A                                   1.3#15
         BL        XTYPEF          REPORT                        1.3#15
         SBM       CDERR,CFLGS     SET DIRECTIVE ERROR           1.3#15
         BU        CCONN.95        AND RETURN TO DIRECTIVE LOOP  1.3#15
CCONN.99 ZR        R4                                           S900707
         LA        R2,MDPD.PNB     GET DPD PATHNAME BLOCK ADDR  S900707
CCONN.9A LW        R5,0,X2         GET 1ST WORD OF PNB          S900707
         SRL       R5,24           JUST FIRST CHARACTER         S900707
         CI        R5,G'!'         IS IT A PNB DELIMITER?       S900707
         BNE       CCONN.9C        NO...BRANCH                  S900707
         ADI       R4,1            INCREMENT DELIMITER COUNT    S900707
         CI        R4,3            HAVE WE SEEN 3 DELIMITERS?   S900707
         BNE       CCONN.9C        NO...BRANCH                  S900707
         ADI       R2,4            INCREMENT PNB POINTER        S900707
         ZR        R3                                           S900707
         ZR        R6                                           S900707
CCONN.9B CI        R6,16           16 CHARACTER PATHNAME LIMIT  S900707
         BGE       CCONN.9E        BRANCH IF AT OR ABOVE LIMIT  S900707
         LB        R5,0,X2         GET DPD FILENAME CHARACTER   S900707
         ADI       R6,1            INCREMENT CHARACTER COUNT    S900707
         CI        R5,G' '         IS CHARACTER A BLANK         S900707
         BEQ       CCONN.9D        BRANCH IF SO                 S900707
         STB       R5,CCON.M3N,X3  SAVE CHARACTER IN ERROR MSG  S900707
         ADI       R2,1            INCREMENT BUFFER POINTERS    S900707
         ADI       R3,1                                         S900707
         BU        CCONN.9B        NEXT CHARACTER               S900707
CCONN.9C ADI       R2,4            INCREMENT PNB POINTER        S900707
         BU        CCONN.9A        NEXT WORD OF PNB             S900707
CCONN.9D ADI       R2,1            SKIP BLANK                   S900707
         BU        CCONN.9B        NEXT CHARACTER               S900707
CCONN.9E LNB       R5,CCON.M3L     GET MESSAGE LENGTH           S900707
         LA        R6,CCON.M3A     GET MESSAGE ADDRESS          S900707
         BL        XTYPE           OUTPUT MESSAGE               S900707
         LNB       R5,CCON.M4L     OUTPUT SECOND PART           S900707
         LA        R6,CCON.M4A                                  S900707
         BL        XTYPE                                        S900707
         BU        XABORT3         AND ABORT                    S900707
*
CCONN90  DATAW     0
PARTN    DATAD     0
CCON.NDX DATAW     0               HOLDS INDEX FOR CURRENT DPOOL 1.3#15
         BOUND     1D                                            |1.3Q29
CCON.LFC DATAW     0               HOLDS LFC   FOR DITTO         1.3#15
CCON.PRM DATAW     0               HOLDS LPRIME VALUE  FOR DITTO 1.3#15
CCON.PSA DATAW     0               HOLDS PRTSTRT FOR  DITTO      1.3#15
CCON.PEA DATAW     0               HOLDS PRTEND  FOR  DITTO      1.3#15
*
         BOUND     1D                                            1.3#15
MDPD.RRS DATAW     0               R R S  FOR M.ASSN
         GEN       8/1,24/0        TYPE 1 RRS
         GEN       1/1,31/0         READ ACCESS, IMPLICIT SHARE  1.3#15
         GEN       5/0,1/1,10/0,16/0  EXPLICIT UNBLOCKED         1.3#15
MDPD.PNB REZ       18W             RESERVE UPTO 18 WORDS FOR PATHNAME
*
MDPD.CNP DATAW     0               C N P FOR OPEN                1.3#15
         ACH       CCONN.98        ERROR RETURN
         GEN       8/1,8/X'24',16/0  READ, IMPL SHARE, UNBLKD    1.3#15
         REZ       3W              AND NOTHING ELSE              1.3#15
*                                                                1.3#15
CCON.M1A DATAB     C' CATALOG<<FATAL>>  ERRROR STATUS: '         1.3#15
CCON.M1D REZ       4B              ERROR CODE                    1.3#15
         DATAB     C'  ASSIGNING DICTIONARY FOR: '               1.3#15
CCON.M1E REZ       8B              PART NAME                     1.3#15
         DATAB     C'.'                                          1.3#15
CCON.M1L DATAB     $-CCON.M1A                                    1.3#15
*                                                                1.3#15
CCON.M2A DATAB     C' CATALOG<<FATAL>>  ERROR STATUS: '          1.3#15
CCON.M2D REZ       4B                                            1.3#15
         DATAB     C'  OPENING DICTIONARY FOR: '                 1.3#15
CCON.M2E REZ       8B              PART NAME                     1.3#15
         DATAB     C'.'                                          1.3#15
CCON.M2L DATAB     $-CCON.M2A                                    1.3#15
*
CCON.M3A DATAB     C' CATALOG<<FATAL>> DATAPOOL DICTIONARY '    S900707
         DATAB     C'FILE : '                                   S900707
CCON.M3N DATAB     C'                '                          S900707
CCON.M3L DATAB     $-CCON.M3A                                   S900707
*
CCON.M4A DATAB     C'                  CONTAINS NO DICTIONARY ' S900707
         DATAB     C'RECORDS.'                                  S900707
CCON.M4L DATAB     $-CCON.M4A                                   S900707
         BOUND     1W                                            1.3#15
*                                                                1.3#15
*----------------------------------------------------------------1.3#15
         TITLE     CBLD     - BUILD DIRECTIVE
***********************************************************************
*
*                  CBLD
*
***********************************************************************
*
*        PROCESS BUILD DIRECTIVE
*
***********************************************************************
CBLD     STF       R0,CCAT90
         TBM       MOPT2,MFLGS     WERE SEPARATE FILES REQUESTED   22001
         BNS       CBLD.1          BR IF SINGLE FILE REQUESTED     22001
*                                                                1.3#09
         LNB       R5,CBLD.M1L     WARN USER                     1.3#09
         LA        R6,CBLD.M1A                                   1.3#09
         BL        XTYPEF                                        1.3#09
         LNB       R5,CPAT.M2L     SECOND LINE                   1.3#09
         LA        R6,CPAT.M2A                                   1.3#09
         BL        XTYPEF                                        1.3#09
*                                                                1.3#09
CBLD.1   ZMD       CATALOG         DISABLE CATALOG DIRECTIVE
         SBM       MBUILD,MFLGS    INDICATE BUILD FOR DEFAULTS
*        SBM       PR.MULTI,MFLAG  FORCE MULTICOPY FOR USER LM'S   22003
         STF       R0,CARD90       RETURN ADDR WHEN CARDERR        12008
         BU        CCAT.1          JOIN CATALOG CODE
*                                                                1.3#09
CBLD.M1A DATAB     C' CATALOG(WARNING) BUILD DIRECTIVE WITH'     1.3#09
         DATAB     C' OPTION 2.'                                 1.3#09
CBLD.M1L DATAB     $-CBLD.M1A                                    1.3#09
         BOUND     1W
*                                                                1.3#09
*----------------------------------------------------------------1.3#09
         TITLE     CCAT     - CATALOG DIRECTIVE
***********************************************************************
*
*                  CCAT
*
***********************************************************************
*
*        PROCESS CATALOG DIRECTIVE
*
***********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
*
FLAGP    EQU       0         CATFLAGS - PRIVILEGED BIT
FLAGU    EQU       1         CATFLAGS - UNPRIVILEGED BIT
FLAGO    EQU       2         CATFLAGS - OVERLAY BIT
FLAGT    EQU       3         CATFLAGS - TRANSIENT AREA BIT
FLAGNUM  EQU       4         CATFLAGS - PRIORITY NUMBER BIT
FLAGNOM  EQU       5         CATFLAGS - NOMAP OPTION BIT
FLAGNOP  EQU       6         CATFLAGS - NO LOAD CREATED BIT
FLAGCAR  EQU       7         CATFLAGS - BINARY CARD OUTPUT BIT
FLAGID   EQU       8         CATFLAGS - TGID VALUE SUPPLIED      1.3#11
*
FLAGSYM  EQU       0         CFLAGS   - SYMBOL TABLE OUTPUT BIT
FLAGRT   EQU       1         CFLAGS   - OLD RTM REAL TIME BIT
FLAGBP   EQU       2         CFLAGS   - OLD RTM BATCH PROGRAM BIT
FLAGSA   EQU       3               CFLAGS - 'SA' OPTION SET BIT
FLAGPGM  EQU       4         CFLAGS   - AT LEAST 1 PROG IN MODULE
*
CATFLAGS REZ       2B                                            1.3#11
CFLAGS   REZ       1B
*
CCAT     STF       R0,CCAT90
         ZMD       BUILD           DISABLE BUILD DIRECTIVE
CCAT.1   EQU       $
         ZBM       CPXRED,CFLGS    CLEAR PROGRAMX FLAG          PR10790
         ZBM       MOBDIR,MFLAG2   CLEAR OBJECT DIRECTIVE FLAG  PR10790
         ZBM       MPRGDIR,MFLAG2  CLEAR PROGRAM XXX FROM FLAG  PR10790
*
*        DO PROCESSING FOR OPTION RELATED STUFF NOW THAT        ENCD-32
*        NO MORE OPTION CHANGES CAN BE MADE                     ENCD-32
*
         TBM       MCATD,MFLAG2   1ST BUILD/CATALOG DIRECTIVE   C019-32
         BS        C8.B           BRANCH IF NOT                 C019-32
         TBM       MOPT1,MFLGS     $OPTION 1 SET?               ENCD-32
         BS        $+4W            NO OVERRIDE BY SET IF SO     ENCD-32
         TBM       MSOP1,MFLAG2    SET NOLIBRARY SPECIFIED?     ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT1,MFLGS     ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT2,MFLGS     $OPTION 2 SET?               ENCD-32
         BS        $+4W            NO OVERRIDE IF SO            ENCD-32
         TBM       MSOP2,MFLAG2    SET MULTIFILE SPECIFIED?     ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT2,MFLGS     ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT3,MFLGS     $OPTION 3 SET                ENCD-32
         BS        $+4W            NO OVERRIDE IF SO            ENCD-32
         TBM       MSOP3,MFLAG2    SET STRICT SPECIFIED         ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT3,MFLGS     ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT4,MFLAG2    $OPTION 4 SET                ENCD-32
         BS        $+4W            NO OVERRIDE IF SO            ENCD-32
         TBM       MSOP4,MFLAG2    SET NODIRECTIVES SPECIFIED   ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT4,MFLAG2    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT5,MFLAG2    $OPTION 5 SET                ENCD-32
         BS        $+4W            NO OVERRIDE IF SO            ENCD-32
         TBM       MSOP5,MFLAG2    SET NOUPDATE SPECIFIED       ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT5,MFLAG2    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT6,MFLAG2    $OPTION 6 SET                ENCD-32
         BS        $+4W            NO OVERRIDE IF SO            ENCD-32
         TBM       MSOP6,MFLAG2    SET SIZE SPECIFIED           ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT6,MFLAG2    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT7,MFLAG2    $OPTION 7 SET                ELST-32C
         BS        $+4W            NO OVERRIDE IF SO            ELST-32C
         TBM       MSOP7,MFLAG2    SET TWOMEG SPECIFIED         ELST-32C
         BNS       $+2W            CONTINUE                     ELST-32C
         SBM       MOPT7,MFLAG2    ELSE SET OPTION FLAG         ELST-32C
*
         TBM       MOPT8,MFLAG3    OPTION 8 SET                 C011-32
         BS        $+4W            FORGET SET DIRECTIVE         C011-32
         TBM       MSOP8,MFLAG3    ELSE TRY SET                 C011-32
         BNS       $+2W            SKIP IF NOT SET              C011-32
         SBM       MOPT8,MFLAG3    ELSE SET AUDIT INDICATOR     C011-32
*
         TBM       MOPT9,MFLAG3    OPTION 9 SET                 EUIC-32
         BS        $+4W            NO OVERRIDE IF SO            EUIC-32
         TBM       MSOP9,MFLAG3    SET NOZERO SPECIFIED         EUIC-32
         BNS       $+2W            CONTINUE IF NOT              EUIC-32
         SBM       MOPT9,MFLAG3    ELSE SET OPTION FLAG         EUIC-32
*
         TBM       MOPT15,MFLGS    $OPTIO 15 SET                ENCD-32
         BS        $+4W            NO OVERRIDE IF SET           ENCD-32
         TBM       MSOP15,MFLAG2   SET INFO SPECIFIED           ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT15,MFLGS    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT18,MFLGS    $OPTION 18 SET               ENCD-32
         BS        $+4W            NO OVERRIDE IF SET           ENCD-32
         TBM       MSOP18,MFLAG2   SET SUPRESS SPECIFIED        ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT18,MFLGS    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT19,MFLGS    $OPTION 19 SET               ENCD-32
         BS        $+4W            NO OVERRIDE IF SET           ENCD-32
         TBM       MSOP19,MFLAG2   SET SYMBOLS SPECIFIED        ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT19,MFLGS    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPT20,MFLGS    $OPTION 20 SET               ENCD-32
         BS        $+4W            NO OVERRIDE IF SET           ENCD-32
         TBM       MSOP20,MFLAG2   SET LIMIT SPECIFIED          ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPT20,MFLGS    ELSE SET OPTION FLAG         ENCD-32
*
         TBM       MOPTTXT,MFLGS   $OPTION TEXT SPECIFIED       ENCD-32
         BS        $+4W            NO OVERRIDE IF SO            ENCD-32
         TBM       MSOPTX,MFLAG2   SET TEXT SPECIFIED           ENCD-32
         BNS       $+2W            CONTINUE                     ENCD-32
         SBM       MOPTTXT,MFLGS   ELSE SET OPTIO FLAG          ENCD-32
*                                                               ENCD-32
         TBM       MOPT19,MFLGS    IS OPTION 19 ON              ENCD-32
         BNS       C8.A            CONTINUE IF NOT              ENCD-32
         TBM       MFILD,MFLAG2    WAS A FILE DIRECTIVE READ    ENCD-32
         BNS       $+3W            CONTINUE IF NOT              ENCD-32
         LB        R5,MTMPFIL      GET USER'S REQUESTED VALUE   ENCD-32
         ARMB      R5,MFILE        ADD TO OVERHEAD              ENCD-32
         TBM       MBUFD,MFLAG2    WAS A BUFFER DIRECTIVE READ  ENCD-32
         BNS       $+3W            CONTINUE IF NOT              ENCD-32
         LB        R5,MTMPBUF      GET USER'S REQUESTED VALUE   ENCD-32
         ARMB      R5,MBUFR        ADD TO OVERHEAD              ENCD-32
         TBM       MSEGF,MFLGS     WAS SEGFILES DIRECTIVE READ  ENCD-32
         BNS       C8.B            CONTINUE                     ENCD-32
         LB        R5,MTMPSEG      GET USER'S REQUESTED VALUE   ENCD-32
         ARMB      R5,MSEGFILE     ADD TO OVERHEAD              ENCD-32
         BU        C8.B            CONTINUE                     ENCD-32
C8.A     TBM       MFILD,MFLAG2    WAS A FILE DIRECTIVE READ    ENCD-32
         BNS       $+3W            GO ON                        ENCD-32
         LB        R5,MTMPFIL      GET USER'S REQUESTED VALUE   ENCD-32
         STB       R5,MFILE        AND SAVE                     ENCD-32
         TBM       MBUFD,MFLAG2    WAS A BUFFER DIRECTIVE READ  ENCD-32
         BNS       $+3W            GO ON                        ENCD-32
         LB        R5,MTMPBUF      GET USER'S REQUESTED VALUE   ENCD-32
         STB       R5,MBUFR        ANS SAVE                     ENCD-32
         TBM       MSEGF,MFLGS     WAS A SEGFILE DIRECTIVE READ ENCD-32
         BNS       C8.B            CONTINUE                     ENCD-32
         LB        R5,MTMPSEG      GET USER'S REQUESTED VALUE   ENCD-32
         STB       R5,MSEGFILE     AND SAVE                     ENCD-32
C8.B     EQU       $                                            ENCD-32
*----
         ABM       31,AID.NCAT    BUMP COUNT OF BUILD/CATL DIRS EAID-32
         LW        R5,AID.NCAT     GET NUMBER OF SEGMENTS       C022-32
         CI        R5,1            ARE THERE OVERLAYS?          C022-32
         BLE       C8.C            NO OVERLAYS...BRANCH         C022-32
         TBM       MDMPG,MFLAG3    DEMAND PAGE MODE SET         C022-32
         BNS       C8.BB           BRANCH IF NOT                C022-32
         LNB       R5,C50.M14L     GET MESSAGE LENGTH           C022-32
         LA        R6,C50.M14A     GET MESSAGE ADDRESS          C022-32
         BL        XTYPE           PUT OUT WARNING MESSAGE      C022-32
         LNB       R5,C50.M15L     2ND HALF LENGTH              C022-32
         LA        R6,C50.M15A     2ND HALF ADDRESS             C022-32
         BL        XTYPE           PUT OUT 2ND HALF OF MESSAGE  C022-32
         ZBM       MDMPG,MFLAG3    CLEAR THE DEMAND PAGE FLAG   C022-32
C8.BB    SBM       MNDMPG,MFLAG3   SET NODEMAND MODE            C022-32
C8.C     ZMW       CCAT91          COUNTER OF LINKBACK ENTRIES  C022-32
         ZBM       CPRED,CFLGS     PROGRAM CARD READ FLAG
         ZBM       CLBIL,CFLGS     RESET DIRECTIVE LEGALITY
         ZBM       CEXIL,CFLGS
         ZBM       CEXPR,CFLGS     RESET EXCLUDE PROCESSED       1.3#02
         ZBM       CINIL,CFLGS     RESET INCLUDE ILLEGAL         1.3#02
         ZBM       CINPR,CFLGS
         LW        R5,MPFST
         STW       R5,MPEXLST      RESET LAST EXCLUDE ADDR       1.3#02
         STW       R5,MPINFST      RESET FIRST INCLUDE POINTER   1.3#02
         STW       R5,MPINLST      RESET LAST INCLUDE POINTER    1.3#02
         STW       R5,MPRFFST      RESET FIRST DYNAMIC REF ADDR  1.3#02
         STW       R5,MPNXT        RESET ACTIVE END OF EXT.T     1.3#02
         ZR        R4              CREATE MODULE ENTRY IN SYMTAB
         ZR        R5
         ZBM       XT.UTOFF,XT.FLGS      TURN ON WARNINGS        1.3#10
         ZBM       XT.LOGED,XT.FLGS      RE-ENBLE ACTION MSG     1.3#10
         ZBM       FLAGPGM,CFLAGS     SET EMPTY MODULE           1.3#10
         TBM       CORGP,CFLGS
         BNS       CCAT.5          BR IF ORIGIN NOT SPECIFIED
         LW        R5,CORGN
CCAT.5   ZR        R6
         ZR        R7
         SBM       MSTMD,MFLGS
         BL        MSYMS           SECOND HALF OF ENTRY
         SBM       MSTMD,MFLGS
         LW        R3,MSYMN
         STW       R3,MMODW        SAVE ITS ADDESS
         SBR       R4,0
         ZR        R5
         TBM       CORGP,CFLGS
         BNS       CCAT.6          BR IF ORIGIN NOT SPECIFIED
         SBR       R4,6
CCAT.6   BL        MSYMS           FIRST HALF OF ENTRY
         ZMB       CFLAGS          ZERO CATALOGER FLAGS
         ZMH       CATFLAGS        ZERO CATALOGER FLAGS          1.3#11
*
*-----------------------------------------------------------------------
*
*      PROCESS CATALOG/BUILD DIRECTIVE PARAMETERS.
*
*                                                                1.3#05
*  FIRST FIELD IS LOADMODULE/TASK  NAME                          1.3#05
*                                                                1.3#05
*
*!!!!!!!!!!BL!!!!!!!!STRING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!|1.3Q17
         BL        STR.CAT                                       |1.3Q17
         LB        R5,CCHRS
         BNZ       CCAT3                                         1.3#05
CCAT1    LI        R5,2B           ILLEGAL BLANK FIELD MSG
CCAT2    BL        CCERR
         BU        CCAT4.5         CONTINUE SCANNING             1.3#11
*
CCAT3    CI        R5,8B
         BLE       CCAT4           BR IF ENTRY NOT OVER 8 CHARACTERS
CCAT35   LI        R5,3B           ILLEGAL ENTRY MSG
         BU        CCAT2
*
CCAT4    EQU       $
         TBM       CRES,CFLGS      DID LMPATH SUPPLY FILE NAME   1.3#11
         BS        CCAT4.00        SKIP IF WE DID                1.3#11
         BL        XVALFILE        VALIDATE THE STRING           1.3#10
         BS        CCAT35          FLAG ERROR                    1.3#10
CCAT4.00 EQU       $                                             1.3#11
         TBM       CCTRD,CFLGS     IS THIS THE FIRST MODULE      1.3#10
         BNS       CCAT4.0         SKIP SEARCH IF IT IS          1.3#10
         LW        R4,=X'80000000'
         ZR        R5
         BL        MSSCH
         TRR       R5,R5
         BNE       CCAT35          BR IF DUPLICATE MODULE NAME
CCAT4.0  EQU       $                                             1.3#10
         STD       R6,2W,R3        SAVE NAME
*
* IF RECATALOGING, ADD NAME TO RECAT TABLE                       1.3#05
         TBM       MRECAT,MFLGS    ARE WE RECATALOGING           1.3#05
         BNS       CCAT4.A         SKIP IF NOT                   1.3#05
         LW        R2,LMENT        GET MODULE COUNT              1.3#05
         SLL       R2,3            CONVERT TO BYTE OFFSET        1.3#05
         STD       R6,LMRECATB,X2  AND STORE NAME                1.3#05
         LI        R2,1            SET TO INCREMENT              1.3#05
         ARMW      R2,LMENT        CONTER                        1.3#05
CCAT4.A  EQU       $                                             1.3#05
*                                                                1.3#05
*
*    SCAN FOR OPTION FIELDS LOOP
*               EXIT TO  CCAT14 ON NULL ARG AND NOT"," DELIMITER
*
CCAT4.5  BL        STRING          OBTAIN OPTION FIELD
         LB        R5,CCHRS        SEE IF ANYTHING IN OPTION FIELD
         BNZ       CCAT4.6         IF SOMETHING THERE, GO PROCESS IT
         LB        R5,CCDLIM       PICK UP LAST DELIMITER
         CI        R5,X'2C'        IF DELIMITER IS ',' THEN
         BEQ       CCAT4.5         THERE MUST BE MORE FIELDS
         BU        CCAT14          ALL THROUGH OPTIONS
*        CHECK FOR 'BP'
CCAT4.6  CAMW      R6,=C'BP'       CHECK FOR RTM 'BP' BATCH
         BNE       CCAT4.7         NOT 'BP', GO ON
         TBM       FLAGBP,CFLAGS   CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         TBM       FLAGRT,CFLAGS   CHECK FOR 'RT'
         BS        CCAT35          IF 'RT' THEN MUTUALLY EXCLUSIVE ERROR
         SBM       FLAGBP,CFLAGS   SET 'BP' FOUND, NO OTHER ACTION REQ.
         BU        CCAT4.5         GET MORE OPTIONS
*        CHECK FOR 'RT'
CCAT4.7  CAMW      R6,=C'RT'       CHECK FOR RTM 'RT' REAL TIME
         BNE       CCAT4.8         NOT 'RT', GO ON
         TBM       FLAGRT,CFLAGS   CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         TBM       FLAGBP,CFLAGS   CHECK FOR BP ALSO
         BS        CCAT35          IF 'BP' & 'RT', THEN ERROR
         SBM       FLAGRT,CFLAGS   SET FOUND FLAG, NO OTHER ACTION REQ.
         BU        CCAT4.5
*        CHECK FOR 'SYM'
CCAT4.8  CAMW      R6,=C'SYM'      CHECK FOR SYMBOL TABLE OUTPUT
         BNE       CCAT4.9
         SBM       30,AID.OCAT    INDICATE OLAYS CATLD SEPARATE EAID-32
         TBM       FLAGSYM,CFLAGS       CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         SBM       FLAGSYM,CFLAGS       SET FOUND FLAG
         SBM       2,1B,R3         SET OPTION FLAG IN MODULE ENTRY
         BU        CCAT4.5         CHECK FOR MORE
*        CHECK FOR 'CAR'
* COMPLETELY NO-OP THIS CAPABILITY. CODE TO SET THE BIT IN THE   GKB-CAR
*            SEGMENT ENTRY REMOVED AT SOME EARLIER TIME.         GKB-CAR
* THIS TIME WE WILL ALSO NOT GENERATE AN ERROR IF ITS WRONG.     GKB-CAR
* WE WILL HOWEVER, SUCCESSFULLY IGNORE IT!                       GKB-CAR
CCAT4.9  CAMW      R6,=C'CAR'      CHECK FOR CARD OUTPUT OF LOAD MOD.
         BNE       CCAT5.0
         BU        CCAT4.5         CHECK FOR MORE
*        CHECK FOR 'NOP'
CCAT5.0  CAMW      R6,=C'NOP'      CHECK FOR NO LOAD MODULE OUPUT
         BNE       CCAT5.1
         TBM       FLAGNOP,CATFLAGS     CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         SBM       FLAGNOP,CATFLAGS     SET FOUND FLAG
         SBM       4,1B,R3         SET OPTION FLAG IN MODULE ENTRY
         BU        CCAT4.5         CHECK FOR MORE
*        CHECK FOR  'NOM'
CCAT5.1  CAMW      R6,=C'NOM'      CHECK FOR NO MEMOREY MAP
         BNE       CCAT5.2
         TBM       FLAGNOM,CATFLAGS     CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         SBM       FLAGNOM,CATFLAGS     SET FOUND FLAG
         SBM       7,1B,R3         SET OPTION FLAG IN MODULE ENTRY
         BU        CCAT4.5
*        CHECK FOR 'P'
CCAT5.2  CAMW      R6,=C'P'        CHECK FOR PRIVILEGED
         BNE       CCAT5.3
         TBM       FLAGP,CATFLAGS  CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         TBM       FLAGU,CATFLAGS  CHECK FOR UNPRIVILEGED
         BS        CCAT35          IF 'U' MUTUALLY EXCLUSIVE ERROR
         TBM       FLAGO,CATFLAGS  CHECK FOR OVERLAY,MUTUALLY EXCLUSIVE
         BS        CCAT35          IF OVERLAY, THEN ERROR
         SBM       FLAGP,CATFLAGS  SET 'P' FOUND
*!!!!!!!!!!LW!!!!!!!!R2,C.TSAD!!!!!!!GET!TSA!ADDRESS!!!!!!!!!!!!C021-32
         M.GTSAD                   GET TSA ADDR                 C021-32
         TRR       R1,R2           INTO R2                      C021-32
         TBM       10,T.ACCESS+1W,R2  IS USER PRIVILEGED?
         BS        CCAT35             BRANCH IF NOT
         SBM       MTYPE,MFLGS     SET PRIVILEGED BIT
         BU        CCAT4.5
*        CHECK FOR 'U'             UNPRIVILEGED
CCAT5.3  CAMW      R6,=C'U'        CHECK FOR UNPRIVILEGED
         BNE       CCAT5.4
         TBM       FLAGU,CATFLAGS  CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         TBM       FLAGP,CATFLAGS  CHECK FOR PRIVILEGED
         BS        CCAT35          MUTUALLY EXCLUSIVE ERROR
         TBM       FLAGO,CATFLAGS  CHECK FOR OVERLAY
         BS        CCAT35          MUTUALLY EXCLUSIVE ERROR
         SBM       FLAGU,CATFLAGS  SET 'U' FOUND FLAG
         ZBM       MTYPE,MFLGS     MARK UNPRIVILEGED
         BU        CCAT4.5
*        CHECK FOR 'O' OVERLAY
CCAT5.4  CAMW      R6,=C'O'        CHECK FOR OVERLAY
         BNE       CCAT5.5
         TBM       FLAGO,CATFLAGS  CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         TBM       FLAGU,CATFLAGS  CHECK FOR UNPRIVILEGED
         BS        CCAT35          IF UNPRIVILEGED,THEN ERROR
         TBM       FLAGP,CATFLAGS  CHECK FOR PRIVILEGED
         BS        CCAT35          IF PRIVILEGED, THEN ERROR
         TBM       FLAGT,CATFLAGS  CHECK FOR TRANSIENT AREA
         BS        CCAT35          IF TRANSIENT,THEN ERROR
         TBM       FLAGNUM,CATFLAGS     CHECK FOR PRIORITY NUMBER
         BS        CCAT35          IF PRIORITY SET, THEN ERROR
         TBM       FLAGRT,CFLAGS   CHECK FOR 'RT'
         BS        CCAT35          IF 'RT' SET, THEN ERROR
         TBM       FLAGBP,CFLAGS   CHECK FOR BATCH PROGRAM
         BS        CCAT35          IF 'BP', THEN ERROR
         TBM       FLAGSA,CFLAGS   CHECK FOR 'SA' OPTION
         BS        CCAT35          IF 'SA' SET, THEN ERROR
         ZMW       M1.TADE         CLEAR NUMBER OF TRANSFER ADDRESSES
         SBM       FLAGO,CATFLAGS  SET OVERLAY FOUND BIT
         TBM       MOPT2,MFLGS     OPTION 2 SET?                S920275
         BS        $+3W            DON'T MODIFY POINTERS IF SO  S920275
         ABM       29,XSYMI1       POINT TO THIS OVERLAY COUNTR EAID-32
         ABM       29,XSRCOV1                                   EAID-32
         ABM       15,COSEQ        INCREMENT SEQUENCE NUMBER
         LW        R5,COVLV        PICKUP OVERLAY COUNT
         STW       R5,1W,R3        STORE IN MODULE ID
         BU        CCAT4.5
*        CHECK FOR 'TRA'
CCAT5.5  CAMW      R6,=C'TRA'      CHECK FOR TRANSIENT AREA
         BNE       CCAT5.51                                      1.3#11
         TBM       FLAGT,CATFLAGS  CHECK FOR DUPLICATE
         BS        CCAT35          IF DUPLICATE, THEN ERROR
         TBM       FLAGO,CATFLAGS  CHECK FOR OVERLAY
         BS        CCAT35          IF OVERLAY, THEN ERROR
         SBM       FLAGT,CATFLAGS  SET TRA FOUND
         LB        R5,CCDLIM       PICKUP LAST DELIMITER
         CI        R5,G'='         SEE IF =
         BNE       CCAT35          IF NOT =, THEN ERROR
         BL        STRING          OBTAIN TRANSIENT SIZE
         LB        R5,CCHRS        ANY VALUE AFTER TRA = ?
         BEQ       CCAT35          NO TRANSIENT SIZE, THEN ERROR
         BL        M1602           CONVERT NUMBER TO BINARY
         TRR       R6,R6           R6 IS ZERO IF ERROR
         BEQ       CCAT35          BR IF CONVERSION ERROR
         ALIGN8W   R7              BOUND TO 8 WORDS
         TBM       MABS,MFLGS      IS PROGRAM ABSOLUTE             21014
         BS        CCAT4.5         BR IF ABSOLUTE                  21014
         STW       R7,MTRNS        SAVE SIZE OF TRANSIENT AREA
         SBM       MTRNSFG,MFLGS   SET TRANSIENT AREA FLAG
         BU        CCAT4.5         RETURN TO LOOP                1.3#13
*                                                                1.3#11
*  CHECK FOR TGID=X    X IS SINGLE HEX DIGIT                     1.3#11
*                                                                1.3#11
*
CCAT5.51 EQU       $               CHECK FOR TGID=               1.3#11
         CAMW      R6,=C'TGID'     WELL, IS IT                   1.3#11
         BNE       CCAT5.55        GO ON TO NEXT IF NOT          1.3#11
         TBM       FLAGID,CATFLAGS  HAVE WE SEEN THIS BEFORE     1.3#11
         BS        CCAT35          REPORT ERROR                  1.3#11
         TBM       FLAGO,CATFLAGS   IS THIS FOR AN OVERLAY       1.3#11
         BS        CCAT35          REPORT ERROR                  1.3#11
         SBM       FLAGID,CATFLAGS  SHOW THIS OPTION             1.3#11
         LB        R5,CCDLIM       GET TERMINATOR                1.3#11
         CI        R5,G'='         IS IT                         1.3#11
         BNE       CCAT35          REPORT ERROR                  1.3#11
         BL        STRING                                        1.3#11
         LB        R5,CCHRS        GET LENGTH OF ARG             1.3#11
         BZ        CCAT35          ERROR IF NONE                 1.3#11
         CI        R5,1            ONE DIGIT ONLY GUYS           1.3#11
         BGT       CCAT35          REPORT ERROR                  1.3#11
         BL        M1602           CONVERT TO BIN                1.3#11
         TRR       R6,R6           WAS IT A HEX DIGIT            1.3#11
         BZ        CCAT35          ERROR IF NOT                  1.3#11
         STB       R7,MTGID        STORE VALUE                   1.3#11
         BU        CCAT4.5         AND ON TO NEXT                1.3#11
*                                                                1.3#11
*        CHECK FOR 'SA'
CCAT5.55 EQU       $
         CAMW      R6,=C'SA'       CHECK FOR SYSTEM ADMINISTRATOR
         BNE       CCAT5.6         BRANCH IF NOT THIS OPTION
         TBM       FLAGSA,CFLAGS   CHECK FOR DUPLICATE
         BS        CCAT35          BRANCH IF DUPLICATE TO ERROR
         SBM       FLAGSA,CFLAGS   SET SA FOUND
         SBM       MSAM,MFLGS      SET SA FOUND FOR PREAMBLE LATER
         BU        CCAT4.5         GO GET NEXT OPTION
*        CHECK FOR PRIORITY NUMBER
CCAT5.6  CI        R5,2            IF PRIORITY, NO MORE THAN 2 CHARACTER
         BGT       CCAT35          TOO MANY PRIORITY CHARACTERS, THEN ER
         LD        R6,CCENT
         BL        M1002           CONVERT TO BINARY
         TRR       R6,R6           CHECK FOR NON NUMERIC CHARACTER
         BEQ       CCAT35          NON NUMERIC, THEN ERROR
         TRR       R7,R7           BINARY VALUE IN R7
         BEQ       CCAT35          VALUE=0, THEN ERROR
         CI        R7,64B          SEE IF RANGE IS 1-64
         BGT       CCAT35          IF > 64, THEN ERROR
         TBM       FLAGO,CATFLAGS  IS THIS AN OVERLAY BEING PROCESSED
         BS        CCAT35          PRIORITY CANNOT BE SET FOR OVERLAY
         STB       R7,MPRIO        SAVE PRIORITY
         SBM       FLAGNUM,CATFLAGS     SET PRIORITY FOUND FLAG
         BU        CCAT4.5         SEE IF MORE
*        CHECK FOR ANY DEFAULTS NEEDED
CCAT14   TBM       FLAGNUM,CATFLAGS     CHECK FOR PRIORITY NUMBER
         BS        CCAT14.1        DON'T NEED DEFAULT
         TBM       FLAGO,CATFLAGS  IS THIS AN OVERLAY BEING PROCESSED
         BS        CCAT14.1        DON'T SET DEFAULT IF OVERLAY
         LI        R7,60
         STB       R7,MPRIO        SET DEFAULT PRIORITY = 60
*        CHECK FOR DEFAULT TASK CATEGORY
CCAT14.1 TBM       FLAGP,CATFLAGS
         BS        CCAT14.2        BRANCH IF PRIVILEGED
         TBM       FLAGU,CATFLAGS
         BS        CCAT14.2        BRANCH IF UNPRIVILEGED
         TBM       FLAGO,CATFLAGS  CHECK FOR OVERLAY
         BS        CCAT14.2        BRANCH IF OVERLAY
         ZBM       MTYPE,MFLGS     NOTHING SET, DEFAULT UNPRIVILEGED
CCAT14.2 EQU       $                                            1.3#11
*CONTINUE
         TITLE     CCAT15 - DO FIRST BUILD/CATALOG PROCESSING
*
* INDICATE CATALOG DIRECTIVE READ AND DO PROCESSING RELATED TO   1.3#04
* FIRST ONLY CATALOG DIRECTIVE.                                  1.3#04
CCAT15   SBM       CCTRD,CFLGS     CATALOG CARD READ FLAG
         BS        CCAT15.X        SKIP IF NOT THE FIRST TIME    1.3#04
*                                                                1.3#10
*        ZAP DIRECTIVES WHICH ARE NOW ILLEGAL                    1.3#10
*                                                                1.3#10
         ZMD       ALLOCATE        RESET LEGALITY OF ALLOCATE,
         ZMD       AS              ASSIGN (SHORT FORM)
         ZMD       ASSIGN          ASSIGN,
         ZMD       VOLUMES         VOLUMES,
         ZMD       SEGFILES        SEGFILES,
         ZMD       FILES           FILES,
         ZMD       BUFFERS         BUFFERS,
         ZMD       ABSOLUTE        ABSOLUTE,
         ZMD       USERNAME        USERNAME,
         ZMD       A1              ASSIGN1,
         ZMD       A2              ASSIGN2,
         ZMD       A3              ASSIGN3,
         ZMD       A4              ASSIGN4,
         ZMD       ENVIRONM        ENVIRONMENT,
         ZMD       OPTION          OPTION,
         ZMD       RECAT           RECATALOG,
         ZMD       MOUNT           MOUNT,
         ZMD       LMPATH          PATHNAME FOR USER LM'S
         ZMD       SYMTAB          AND SYMTAB DIRECTIVES
         ZMD       PASSWORD
         ZMD       CONNECT
         ZMD       EXTDMPX
         ZMD       SPACE
         ZMD       OPSET                                        ENCD-32
         ZMD       LIBRARY                                      ENCD-32
         ZMD       DIRECTRY                                     ENCD-32
         ZMD       FLOATMOD                                     EFLM-33
         ZMD       DEBUGGER                                     EDBG-34
*                                                                1.3#15
*    SEE IF DPD NEEDS TO BE INITIALIZED                          1.3#15
*       AND DO IT IF IT DOES                                     1.3#15
*                                                                1.3#15
         LI        R3,1600         INDEX FOR DPD ENTRY
         LW        R7,DPOOLTAB+DPLFC,X3  GET LFC FROM TABLE      1.3#15
         CI        R7,-1           IS IT INIT'D                  1.3#15
         BEQ       CIDPD.9         SKIP IF NOT ASSIGNED          1.3#15
         LW        R7,DPOOLTAB+LPRIME,X3   ELSE GET LPRIME       1.3#15
         CI        R7,-1           WAS IT DONE BY CONNECT        1.3#15
         BNE       CIDPD.9         SKIP OUT IF IT WAS            1.3#15
         LD        R6,DPNAME       LOOK FOR DATAPOOL PART'N      1.3#15
         BL        XCORE                                         1.3#15
         BNS       CIDPD.1         SKIP IF FOUND                 1.3#15
         SBM       CDERR,CFLGS     SET DIRECTIVE ERROR           1.3#15
         BU        CIDPD.9         AND CONTINUE                  1.3#15
CIDPD.1  EQU       $                                             1.3#15
         SLL       R6,11           CONVERT PAGES TO BYTES        1.3#15
         STW       R7,CCON.PSA              SAVE START           1.3#15
         ADR       R6,R7                  COMPUTE END            1.3#15
         STW       R7,CCON.PEA              AND SAVE             1.3#15
         LW        R7,=G'DPD'      SET LFC                       1.3#15
         STW       R7,CCON.LFC                                   1.3#15
*                                                                1.3#15
         LD        R6,DPNAME       GET DATAPOOL NAME             1.3#15
         BU        CCONNOPN        USE CONNECT CODE TO OPEN      1.3#15
CIDPD.9  EQU       $               MERGE                         1.3#15
*                                                                1.3#05
*    SET PATH NAME BLOCK DEPENDING ON RECATALOG &  LMPATH DIRS   1.3#05
*                                                                1.3#05
         TBM       CRES,CFLGS      DID LMPATH SET FILENAME       1.3#05
         BS        CCAT15.A        SKIP IF IT DID                1.3#05
         TBM       MRECAT,MFLGS    WAS A RECATALOG SPECIFIED     1.3#05
         BS        CCAT15.A        SKIP IF IT WAS                1.3#05
         LW        R1,MMODW        GET SYMTAB ADDR OF THIS SEG   1.3#05
         LD        R6,1D,X1        GET MODULE NAME, USE AS FILE  1.3#05
         STD       R6,XCREATNM     SAVE THIS MODULE NAME AS FILE 1.3#05
CCAT15.A EQU       $                                             1.3#05
         TBM       MCATD,MFLAG2    FIRST TIME THROUGH?          PR12424
         BNS       $+3W            YES...FORM PATHNAME          PR12424
         TBM       MOPT2,MFLGS     SEPARATE LM'S                 1.3#09
         BS        $+2W            SKIP, WILL BE DONE LATER      1.3#09
         BL        XPATH           FORM PATHNAME FROM SUPLD INFO 1.3#05
*
*        IF THIS IS THE FIRST PASS THROUGH, ALLOCATE BBUFF FOR  ENCD-32
*        SGO, DETERMINE SIZE OF OBJECT CODE TEMP FILE AND OPEN  ENCD-32
*        IT.                                                    ENCD-32
*
         TBM       MCATD,MFLAG2    FIRST CATALOG/BUILD DIR      ENCD-32
         BS        CCAT.0          SKIP IF NOT                  ENCD-32
         SBM       MCATD,MFLAG2    SET FLAG IF SO               ENCD-32
         BL        XLOC            SET PARAMS FOR TEMP CREATE   ENCD-32
         M.INQUIRY   SGPNTRS,SGOLFC     GET SGO INFO            ENCD-32
         LW        R1,PNTERS+1W    GET FAT ADDR                  1.3#06
         TBM       5,DFT.STB,X1    IS IT A VOLUME RESOURCE       1.3#06
         BNS       CCAT.00         SKIP IF NOT A VOLUME RES      1.3#06
         TBM       MOPT20,MFLGS    SLOW MODE ENABLED             1.3#06+
         BS        CCAT.00         USE TSA SPACE IF SET          1.3#06+
         LI        R1,SGOBUFSB     GET BUFFER SIZE               1.3#06
         BL        XGETEA          GET THE MEMORY FOR SGO BBUF   1.3#06
         TRR       R2,R2           IS IT OK                      1.3#06
         BZ        CCAT.00         JUST USE TSA AREA IF NO SPACE 1.3#06+
         LI        R1,SGOBUFSS     GET SECTOR SIZE               1.3#06
         SLL       R1,24           POSITION                      1.3#06
         ORR       R1,R2           FORM WORD 15                  1.3#06
         LA        R1,XBIRD91      GET FCB ADDRESS               1.3#06
         STW       R2,15W,X1       AND SET BLOCKING BUFFER ADDR  1.3#06
CCAT.00  LW        R3,SGPNTRS+1W   GET FAT ADDRESS              ENCD-32
         LW        R5,DFT.EOF,X3   GET EOF BLOCK NUMBER         ENCD-32
         CI        R5,200          SGO BIGGER THAN 200 SECTORS? ENCD-32
         BGE       $+2W            USE SGO SIZE IF > 200        ENCD-32
         LI        R5,200          IF SGO < 200, SIZE = 200     ENCD-32
         STW       R5,TMPSIZE      SAVE SIZE FOR LATER          ENCD-32
         SBR       R5,0            SIGNAL TEMP FILE CREATE      ENCD-32
         LA        R1,XTEMP        FCB ADDR                     ENCD-32
         LI        R6,16           ALLOW 16 SEGMENTS            ENCD-32
         BL        XCRETMP         CREATE TEMP OBJ FILE         ENCD-32
         SBR       R1,1            SIGNAL R/W OPEN              ENCD-32
         BL        BB.OPNR         OPEN TEMP OBJ FILE           ENCD-32
         LA        R1,XBIRD91      SGO FCB ADDRESS              ETCM-32
         BL        BB.OPNR         ALLOCATE SGO I/O BUFFERS     ETCM-32
         LA        R1,XOBJECT      OBJ FCB ADDRESS              ETCM-32
         BL        BB.OPNR         ALLOCATE OBJ I/O BUFFERS     ETCM-32
         LA        R2,LT.LIBS      START ADDRESS OF LIB LFCTAB  PR11094
         LA        R4,LT.DIRS      START ADDRESS OF DIR LFCTAB  PR11094
         TRR       R4,R1           COPY DIR ADDR TO R1          PR11094
CCAT.01  CAR       R2,R4           DONE WITH ALL LFC ENTRIES?   PR11094
         BLE       CCAT.0          YES...EXIT                   PR11094
         LW        R5,0,X2         GET LIBRARY ENTRY            PR11094
         BNZ       CCAT.03         BRANCH IF ASSIGNED           PR11094
         LW        R5,0,X1         GET DIRECTORY ENTRY          PR11094
         BZ        CCAT.05         BOTH UNASSIGNED...NEXT       PR11094
         LB        R5,3,X1         GET LAST BYTE OF DIR ENTRY   PR11094
         CI        R5,G'R'         IS IT DIR                    PR11094
         BNE       $+3W            CONTINUE IF NOT              PR11094
         LW        R7,XLB.LIBC     GET LIB LFC                  PR11094
         BU        CCAT.02         PUT IN ERROR MESSAGE         PR11094
         CI        R5,G'D'         IS IT LID                    PR11094
         BNE       $+3W            CONTINUE IF NOT              PR11094
         LW        R7,XLB.LISC     GET LIS LFC                  PR11094
         BU        CCAT.02         PUT IN MESSAGE               PR11094
         LW        R7,0,X1         GET DIRECTORY LFC ENTRY      PR11094
         ANMW      R7,=X'00FFFFFF'  MASK OFF TYPE BYTE          PR11094
         SBR       R7,12            CONVERT TO Lnn LFC          PR11094
CCAT.02  ZMW       0,X1            CLEAR DIRECTORY ENTRY        PR11094
         LA        R3,C50.M11F     LFC LOCATION IN MESSAGE      PR11094
         BL        XSTB            PUT LFC IN MESSAGE           PR11094
         LNB       R5,C50.M11L     MESSAGE LENGTH               PR11094
         LA        R6,C50.M11A     MESSAGE ADDRESS              PR11094
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         BU        CCAT.05         NEXT ENTRY                   PR11094
CCAT.03  LW        R5,0,X1         GET DIRECTORY ENTRY          PR11094
         BNZ       CCAT.05         NEXT ENTRY IF ASSIGNED       PR11094
         LB        R5,3,X2         GET LAST BYTE OF LIB ENTRY   PR11094
         CI        R5,G'B'         IS IT LIB                    PR11094
         BNE       $+3W            CONTINUE IF NOT              PR11094
         LW        R7,XLB.DIRC     GET DIR LFC                  PR11094
         BU        CCAT.04         PUT IN MESSAGE               PR11094
         CI        R5,G'S'         IS IT LIS                    PR11094
         BNE       $+3W            Lnn IF NOT                   PR11094
         LW        R7,XLB.LIDC     GET LID LFC                  PR11094
         BU        CCAT.04         PUT IN MESSAGE               PR11094
         LW        R7,0,X2         GET LIBRARY LFC ENTRY        PR11094
         ANMW      R7,=X'00FFFFFF'  MASK OFF TYPE BYTE          PR11094
         ZBR       R7,12           CONVERT TO Dnn LFC           PR11094
CCAT.04  ZMW       0,X2            CLEAR LIBRARY ENTRY          PR11094
         LA        R3,C50.M12F     LFC LOCATION IN MESSAGE      PR11094
         BL        XSTB            PUT LFC IN MESSAGE           PR11094
         LNB       R5,C50.M12L     MESSAGE LENGTH               PR11094
         LA        R6,C50.M12A     MESSAGE ADDRESS              PR11094
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,C50.M13L     SECOND HALF                  PR11094
         LA        R6,C50.M13A                                  PR11094
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
CCAT.05  ADI       R2,1W           ADJUST POINTERS              PR11094
         ADI       R1,1W                                        PR11094
         BU        CCAT.01         NEXT ENTRY                   PR11094
CCAT.0   EQU       $                                            ENCD-32
*                                                                1.3#05
         BL        XLFCPAK         COMPRESS LFC CONTROL TABLE    1.3#04
         LW        R1,LIBCNT       GET NUMBER OF ACTIVE LIB/DIR  1.3#04
         BZ        CCAT15.X        BRANCH OUT IF NO ACTIVE LIBS  1.3#04
         TBM       MOPT20,MFLGS    IS EXTENDED MEM INHIBITED     1.3#04
         BS        CCAT15.3        BR IF IT IS                   1.3#04
         SLL       R1,6            MULTIPLY BY 64 (16W*4)        1.3#04
         ADI       R1,LIBBFSZ      PLUS SPACE FOR A BUFFER       1.3#04
         BL        XGETEA          MEM FOR LIB FCB'S PLUS BBUF   1.3#04
         TRR       R2,R2           DID WE GET IT                 1.3#04
         BZ        CCAT15.3        BR IF NOT, MEANS NO IMD'S     1.3#04
*                                  AND SHARED FCB FOR LIBS       1.3#04
         BL        XBLDFCB         BUILD DYNAMIC LIB FCB'S       1.3#04
*                                                                1.3#04
* NOW LETS GET THEM DIR'S READ INTO MEMORY                       1.3#04
*                                                                1.3#04
         LW        R1,LIBCNT       GET NUMBER OF ACTIVE LIBS     1.3#04
         SLL       R1,4            MULTIPLY BY 16(4W/ENTRY)      1.3#04+
         BL        XGETEA     GET MEM FOR DIR'S ARRAY BOUND TAB. 1.3#04
         TRR       R2,R2           DID WE GET IT                 1.3#04
         BZ        CCAT15.3        BR IF NOT, MEANS NO IMD'S     1.3#04
*                                                                1.3#04
         STW       R2,LT.DABD      SAVE ADDR OF DIR ABD'S        1.3#04
         ZR        R1              SET UP LFC TAB INDEX          1.3#04
         LW        R4,=X'00FFFFFF' SET UP LFC TAB MASK           1.3#04
         LNW       R3,LIBCNT       SET UP LOOP CONTROL           1.3#10+
         LI        R5,1            DEFAULT ACCESS MODE IS READ   1.3#10
CCAT15.0 EQU       $               LOOP TOP                      1.3#04
         LMW       R7,LT.DIRS,X1   GET DIR LFC                   1.3#04
         STW       R7,GPFCB2       AND SET INTO  FCB             1.3#04
         LA        R7,GPFCB2       GET ADDR OF FCB               1.3#04
         LMW       R6,LT.LIBS,X1   GET ADDR OF LIB FCB           1.3#04
*CAT15.2 EQU       $                                             1.3#04
         BL        XLDOPN          OPEN THIS LIB/DIR PAIR        1.3#04
         BL        XDIRLD          LOAD THIS DIRECTORY           1.3#04
         ABR       R1,29           BUMP LFC TABLE INDEX          1.3#04
         BIB       R3,CCAT15.0     AND LOOP FOR ALL LIB/DIR S    1.3#10+
*                                                                1.3#04
CCAT15.3 EQU       $                                             1.3#04
*   SET UP GPFCB'S (INCASE SOME DISC RESIDENT DIRECTORIES)       1.3#04
         LA        R3,GPBUF1           GET BUFFER ADDR           1.3#04
         STW       R3,GPFCB2+FCB.ERWA  AND PLUG                  1.3#04
         STW       R3,GPFCB1+FCB.ERWA  INTO BOTH FCB'S           1.3#11
         LI        R3,768              SET UP XFER COUNT         1.3#04
         STW       R3,GPFCB2+FCB.EQTY  AND PLUG                  1.3#04
         STW       R3,GPFCB1+FCB.EQTY  INTO BOTH FCB'S           1.3#11
         LA        R3,XLISH.19         GET THE ERROR RETURN ADDR 1.3#04
         STW       R3,GPFCB2+FCB.ERRT  AND PLUG                  1.3#04
         LA        R3,XLIRD.99     LIB READ ERROR RETURN         1.3#11
         STW       R3,GPFCB1+FCB.ERRT   AND PLUG                 1.3#11
CCAT15.X EQU       $                                             1.3#04
*
*-----------------------------------------------------------------------
         TITLE     CCAT16 - PROCESS POST CATALOG DIRECTIVES.
*
*   NOW READ ANY CONTROL STATEMENTS THAT FOLLOW CATALOG OR BUILD
*
CCAT16   BL        XSIRD           READ A DIRECTIVE
         TRR       R5,R5
         BNE       CCAT22          BR ON EOF
         BL        STRING          SCAN IT
         LW        R2,=C'LINK'
         CAMW      R2,CCENT
         BEQ       CCAT161         BR IF LINKBACK DIRECTIVE
         LW        R2,=C'EXCL'
         CAMW      R2,CCENT
         BEQ       CCAT211         BR IF EXCLUDE DIRECTIVE
         LW        R2,=C'INCL'
         CAMW      R2,CCENT
         BEQ       CCAT215         BR IF INCLUDE DIRECTIVE
         LW        R2,=C'PROG'
         LW        R3,=C'RAM '
         CAMD      R2,CCENT
         BEQ       CCAT2110        BR IF PROGRAM DIRECTIVE
         LW        R3,=C'RAMX'
         CAMD      R2,CCENT
         BEQ       CCAT219         BR IF PROGRAMX DIRECTIVE
         LW        R2,=C'OBJE'                                  ENCD-32
         CAMW      R2,CCENT                                     ENCD-32
         BEQ       CCAT21.1        BR IF OBJECT DIRECTIVE       ENCD-32
*   TEST FOR DIRECTIVES LEGAL HERE                               1.3#10
         LD        R2,CCENT        GET THE FIELD VALUE           1.3#13
         CAMW      R2,BUILD                                      |1.3Q33
         BEQ       CCAT16.1        OK, CONTINUE                  1.3#10
         CAMW      R2,CATALOG                                    |1.3Q33
         BEQ       CCAT16.1        OK,CONTINUE                   1.3#10
         CAMW      R2,LORIGIN                                    |1.3Q33
         BEQ       CCAT16.1        OK, CONTINUE                  1.3#10
         CAMW      R2,ORIGIN                                     |1.3Q33
         BEQ       CCAT16.1        OK, CONTINUE                  1.3#10
         LI        R5,1            SET ILLEGAL DIRECTIVE         1.3#10
         BL        CCERR           AND REPORT                    1.3#10
         BU        CCAT16          KEEP TRYING                   1.3#10
CCAT16.1 EQU       $               NORMAL MODULE END             1.3#10
*                                  GO PROCESS OBJ CODE           1.3#10
         SBM       CUDIG,CFLGS     DIRECTIVE IN BUFFER FLAG
         BU        CCAT22
*
*-----------------------------------------------------------------------
*
CLB.MSG  DATAB     C'     LINKBACK MUST PRECEDE  EXCLUDE/'       1.3#10
         DATAB     C'INCLUDE/PROGRAM(X).'                        1.3#10
CLB.MSL  DATAB     $-CLB.MSG                                     1.3#10
*                                                                1.3#10
CEX.MSG  DATAB     C'     EXCLUDE MUST PRECEDE  INCLUDE/'        1.3#10
         DATAB     C'PROGRAM(X).'                                1.3#10
CEX.MSL  DATAB     $-CEX.MSG                                     1.3#10
*                                                                1.3#10
CIN.MSG  DATAB     C'     INCLUDE MUST PRECEDE  PROGRAM(X).'     1.3#10
CIN.MSL  DATAB     $-CIN.MSG                                     1.3#10
*                                                                1.3#10
CPX.MSG  DATAB     C'     PROGRAMX  ILLEGAL WITH  PROGRAM.'      1.3#10
CPX.MSL  DATAB     $-CPX.MSG                                     1.3#10
         BOUND     1W                                            1.3#10
*
         TITLE     CCAT161 - PROCESS LINKBACKS
*
*    HERE FOR "LINKBACK"  DIRECTIVE
*
CCAT161  LW        R3,CCATR3       RELOAD SAVED R3 FOR ENTRY INDEX
         TBM       CLBIL,CFLGS
         BNS       CCAT17          PROCEED IF LEGAL              1.3#02
CCAT162  LI        R5,1B           PROGRAM CARD READ
         BL        CCERR           ILLEGAL DIRECTIVE MSG
         LNB       R5,CLB.MSL                                    1.3#10
         LA        R6,CLB.MSG                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BU        CCAT16
*
CCAT17   BL        STRING          OBTAIN MODULE NAME
         LB        R5,CCHRS
         BNZ       CCAT18          BR IF ENTRY IS PRESENT
CCAT172  LI        R5,2B           ILLEGAL BLANK FIELD MSG
         BL        CCERR
         BU        CCAT16
CCAT18   CI        R5,8B
         BGT       CCAT20          BR IF MORE THAN 8 CHARACTER ENTRY
         LW        R5,CCAT91
         BNE       CCAT19          BR IF MORE LINKBACK ENTRIES AVAILABLE
         ZR        R4
         ZR        R5
         ZR        R6
         ZR        R7
         LW        R3,MSYMN
         ADI       R3,3W           ENTRY INDEX
         SBM       MSTMD,MFLGS
         BL        MSYMS           RESERVE 4 LINKBACK ENTRIES
         LI        R5,-4B
         STW       R5,CCAT91       ENTRY COUNTER
CCAT19   LW        R4,=X'80000000'
         ZR        R5
         LD        R6,CCENT
         BL        MSSCH           SEARCH FOR SPECIFIED MODULE
         TRR       R5,R2
         BNE       CCAT205         BR IF MODULE FOUND
CCAT20   LI        R5,3B           ILLEGAL ENTRY MSG
         BL        CCERR
         BU        CCAT21
CCAT205  LW        R1,MMODW
         LW        R5,1W,R2
         BEQ       CCAT21          IGNORE IF MAIN
         BL        MLINK
         TRR       R5,R5
         BNE       CCAT20          BR IF ALREADY LINKED TO SPECIFIED MOD
         CAMW      R2,MMODW
         BEQ       CCAT20          BR IF CURRENT MODULE SPECIFIED
         LH        R5,1W,R2
         CAMH      R5,1W,R1
         BEQ       CCAT20          BR IF OVERLAY AT SAME LEVEL
         LW        R5,1W,R2
         STW       R5,0,R3         STORE LINKBACK ENTRY
         ABM       7,3B,R1         INCREMENT ENTRY COUNT
         SUI       R3,1W           UPDATE INDEX
         ABM       31,CCAT91
CCAT21   BL        STRING
         LB        R5,CCHRS
         BNE       CCAT18          PROCESS ADDITIONAL ENTRY
         STW       R3,CCATR3       SAVE ENTRY INDEX POINTER
         BU        CCAT16
*
*-----------------------------------------------------------------------
         TITLE     CCAT211 - PROCESS EXCLUDE DIRECTIVES
*
*   HERE TO PROCESS   "EXCLUDE" DIRECTIVES.
*
CCAT211  EQU       $                                             1.3#02
         TBM       CEXIL,CFLGS     ARE EXCLUDES ILLEGAL          1.3#02
         BNS       CCAT2111        SKIP IF NOT                   1.3#02
         LI        R5,1                                          1.3#10
         BL        CCERR           ILLEGAL DIRECTIVE             1.3#10
         LNB       R5,CEX.MSL                                    1.3#10
         LA        R6,CEX.MSG                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BU        CCAT16          BACK TO DIRECTIVE LOOP        1.3#10
*                                                                1.3#10
CCAT2111 EQU       $                                             1.3#10
         SBM       CLBIL,CFLGS     LINKBACKS NOW ILLEGAL         1.3#10
*
         BL        STRING          GET ARUGEMT                   1.3#02
         LB        R5,CCHRS
         BZ        CCAT172         BR IF NO ENTRY
CCAT212  CI        R5,8B
         BLE       CCAT2122        BR IF NOT MORE THAN 8 CHARACTER ENTRY
         LI        R5,3B           ILLEGAL ENTRY MSG
         BL        CCERR
         BU        CCAT2133
*---                                                             1.3#02
CCAT2122 LW        R1,MPNXT        OBTAIN NXT EX REF STORAGE ADDRESSS
         CAMW      R1,MSYMN        IS THERE ROOM IN THE TABLE FOR IT.
         BLT       CCAT213         BR IF NO CLASH WITH SYMTAB
CCAT2123 LA        R6,MSOFMSG      SYMBOL TABLE OVERFLOW MSG
         LNB       R5,MSOFMLN                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BL        XABORT           EXIT FROM CATALOG
CCAT213  EQU       $                                             1.3#02
         LD        R6,CCENT        GET THE SYMBOL                1.3#02
         SBR       R6,0            SHOW IT AS EXCLUDED           1.3#02
         BL        MEADD           GO ADD TO EXTERNAL TABLE      1.3#02
         BCT       1,CCAT2133      SKIP IF NOT ADDED             1.3#02
         SBM       CEXPR,CFLGS     SHOW AN EXCLUDE PROCESSED     1.3#02
         STW       R1,MPEXLST      SET CURRENT LAST EXCLUDE      1.3#02
         LW        R1,MPNXT        ADVANCE ALL OTHER TABLES     S8701186
         STW       R1,MPINFST      BUMP UP INCLUDE FST           1.3#02
         STW       R1,MPINLST      AND LAST                      1.3#02
         STW       R1,MPRFFST      AND FIRST REF                 1.3#02
CCAT2133 BL        STRING
         LB        R5,CCHRS
         BNZ       CCAT212         BR IF ADDITIONAL ENTRY IS PRESENT
         BU        CCAT16
*
*-----------------------------------------------------------------------
         TITLE     CCAT215 - PROCESS INCLUDE DIRECTIVES
*
*   HERE TO PROCESS   "INCLUDE"  DIRECTIVES
*
CCAT215  EQU       $                                             1.3#02
         TBM       CINIL,CFLGS     ARE INCLUDES ILLEGAL          1.3#02
         BNS       CCAT2151        SKIP IF NOT                   1.3#02
         LI        R5,1                                          1.3#10
         BL        CCERR                                         1.3#10
         LNB       R5,CIN.MSL                                    1.3#10
         LA        R6,CIN.MSG                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BU        CCAT16          BACK TO DIECTIVE LOOP         1.3#10
*                                                                1.3#10
CCAT2151 EQU       $                                             1.3#10
         SBM       CLBIL,CFLGS     LINKBACK NOW ILLEGAL          1.3#10
         SBM       CEXIL,CFLGS     EXCLUDE NOW ILLEGAL           1.3#10
*
         BL        STRING
         LB        R5,CCHRS
         BZ        CCAT172         BR IF NO ENTRY
CCAT216  CI        R5,8B
         BLE       CCAT217         BR IF NOT MORE THAN 8 CHARACTER ENTRY
CCAT2166 LI        R5,3B           ILLEGAL ENTRY MSG
         BL        CCERR
         BU        CCAT218
*---                                                             1.3#02
CCAT217  EQU       $                                             1.3#02
         LW        R1,MPNXT        GET NEXT EXT.T SLOT ADDR      1.3#02
         CAMW      R1,MSYMN        TEST IF EX REF TABLE IS FULL
         BGE       CCAT2123        IF YES, SYMBOL TBL OVERFLOW ERROR
*---                                                             1.3#02
         LD        R6,CCENT        GET INCLUDED NAME
         BL        MEADD            ADD TO EXTERNAL TABLE        1.3#02
         BCT       1,CCAT218       SKIP IF NOT ADDED             1.3#02
         SBM       CINPR,CFLGS     SHOW AN INCLUDE DONE          1.3#02
         BS        CCAT2172        SKIP IF NOT THE FIRST         1.3#02
         STW       R1,MPINFST      SET ADDR OF FIRST INCLUDE     1.3#02
CCAT2172 EQU       $                                             1.3#02
         STW       R1,MPINLST      SET ADDR OF LAST INCLUDE      1.3#02
         LW        R1,MPNXT        ADVANCE THE REF TABLE        S8701186
         STW       R1,MPRFFST      AND FIRST DYNAMIC REF         1.3#02
CCAT218  BL        STRING          OBTAIN NEXT ENTRY
         LB        R5,CCHRS
         BZ        CCAT16          BR IF NONE
         BU        CCAT216
*
*-----------------------------------------------------------------------
         TITLE     CCAT219 - PROCESS PROGRAMX DIRECTIVE
*
*   HERE TO PROCESS "PROGRAMX" DIRECTIVES.
*
CCAT219  TBM       CPRED,CFLGS
         BNS       CCAT2190        SKIP IF NOT ILLEGAL
         LI        R5,1            ILLEGAL                       1.3#10
         BL        CCERR                                         1.3#10
         LNB       R5,CPX.MSL                                    1.3#10
         LA        R6,CPX.MSG                                    1.3#10
         BL        XTYPEF                                        1.3#10
         BU        CCAT16          BACK TO DIRECTIVE LOOP        1.3#10
*                                                                1.3#10
CCAT2190 EQU       $                                             1.3#10
         SBM       CPXRED,CFLGS    INDICATE PROGRAMX DIR. READ  ENCD-32
*!!!!!!!!LW!!!!!!!!R1,MPNXT!!!!!!!!GET!ADDR!OF!NEXT!EXT.T1.3#02!S8701186
*!!!!!!!!STW!!!!!!!R1,MPRFFST!!!!!!AND!SAVE!AS!THE!LAST!I1.3#02!S8701186
*!!!!!!!!BU!!!!!!!!CCAT23!!!!!!!!!!AND!CONTINUE!!!!!!!!!!!!!!!!!PR10790
         BU        CCAT16          AND CONTINUE                 PR10790
*
*-----------------------------------------------------------------------
         TITLE     CCAT2110 - PROCESS PROGRAM DIRECTIVES
*
*    HERE TO PROCESS   "PROGRAM"  DIRECTIVES
*
CCAT2110 EQU       $                                             1.3#02
*
         SBM       CLBIL,CFLGS     LINKBACK NOW ILLEGAL          1.3#10
         SBM       CEXIL,CFLGS     EXCLUDE TOO                   1.3#10
         SBM       CINIL,CFLGS     AND INCLUDE                   1.3#10
         BL        STRING          OBTAIN PROGRAM NAME          ENCD-32
         STD       R6,PNAME        SAVE PROGRAM NAME            ENCD-32
         LB        R5,CCHRS        GET NAME LENGTH              ENCD-32
         STB       R5,PCHARS       AND SAVE                     ENCD-32
         BL        STRING          GET NEXT FIELD OF INPUT      ENCD-32
         STD       R6,PNAME2       SAVE SECOND FIELD            ENCD-32
         LB        R5,CCHRS                                     ENCD-32
         STB       R5,PCHARS2      SAVE CHAR COUNT              ENCD-32
         TRR       R5,R5           WAS THERE ANY?               ENCD-32
         BNE       CCAT21.8        CONTINUE IF SO               ENCD-32
         LD        R6,PNAME        RESTORE PROGRAM NAME         ENCD-32
         LB        R5,PCHARS       AND CHAR COUNT               ENCD-32
         BU        CCAT2112        MERGE                        ENCD-32
CCAT21.8 CAMW      R6,=C'FROM'     IS THIS A PROGRAM FROM DIR?  ENCD-32
         BNE       CCAT21.G        NOT A PROGRAM XXX FROM DIR   ENCD-32
         TBM       CPRED,CFLGS     WAS A PROGRAM DIRECTIVE READ ENCD-32
         BS        CCAT21.I        SKIP SGO PROCESSING IF SO    ENCD-32
         TBM       CPXRED,CFLGS    WAS A PROGRAMX DIR. READ     ENCD-32
         BS        CCAT21.I        SKIP SGO PROCESSING IF SO    ENCD-32
         TBM       MOBDIR,MFLAG2   WAS AN OBJECT DIRECTIVE READ PR10790
         BS        CCAT21.I        SKIP SGO PROCESSING IF SO    PR10790
         TBM       MPRGDIR,MFLAG2  FIRST PROGRAM XXX FROM DIR   ENCD-32
         BS        CCAT21.I        NO SKIP SGO PROCESSING       ENCD-32
         LW        R3,SGPNTRS+1W   GET SGO FAT ADDR             ENCD-32
         TBM       5,DFT.STB,X3    IS SGO A VOLUME RESOURCE?    PR12302
         BNS       CAT21.B         NO...CHECK FOR NULL DEVICE   PR12302
         LW        R7,DFT.EOF,X3   ANYTHING IN SGO?             ENCD-32
         CI        R7,0                                         ENCD-32
         BEQ       CCAT21.I        SKIP IF NO SGO TO PROCESS    ENCD-32
CAT21.A  LI        R5,1            PROCESS SGO OBJECT           ENCD-32
         ZR        R6                                           ENCD-32
         BL        CA                                           ENCD-32
         BU        CCAT21.I        AND CONTINUE                 PR12302
CAT21.B  LW        R3,SGPNTRS+2W   GET UDT ADDRESS              PR12302
         LB        R7,5,X3         GET DEVICE TYPE CODE         PR12302
         CI        R7,X'0F'        NULL DEVICE?                 PR12302
         BEQ       CCAT21.I        SKIP SGO PROCESSING IF SO    PR12302
         BU        CAT21.A         ELSE PROCESS SGO             PR12302
CCAT21.I SBM       MPRGDIR,MFLAG2  SHOW PROGRAM XXX FROM READ   ENCD-32
         LW        R7,OBJLFC       GET OBJ LFC                  ENCD-32
         LA        R3,LFCLOC       LOCATION IN CALL BLOCK       ENCD-32
         BL        XSTB            STORE LFC IN CALL BLOCK      ENCD-32
         LB        R2,CCPTR        CURRENT INPUT LINE POINTER   ENCD-32
         ZR        R3                                           ENCD-32
CCAT21.A LB        R7,MDBUF,X2     GET CHAR FROM INPUT LINE     ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BNE       CCAT21.C        STORE IF NOT                 ENCD-32
         ADI       R2,1            BUMP INPUT LINE POINTER      ENCD-32
         BU        CCAT21.A                                     ENCD-32
CCAT21.B LB        R7,MDBUF,X2     GET CHAR FROM INPUT LINE     ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BEQ       CCAT21.D        DONE IF SO                   ENCD-32
CCAT21.C STB       R7,PATHLOC,X3   SAVE IN CALL BLOCK           ENCD-32
         ADI       R2,1            BUMP POINTERS                ENCD-32
         ADI       R3,1                                         ENCD-32
         BU        CCAT21.B        NEXT CHAR                    ENCD-32
CCAT21.D ADI       R3,12           ADD LENGTH OF OTHER CHARS    ENCD-32
         STW       R3,SCOUNT       SAVE SIZE IN CALL BLOCK      ENCD-32
         ZR        R7                                           ENCD-32
         M.TSMPC   LIBPCB          CREATE RRS                   ENCD-32
         LA        R1,LIBRS                                     ENCD-32
         ZR        R7                                           ENCD-32
         SVC       2,X'52'         ASSIGN FILE                  ENCD-32
         TRR       R7,R7           CHECK STATUS                 ENCD-32
         BEQ       CCAT21.H        CONTINUE IF OK               ENCD-32
         TRR       R7,R5                                        ENCD-32
         M.CONBAD                  CONVERT STATUS               ENCD-32
         ANMW      R7,=X'0000FFFF'                              ENCD-32
         LA        R3,C50.M9S                                   ENCD-32
         BL        XSTB            PUT STATUS IN MESSAGE        ENCD-32
         LW        R6,SCOUNT       DETERMINE PATHNAME LENGTH    PR11087
         SUI       R6,12                                        PR11087
         ZR        R3              CLEAR R3                     PR11087
CAT21.5  CI        R6,0            DONE WITH FILE NAME          PR11087
         BEQ       CAT21.6         YES...BRANCH                 PR11087
         LB        R5,PATHLOC,X3   GET BYTE OF FILE NAME        PR11087
         STB       R5,C50.M9N,X3   SAVE IN MESSAGE              PR11087
         ADI       R3,1            ADJUST POINTER               PR11087
         SUI       R6,1            ADJUST LENGTH                PR11087
         BU        CAT21.5         NEXT BYTE                    PR11087
CAT21.6  LNB       R5,C50.M9L      MESSAGE LENGTH               ENCD-32
         LA        R6,C50.M9A      MESSAGE ADDRESS              ENCD-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,C50.M9BL     SECOND HALF                  PR11087
         LA        R6,C50.M9B                                   PR11087
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         LNB       R5,C50.M9CL     THIRD PART                   PR11087
         LA        R6,C50.M9C                                   PR11087
         BL        XTYPE           PUT OUT THIRD PART           C013-32
         SBM       CDERR,CFLGS     SHOW PASS A ERROR            ENCD-32
         BU        CCAT16          CONTINUE                     ENCD-32
CCAT21.H LD        R6,PNAME                                     ENCD-32
         LB        R5,PCHARS                                    ENCD-32
         CI        R5,8B                                        ENCD-32
         BLE       CCAT21.E        BR IF NOT MORE THAN 8 CHARS  ENCD-32
         LI        R5,3B                                        ENCD-32
         BL        CCERR           ILLEGAL ENTRY MESSAGE        ENCD-32
         BU        CCAT16          RETURN                       ENCD-32
CCAT21.E LI        R5,1            SIGNAL OBJ POSITION          ENCD-32
         BL        XGOPO           POSITION OBJ TO PROGRAM      ENCD-32
         TRR       R6,R6           DID WE FIND IT               ENCD-32
         BNE       CCAT21.F        BRANCH IF SO                 ENCD-32
         LI        R5,3B                                        ENCD-32
         BL        CCERR           ERROR MESSAGE                ENCD-32
         BU        CCAT16          RETURN                       ENCD-32
CCAT21.F ZR        R5              PROCESS SINGLE PROGRAM       ENCD-32
         LI        R6,1            PROCESS FROM OBJ             ENCD-32
         BL        CA              PROCESS OBJECT               ENCD-32
         LA        R1,XOBJECT                                   ENCD-32
         M.DASN                    DEASSIGN OBJ FILE            ENCD-32
         ZBM       XOBRDFST,XFLGS  SHOW FILE NOT OPEN           PR10775
         BU        CCAT16          RETURN                       ENCD-32
*
*!!!!!!!!BL!!!!!!!!STRING!!!!!!!!!!OBTAIN!PROGRAM!NAME!!!!!!!!!!ENCD-32
*!!!!!!!!LB!!!!!!!!R5,CCHRS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
CCAT21.G LD        R6,PNAME        RESTORE FIRST NAME           ENCD-32
         LB        R5,PCHARS       AND CHAR COUNT               ENCD-32
CCAT2112 CI        R5,8B
         BLE       CCAT2114        BR IF NOT MORE THAN 8 CHARACTERS
CCAT2113 LI        R5,3B
         BL        CCERR           ILLEGAL ENTRY MSG
         BU        CCAT2115
CCAT2114 ZR        R5              TELL XGOPO TO POSITION SGO   ENCD-32
         BL        XGOPO           POSITION SGO TO PROGRAM
         TRR       R6,R6
         BZ        CCAT2113        BR IF PROGRAM NOT FOUND
         SBM       CPRED,CFLGS     SHOW A PROGRAM DIRECTIVE DONE 1.3#02
*!!!!!!!!BS!!!!!!!!CCAT211X!!!!!!!!SKIP!IF!NOT!FIRST!!!!!1.3#02!S8701186
*!!!!!!!!LW!!!!!!!!R5,MPNXT!!!!!!!!GET!ADDR!OF!NEXT!EXT.T1.3#02!S8701186
*!!!!!!!!STW!!!!!!!R5,MPRFFST!!!!!!AND!SAVE!AS!ADDR!OF!LA1.3#02!S8701186
*CCAT211X!!EQU!!!!!!!$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1.3#02!S8701186
         ZR        R5
         ZR        R6                                           ENCD-32
         BL        CA              FIRST PASS OVER PROGRAM
CCAT2115 TBM       CSCAN,CFLGS                                  ENCD-32
         BS        CCAT21.9                                     ENCD-32
         LB        R5,PCHARS2                                   ENCD-32
         BEQ       CCAT16          RETURN IF NO MORE PROGRAMS
         SBM       CSCAN,CFLGS   SHOW PRE-SCANNED FIELDS DONE   ENCD-32
         LD        R6,PNAME2                                    ENCD-32
         BU        CCAT2112                                     ENCD-32
CCAT21.9 BL        STRING                                       ENCD-32
         LB        R5,CCHRS
         BNE       CCAT2112        BR IF ANOTHER NAME TO PROCESS
         ZBM       CSCAN,CFLGS     CLEAR PRE-SCAN FLAG          ENCD-32
         BU        CCAT16
*
PNAME    DATAD     0          SAVE AREAS FOR PRE-SCANNED FIELDS ENCD-32
PNAME2   DATAD     0                                            ENCD-32
PCHARS   DATAB     0                                            ENCD-32
PCHARS2  DATAB     0                                            ENCD-32
*
         TITLE     CCAT21.1        PROCESS OBJECT DIRECTIVE     ENCD-32
*                                                               ENCD-32
*        PROCESS "OBJECT" DIRECTIVES                            ENCD-32
*                                                               ENCD-32
CCAT21.1 TBM       CPRED,CFLGS     WAS PROGRAM DIRECTIVE READ   ENCD-32
         BS        CCAT21.2        SKIP SGO PROCESSING IF SO    ENCD-32
         TBM       CPXRED,CFLGS    WAS PROGRAMX DIRECTIVE READ  ENCD-32
         BS        CCAT21.2        SKIP SGO PROCESSING IF SO    ENCD-32
         TBM       MPRGDIR,MFLAG2  PROGRAM XXX FROM DIR READ?   PR10790
         BS        CCAT21.2        SKIP SGO PROCESSING IF SO    PR10790
         TBM       MOBDIR,MFLAG2   FIRST OBJECT DIRECTIVE?      ENCD-32
         BS        CCAT21.2        SKIP SGO PROCESSING IF NOT   ENCD-32
         LW        R3,SGPNTRS+1W   GET FAT ADDRESS              ENCD-32
         TBM       5,DFT.STB,X3    IS SGO A VOLUME RESOURCE?    PR12302
         BNS       CAT21.4         CHECK FOR NULL DEVICE IF NOT PR12302
         LW        R5,DFT.EOF,X3   ANYTHING IN SGO?             ENCD-32
         CI        R5,0                                         ENCD-32
         BEQ       CCAT21.2        SKIP SGO PROCESSING IF NONE  ENCD-32
CAT21.3  LI        R5,1            SET R5 NON-ZERO              ENCD-32
         ZR        R6                                           ENCD-32
         BL        CA              PROCESS ALL OBJECT IN SGO    ENCD-32
         BU        CCAT21.2        AND CONTINUE                 PR12302
CAT21.4  LW        R3,SGPNTRS+2W   GET UDT ADDRESS              PR12302
         LB        R5,5,X3         GET DEVICE TYPE CODE         PR12302
         CI        R5,X'0F'        NULL DEVICE?                 PR12302
         BEQ       CCAT21.2        SKIP SGO PROCESSING IF SO    PR12302
         BU        CAT21.3         ELSE PROCESS SGO             PR12302
CCAT21.2 SBM       MOBDIR,MFLAG2   SHOW OBJECT DIRECTIVE READ   ENCD-32
         LW        R7,OBJLFC       GET OBJ LFC                  ENCD-32
         LA        R3,LFCLOC       PUT IT IN CALL BLOCK         ENCD-32
         BL        XSTB                                         ENCD-32
         LB        R2,CCPTR        CURRENT LINE POINTER         ENCD-32
         ZR        R3                                           ENCD-32
CCAT21.3 LB        R7,MDBUF,R2     GET CHAR FROM INPUT BUFFER   ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BNE       CCAT21.5        SAVE IT IF NOT               ENCD-32
         ADI       R2,1            BUMP POINTER                 ENCD-32
         BU        CCAT21.3        CONTINUE                     ENCD-32
CCAT21.4 LB        R7,MDBUF,R2     GET CHAR FROM INPUT BUFFER   ENCD-32
         CI        R7,G' '         SPACE?                       ENCD-32
         BEQ       CCAT21.6        DONE IF SO                   ENCD-32
CCAT21.5 STB       R7,PATHLOC,R3   SAVE CHAR IN CALL BLOCK      ENCD-32
         ADI       R2,1            BUMP POINTERS                ENCD-32
         ADI       R3,1                                         ENCD-32
         BU        CCAT21.4        NEXT CHARACTER               ENCD-32
CCAT21.6 ADI       R3,12           ADD LENGTH OF OTHER CHARS    ENCD-32
         STW       R3,SCOUNT       SAVE IN CALL BLOCK           ENCD-32
         ZR        R7                                           ENCD-32
         M.TSMPC   LIBPCB          GET RRS                      ENCD-32
         LA        R1,LIBRS                                     ENCD-32
         ZR        R7                                           ENCD-32
         SVC       2,X'52'         ASSIGN FILE                  ENCD-32
         TRR       R7,R7           CHECK STATUS                 ENCD-32
         BEQ       CCAT21.7        CONTINUE IF OK               ENCD-32
         TRR       R7,R5                                        ENCD-32
         M.CONBAD                  CONVERT STATUS               ENCD-32
         ANMW      R7,=X'0000FFFF'                              ENCD-32
         LA        R3,C50.M9S                                   ENCD-32
         BL        XSTB            PUT STATUS IN MESSAGE        ENCD-32
         LW        R6,SCOUNT       DETERMINE PATHNAME LENGTH    PR11087
         SUI       R6,12                                        PR11087
         ZR        R3              CLEAR R3                     PR11087
CAT21.1  CI        R6,0            DONE WITH FILE NAME          PR11087
         BEQ       CAT21.2         YES...BRANCH                 PR11087
         LB        R5,PATHLOC,X3   GET BYTE OF FILE NAME        PR11087
         STB       R5,C50.M9N,X3   SAVE IN MESSAGE              PR11087
         ADI       R3,1            ADJUST POINTERS              PR11087
         SUI       R6,1                                         PR11087
         BU        CAT21.1         NEXT BYTE                    PR11087
CAT21.2  LNB       R5,C50.M9L      LOAD MESSAGE LENGTH          ENCD-32
         LA        R6,C50.M9A      MESSAGE ADDRESS              ENCD-32
         BL        XTYPE           PUT OUT MESSAGE              C013-32
         LNB       R5,C50.M9BL                                  PR11087
         LA        R6,C50.M9B                                   PR11087
         BL        XTYPE           PUT OUT SECOND HALF          C013-32
         LNB       R5,C50.M9CL     THIRD PART                   PR11087
         LA        R6,C50.M9C                                   PR11087
         BL        XTYPE           PUT OUT THIRD PART           C013-32
         SBM       CDERR,CFLGS     SHOW PASS A ERROR            ENCD-32
         BU        CCAT16          CONTINUE                     ENCD-32
CCAT21.7 LI        R5,1                                         ENCD-32
         LI        R6,1                                         ENCD-32
         BL        CA              PROCESS ALL OBJECT IN FILE   ENCD-32
         LA        R1,XOBJECT                                   ENCD-32
         M.DASN                    DEASSIGN OBJ FILE            ENCD-32
         ZBM       XOBRDFST,XFLGS  SHOW FILE NOT OPEN           PR10775
         BU        CCAT16          RETURN                       ENCD-32
*-----------------------------------------------------------------------
         TITLE     CCAT22 - PROCESS  END-OF-MODULE CASE
*
*    HERE IF  EOF  , "EXIT" OR "X"
*     -OR-    A DIRECTIVE THAT IS NOT LINKBACK,INCLUDE,EXCLUDE,PROGRAM
*             OR PROGRAMX,  AND IS LEGAL IN CONTEXT!
*
CCAT22   TBM       CPRED,CFLGS
         BS        CCAT23          BR IF PROGRAM CARD READ
         TBM       MPRGDIR,MFLAG2  PROGRAM XXX FROM DIR READ?   PR10790
         BS        CCAT23          BRANCH IF SO                 PR10790
         TBM       MOBDIR,MFLAG2   OBJECT DIRECTIVE READ?       PR10790
         BS        CCAT23          BRANCH IF SO                 PR10790
         TBM       CPXRED,CFLGS    PROGRAMX DIRECTIVE READ?     PR10790
         BS        CCAT23          BRANCH IF SO                 PR10790
*!!!!!!!!LW!!!!!!!!R1,MPNXT!!!!!!!!GET!CURRENT!EXT.T!SLOT1.3#02!S8701186
*!!!!!!!!STW!!!!!!!R1,MPRFFST!!!!!!AND!SAVE!AS!FIRST!DYMA1.3#02!S8701186
         LW        R3,SGPNTRS+1W   GET SGO FAT ADDRESS          ENCD-32
         TBM       5,DFT.STB,X3    SGO ASSIGNED TO VOL RESOURCE PR11483
         BNS       CCAT22.2        SKIP EOF TEST IF NOT         PR11483
         LW        R5,DFT.EOF,X3   ANYTHING IN SGO?             ENCD-32
         BEQ       CCAT23          SKIP SGO PROCESSING IF NOT   ENCD-32
CCAT22.1 ZR        R6                                           ENCD-32
         LI        R5,1            PROCESS ENTIRE SGO FILE INDICATOR
         BL        CA
         BU        CCAT23          AND CONTINUE                 PR12302
CCAT22.2 LW        R3,SGPNTRS+2W   GET UDT ADDRESS              PR12302
         LB        R3,5,X3         GET DEVICE TYPE CODE         PR12302
         CI        R3,X'0F'        NULL DEVICE?                 PR12302
         BEQ       CCAT23          SKIP SGO PROCESSING IF SO    PR12302
         BU        CCAT22.1        ELSE PROCESS SGO             PR12302
*
*PROCESS SYSTEM SUBROUTINE LIBRARY ROUTINES
*
CCAT23   TBM       CDERR,CFLGS
         BNS       CCAT25          BR IF NO DIRECTIVE ERRORS
CCAT24   LF        R0,CCAT90
         TRSW      R0              RETURN
         NOP
*
CCAT25   EQU       $                                             1.3#02
         LW         R1,MPINFST     GET START OF INCLUDES         1.3#02
         CAMW       R1,MPRFFST     DOES 1ST INCL=1ST REF         1.3#02+
         BEQ        CCAT2522       BR IF NO INCLUDES             1.3#02+
CCAT251  EQU        $                                            1.3#02
         LD         R6,0,X1        GET ENTRY                     1.3#02
         BZ        CCAT2511        SKIP IF ZERO                  1.3#02+
         ZMD       0,X1            AND ZAP IT                    1.3#02
         BL         CCAT30         GO PROCESS THIS SYMBOL        1.3#02
CCAT2511 EQU       $                                             1.3#10
         ABR        R1,28          ELSE BUMP TO NEXT             1.3#02+
         CAMW      R1,MPINLST      AT END OF INCLUDES            1.3#02+
         BLE       CCAT251         STAY IN LOOP IF NOT           1.3#02+
CCAT252  EQU       $                                             1.3#02
         LW        R1,MPINFST      GET START OF INCLUDE TABLE    1.3#02
         LW        R2,MPRFFST      GET START OF REF'S            1.3#02
         STW       R1,MPRFFST      UPDATE START OF REF'S         1.3#02
         LNW       R4,MEXTS        GET NUMBER OF EXT'S           1.3#02
         BZ        CCAT32          ALL DONE IF ZERO              1.3#02+
CCAT2521 EQU       $                                             1.3#02
         LD        R6,0,X2         GET NEXT EXT                  1.3#02
         STD       R6,0,X1         STORE OVER NEXT INCL          1.3#02
         ZMD       0,X2            ZAP THE OLD GUY               1.3#02
         ABR       R2,28           BUMP IN POINTER               1.3#02
         ABR       R1,28           BUMP OUT POINTER              1.3#02
         BIB       R4,CCAT2521     AND LOOP                      1.3#02
         STW       R1,MPNXT        SAVE NEXT EXT SLOT ADDR       1.3#02
*                                                                1.3#02
         LW        R1,MPRFFST      GET ADDR OF EXT TO DO         1.3#02
CCAT2522 EQU       $                                             1.3#02
         CAMW      R1,MPNXT        ARE WE AT THE END             1.3#02
         BGE       CCAT253         SKIP IF END                   1.3#02
         LD        R6,0,X1         GET CURRENT SYMBOL            1.3#02
         LW        R2,MPNXT        GET ADDR OG NEXT SLOT         1.3#02
         SUI       R2,8            BACK IT UP                    1.3#02
         LD        R4,0,X2         GET LAST ENTRY                1.3#02
         STD       R4,0,X1         AND MOVE IT                   1.3#02
         STW       R2,MPNXT        THEN RESTORE MODIFIED MPNXT   1.3#02
         ZMD       0,X2            ZAP THE MOVED ONE             1.3#02
         LW        R2,MEXTS        GET EXT COUNT                 1.3#02
         SUI       R2,1            DECREMENT                     1.3#02
         STW       R2,MEXTS        AND SAVE                      1.3#02
         BL        CCAT30          NOW GO DO CURRENT SYMBOL      1.3#02
         ABR       R1,28           BUMP TO NEXT SLOT ADDR        1.3#02
         BU        CCAT2522        LOOP THROUGH THIS BRANCH      1.3#02
CCAT253  EQU       $                                             1.3#02
         LW        R1,MEXTS        GET NUMBER OF EXTERNALS       1.3#02
         BZ        CCAT32          ALL DONE IF ZERO              1.3#02
         LW        R1,MPRFFST      RECOVER START OF REF'S        1.3#02
         BU        CCAT2522        AND CONTINUE PROCESSING       1.3#02
         TITLE     CCAT30 - PROCESS ALL LIBRARIES
*                                                                1.3#02
*   HERE TO PROCESS AN EXT.T ENTRY                               1.3#02
*                                                                1.3#02
CCAT30   EQU       $                                             1.3#02
         STF       R0,CCAT30RS                                   1.3#02
         BL        XLISH           FIND SYMBOL IN LIBRARY        1.3#02
         TRR       R7,R7
         BNN       CCAT30.1        BR IF FOUND                   1.3#02+
         TBM       CPRED,CFLGS     WAS A "PROGRAM" DIR READ      1.3#02+
         BS        CCAT311         ASSUME EXT WILL COME LATER    1.3#02+
         TBM       MPRGDIR,MFLAG2  PROGRAM XXX FROM DIR READ?   PR10790
         BS        CCAT311                                      PR10790
         TBM       MOBDIR,MFLAG2   OBJECT DIRECTIVE READ?       PR10790
         BS        CCAT311                                      PR10790
         LD        R6,CCAT30RS+6W  RECOVER SYMBOL NAME           1.3#02+
         LA        R3,CCAT30.D     ADDR OF LOCATION IN MESSAGE   1.3#02+
         BL        XST2            AND STORE IT                  1.3#02+
         LNB       R5,CCAT30.L     SET ERROR MSG COUNT FOR BOTH  1.3#02+
         LA        R6,CCAT30.M     PLUS THE ADDRESS              1.3#02+
         BL        XTYPE           AND LOG IT                    1.3#02+
         BU        CCAT311         THEN RETURN TO CALLER         1.3#02
CCAT30.1 EQU       $               HERE IF FOUND IN A LIBRARY    1.3#02
         STW       R6,MLIBL        SAVE LIB LOC FOR M1PNM
         STW       R7,MLIBN        SAV SUBROUTINE LIBRARY FCB INDEX
         ZMW       MOBJC
         LW        R5,MSYMN        SAVE CONTROL ENTRY ADDRESS
         STW       R5,MSYMC
         LW        R4,=X'06000000'
         ZR        R5
         ZR        R6
         ZR        R7
         BL        MSYMS           STORE A CONTROL ENTRY IN SYMTAB
         ZMH       MXSEQ           INITIALIZE EXPECTED SEQUENCE NUMBER,
         ZBM       MPEND,MFLGS     END OF PROGRAM FLAG, AND
         LW        R5,=C'    '     PROGRAM ELEMENT NAME
         STW       R5,MPNAM
         STW       R5,MPNAM+1W
         ZR        R7                                            1.3#04
         LW        R6,MLIBL        RECOVER LIBRARY POSITION INFO 1.3#04
         SRLD      R6,16           MOVE LOGICAL RECORN NUM TO R7 1.3#04
         SRL       R7,16           AND POSITION                  1.3#04
         TRR       R6,R5           SECTOR NUMBER TO R5           1.3#04
         TRR       R7,R6           RECORD NUMBER TO R6           1.3#04
CCAT31   EQU       $               LOOP TOP                      1.3#04
         LW        R7,MLIBN        GET LIBRARY FILE INDEX        1.3#04
         BL        XLIRD           READ A CARD FROM LIBRARY
         ZR        R5
         SBM       XLIBEDCK,XFLGS  PROCCESSING LIBRARY RECORDS    0270
         BL        MOBSC           PROCESS CARD
         ZBM       XLIBEDCK,XFLGS                                 0270
         LI        R5,-1           INDICATE SEQ. PROC TO XLIRD   1.3#04
         TBM       MPEND,MFLGS
         BNS       CCAT31          BR IF NOT END OF PROGRAM
         LW        R1,MSYMC
         LW        R4,MOBJC        GET OBJECT CODE SIZE, IN BYTES
         ADI       R4,3            ROUND UP TO WORD MULTIPLE
         SRL       R4,2
         SLL       R4,2
         STW       R4,2W,R1        STORE OBJECT CODE COUNT IN SYMTAB
         SBM       FLAGPGM,CFLAGS   INDICATE AT LEAST ONE PROG   1.3#10
CCAT311  EQU       $                                             1.3#02
         LF        R0,CCAT30RS                                   1.3#02
         TRSW      R0                                            1.3#02
         NOP                                                     1.3#02
*                                                                1.3#02
*----------------------------------------------------------------1.3#02
         TITLE     CCAT32 - END OF CATALOG DIRECTIVE PROCESSING
CCAT32   EQU       $
         ZBM       FLAGPGM,CFLAGS  TEST&RESET PROG COUNT         1.3#10
         BNS       CCAT32.1        LOG ERROR                     1.3#10
         LW        R1,MSYMC        GET CONTROL ENTRY ADDR
         SBM       7,0,R1          END OF MODULE FLAG
CCAT33   LF        R0,CCAT90
         TRSW      R0              RETURN
         NOP
CCAT32.1 EQU       $
         LW        R1,MMODW        GET MODULE STAB ADDR          1.3#02+
         LD        R6,1D,X1        GET MODULE NAME               1.3#02+
         STW       R6,CCAT32.D     PLUG INTO MESSAGE             1.3#02+
         STW       R7,CCAT32.D+1W                                1.3#02+
         LA        R6,CCAT32.M     MESSAGE ADDR                  1.3#02+
         LNB       R5,CCAT32.L     LENGTH                        1.3#02+
         BL        XTYPEF          LOG                           1.3#02+
         SBM       CDERR,CFLGS     SET PASS-A ERROR FLAG         1.3#10
         BU        CCAT33          CONTINUE                      1.3#10
         BOUND     8W
CCAT90   RES       8W
CCAT30RS REZ       8W                                            1.3#02
CCAT91   DATAW     0               COUNTER FOR LINKBACK ENTRIES
CCATR3   RES       1W              SAVE R3 FOR MULTIPLE LINKBACK CARDS
*
CCAT30.M DATAB     C' CATALOG(WARNING) GLOBAL SYMBOL   '         1.3#02+
CCAT30.D RES       8B                                            1.3#02+
         DATAB     C'   NOT FOUND IN ANY DIRECTORY.'             1.3#02&
CCAT30.L DATAB     $-CCAT30.M                                    1.3#02+
         BOUND     1W
CCAT32.M DATAB     C' CATALOG<<FATAL>>  LOAD MODULE: '           1.3#02+
CCAT32.D RES       8B                                            1.3#02+
         DATAB     C' CONTAINS NO PROGRAMS.'                     1.3#02+
CCAT32.L DATAB     $-CCAT32.M                                    1.3#02+
*
         TITLE     CENV     - ENVIRONMENT DIRECTIVE
***********************************************************************
*
*        CENV
*
**********************************************************************
*
*        ENVIRONMENT NNNN MEM RESIDENT SHARED UNIQUE
*
**********************************************************************
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
CENV     STF       R0,CARD90
CENV0    BL        STRING           GET NEXT FIELD
         LB        R5,CCHRS        ANY FIELD FOUND
         BNZ       CENV0.1         NOT BLANK FIELD,THEN PROCESS IT
         LB        R5,CCDLIM       PICK UP LAST DELIMITER
         CI        R5,G','         IS DELIMITER   ','
         BEQ       CENV0           BR IF COMMA DELIMITER, NOT END OF LIN
         BU        CARDEXIT
CENV0.1  CAMW      R6,CENND        IS 1ST PART OF KEYWORD NODE? S900452
         BNE       CENV0.2         CONTINUE PROCESSING IF NOT   S900452
         SRL       R7,24           SHIFT 5TH CHARACTER OVER     S900452
         CI        R7,G'M'         IS IT AN M?                  S900452
         BNE       CENV0.2         CONTINUE IF NOT              S900452
         LW        R4,CENND2       GET NODEMAND VALUE           S900452
         EXM       CENND2+1W       SET FLAG BIT                 S900452
         BU        CENV0           LOOP FOR MORE                S900452
CENV0.2  ZR        R1                                           S900452
         LI        R2,-CENVNV      # VERBS
CENV1    CAMW      R6,CENVVB,R1
         BEQ       CENV2           FOUND VERB
         ADI       R1,1D           INCREMENT INDEX BY DOUBLEWORD
         BIB       R2,CENV1        LOOP
         BU        CARDERR1
CENV2    LW        R4,CENVVV,R1    GET VALUE
         EXM       CENVVV+1W,R1    STORE VALUE
         CAMW      R6,CENND-2W     WAS DEMAND SPECIFIED?        EAGE-33
         BNE       CENV0           NO...BRANCH                  EAGE-33
         BL        STRING          GET NEXT KEYWORD             EAGE-33
         LB        R5,CCHRS        ANY CHARACTERS READ?         EAGE-33
         BEQ       CENV0+3W        NO...BRANCH                  EAGE-33
         CAMW      R6,=C'AGE '     WAS AGE VALUE SPECIFIED?     EAGE-33
         BNE       CENV0.1         NO...BRANCH                  EAGE-33
         BL        STRING          GET NEXT KEYWORD             EAGE-33
         LB        R5,CCHRS        ANY CHARACTERS READ?         EAGE-33
         BEQ       CARDERR1        NO...ERROR                   EAGE-33
         BL        M1002           CONVERT TO HEX               EAGE-33
         TRR       R6,R6           WAS IT ZERO?                 EAGE-33
         BEQ       CARDERR3        YES...ERROR                  EAGE-33
         STW       R7,AGEVAL       SAVE VALUE FOR LATER         EAGE-33
         BU        CENV0           LOOP FOR MORE
*
*        OPTION VERB TABLE
*
         BOUND     1D
CENVVB   EQU       $
         DATAD     C'MAP2048 '
         DATAD     C'MAP8192 '
         DATAD     C'E       '
         DATAD     C'H       '
         DATAD     C'S       '
         DATAD     C'RESIDENT'
         DATAD     C'SHARED  '
         DATAD     C'MULTICOP'
         DATAD     C'UNIQUE  '
         DATAD     C'NODEBUG '
         DATAD     C'TSBB    '     TASK SUPPLIED BLOCKING BUF    1.3#11
         DATAD     C'SSBB    '     SYSTEM SUPPLIED BLOCKING BUF C008-30
         DATAD     C'MODULENA'     RETAIN LM NAME FROM PREAMBLE  1.3#11
         DATAD     C'FILENAME'     USE FILENAME AS TASK NAME    C008-30
         DATAD     C'ONRA    '     REAL TIME ACCOUNTING ON      ECSW-30
         DATAD     C'OFRA    '     REAL TIME ACCOUNTING OFF     ECSW-30
         DATAD     C'MAPOUT  '     MAPOUT MPX KEYWORD           EOUT-32
         DATAD     C'NOMAPOUT'     MAPIN MPX KEYWORD            EOUT-32
         DATAD     C'SYSMAP  '     SYSTEM MAPOUT KEYWORD        EOUT-32B
         DATAD     C'DEMAND  '     DEMAND PAGE KEYWORD          EDMP-32
CENND    DATAD     C'NODEMAND'     NODEMAND PAGE KEYWORD        S900452
CENVNV   EQU       $-CENVVB/8      # ENTRIES IN TABLE
*
*        OPTION VALUE/STORAGE TABLE
*
CENVVV   EQU       $
         DATAW     X'2000'         MAP2048
         STW       R4,MPAGESZ
*
         DATAW     X'8000'         MAP8192
         STW       R4,MPAGESZ
*
         DATAW     1               E TYPE MEM
         STW       R4,PRMEMS
*
         DATAW     2               H TYPE MEM
         STW       R4,PRMEMS
*
         DATAW     3               S TYPE MEM
         STW       R4,PRMEMS
*
         DATAW     0               RESIDENT
         SBM       PR.RES,MFLAG    SET RESIDENT FLAG
*
         DATAW     0               SHARED
         SBM       PR.SHR,MFLAG    SET SHARED FLAG
*
         DATAW     0               MULTI-COPIED
         SBM       PR.MULTI,MFLAG   SET MULTICOPY FLAG
*
         DATAW     0               UNIQUE                        1.3#14
         ZBM       PR.MULTI,MFLAG  RESET MULTICOPY FLAG          1.3#14
*  UNIQUE IS EFFECTIVELY A NOP, IT IS INCLUDED FOR FUTURE USE    1.3#14
*
         DATAW     0               NODEBUG
         SBM       PR.NODBG,MFLAG  SET NO DEBUGGER ATTACH FLAG
*
         DATAW     0               TSBB                          1.3#11
         SBM       MTSBB,MFLGS     SET TASK SUPPLIED BLK BUFS    1.3#11
*
         DATAW     0               SSBB                         C008-30
         ZBM       MTSBB,MFLGS    SET SYSTEM SUPPLIED BLK BUFS  C008-30
*
         DATAW     0               MODULENAME                    1.3#11
         SBM       MRCMN,MFLGS     SET RETAIN PREAMBLE NAME      1.3#11
*                                                                1.3#11
         DATAW     0               FILENAME                     C008-30
         ZBM       MRCMN,MFLGS     RESET RETAIN PREAMBLE NAME   C008-30
*
         DATAW     0               ONRA                         ECSW-30
         SBM       MONRA,MFLGS     SET REAL TIME ACCOUNTING ON  ECSW-30
*
         DATAW     0               OFRA                         ECSW-30
         SBM       MOFRA,MFLGS     SET REAL TIME ACCOUNTING OFF ECSW-30
*
         DATAW     0               MAPOUT                       EOUT-32
         SBM       MMOUT,MFLGS     SET MPX MAPOUT BIT           EOUT-32
*
         DATAW     0               NOMAPOUT                     EOUT-32
         SBM       MMIN,MFLGS      SET NOMAPOUT BIT             EOUT-32
*
         DATAW     0               SYSMAP                       EOUT-32B
         SBM       MSYSM,MFLAG3    SET SYSMAP BIT               EOUT-32B
*
         DATAW     0               DEMAND                       EDMP-32
         SBM       MDMPG,MFLAG3    SET DEMAND BIT               EDMP-32
*
CENND2   DATAW     0               NODEMAND                     S900452
         SBM       MNDMPG,MFLAG3   SET NODEMAND BIT             EDMP-32
*
AGEVAL   DATAW     0               DEMAND PAGE AGE VALUE        EAGE-33
*
*----------------------------------------------------------------1.3#11
         TITLE     CA       - FIRST PASS OVER OBJECT CODE
************************************************************************
*
*                  CA
*
************************************************************************
*
*        PERFORM FIRST PASS OVER OBJECT CODE FILES              ENCD-32
*        CALL R5 - 0, PROCESS SINGLE PROGRAM FROM CURRENT       ENCD-32
*                     OBJECT FILE POSITION                      ENCD-32
*                  NOT 0, PROCESS ENTIRE OBJECT FILE            ENCD-32
*             R6 - 0, PROCESS OBJECT FROM SGO                   ENCD-32
*                  NOT 0, PROCESS OBJECT FROM OBJ               ENCD-32
*
************************************************************************
CA       STF       R0,CA90
         TBM       CDERR,CFLGS
         BS        CA1             BR TO EXIT IF DIRECTIVE ERRORS
         TRR       R5,R5           PROCESS SINGLE 'SGO' MODULE
         BEQ       CA3             BR IF CALL TO PROCESS SINGLE PROGRAM
         TRR       R6,R6           WHICH FILE TO PROCESS?       ENCD-32
         BNE       CA2             PROCESS OBJ IF NOT ZERO      ENCD-32
         BL        XBIRW           REWIND SGO
         BL        XBIRD           READ A CARD FROM SGO
         TRR       R5,R5           TEST FOR EOF                  1.3#08
         BNZ       CA4.1           ERROR OUT IF EOF              1.3#08
         BU        CA3                                          ENCD-32
CA2      BL        XOBRW           REWIND OBJ FILE              ENCD-32
         BL        XOBRD           READ OBJECT FROM OBJ         ENCD-32
         TRR       R5,R5           TEST FOR EOF                 ENCD-32
         BNZ       CA4.1           ERROR OUT IF EOF             ENCD-32
CA3      ZMW       MOBJC           INITIALIZE OBJECT CODE COUNT,
         ZMH       MXSEQ           EXPECTED SEQUENCE NUMBER,
         ZBM       MPEND,MFLGS     PROGRAM END FLAG,
         LW        R5,=C'    '     PROGRAM ELEMENT NAME
         STW       R5,MPNAM
         STW       R5,MPNAM+1W
         LW        R5,MSYMN
         STW       R5,MSYMC        SAVE CONTROL ENTRY ADDRESS
         LW        R4,=X'04000000'
         ZR        R5
         ZR        R6
         ZR        R7
         BL        MSYMS           STORE CONTROL ENTRY IN SYMTAB
CA4      BL        MOBSC           PROCESS CARD
         TBM       MPEND,MFLGS
         BS        CA5             BR IF END OF PROGRAM ELEMENT
         LW        R6,CA90+6W      WHICH FILE TO PROCESS        ENCD-32
         BNE       CA4.0           PROCESS OBJ IF NOT ZERO      ENCD-32
         BL        XBIRD           READ A CARD FROM SGO
         TRR       R5,R5
         BEQ       CA4             BR IF NO EOF
         BU        CA4.1                                        ENCD-32
CA4.0    BL        XOBRD           READ A CARD FROM OBJ         ENCD-32
         TRR       R5,R5                                        ENCD-32
         BEQ       CA4             CONTINUE IF NOT EOF          ENCD-32
CA4.1    EQU       $                                             1.3#08
         LI        R5,8                                          1.3#08
         LA        R6,ERRLFC       LOG LFC ID                    1.3#08
         BL        XPRNT                                         1.3#08
         LI        R5,E.PREEOF     PREMATURE END OF FILE MSG
         BL        MBERR           ERROR EXIT - NO RETURN        1.3#05
CA5      LW        R1,MSYMC
         LW        R4,MOBJC        GET OBJECT CODE SIZE, IN BYTES
         ADI       R4,3            ROUND UP TO WORD MULTIPLE
         SRL       R4,2
         SLL       R4,2
         STW       R4,2W,R1        AND STORE IN CONTROL ENTRY
         SBM       FLAGPGM,CFLAGS    INDICATE AT LEAST ONE PGM   1.3#10
         LW        R5,CA90+5W
         BEQ       CA1             BR IF PROCESS A SINGLE PROGRAM
         LW        R6,CA90+6W      WHICH FILE TO PROCESS        ENCD-32
         BNE       CA2.1           PROCESS OBJ IF NOT ZERO      ENCD-32
         BL        XBIRD           READ A CARD FROM SGO
         TRR       R5,R5
         BEQ       CA3             BR IF NO EOF
         BU        CA1                                          ENCD-32
CA2.1    BL        XOBRD           READ A CARD FROM OBJ         ENCD-32
         TRR       R5,R5                                        ENCD-32
         BEQ       CA3             CONTINUE IF NOT EOF          ENCD-32
CA1      LF        R0,CA90
         TRSW      R0              RETURN
         SPACE
CA90     RES       1F              (LAST CELL OF TABLE OF UNDEFINEDS)
         TITLE     PASS-B1  - PASS-B DATA STRUCTURES
***********************************************************************
*
*                  B
*
***********************************************************************
*
*        PERFORM SECOND PASS OVER OBJECT CODE
*
***********************************************************************
*                                                                1.3#05
*   FOLLOWING EQUATES ARE FOR OFFSETS INTO MAIN SYMBOL TABLE     1.3#05
*   ENTRIES. NEW CODE WILL REFERENCE THEM, OLD CODE WILL BE      1.3#05
*   UPDATED WHEN EVER IT MAKES SENSE.                            1.3#05
*                                                                1.3#05
*   WE PUT THEM HERE FOR NOW                                     1.3#05
*                                                                1.3#05
*   FOLLOWING ARE FOR SEGMENT TYPE ENTRIES                       1.3#05
*                                                                1.3#05
MST.SEA  EQU       7W              CONTAINS SEG ENDING ADDR      1.3#05
MST.SSA  EQU       5W              CONTAINS SEG STARTING ADDR    1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
BFLGS    DATAB     0
*BFLGS EQUS
BFRST    EQU       0               FIRST ELEMENT OF MODULE
BFSEG    EQU       1               FIRST SEGMENT OF RUN          1.3#05
BLMOPN   EQU       2               INDICATES LOAD MOD FILE OPEN  1.3#05
BSECTS   EQU       3        INDICATES CURRENT PROG ELEM HAS SECTS1.3#05
BLMSCTS  EQU       4        IDICATES A CSECT ASSEMBLY AREA IS ALLOC'D
*
BMODNXT  DATAW     0    HOLDS ADDR OF NEXT MODULE ENTRY(PASS-B)  1.3#05
         BOUND     1D                                            1.3#05
BPREAMB  RES       96D             PREAMBLE AREA                 1.3#05
MRRS     RES       192D            RRS AREA                      1.3#05
*
*
*
         BOUND     1W
         TITLE     PASS-B2   MEMORY & LOAD MODULE FILE SIZE REQUIREMENTS
*                                                                1.3#05
*  THE FOLLOWING LOOP IS EXECUTED TO FIND:                       1.3#05
*                                                                1.3#05
*        1)  LARGEST PROGRAM ELEMENT SIZE AND NAME               1.3#05
*        2)  LARGEST SEGMENT SIZE                                1.3#05
*        3)  TOTAL FILE SPACE REQUIREMENTS FOR LOAD MODULES      1.3#05
*        4)  TOTAL FILE SPACE REQUIREMENTS FOR DEBUG SYMBOLS     1.3#05
*                                                                1.3#05
*                                                                1.3#05
*     MAJOR VARIABLES CALCULTED BY THIS LOOP ARE:                1.3#05
*                                                                1.3#05
         BOUND     1D                                            1.3#05
BLSEGDS  DATAW     0    BYTE SIZE OF LARGEST SEGMENT  DSECT      1.3#05
*                       USED TO RESERVE STORAGE FOR RELO MATRIX  1.3#05
BLSEGCS  DATAW     0    BYTE SIZE OF LARGEST SEGMENT CSECT       1.3#05
*                                                                1.3#05
BLPGMDS  DATAW     0    BYTE SIZE OF LARGEST PROGRAM DSECT       1.3#05
*                       USED TO CALC. MIMI. STORAGE FOR ASSEM    1.3#05
BLPGMCS  DATAW     0    BYTE SIZE OF LARGEST PROGRAM CSECT       1.3#05
*                                                                1.3#05
BLMSIZE  DATAW     0    FILE SIZE OF LOAD MODULE                 1.3#05
BDBGSIZE DATAW     0    FILE SIZE OF DEBUG SYMBOLS(GLOBAL+LOCAL) 1.3#05
BNSEG    DATAW     0    NUMBER OF SEGMENTS IN RUN COUNTER        1.3#05
NSLOP    REZ       1W                                           EAID-32
BDBGLMSZ REZ       1W       COUNT OF SYMBOLS FOR FILE CREATION  EAID-32
AID.SLN1 REZ       100W                                         EAID-32
XSRCOV1  ACW       AID.SLN1                                     EAID-32
XSRCOV2  ACW       AID.SLN1                                     EAID-32
*                                                                1.3#05
*                                                                1.3#05
*                                                                1.3#05
*     THIS MARKS THE START OF PHASE 5                            1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
B        EQU       $
BBBB     EQU       $                                             1.3#05
         LA        R1,XTEMP        REWIND CURRENT OBJ TEMP FILE PR10746
         BL        BB.RWND                                      PR10746
         ZR        R4                                            1.3#05
         ZR        R5                                            1.3#05
         ZR        R6                                            1.3#05
         ZR        R7                                            1.3#05
         SBM       MSTMD,MFLGS     INDICATE ITS A SEGMENT ENTRY  1.3#05
         BL        MSYMS           MAKE SURE THERE IS A ZERO ENT 1.3#05
         SBM       MSTMD,MFLGS     INDICATE ITS A CONTROL ENT    1.3#05
         BL        MSYMS           SECOND HALF OF NULL SEGMENT   1.3#05
         LW        R4,MSYMN        GET BACK POINTER              1.3#05
         ADI       R4,4W           BUMP TO THIS ENTRY            1.3#05
         STW       R4,MSYMN        AND RESTORE                   1.3#05
*
         LW        R5,M1.TADE      GET TRAD COUNT               |84.1011
         CI        R5,1            HOW MANY?                    |84.1011
         BLE       $+2W            SKIP IF 0 OR 1               |84.1011
         SBM       XABORTFL,XFLGS  INDICATE ABORT TO BE SET     |84.1011
*                    DONE HERE TO ALLOW PHASE 2 TO START        |84.1011
*                                                                1.3#05
         TBM       MOPT15,MFLGS    IS OPTION 15 ON               1.3#08
         BS        $+2W            SKIP IF IT IS                 1.3#08
         ZMW       XINFOENT        ELSE ZERO INFO SECTR CNT      1.3#08
*                                                                1.3#08
         ZMW       BDBGSIZE        PRESET DBG SYM FILE SIZE      1.3#05
         TBM       MOPT19,MFLGS    ARE SYMBOLS ON                1.3#05
         BNS       B0.0            SKIP IF NOT                   1.3#05
         LW        R5,XSYML       GET CNT OF LOCAL SYMS IN ROOT EAID-32
         ZR        R4                                           EAID-32
         DVI       R4,48          48 ENTRIES PER SECTOR         EAID-32
         ADI       R5,1           ROUND UP                      EAID-32
         STW       R5,BDBGSIZE    INIT FILE SIZE                EAID-32
         STW       R5,BDBGLMSZ                                  EAID-32
*----------------------------------------------------------------------
         TBM       MOPT2,MFLGS    SEPARATE OVERLAYS?            EAID-32
         BS        B0.I1          YES, DON'T REDO SIZE          EAID-32
*!!!!!!!!LW!!!!!!!!R5,XSYMENT!!!!!GET!COUNT!OF!LOCAL!SYMBOLS!!!!EAID-32E
         ZMW       BDBGLMSZ                                     PR11750
         LA        R3,XSYMMOD   GET ADDR OF SYMBOL COUNT TABLE  EAID-32E
         LA        R2,XSYML        GET END ADDR OF TABLE        EAID-32E
B0.I0    CAR       R3,R2           AT END OF TABLE?             EAID-32E
         BLE       B0.I1           DONE IF SO                   EAID-32E
         LW        R5,0,X3         GET SYMBOL COUNT FOR OVERLAY EAID-32E
         BEQ       B0.I1           DONE IF ZERO                 EAID-32E
         ZR        R4                                           EAID-32E
         DVI       R4,48          48 ENTRIES PER SECTOR         EAID-32
         TRR       R4,R4           ANY REMAINDER?               EAID-32G
         BZ        $+2W            SKIP INCREMENT IF NOT        EAID-32G
         ADI       R5,1           ROUND UP                      EAID-32G
*!!!!!!!!STW!!!!!!!R5,BDBGLMSZ!!!!INIT!FILE!SIZE!!!!!!!!!!!!!!!!EAID-32E
         ARMW      R5,BDBGLMSZ     ADD TO CURRENT SIZE          EAID-32E
         ADI       R3,4            NEXT TABLE ENTRY             EAID-32E
         BU        B0.I0           CONTINUE                     EAID-32E
B0.I1    EQU       $                                            EAID-32
*----------------------------------------------------------------------
         LW        R5,XSRCRT      # OF SOURCE CHARS IN ROOT     EAID-32
         TRR       R5,R5          ANY SOURCE?                   EAID-32
         BZ        B0.I2          NO                            EAID-32
         TBM       MOPT2,MFLGS                                  EAID-32
         BNS       $+2W           IF SEPARATE OVERLAYS...       EAID-32
         STW       R5,AID.SLEN    SET AS TOTAL FOR ROOT FILE    EAID-32
         ZR        R4                                           EAID-32
         DVI       R4,768         768 CHARACTERS PER BLOCK      EAID-32
         TRR       R4,R4          ANY REMAINDER?                EAID-32
         BZ        $+2W           NO                            EAID-32
         ADI       R5,1           BUMP 1 SECTOR FOR REMAINDER   EAID-32
         ADI       R5,1           COUNT IS FROM 0               EAID-32
         ARMW      R5,BDBGSIZE    ADD SOURCE SIZE & DEBUG STUFF EAID-32
*----------------------------------------------------------------------
B0.I2    EQU       $                                            EAID-32
         LW        R5,AID.SLEN    # OF SOURCE CHARACTERS        EAID-32
         TRR       R5,R5          ANY SOURCE?                   EAID-32
         BZ        B0.0           NO                            EAID-32
         ZR        R4                                           EAID-32
         DVI       R4,768         768 CHARACTERS PRE BLOCK      EAID-32
         TRR       R4,R4          ANY REMAINDER?                EAID-32
         BZ        $+2W           NO                            EAID-32
         ADI       R5,1           BUMP 1 SECTOR FOR REMAINDER   EAID-32
         ADI       R5,1           COUNT IS FROM 0               EAID-32
         ARMW      R5,BDBGLMSZ    ADD SOURCE SIZE & DEBUG STUFF EAID-32
B0.0     EQU       $                                             1.3#05
*                                                                1.3#05
         TBM       MOPT2,MFLGS     IS OPTION 2 ON                1.3#09
         BS        $+2W            SKIP IF IT IS                 1.3#09
         BL        XLOC            LOCATE OLD FILE AND INIT VOLU 1.3#05
*                                  DONE BY SEGMENT WHEN OPT 2 ON 1.3#09
*                                                                1.3#09
         ZMW       LMBASE          INIT LOAD MODULE BASE ADDR    1.3#05
         ZMW       LMFSIZE         INIT LM FILE SIZE             1.3#05
         ZMW       BNSEG           INIT NUMBER OF SEGMENTS       1.3#05
*                                                                1.3#05
         TBM       MRECAT,MFLGS    ARE WE RECATALOGING           1.3#05
         BNS       B0.1            SKIP IF NOT                   1.3#05
         BL        LMRECAT         GO EVALUATE SIZE OF KEEPERS   1.3#05
*!!!!!!!!!!LW!!!!!!!!R5,LMCPYSTR!!!!!IS!ROOT!BEING!COPIED!!!!!!!!|1.3Q18
         LH        R5,LMCPYSTR     IS ROOT BEING COPIED          |1.3Q18
         BNZ       B0.1            SKIP IF NOT                   1.3#05
         ZBM       MOPT15,MFLGS    AND PROGRAM INFO              1.3#05
         LI        R2,-192D        NUMBER OF DW'S IN 2 SECTORS   1.3#05
         ZMD       MRRS+192D,X2    ZAP THE RRS AREA              1.3#05
         BID       R2,$-1W         LOOP                          1.3#05
B0.1     EQU       $                                             1.3#05
         LW        R5,LMFSIZE      GET CURRENT SIZE              1.3#05
         ADI       R5,1           +1-FOR INDEX BLOCK             1.3#05
         STW       R5,BLMSIZE      INIT LM FILE SIZE             1.3#05
*                                                                1.3#05
         LW        R5,MSYND      GET TOP OF SYMBOL TABLE         1.3#05
         SUI       R5,4W         BACK IT DOWN TO SEG ENT START   1.3#05
*                                                                1.3#05
B1.1     EQU       $               LOOP TOP                      1.3#05
         LW        R4,=X'80000000' LOOK FOR SEGMENT ENTRY        1.3#05
         ZR        R7              ANY NAME WILL DO              1.3#05
         BL        MSSCH           S E A R C H                   1.3#05
         TRR       R5,R1           SET UP INDEX                  1.3#05
         BZ        B1.3            LEAVE IF ALL DONE             1.3#05
         STW       R5,MMODW        UPDATE ADDR OF WORKING MODULE 1.3#05
         ZBM       BFSEG,BFLGS     RESET ROOT FLAG               1.3#05
         LW        R5,1W,X1        GET LEVEL/SEQ.NUM             1.3#05
         BNZ       $+2W            SKIP IF NOT ROOT              1.3#05
         SBM       BFSEG,BFLGS     ELSE SET FLAG                 1.3#05
         BL        BSEGPRMS        GO CALCULATE SEGMENT PARMS    1.3#05
         ZBM       BFSEG,BFLGS     RESET FIRST SEGMENT FLAG      1.3#05
         BNS       $+2W            SKIP IF NOT SET               1.3#05
         ARMW      R7,BDBGSIZE     ADD TO GLOBAL SYMBOL SIZE     1.3#05
         ARMW      R7,BDBGLMSZ    ADD TO GLOBAL SYMBOL TOTAL    EAID-32
*                                                                1.3#05
         LI        R0,3            GET OVERHEAD SECT/LM          1.3#05
         TRR       R1,R7           SAVE R1                       1.3#05
         LW        R1,MMODW        GET ADDR OF SEG ENTRY         1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPRESSED           1.3#05
         BNS       B1.21           SKIP IF OUTPUT ENABLED        1.3#05
         LW        R1,1W,X1        GET OVERLAY LEVEL/SEQ         1.3#05
         BNZ       $+2W            SKIP OVERHEAD IF OVERLAY      1.3#05
         ARMW      R0,BLMSIZE      AND ADD TO TOTAL              1.3#05
         BU        B1.22           SKIP TO LOOP CONTROL          1.3#05
B1.21    EQU       $               HERE IF OUTPUT NOT SUPRESSED  1.3#05
         ARMW      R0,BLMSIZE      AND ADD TO TOTAL              1.3#05
         ARMW      R6,BLMSIZE      ADD TO LM FILE SIZE           1.3#05
B1.22    EQU       $                                             1.3#05
*                                                                1.3#05
*    DO BYTE STUFF                                               1.3#05
*                                                                1.3#05
         CAMW      R2,BLSEGDS      IS IT LARGEST                 1.3#05
         BLE       $+2W            SKIP IF NOT                   1.3#05
         STW       R2,BLSEGDS      ELSE STORE AS LARGEST SEG     1.3#05
*                                                                1.3#05
         CAMW      R3,BLSEGCS      IS LARGEST CSECT HERE         1.3#05
         BLE       $+2W            SKIP IF NOT                   1.3#05
         STW       R3,BLSEGCS      ELSE SAVE AS LARGEST          1.3#05
*                                                                1.3#05
         CAMW      R4,BLPGMDS      IS LRGEST PGM IN THIS SEG     1.3#05
         BLE       $+2W            SKIP IF NOT                   1.3#05
         STW       R4,BLPGMDS      ELSE SAVE                     1.3#05
*                                                                1.3#05
         CAMW      R5,BLPGMCS      IS LARGEST SINGLE CSECT HERE  1.3#05
         BLE       $+2W            SKIP IF NOT                   1.3#05
         STW       R5,BLPGMCS      ELSE SAVE AS LARGEST          1.3#05
*                                                                1.3#05
*        UPDATE POINTERS AND COUNTERS FOR LOOP CONTROL           1.3#05
*                                                                1.3#05
         ABM       31,BNSEG        BUMP SEGMENT COUNT            1.3#05
         SUI       R7,8W           BACK DOWN TO NEXT SEG ENT     1.3#05
         TRR       R7,R5           SET R5 FOR SEARCH             1.3#05
         BU        B1.1            AND LOOP                      1.3#05
*                                                                1.3#05
*                                                                1.3#05
B1.3     EQU       $               HERE AT END OF SIZING LOOP    1.3#05
         LW        R7,DIRSECTS     NUMBER OF DIRECTIVE SECTORS  ETCM-32
         ARMW      R7,BLMSIZE      ADD TO LM SIZE               ETCM-32
         LW        R7,BLMSIZE      GET TOTAL SIZE                1.3#05
         ADMW      R7,BDBGSIZE     ADD IN DEBUG REQUIREMENTS     1.3#05
         ADMW      R7,XINFOENT     AND INFO REQUIREMENTS         1.3#05
         SUI       R7,1            MINUS INDEX BLOCK             1.3#05
         STW       R7,LMTABB       AND SET FOR LMCLOS            1.3#05
*  CONTINUE PROCESSING                                           1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     PASS-B3   OLD MEMORY SIZE CALCULATOR          1.3#05
* FOLLOWING SEQUENCE TO HANDLE OLD "CAR" OPTION IS REMOVED       GKB-CAR
         TITLE     PASS-B4  LAYOUT THE MEMORY & LOAD MODULE FILE
*PARTITION AVAILABLE MEMORY INTO PROGRAM AND MATRIX AND DATAPOOL TABLE
*
B15      EQU       $
*                                                                1.3#05
*   NEW MEMORY ALLOCATION SCHEME IS TO ALLOCATE EXTENDED MEMORY  1.3#05
*   ARRAYS FOR A RELOCATION MATRIX AND SEGMENT BUILDING AREA.    1.3#05
*                                                                1.3#05
*   THE MATRIX ARRAY IS SIZED TO HOLD THE LARGEST MATRIX FOR     1.3#05
*   EACH OF THE CSECT(IFF PRESENT) AND THE DSECT.                1.3#14
*                                                                1.3#14
*   THE ASSEMBLY ARRAYS ARE THE MIN(LARGEST SEGMENT, A DEFAULT)  1.3#14
*   THEN THE MAX(CHOSEN MIN, LARGEST PROGRAM ELEMENT) EACH FOR   1.3#14
*   THE CSECT(IFF PRESENT) AND THE DSECT.                        1.3#14
*                                                                1.3#14
*    THE DEFAULTS ARE ARBITRARY BUT MUST BE INTEGER MULTIPLES    1.3#14
*    OF THE SECTOR SIZE.                                         1.3#14
*    CURRENTLY,  IF OPTION 20 CSECT=8448(11 SECTORS)             1.3#14
*                OR NOT SET        =15360(20 SECTORS)            1.3#14
*                                                                1.3#14
*     IF CSECT THEN DSECT SIZES ARE                              1.3#14
*               IF OPTION 20  DSECT=8448(11 SECTORS)             1.3#14
*               OR NOT SET         =15360(20 SECTORS)            1.3#14
*     ELSE (NO CSECT)                                            1.3#14
*               IF OPTION 20 DESECT=16896(22 SECTORS)            1.3#14
*               OR NOT SET         =30720(40 SECTORS)            1.3#14
*                                                                1.3#14
*                                                                1.3#05
*   THE SPACE BETWEEN THE TOP OF CODE AND THE BOTTOM OF SYMTAB   1.3#05
*   IS ALL ALLOCATED TO DATAPOOL VARIABLES.                      1.3#05
*                                                                1.3#05
*                                                                1.3#05
*   ALLOCATE DEBUG BUFFER IF REQUIRED                            1.3#05
*                                                                1.3#05
         TBM       MOPT19,MFLGS    DEBUG SYMBOLS REQUESTED       1.3#05
         BNS       B15.1           SKIP IF NOT                   1.3#05
         LI        R1,EMDBBSZ      GET BUFFER SIZE               1.3#05
         TBM       MOPT20,MFLGS    IS LIMIT MEM FLAG ON          1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         LI        R1,768          ELSE USE SMALL BUFFER         1.3#05
         ADI       R1,2W           SOME EXTRA FOR BOUNDING       1.3#05
         BL        XGETEA          MEM FOR DEBUG SYMBOL BBUF     1.3#05
         TRR       R2,R2           DID WE GET IT                 1.3#05
         BZ        B15.ERR         BR IF NOT                     1.3#05
         LW        R4,BLMSIZE      GET SIZE OF LM STUFF          1.3#05
         BL        XDBGINIT        AND INIT DEBUG STUFF          1.3#05
B15.1    EQU       $                                             1.3#05
*                                                                1.3#05
*    CALCULATE THE SIZE OF THE DSECT MATRIX                      1.3#05
*                                                                1.3#05
         LW        R7,BLSEGDS      GET SIZE OF LARGEST SEGMENT   1.3#05
         SRL       R7,2            CONVERT TO WORDS              1.3#05
         ES        R6                                            1.3#05
         DVI       R6,32           CALCULATE SIZE OF REL MATRIX  1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP SIZE                1.3#05
         SLL       R7,2            AND CONVERT TO BYTE COUNT     1.3#05
*                                                                1.3#05
*   ALLOCATE DSECT MATRIX MEMORY                                 1.3#05
*                                                                1.3#05
         TRR       R7,R1           REQUEST AMOUNT TO R1          1.3#05
         BL        XGETEA          MEM FOR DSECT MATRIX BUFFER   1.3#05
         TRR       R2,R2           DID WE GET IT                 1.3#05
         BZ        B15.ERR         BR IF NOT                     1.3#05
         STW       R2,DSCTBASE+MDSTRMAD SAVE AS MATRIX BASE ADDR 1.3#05
         STW       R3,DSCTBASE+MDSTRMSZ AND SAVE SIZE            1.3#05
B15.3    EQU       $                                             1.3#05
*                                                                1.3#05
*   CALCULATE CSECT MATRIX SIZE                                  1.3#05
*                                                                1.3#05
         LW        R7,BLSEGCS      GET LARGEST SEGMENT CSECT     1.3#05
         BZ        B15.4             SKIP IF NO CSECT            1.3#05
         SRL       R7,2              CONVERT SIZE TO WORD COUNT  1.3#05
         ES        R6                                            1.3#05
         DVI       R6,32             CALC SIZE OF MATRIX         1.3#05
         TRR       R6,R6             ANY REMAINDER               1.3#05
         BZ        $+2W              SKIP IF NONE                1.3#05
         ADI       R7,1              ELSE ROUND UP               1.3#05
         SLL       R7,2              CONVERT TO BYTE COUNT       1.3#05
*                                                                1.3#05
*    ALLOCATE CSECT MATRIX MEMORY                                1.3#05
*                                                                1.3#05
         TRR       R7,R1           REQUEST AMOUNT TO R1          1.3#05
         BL        XGETEA          MEM FOR CSECT MATRIX BUFFER   1.3#05
         TRR       R2,R2           DID WE GET IT                 1.3#05
         BZ        B15.ERR         BR IF NOT                     1.3#05
         STW       R2,CSCTBASE+MDSTRMAD SAVE STARTING ADDRESS    1.3#05
         STW       R3,CSCTBASE+MDSTRMSZ AND SIZE OF CSECT MATRIX 1.3#05
B15.4    EQU       $                                             1.3#05
*                                                                1.3#05
*   CALCULATE SIZE OF CSECT ASSEMBLY AREA                        1.3#05
*                                                                1.3#05
         ZBM       BLMSCTS,BFLGS   RESET CSECT ASSM AREA FLAG    1.3#14
         LW        R2,BLSEGCS      GET LARGEST SEGMENT CSECT     1.3#05
         TBM       MOPT20,MFLGS    IS SLOW MODE SET              1.3#05+
         BS        B15.41          USE SMALL SIZES               1.3#05+
         CI        R2,15360        COMPARE TO DEFAULT MINIMUM    1.3#05
         BLT       $+2W            SKIP IF SEGMENT SMALLER       1.3#05
         LI        R2,15360        ELSE USE DEFAULT MINIMUM      1.3#05
         BU        B15.42          GOTO MERGE POINT              1.3#05+
B15.41   EQU       $                                             1.3#05+
         CI        R2,8448         USE AN 11 SECTOR BUFFER       1.3#05+
         BLT       $+2W            UNLESS SEGMENT IS LESS        1.3#05+
         LI        R2,8448                                       1.3#05+
*                                                                1.3#05
B15.42   EQU       $                                             1.3#05+
         LW        R1,BLPGMCS      GET LARGEST PROGRAM CSECT     1.3#05
         BZ        B15.5           SKIP IF NO CSECT              1.3#05
         SBM       BLMSCTS,BFLGS   SET CSECT ASSM AREA ALLOC'D   1.3#14
         ADI       R1,768          BUMP BY BOUNDING AMOUNT       1.3#05
         CAR       R1,R2           AND COMPARE TO MAX            1.3#05
         BLT       $+2W            SKIP IF LESS THAN MINIMUM     1.3#05
         TRR       R2,R1           ELSE GET MINIMUM SIZE         1.3#05
         BL        XGETEA          MEM FOR CSECT CODE ASSEMBLY   1.3#05
         TRR       R2,R2           GOT IT?                       1.3#05
         BZ        B15.ERR         BR IF NOT                     1.3#05
         STW       R2,CSCTBASE+MDSTFST ELSE SAVE STARTING ADDR   1.3#05
         STW       R3,CSCTBASE+MDSTSIZ AND SIZE                  1.3#05
         ADR       R2,R3           CALC ENDING ADDR              1.3#05
         STW       R3,CSCTBASE+MDSTLST AND SAVE                  1.3#05
*  INITIALIZE ASSEMBLY POINTERS                                  1.3#05
         STW       R2,CSCTBASE+MDSTPEB PROG ELEMT. BASE          1.3#05
         STW       R2,CSCTBASE+MDSTNXT AND NEXT AVAIL LOC.       1.3#05
B15.5    EQU       $                                             1.3#05
*                                                                1.3#05
*  ALLOCATE DSECT ASSEMBLY AREA                                  1.3#05
*                                                                1.3#05
         LW        R2,BLSEGDS      GET LARGEST SEGMENT SIZE      1.3#05
         ZR        R3              INIT DSECT TABLE POINTER      1.3#14
         TBM       BLMSCTS,BFLGS   IS CSECT PRESENT              1.3#14
         BS        $+2W            SKIP TO CHOOSE FROM 1ST 2 ENTS1.3#14
         ADI       R3,2W           ELSE CHOOSE FROM LAST 2       1.3#14
         TBM       MOPT20,MFLGS    IS SLOW MODE SET              1.3#05+
         BS        $+2W            USE FIRST OF SELECTED TWO     1.3#14
         ADI       R3,1W           ELSE USE 2ND OF CHOSEN        1.3#14
*                                                                1.3#14
         CAMW      R2,B15.DSS,X3   COMPARE TO SELECTED DEFAULT   1.3#14
         BLT       $+2W            SKIP IF SMALLER               1.3#14
         LW        R2,B15.DSS,X3   ELSE USE SELECTED DEFAULT     1.3#14
*                                                                1.3#05
         LW        R1,BLPGMDS      GET SIZE OF LRGST PROG        1.3#05
         ADI       R1,768          ADD IN BOUNDING AREA          1.3#05
         CAR       R1,R2           COMPARE TO MINIMUM            1.3#05
         BLT       $+2W            SKIP IF GREATER               1.3#05
         TRR       R2,R1           ELSE LOAD MINIMUM             1.3#05
         BL        XGETEA          MEM FOR DSECT CODE ASSEMBLY   1.3#05
         TRR       R2,R2           DID WE GET IT                 1.3#05
         BZ        B15.ERR         USE OLD WAY IF WE DIDN'T      1.3#05
         STW       R2,DSCTBASE+MDSTFST SET IMAGE ASSEM AREA ADDR 1.3#05
         STW       R3,DSCTBASE+MDSTSIZ AND IMAGE AREA SIZE       1.3#05
         ADR       R2,R3           CALC ENDING ADDR              1.3#05
         STW       R3,DSCTBASE+MDSTLST AND SAVE                  1.3#05
*    INITIALIZE  BUILD AREA POINTERS                             1.3#05
         STW       R2,DSCTBASE+MDSTPEB START, PRG. ELE. BASE AND 1.3#05
         STW       R2,DSCTBASE+MDSTNXT NEXT FREE LOC. POINTERS   1.3#05
*                                                                1.3#05
*                                                                1.3#05
*                                                                1.3#05
*   ALLOCATE DATAPOOL TABLE MEMORY                               1.3#05
*                                                                1.3#05
         LW        R4,MPFST        GET START OF FREE MEM         1.3#05
         STW       R4,MDPFT        SET STARTING ADDR OF DATAPOOL 1.3#05
         LW        R5,MSYMN
         SUMW      R5,MDPFT        SUBTRACT DATAPOOL START       1.3#05
         ZR        R4
         DVI       R4,3W
         BGT       B15.6           BR IF THERE IS SPACE FOR ONE ENTRY
         LNB       R5,B15.M3L                                    1.3#05
         LA        R6,B15.MSG3                                   1.3#05
         BL        XTYPEF                                        1.3#05
         BL        XABORT                                        1.3#05
B15.6    STW       R5,MDPNE        NUMBER OF DATAPOOL TABLE ENTRIES
*
*
*  IF WE ARE PRODUCING A NEW FORMAT LM FILE THEN SIZE AND        1.3#05
*  CREATE IT HERE. ELSE, A NEW FILE IS CREATED AS EACH SEGMENT   1.3#05
*  IS DONE.                                                      1.3#05
*                                                                1.3#05
         TBM       MOPT2,MFLGS                                     22001
         BS        B20.0           BRANCH IF OLD FORMAT            22001
         LW        R5,BLMSIZE      SET LOAD MODULE SIZE          1.3#05
         ZR        R6              PRESET DEBUG SPACE            1.3#05
         TBM       MOPT19,MFLGS    SYMBOLS REQUESTED             1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         LW        R6,BDBGLMSZ    GET NUMBER OF SYMBOLS IN ROOT EAID-32
         ZR        R7              PRESET INFO SPACE REQUIR.     1.3#05
         TBM       MOPT15,MFLGS    INFO REQUESTED                1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         LW        R7,XINFOENT     SET UP SPACE REQUIR. FOR INFO 1.3#05
*                                                                1.3#10
         ADR       R6,R5           LM PLUS DEBUG STUFF           1.3#10
         ADR       R7,R5           PLUS INFO STUFF               1.3#10
         ADMW      R5,NSLOP       ADD ROUND OFF SLOP            EAID-32
         ADMW      R5,AID.NCAT    ADD 1 SECTOR PER MODULE SLOP  EAID-32
         ADMW      R5,AID.NCAT    ADD 1 SECTOR FOR EACH MODULE  EAID-32
*                                 TO BE CATALOGED,SINCE EACH    EAID-32
*                                 ALWAYS HAS AT LEAST 1 SECTOR  EAID-32
*                                 OF SOURCE                     EAID-32
         STW       R5,LMTABB      ALSO SET AS TABLE SECTOR      EAID-32
         ADI       R5,1           BUMP, SIZE IS ONE RELATIVE    EAID-32
         TBM       MOPT4,MFLAG2    SAVE DIRECTIVES?             ETCM-32
         BS        $+2W            DON'T ADD DIRECTIVE SECTORS  ETCM-32
         ADMW      R5,DIRSECTS     ADD SECTORS FOR DIRECTIVES   ETCM-32
         LI        R6,32           ALLOW ALL 32 SEGMENTS         1.3#10
         LA        R1,MODFCB       MODULE FILE FCB ADDR          1.3#10
         BL        XCRETMP         GET A TEMP FILE               1.3#05
         TRR       R7,R7           ANY ERROR                     1.3#05
         BZ        B15.MRG1        CONTINUE IF NONE              1.3#05
B15.7    EQU       $               HERE FOR TEMP FILE ALLOC ERR  1.3#05
         STW       R7,B15.M2D1                                   1.3#05
         LNB       R5,B15.M2L      GET LENGTH(UT&SLO)            1.3#05
         LA        R6,B15.MSG2     GET ADDR                      1.3#05
         BL        XTYPEF          LOG MESSAGE                   1.3#05
         BL        XABORT          AND QUIT                      1.3#05
*                                                                1.3#05
B15.ERR  EQU       $                                             1.3#05
         LNB       R5,B15.M1L                                    1.3#05
         LA        R6,B15.MSG1                                   1.3#05
         BL        XTYPEF                                        1.3#05
         BL        XABORT                                        1.3#05
*                                                                1.3#05
B15.MRG1 EQU       $                                             1.3#05
         SBM       BLMOPN,BFLGS    INDICATE LM FILE OPEN         1.3#05
         TBM       MRECAT,MFLGS    ARE WE RECATALOGING           1.3#05
         BNS       B20.0           SKIP OUT IF NOT               1.3#05
         LH        R7,LMCPYSTR     GET FIRST ENTRY IN COPY LIST  1.3#05
         BNZ       B20.0           IF NOT ROOT, LINK FIRST       1.3#05
         LNW       R3,LMCOPY       ELSE COPY FIRST               1.3#05
         LA        R1,B15.SEGE     ADDR OF SIMULATED ENTRY       1.3#05
         ZR        R2              INIT COPY LIST INDEX          1.3#05
         NOP                                                     1.3#05
B15.8    EQU       $                                             1.3#05
         LH        R4,LMCPYSTR,X2   GET NEXT START ADDR          1.3#05
         STW       R4,B15.SEGE+1W   SET UP FOR LMTAB             1.3#05
         LH        R5,LMCPYSIZ,X2   AND SIZE                     1.3#05
         SLL       R2,2             CONVERT TO DW INDEX          1.3#05
         LD        R6,LMCPYMOD,X2   GET NAME                     1.3#05
         STD       R6,1D,X1         STORE FOR LMTAB              1.3#05
         SRL       R2,2             BACK TO HW INDEX             1.3#05
         BL        XCOPYMOD         NOW COPY THIS MODULE         1.3#05
         BL        LMTAB            UPDATE LM INDEX BLOCK        1.3#05
         ADI       R2,1H            BUMP R2                      |1.3Q18
         ARMW      R5,LMBASE        AND BASE FOR NEXT MODULE     1.3#05
         BIB       R3,B15.8         AND LOOP                     1.3#05
         ZBM       MRECAT,MFLGS     RESET RECAT MODE             1.3#05
         ZMB       LMFCBIN         ZAP BYTE ZERO OF FCB          1.3#05
         ZR        R7                                            1.3#05
         LA        R1,LMFCBIN                                    1.3#05
         SVC       2,X'53'         M.DASN OLD LMFILE             1.3#05
         BU        B20.0           NOW PROCESS MODULES           1.3#05
*                                                                1.3#05
         BOUND     1D                                            1.3#05
B15.SEGE DATAW     0                                             1.3#05
         DATAW     0                                             1.3#05
         DATAD     0                                             1.3#05
*
B15.DSS  DATAW     8448            DSECT SIZE IF OPT20&CSECT     1.3#14
         DATAW     15360           DSECT SIZE IF -OPT20&CSECT    1.3#14
         DATAW     16896           DSECT SIZE IF OPT20&-CSECT    1.3#14
         DATAW     30720           DSECT SIZE IF -OPT20&-CSECT   1.3#14
*                                                                1.3#05
B15.MSG1 DATAB     C' CATALOG<<FATAL>> INSUFFICIENT PHYSICAL '   1.3#05
         DATAB     C'MEMORY TO CATALOG THIS TASK.'               1.3#05
B15.M1L  DATAB     $-B15.MSG1                                    1.3#05
         BOUND     1W
*                                                                1.3#05
B15.MSG2 DATAB     C' CATALOG<<FATAL>>  ERROR TYPE:  '           1.3#05
B15.M2D1 REZ       4B              HOLDS XXNN STATSU             1.3#05&
         DATAB     C'  WHILE ALLOCATING TEMPORARY LOAD MODULE.'  1.3#05&
B15.M2L  DATAB     $-B15.MSG2                                    1.3#05
*                                                                1.3#05
B15.MSG3 DATAB     C' CATALOG<<FATAL>> NO MEMORY FOR DATAPOOL '  1.3#05
         DATAB     C'VARIABLE TABLE.'                            1.3#05
B15.M3L  DATAB     $-B15.MSG3                                    1.3#05
         BOUND     1W
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     PASS-B5 - MAIN PROCESSING LOOP
*BEGIN PROCESSING NEW MODULE.  BUILD PREAMBLE
*                                                                1.3#05
B20.0    EQU       $
B20      EQU       $                                             1.3#05
         LW        R1,MSYND        GET TOP OF SYMBOL TABLE       1.3#05
         SUI       R1,4W           BACK IT DOWN TO FIRST ENTRY   1.3#05
         STW       R1,BMODNXT      AND SAVE AS ADDR OF NXT MOD   1.3#05
B20.1    EQU       $               SEGMENT LOOP TOP              1.3#05
         LW        R1,BMODNXT      GET ADDR OF NEXT MODULE       1.3#05
         TBM       0,0,X1          IS THERE ANOTHER MODULE       1.3#05
         BS        B205            BR TO PROCESS                 1.3#05
*
* THERE ARE NO MORE MODULES TO PROCESS. IF WE ARE CATALOGING A
* NEW FORMAT LOAD MODULE THEN CALL THE ROUTINE LMCLOSE TO WRITE
* THE INDEX BLOCK TO THE FILE AND CLOSE IT.
*
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TBM       MOPT2,MFLGS                                     22001
         BS        B20.6           BRANCH IF OLD FORMAT            22001
         TBM       MRECAT,MFLGS    ANY RECAT STUFF TO DO         1.3#05
         BNS       B20.5           SKIP IF NOT                   1.3#05
         LNW       R3,LMCOPY       ELSE COPY FIRST               1.3#05
         LA        R1,B15.SEGE     SET UP FOR LMTAB              1.3#05
         ZR        R2              INIT COPY LIST INDEX          1.3#05
         NOP                                                     1.3#05
B20.4    EQU       $                                             1.3#05
         LH        R4,LMCPYSTR,X2   GET NEXT START ADDR          1.3#05
         STW       R4,B15.SEGE+1W                                1.3#05
         LH        R5,LMCPYSIZ,X2   AND SIZE                     1.3#05
         SLL       R2,2            CONVERT TO DW INDEX           1.3#05
         LD        R6,LMCPYMOD,X2                                1.3#05
         STD       R6,1D,X1                                      1.3#05
         SRL       R2,2            BACK TO HW INDEX              1.3#05
         BL        XCOPYMOD         NOW COPY THIS MODULE         1.3#05
         BL        LMTAB            UPDATE LM INDEX BLOCK        1.3#05
         ARMW      R5,LMBASE        AND BASE FOR NEXT MODULE     1.3#05
         BIB       R3,B20.4         AND LOOP                     1.3#05
         ZBM       MRECAT,MFLGS     RESET RECAT MODE             1.3#05
         ZMB       LMFCBIN         ZAP BYTE ZERO OF FCB          1.3#05
         ZR        R7                                            1.3#05
         LA        R1,LMFCBIN                                    1.3#05
         SVC       2,X'53'         M.DASN OLD LM FILE            1.3#05
B20.5    EQU       $                                             1.3#05
         BL        LMCLOSE
B20.6    EQU       $
         BL        XSYM
         TBM       XABORTFL,XFLGS  CHECK ABORT FLAG                21016
         BS        XABORT                                        1.3#10
*
*!!!!!!!!BL!!!!!!!!XBIRD!!!!!!!!!!!RESET!SGO!FILE!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!BL!!!!!!!!XBIRW!!!!!!!!!!!AND!REWIND!!!!!!!!!!!!!!!!!!!ENCD-32
         LW        R3,SGPNTRS+1W   GET SGO FAT ADDRESS          PR10808
         LW        R5,DFT.EOF,X3   GET SGO SIZE                 PR10808
         CI        R5,0            ANYTHING ON SGO              PR10808
         BEQ       B20.6C          SKIP REWIND IF NO SGO        PR10808
         TBM       XBIRDFST,XFLGS  IS SGO OPEN                  PR10808
         BS        B20.6B          SKIP OPEN IF SO              PR10808
         M.OPENR   XBIRD91,EXITCNP    OPEN SGO                  PR10808
B20.6B   M.RWND    XBIRD91            REWIND SGO                PR10808
B20.6C   EQU       $                                            PR10808
         M.EXIT                    EXIT FROM CATALOGER
*=======================================================================
*=======================================================================
*
*
B205     EQU       $                                             1.3#05
         STW       R1,MMODW       SAVE THIS SEG ADDR             1.3#05
         ZBM       BFSEG,BFLGS     INIT ROOT FLAG                1.3#05
         LW        R5,1W,X1        GET LEVEL/SEQUENCE            1.3#05
         BNZ       $+2W            SKIP IF NOT ROOT              1.3#05
         SBM       BFSEG,BFLGS     ELSE SET ROOT FLAG            1.3#05
         TBM       BFSEG,BFLGS    CATALOGING ROOT?              EAID-32
         BS        B20.AID        YES, THEN NEXT STEP IS DONE   EAID-32
*-----------------------------------------------------------------------
B206     ABM       29,XSYMI2                                    EAID-32
         LW        R5,*XSYMI2     GET COUNT OF LOCAL SYMBOLS    EAID-32
         ZR        R4                                           EAID-32
         DVI       R4,48          48 ENTRIES PER SECTOR         EAID-32
         ADI       R5,1           ROUND UP                      EAID-32
         STW       R5,BDBGSIZE    INIT FILE SIZE                EAID-32
*----------------------------------------------------------------------
         ABM       29,XSRCOV2                                   EAID-32
         LW        R5,*XSRCOV2    # OF SOURCE CHARS IN OLAY     EAID-32
         TRR       R5,R5          ANY SOURCE?                   EAID-32
         BZ        B20.AID        NO                            EAID-32
         STW       R5,AID.SLEN                                  EAID-32
         ZR        R4                                           EAID-32
         DVI       R4,768         768 CHARACTERS PRE BLOCK      EAID-32
         TRR       R4,R4          ANY REMAINDER?                EAID-32
         BZ        $+2W           NO                            EAID-32
         ADI       R5,1           BUMP 1 SECTOR FOR REMAINDER   EAID-32
         ADI       R5,1           COUNT IS FROM 0               EAID-32
         ARMW      R5,BDBGSIZE    ADD SOURCE SIZE TO DBUG STUFF EAID-32
B20.AID  EQU       $                                            EAID-32
*
* A NEW MODULE HAS BEEN FOUND. IF WE ARE CATALOGING A NEW FORMAT
* LOAD MODULE THEN CALL THE ROUTINE LMTAB TO UPDATE THE INDEX BLOCK
* WITH THE NEW MODULE NAME AND THE STAT BLOCK NUMBER.
*
         TBM       MOPT2,MFLGS                                     22001
         BS        B20.7           BRANCH IF OLD FORMAT            22001
         BL        LMTAB
         BU        B20.8           CONTINUE                      1.3#05
B20.7    EQU       $
*                                                                1.3#05
*  ELSE CALCULATE REQUIRED SIZES THIS SEGMENT AND CREATE FILE    1.3#05
*                                                                1.3#05
          LD       R6,1D,X1        GET MODULE NAME               1.3#05
         STD       R6,XCREATNM     SAVE AS FILE NAME             1.3#05
         BL        XPATH           BUILD PATHNAME                1.3#05
         BL        XLOC            LOCATE OLD LM FILE & INIT VOL 1.3#05
         BL        BSEGPRMS        CALCULATE SEGMENT SIZE INFO   1.3#05
         TRR       R6,R5           MOVE DATA FOR NEXT CALL       1.3#05
         TRR       R7,R6           THIS ONE TOO                  1.3#05
         ADI       R5,1            ADD IN PREAMBLE REQUIREMENT   1.3#05
         ADI       R5,2            ELSE ADD IN RRS SPACE         1.3#05
         TBM       MOPT19,MFLGS    DEBUG SYMBOLS ON              1.3#05
         BS        $+3W            SKIP IF ON                    1.3#05
         ZR        R6              ELSE RESET SPACE REQUEST      1.3#05
         BU        $+2W            AND SKIP AGAIN                1.3#05
         ADMW      R6,BDBGSIZE     ELSE ADD IN LOCAL SIZE        1.3#05
         ZR        R7              INIT INFO REQUIREMNTS         1.3#05
         TBM       MOPT15,MFLGS    PROG INFO REQUESTED           1.3#05
         BNS       $+2W            SKIP IF NOT SET               1.3#05
         LW        R7,XINFOENT     ELSE GET INFO SPACE REQUIR.   1.3#05
*                                                                1.3#10
         ADR       R6,R5           LM PLUS DEBUG STUFF           1.3#10
         ADR       R7,R5           PLUS INFO STUFF               1.3#10
         TBM       MOPT4,MFLAG2    SAVE DIRECTIVES?             ETCM-32
         BS        $+2W            DON'T ADD DIRECTIVE SECTORS  ETCM-32
         ADMW      R5,DIRSECTS     ADD SECTORS FOR DIRECTIVES   ETCM-32
         LI        R6,32           ALLOW ALL 32 SEGMENTS         1.3#10
         LA        R1,MODFCB       FILE FCB ADDR                 1.3#10
         BL        XCRETMP         AND CREATE THE LM  FILE       1.3#05
         TRR       R7,R7           ANY ERROR                     1.3#05
         BNZ       B15.7           BR TO ERROR OUT               1.3#05
         SBM       BLMOPN,BFLGS    INDICATE LM FILE OPEN         1.3#05
*                                                                1.3#05
*                                                                1.3#05
B20.8    EQU       $                                             1.3#05
         BL        BLNKSEG         LINK THIS SEGMENT             1.3#05
         ZBM       MOPT15,MFLGS    RESET INFO OPTION             1.3#05
         TBM       MOPT2,MFLGS     IS IT OLD OR NEW FORMAT       1.3#05
         BS        B20.84          BRANCH IF OLD                 1.3#05
         LW        R7,LMFSIZE      SIZE OF SEGMENT JUST DONE     1.3#05
         ADI       R7,1            ADD AN EXTRA JUST IN CASE    EAID-32
         ARMW      R7,LMBASE       INTO BASE ADDR FOR NEXT LM    1.3#05
         BU        B20.1           LOOP FOR NEXT                 1.3#05
*                                                                1.3#05
B20.84   EQU       $               HERE FOR OLD FORMAT           1.3#05
         ZBM       4,MOPTS         FORCE FOR XCLOS               1.3#05
         BL        XCLOS           CLOSE AND DEALLOCATE LM FILE  1.3#05
         BU        B20.1           GO LOOP FOR MORE              1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     PASS-B6  - SEGMENT LINK ROUTINE
**************************************************************
*
*BEGIN PROCESSING A NEW PROGRAM ELEMENT
*
*****************************************************************
         SPACE
BLNKSEG  STF       R0,BLS.RSAV                                   1.3#05
*                                                                1.3#05
         ZBM       XT.UTOFF,XT.FLGS      RE-ENABLE WARNINGS      1.3#10
         ZBM       XT.LOGED,XT.FLGS      AND ACTION MESSAGE      1.3#10
         SBM       XLMFBAD,XFLGS    INDIATE LM NOT STORED        1.3#14
*
         LW        R1,MMODW        RECOVER SYMT ADDR OF SEG ENT  1.3#05
         LI        R6,3            INIT SIZE FOR PRE+RRS         1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPPRESSED          1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         LI        R6,0            ELSE INIT LMFSIZE AT ZERO     1.3#05
         STW       R6,LMFSIZE      SET INIT OFFSETS FOR THIS SEG 1.3#05
*                                                                1.3#05
         BL        BSEGPRMS        CALCULATE FILE STUFF          1.3#05
         SUI       R1,8W           BACK SYMTAB POINTER DOWN      1.3#05
         STW       R1,BMODNXT      SAVE ADDR OF NEXT SEG ENTRY   1.3#05
         ZBM       MSECTS,MFLGS    RESET SECTIONED SEGMENT FLAG  1.3#21
         TRR       R3,R3           ANY CSECT IN SEGMENT          1.3#21
         BZ        $+2W            SKIP IF NOT                   1.3#21
         SBM       MSECTS,MFLGS    ELSE SHOW SECTIONED SEGMENT   1.3#21
*
         BL        BBLDPRE         BUILD PRE AMBLE               1.3#05
*                                                                1.3#05
         ZR        R7                                            1.3#05
         ZMW       MCREC                                         1.3#05
*!!!!!!!!!!ZBM!!!!!!!MSECTS,MFLGS!!!!INIT!SEGMENT!AS!UNSECTIONED!1.3#21
*                                                                1.3#05
         LW        R4,BPREAMB+PR.SFAD  GET FILE ADDR OF DSECT    1.3#05
         STW       R4,DSCTBASE+MDSTSFAD  AND SAVE IN DOPE VECTOR 1.3#05
         LW        R4,BPREAMB+PR.SFAC  GET FILE ADDR OF CSECT    1.3#05
         STW       R4,CSCTBASE+MDSTSFAD  AND SAVE IN DOPE VECTOR 1.3#05
*                                                                1.3#05
         ZMW       DSCTBASE+MDSTBOUT RESET DSECT BYTES OUT COUNT 1.3#05
         ZMW       CSCTBASE+MDSTBOUT  SECTORS AND BYTES          1.3#05
*                                                                1.3#05
         ZMW       DSCTBASE+MDSTSOUT AND SECTORS OUT COUNT       1.3#05
         ZMW       CSCTBASE+MDSTSOUT  SAME FOR CSECT             1.3#05
*                                                                1.3#05
         ZMW       DSCTBASE+MDSTCHKD  ZERO CHECKSUM ACCUMULATOR  1.3#05
         ZMW       CSCTBASE+MDSTCHKD  FOR BOTH SECTIONS          1.3#05
*                                                                1.3#05
         LW        R4,=X'04000000'                               1.3#05
         LW        R5,MMODW        MODULE START ADDRESS          1.3#05
         TRR       R5,R1           TO ACCESS MODULE ENTRY        1.3#05
         BL        MSSCH                                         1.3#05
         STW       R5,MSYMC        FIRST CONTROL ENTRY           1.3#05
*                                                                1.3#05
         BL        BGSYMS          OUTPUT GLOBAL SYMBOLS         1.3#05
         SBM       MFSTE,MFLGS     SET FIRST PROGRAM FLAG        1.3#05
*
*        TOP OF PROGRAM ELEMENT LOOP
*
B31      ZMH       MXSEQ           INITIALIZE EXPECTED SEQUENCE NUMBER,
         ZBM       MPEND,MFLGS     END OF PROGRAM FLAG, AND
         LW        R1,MSYMC        GET ADDR OF CURRENT CONTROL   1.3#05
         SUI       R1,4W           BACK IT UP TO PROG ENTRY      1.3#05
         LD        R4,1D,X1        GET PROGRAM NAME              1.3#05
         STD       R4,MPNAM        AND SAVE FOR ANY MESSAGES     1.3#05
B31.CPRG SBM       XNEWMOD,XFLGS   SET FLAG FOR INFO RECORDS     1.3#05
*                                                                1.3#05
* OUTPUT SYMBOLIC DEBUGGER ITEM FOR "PROGRAM" ENTRY              1.3#05
*                                                                1.3#05
         TBM       MOPT19,MFLGS    IS SYMBOL GENERATION ON?      1.3#05
         BNS       B31.002         BR   IF NOT                   1.3#05
         SBR       R4,0            MAKE IT A PROGRAM ENTRY       1.3#05
         STD       R4,XSYMBUF      STORE PROG. NAME IN WRDS 0&1  1.3#05
         LW        R4,=X'00FFFFFF'                               1.3#05
         LMW       R5,5W,X1        GET CAT ALLOCATION THIS CNTRL 1.3#05
         ADMW      R5,7W,X1        ADD IN MODULE RELATIVE ADDR   1.3#05
         TRR       R5,R4           MOVE TO R4                    1.3#05
         LW        R5,AID.SSCT     GET THE CURR SOURCE SECTOR # EAID-32
         SRL       R5,7            LOSE A PORTION OF THE OFFSET EAID-32
*                                  PORTION                      EAID-32
         SLL       R5,7            PUT IT IN ITS CORRECT PLACE  EAID-32
         STW       R5,AID.SSB      SAVE FOR LATER               EAID-32
         SLL       R5,15           PREP FOR STORE IN SYM TABLE  EAID-32
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE            1.3#05
         BNS       B31.001         BR IF NOT ABSOLUTE            1.3#05
         ADMW      R4,MPABS        ADD IN ABSOLUTE BASE          1.3#05
         SBR       R5,31           SHOW IT AS ABSOLUTE TO DEBUG  1.3#05
B31.001  EQU       $                                             1.3#05
         STW       R4,XCOMRELO          SAVE COMMON RELOC FOR M2 1.3#05
         ORMW      R4,=X'12000000'   PUT IN TYPE 18             EAID-32
         STD       R4,XSYMBUF+1D      STORE SECOND HALF          1.3#05
         BL        XDBGSYM         GO ADD TO BUFFER              1.3#05
         LW        R1,MSYMC        GET CONTROL ENTRY            EAID-32B
         TBM       8,0,R1          ARE WE SECTIONED?            EAID-32
         BNS       B31.002         SKIP IF NOT                  EAID-32
         SUI       R1,4W           GET PROGRAM ENTRY            EAID-32B
         LD        R4,1D,X1        GET PROGRAM NAME             EAID-32B
         STD       R4,XSYMBUF      SAVE IN BUFFER               EAID-32B
         SUI       R1,8W           GET CSECT SECTION ENTRY      EAID-32B
         LW        R4,1W,R1        GET ORIGIN ADDRESS           EAID-32B
         ANMW      R4,=X'00FFFFFF' JUST THE ADDRESS             EAID-32B
         ADMW      R4,DEBIAS       BIAS IT                      EAID-32C
         ZR        R5                                           EAID-32B
         SBR       R5,29           SET CSECT ADDR BIT           EAID-32B
         SBR       R5,31           SET ABSOLUTE ADDR BIT        EAID-32
         ORMW      R4,=X'11000000' OR IN TYPE VALUE (17 DEC.)   EAID-32B
         STD       R4,XSYMBUF+1D   SAVE IN BUFFER               EAID-32B
         BL        XDBGSYM         PUT OUT RECORD               EAID-32B
*                                                                1.3#05
*    INITIALIZE ASSEMBLY POINTERS                                1.3#05
*                                                                1.3#05
*          ALWAYS DO THE DSECT POINTERS                          1.3#05
*                                                                1.3#05
B31.002  EQU       $                                             1.3#05
         LW        R1,MSYMC        GET CURRENT CONTROL ENTRY
         LW        R2,MMODW
         LW        R4,=X'00FFFFFF'
         LMW       R6,3W,X1        ELEMENT'S ADDRESS             1.3#05
         SUMW      R6,5W,X2        SUB OUT MODULE ORIGIN         1.3#05
         SUMW      R6,DSCTBASE+MDSTBOUT AND ANY AMOUNT THATS OUT 1.3#05
         TBM       MFSTE,MFLGS     IS THIS THE FIRST PROG ELE    1.3#07
         BS        $+2W            SKIP IF IT IS THE FIRST       1.3#07
         SUMW      R6,BSP.BIAS     REMOVE UN-INIT'D AREA         1.3#07
         ADMW      R6,DSCTBASE+MDSTFST ADD IN BUFFER BASE        1.3#05
         STW       R6,DSCTBASE+MDSTNXT PLUS NEXT FREE LOC POINTR 1.3#05
         STW       R6,DSCTBASE+MDSTHST PLUS HI LOCATION USED     1.3#05
         TBM       MFSTE,MFLGS     IS THIS FIRST PGM             1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         SUMW      R6,BSP.BIAS     PROG BASE CAN BE BELOW START  1.3#07
         STW       R6,DSCTBASE+MDSTPEB AND SET PRG. ELEM.  BASE  1.3#05
*                                                                1.3#05
         ZR        R7              INIT SIZE ACCUMULATOR         1.3#05
         LMW       R5,1W,X1        GET CAT ALLOCATED AMOUNT      1.3#05
         ADR       R5,R7           AND ACCUMULATE                1.3#05
         LMW       R5,2W,X1        GET SIZE OF OBJECT CODE       1.3#05
         ADR       R5,R7           AND ACCUMULATE                1.3#05
         ADR       R6,R7           ADD IN POSITION IN BUFFER     1.3#05
         CAMW      R7,DSCTBASE+MDSTLST WILL THIS PROG OVERFLOW   1.3#05
         BLE       BLS.32          SKIP IF NOT                   1.3#05
         LA        R1,DSCTBASE     SET UP DOPE VECTOR ADDR       1.3#05
         BL        MFLSHBUF        FLUSH THE ASSEMBLY AREA       1.3#05
         LW        R1,MSYMC        RECOVER CONTROL ENTRY ADDR    1.3#05
BLS.32   EQU       $                                             1.3#05
         LMW       R6,3W,R1        ELEMENT'S ADDRESS  AGAIN      1.3#05
         LMW       R5,1W,X1        CAT ALLOCATED AMOUNT          1.3#05
         ADR       R5,R6
         STW       R6,DSCTBASE+MDSTORG ADDR OF ELEMENT'S OBJ CODE
*
*        DO CSECT POINTERS IF CSECT PRESENT
*
         ZMW       MSEC1           CLEAR SIZE OF SECTION ONE      12013
         TBM       8,0,R1          ANY SECTIONS
         BS        B31.02          PROCESS IF SET                1.3#05
         ZBM       BSECTS,BFLGS    ELSE SHOW NO SECTS THIS PROG  1.3#05
         BU        B31.2           AND CONTINUE                  1.3#05
B31.02   EQU       $                                             1.3#05
*!!!!!!!!!!SBM!!!!!!!MSECTS,MFLGS!!!!INDICATE!SECTIONED!SEGMENT!!1.3#21
         SBM       BSECTS,BFLGS    SHOW THIS PROG HAS SECTIONS   1.3#05
         TRR       R1,R3           CONTROL ENTRY ADDR TO R3
         SUI       R3,4W           BACK IT DOWN TO PROG ENTRY
B31.1    SUI       R3,4W           LOOP TO PROCESS SECTION ENTRIES
         TBM       3,0,R3          SECTION ID
         BNS       B31.2           NO SECTIONS
         TBM       2,0,R3          MUST NOT BE COMMON
         BS        B31.2           NOT A SECTION
         LB        R4,4B,R3        GET SECTION NUMBER
         CI        R4,1            SECTION ONE
         BNE       B31.1           NOT SECT ONE
*                                                                1.3#05
*    SET UP SECTION 1 STUFF                                      1.3#05
*                                                                1.3#05
         LW        R4,=X'00FFFFFF'
         LMW       R6,1W,R3        GET SECTION ORIGIN
         STW       R6,CSCTBASE+MDSTORG   SAVE AS OBJ CODE ORG    1.3#05
*!!!!!!!!ARMW!!!!!!R6,DSCTBASE+MDINTREF!!!!!!!!!!!!!!!!!!!!!!!!!ELST-32F
*        TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-32
*        BNS       $+2W            SKIP IF NOT                  ELST-32
*        ZMW       CSCTBASE+MDSTORG  CSECT BIAS=0 IF 2.5MB      ELST-32
         ZMW       CSCTBASE+MDINTREF                            ELST-32
         SUMW      R6,BSP.CORG     REMOVE SEGMENT CSECT ORIGIN   1.3#05
         SUMW      R6,CSCTBASE+MDSTBOUT    PLUS ANY AMNT OUTPUT  1.3#05
         ADMW      R6,CSCTBASE+MDSTFST     PLUS START OF BUFFER  1.3#05
         STW       R6,CSCTBASE+MDSTNXT    SAVE AS NEXT LOCATION  1.3#05
         STW       R6,CSCTBASE+MDSTHST        HIGHEST LOC USED   1.3#05
         STW       R6,CSCTBASE+MDSTPEB    AND BASE OF THIS PRGRM 1.3#05
*
         LMW       R7,0,R3         GET SIZE OF SECTION
         ADR       R6,R7           ADD IN POSITION IN BUFFER     1.3#05
         CAMW      R7,CSCTBASE+MDSTLST   WILL IT OVERFLOW BUFFER 1.3#05
         BLE       B31.2                 SKIP IF IT WILL         1.3#05
         LA        R1,CSCTBASE           ELSE SET UP TO          1.3#05
         BL        MFLSHBUF              TO OUTPUT WHATS DONE    1.3#05
         LW        R1,MSYMC        RECOVER CONTROL ENTRY ADDR    1.3#05
*
*        SET ORIGINS AND ZERO ANY CATALOG ALLOCATED SPACE
*
B31.2    EQU       $
         TBM       MFSTE,MFLGS
         BNS       B33           BR IF NOT FIRST ELEMENT OF MODULE
*!!!!!!!!ZR!!!!!!!!R5!!!!!!!!!!!!!!NO!CAT!ALLOCATION!TO!INIT!!!!S8700870
         SUMW      R5,BSP.BIAS     SET ALLOCATION TO UN-INIT'D  S8700870
         LA        R1,DSCTBASE     BUT WE MUST ZERO THE ASSEM    1.3#05
         BL        BRMCLR          ZERO THE MATRIX               1.3#05
         BL        BIACLR          ZERO ASSEMBLY AREA            1.3#05
*
         TBM       MSECTS,MFLGS    IF SECTIONED SEGMENT          1.3#05
         BNS       B33                                           1.3#05
         LA        R1,CSCTBASE     ZERO ASSEM AREA               1.3#05
         BL        BRMCLR                                        1.3#05
         BL        BIACLR                                        1.3#05
*                                                                1.3#05
B33      EQU       $                                             1.3#05
         LA        R1,DSCTBASE     DEFAULT START IS IN DSECT     1.3#05
         STW       R1,CURRBASE     INTO DOPE VECTOR POINTER      1.3#05
         TRN       R5,R5
         BEQ       B35
B34      ZMW       MTCORCL2        ABS DATA IS ZERO
         LI        R1,MT.ABS       STORE ABS DATA
         LI        R4,4            4 BYTES OF ABS DATA
         STB       R4,MTCORCL3
B34.1    BL        MTCOR           STORE ABS DATA IN IMAGE
         BIW       R5,B34.1        OUTPUT N WORDS OF ZERO COMMON
*
*      LINK CURRENT PROGRAM ELEMENT
*
B35      EQU       $                                            ENCD-32
         LW        R3,TCNT         GET CURRENT TEMP FILE CNT    ENCD-32
         CAMW      R3,TMPCNT       COMPARE WITH PASS A NUMBER   ENCD-32
         BGT       B39.4           PASS B CAN'T BE > PASS A     ENCD-32
         M.CONBAD  TCNT            CONVERT COUNT TO ASCII       ENCD-32
         SLL       R7,16           POSITION TO MAKE LFC         ENCD-32
         SRL       R7,16                                        ENCD-32
         LW        R4,=X'FFFF0000'                              ENCD-32
         LMW       R6,TMPLFC       GET TEMP LFC                 ENCD-32
         ORR       R6,R7           OR IN TEMP COUNT             ENCD-32
         STW       R7,TMPLFC       SAVE NEW TEMP LFC            ENCD-32
         STW       R7,XTEMP        SAVE IN FCB                  ENCD-32
         LW        R3,XTEMP+FCB.FAT  AND IN EXPANDED FCB        ENCD-32
         STW       R7,0,X3                                      ENCD-32
         ZMW       FCB.FAT,X3      ZERO FAT ADDR IN EXP. FCB    ENCD-32
B35.1    BL        XTMRD           READ A RECORD FROM TEMP OBJ  ENCD-32
*!B35!!!!LW!!!!!!!!R1,MSYMC!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!TBM!!!!!!!6,0,R1!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!BS!!!!!!!!B36!!!!!!!!!!!!!BR!IF!PROGRAM!FROM!SUBROUTINEENCD-32
*!!!!!!!!SUI!!!!!!!R1,4W!!!!!!!!!!!BUMP!TO!PROGRAM!ENTRY!!!!!!!!ENCD-32
*!!!!!!!!LD!!!!!!!!R6,2W,X1!!!!!!!!AND!PICK!UP!PROGRAM!NAME!!!!!ENCD-32
*!!!!!!!!ADI!!!!!!!R1,4W!!!!!!!!!!!RESTORE!R1!TO!CONTROL!ENTRY!!ENCD-32
*!!!!!!!!BL!!!!!!!!XGOPO!!!!!!!!!!!POSITION!SGO!TO!PROGRAM!!!!!!ENCD-32
*!!!!!!!!BU!!!!!!!!B39!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!B36!!!!SUI!!!!!!!R1,4W!!!!!!!!!!!HERE!TO!START!LIBRARY!!!!!!!!ENCD-32
*!!!!!!!!LH!!!!!!!!R5,1H,X1!!!!!!!!GET!REL!BLOCK!N0.!!!!!!!!!!!!ENCD-32
*!!!!!!!!LB!!!!!!!!R6,1B,R1!!!!!!!!RELATIVE!LOGICAL!RECORD!NO.!!ENCD-32
*!!!!!!!!LB!!!!!!!!R7,4B,R1!!!!!!!!OBTAIN!SUBROUTINE!LIBRARY!!!!ENCD-32
*!!!!!!!!SRL!!!!!!!R7,1!!!!!!!!!!!!REMOVE!BIT!7!(PART!OF!TRA)!!!ENCD-32
*!!!!!!!!SLL!!!!!!!R7,2!!!!!!!!!!!!CONVERT!TO!BYTE!OFFSET!!!!!!!ENCD-32
*!!!!!!!!LW!!!!!!!!R1,MSYMC!!!!!!!!RESTORE!CONTROL!ENTRY!ADDR!!!ENCD-32
*!!!!!!!!BL!!!!!!!!XLIRD!!!!!!!!!!!GET!THIS!FIRST!RECORD!!!!!!!!ENCD-32
*!!!!!!!!BU!!!!!!!!B39!!!!!!!!!!!!!AND!GO!PROCESS!!!!!!!!!!!!!!!ENCD-32
*!B37!!!!LW!!!!!!!!R1,MSYMC!!!!!!!!LOOP!TOP!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!TBM!!!!!!!6,0,R1!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!BS!!!!!!!!B38!!!!!!!!!!!!!BR!IF!PROGRAM!FROM!SYS!SUB!!!ENCD-32
*!!!!!!!!BL!!!!!!!!XBIRD!!!!!!!!!!!READ!CARD!FROM!SGO!!!!!!!!!!!ENCD-32
*!!!!!!!!BU!!!!!!!!B39!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!B38!!!!EQU!!!!!!!$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ENCD-32
*!!!!!!!!LI!!!!!!!!R5,-1!!!!!!!!!!!SET!SEQUENTIAL!MODE!!!!!!!!!!ENCD-32
*!!!!!!!!BL!!!!!!!!XLIRD!!!!!!!!!!!READ!A!CARD!FROM!THE!LIBRARY!ENCD-32
B39      LI        R5,1B
         BL        MOBSC           PROCESS CARD
         TBM       MPEND,MFLGS
*!!!!!!!!BNS!!!!!!!B37!!!!!!!!!!!!!BR!IF!NOT!END!OF!PROGRAM!!!!!ENCD-32
         BNS       B35.1           CONTINUE IF NOT END OF PROG  ENCD-32
         LW        R1,MSYMC        RESTORE CONTROL ENTRY ADDR   ENCD-32
         ZBM       MFSTE,MFLGS     CLEAR FIRST PROGRAM ELEMENT FLAG
         TBM       7,0,R1
         BS        B39.4           BR IF END OF MODULE
         LH        R5,1H,R1
         SLL       R5,4
         SUR       R5,R1
         STW       R1,MSYMC        ADDRESS OF NEXT CONTROL ENTRY
         BU        B31
B39.4    EQU       $
*                                                                1.3#05
*    COMPLETE SEGMENT PROCESSING                                 1.3#05
*                                                                1.3#05
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ECSV-33
         BNS       B39.4A          NO...BRANCH                  ECSV-33
         TBM       MSEGR,MFLAG3    CSEGVAL DEFINITION READ?     ECSV-33
         BNS       B39.4A          NO...BRANCH                  ECSV-33
         ZBM       MSEGR,MFLAG3    SHOW CSEGVAL ADJUSTED        ECSV-33
         LW        R1,CREGBAS      GET IMAGE BASE ADDR          ECSV-33
         ADMW      R1,CREGLOC      ADD PROGRAM RELATIVE ADDR    ECSV-33
         LW        R4,C31.7T       GET CSECT ORIGIN ADDRESS     ECSV-33
         ARMW      R4,0,R1         STORE IN CSEGVAL             ECSV-33
B39.4A   LW        R1,MMODW        GET ADDR OF SEG ENTRY         1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPRESSED           1.3#05
         BS        B39.5           SKIP FINAL OUTPUTS IF SET     1.3#05
*
*    OUTPUT TAIL OF DSECT CODE                                   1.3#05
*                                                                1.3#05
         LW        R4,DSCTBASE+MDSTHST GET HIGHEST LOC USED      1.3#05
         STW       R4,DSCTBASE+MDSTNXT SAVE AS NEXT              1.3#05
         LA        R1,DSCTBASE     SET UP DOPE VECTOR ADDR       1.3#05
         BL        MPRGEBUF        OUTPUT THE LAST PIECE         1.3#05
         LW        R4,DSCTBASE+MDSTCHKD   GET DSECT CHECKSUM     1.3#05
         STW       R4,BPREAMB+PR.CHKD     INTO PREAMBLE          1.3#05
*
*    OUTPUT DSECT RELOCATION MATRIX                              1.3#05
*                                                                1.3#05
         LA        R3,BPREAMB      GET ADDR OF PREAMBLE          1.3#05
         LW        R4,PR.SFADR,X3  GET DISC ADDR OF RELO MAT     1.3#05
         LW        R2,PR.BYTDR,X3  GET SIZE OF MATRIX            1.3#05
         LW        R3,DSCTBASE+MDSTRMAD GET MEMORY ADDR OF DATA  1.3#05
         BL        XWRTMOD         AND PUMP OUT THE MATRIX       1.3#05
*                                                                1.3#05
*      CALCULATE RELOCATION MATRIX CHECKSUM                      1.3#05
*                                                                1.3#05
         LA        R2,BPREAMB+PR.CHKDR DSECT RELOM CHK SUM       1.3#05
         LW        R3,DSCTBASE+MDSTRMAD STARTING ADDR            1.3#05
         TRR       R3,R4                                         1.3#05
         ADMW      R4,DSCTBASE+MDSTRMSZ CALC ENDING ADDR         1.3#05
         BL        MCHKSUM                                       1.3#05
*                                                                1.3#05
*    COMPLETE CSECT IF PRESENT                                   1.3#05
*                                                                1.3#05
         TBM       MSECTS,MFLGS    ANY CSECT IN THIS SEGMENT     1.3#05
         BNS       B39.5           SKIP IF NOT                   1.3#05
*    OUTPUT TAIL OF CSECT CODE                                   1.3#05
*                                                                1.3#05
         LW        R4,CSCTBASE+MDSTHST GET HIGHEST LOC USED      1.3#05
         STW       R4,CSCTBASE+MDSTNXT SAVE AS NEXT              1.3#05
         LA        R1,CSCTBASE     SET UP DOPE VECTOR ADDR       1.3#05
         BL        MPRGEBUF        OUTPUT THE LAST PIECE         1.3#05
         LW        R4,CSCTBASE+MDSTCHKD   GET DSECT CHECKSUM     1.3#05
         STW       R4,BPREAMB+PR.CHKC     INTO PREAMBLE          1.3#05
*
*    OUTPUT CSECT RELOCATION MATRIX                              1.3#05
*                                                                1.3#05
         LA        R3,BPREAMB      GET ADDR OF PREAMBLE          1.3#05
         LW        R4,PR.SFACR,X3  GET DISC ADDR OF RELO MAT     1.3#05
         LW        R2,PR.BYTCR,X3  GET SIZE OF MATRIX            1.3#05
         LW        R3,CSCTBASE+MDSTRMAD GET MEMORY ADDR OF DATA  1.3#05
         BL        XWRTMOD         AND PUMP OUT THE MATRIX       1.3#05
*                                                                1.3#05
*      CALCULATE RELOCATION MATRIX CHECKSUM (CSECT)              1.3#05
*                                                                1.3#05
         LA        R2,BPREAMB+PR.CHKCR DSECT RELOM CHK SUM       1.3#05
         LW        R3,CSCTBASE+MDSTRMAD STARTING ADDR            1.3#05
         TRR       R3,R4                                         1.3#05
         ADMW      R4,CSCTBASE+MDSTRMSZ CALC ENDING ADDR         1.3#05
         BL        MCHKSUM                                       1.3#05
*                                                                1.3#05
B39.5    EQU       $
*  FINISH OFF DEBUG SYMBOL GENERATION IF OPTION ON               1.3#05
         TBM       MOPT19,MFLGS    DEBUG SYMS ON?                1.3#05
         BNS       B20.81                                        1.3#05
         ZMD       XSYMBUF         ZAP FIRST HALF                1.3#05
         ZMD       XSYMBUF+1D      AND SECOND HALF               1.3#05
         SBM       0,XSYMBUF       MAKE IT A PROGRAM ENTRY       1.3#05
         BL        XDBGSYM         OUTPUT NULL LAST ENTRY        1.3#05
         BL        XDBGBND        SECTOR BOUND BUFF FOR SOURCE  EAID-32
         BL        XDBGSRC        GO OUTPUT THE SOURCE          EAID-32
B20.81   EQU       $                                             1.3#05
*                                                                1.3#05
         TBM       7,MOPTS         LOAD MAP REQUIRED             1.3#05
         BS        $+2W            SKIP IF NOT                   1.3#05
         BL        BPRNTMAP        ELSE DO IT                    1.3#05
*                                                                1.3#05
*                                  SEE IF MODULE INFO WANTED     1.3#05
         TBM       MOPT15,MFLGS                                  1.3#05
         BNS       B20.83          IF NOT BRANCH                 1.3#05
         TBM       3,XIDFLGS       IS THERE ANY INFO             1.3#05
         BNS       B20.83          IF NOT BRANCH                 1.3#05
         TBM       0,XIDFLGS       HAS FCB BEEN ASSIGNED         1.3#05
         BS        $+2W            IF SO SKIP                    1.3#05
         BL        WRTINFO                                       1.3#05
         M.RWND    INFOFCB         REWIND TEMP FILE              1.3#05
         LW        R6,XINFOENT     GET NUMBER OF BLOCKS          1.3#05
         TRN       R6,R6           SET UP FOR LOOP               1.3#05
         LW        R4,BPREAMB+PR_SFAID  GET DISC ADDR OF INFO    1.3#05
         LI        R2,768          ONE SECTOR AT A TIME          1.3#05
         LW        R3,INFOFCB+8W   GET BUFFER ADDR.              1.3#05
B20.82   M.READ    INFOFCB         READ BLOCK                    1.3#05
         ZR        R1              USE XWRTMOD ERROR RETURN      1.3#05
         BL        XWRTMOD         WRITE IT OUT TO LOAD MODULE   1.3#05
         ABR       R4,31           INCERMENT FILE SECTOR NUMBER  1.3#05
         BIB       R6,B20.82       DO UNTIL ALL WROTE            1.3#05
B20.83   EQU       $                                             1.3#05
*                                                                1.3#05
         LW        R1,MMODW        GET ADDR OF SEG ENTRY         1.3#05
         LW        R5,1W,X1        GET OVERLAY LEVEL/SEQ         1.3#05
         BZ        BLS.99          OUTPUT PREAMB+RRS IF ROOT     1.3#05
         TBM       4,1B,X1         ELSE SEE IF OUTPUT SUPRESSED  1.3#05
         BS        BLS.XIT         SKIP OUTPUT IF SET            1.3#05
BLS.99   EQU       $                                             1.3#05
         LA        R3,BPREAMB      ADDR OF PREAMBLE              1.3#05
         LD        R6,VERNUM      FETCH USER VERSION NUMBER     EAID-32
         STD       R6,X'150',X3   STORE IN PREAMBLE             EAID-32
         LW        R6,AID.VRSN    AND RELEASE NUMBER            EAID-32
         STW       R6,X'140',X3   PUT IN WORD X'50'             EAID-32
         LW        R7,TXPM.ADR    GET TXPM ADDRESS              EAID-32
         BZ        BLS.I1                                       EAID-32
         SRL       R7,4           POSITION IN BYTE 2            EAID-32
         SBR       R7,31          INDICATE T-XPM TASK           EAID-32
BLS.I1   EQU       $                                            EAID-32
         TBM       MOPT2,MFLGS    SEPARATE OVERLAYS?            EAID-32
         BNS       BLS.I2         NO                            EAID-32
         LW        R6,AID.NCAT    MORE THAN ONE MODULE?         EAID-32
         CI        R6,1                                         EAID-32
         BLE       BLS.I2         YES, NOT REALLY OVERLAID      EAID-32
         SBR       R7,30          INDICATE OLAYS IN SEP FILES   EAID-32
BLS.I2   EQU       $                                            EAID-32
         ORMW      R7,AID.OCAT    SET BIT 30 IF SYM OPTION SET  EAID-32
         SBR       R7,0           INDICATE AID CATALOGER        EAID-32
         TBM       29,TXPM.FLG    MPXONLY?                      EAID-32
         BNS       $+2W                                         EAID-32
         SBR       R7,29          INDICATE MPX ONLY TASK        EAID-32
         STW       R7,X'130',X3   PUT IT IN THE PEAMBLE         EAID-32
         ZMW       TXPM.FLG                                     EAID-32
         LI        R2,2304         3 SECTORS                     1.3#05
         ZR        R4              AT SECTOR ZERO                1.3#05
         ZR        R1              USE XWRTMOD ERROR HANDLING    1.3#05
         BL        XWRTMOD         WRITE THE PREAMBLE+RRS        1.3#05
         TBM       BFSEG,BFLGS     WAS THIS THE ROOT             1.3#05
         BNS       $+4W            SKIP IF NOT                   1.3#05
         LI        R2,-192D        NUMBER OF DW'S IN 2 SECTORS   1.3#05
         ZMD       MRRS+192D,X2    ZAP THE RRS AREA              1.3#05
         BID       R2,$-1W         LOOP                          1.3#05
*                                                                1.3#05
BLS.XIT  EQU       $                                             1.3#05
         LF        R0,BLS.RSAV                                   1.3#05
         TRSW      R0                                            1.3#05
         BOUND     1W                                           EAID-32
TXPM.ADR REZ       1W             TSABASE PARAMETER             EAID-32
TXPM.FLG REZ       1W             TXPM FLAG WORD                EAID-32
*        BIT       0              MODULE REFERENCES TSA         EAID-32
*        BIT       1              MODULE HAS CSET               EAID-32
*        BIT       4              TSA REFERENCE WORD INSERTED   EAID-32
*        BIT       31             USED TEMPORARILY              EAID-32
SEP.OVLY REZ       1W                                           EAID-32
AID.VRSN DATAW     X'E4A031A0'    XPM-64 VERSION NUMBER         EAID-32
         BOUND     1F                                            1.3#05
BLS.RSAV RES       1F                                            1.3#05
*BLS.BIAS DATAW     0     HOLDS CAT ALLOC FOR FIRST PRG ELE       1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     BPRNTMAP - OUTPUT LOAD MODULE MAP
BPRNTMAP STF       R0,BPM.RSAV                                   1.3#05
*                                                                1.3#05
*
*  OUTPUT LOAD MODULE MAP
*
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         ZBM       XSLOEOM,XFLGS   RESET MAP SUPPRESS FLAG       1.3#10
         ZBM       BPMMSG,BPMFLGS  AND SUPPRESS MESSAGE ISSUED   1.3#10
         LB        R5,HD1.CC       LOAD CARR CNTRL FOR HDR LINE 1  11012
         STB       R5,MPCCC+7B     STORE IN CARRIAGE CONTROL BYTE  22007
         LB        R5,PRODREVL     GET LENGTH OF TITLE (PROD ONLY) 11013
         LA        R6,CATITLE      GET ADDRESS OF TITLE            22007
         BL        XPRNT           EJECT PAGE
         LW        R1,MMODW        GET ADDRESS OF MODULE ENTRY
         LD        R4,2W,R1        GET MODULE NAME
         STD       R4,B59+1W       STORE NAME IN SUBTITLE BUFFER
         LB        R5,HD2.CC       LOAD CARR CNTRL FOR HDR LINE 2  11012
         TBM       CSLOUT,CFLGS    IS SLO=UT?                    1.3#10
         BNS       $+2W            SKIP IF NOT                   1.3#10
         LI        R5,G' '         ELSE SET CC TO NULL           1.3#10
         STB       R5,MPCCC+7B     STORE IN CARRIAGE CONTROL BYTE  22007
         LI        R5,32           LENGTH OF SUBTITLE LINE
         LA        R6,B59          ADDRESS OF SUBTITLE BUFFER
         BL        XPRNT           PRINT HEADING
         LI        R5,G'0'         SET DOUBLE SPACE              1.3#10
         STB       R5,MPCCC+7      INTO CC                       1.3#10
         ZR        R5                                            1.3#10
         BL        XPRNT           AND ISSUE                     1.3#10
*
*
         LI        R5,39           LENGTH OF LINE
         LA        R6,B60
         BL        XPRNT           PRINT DASHES
         LD        R4,B59+1W       PICK UP MODULE NAME
         STD       R4,MPBUF+1D     STORE NAME IN OUTPUT BUFFER
         LA        R6,MPBUF        ADDRESS OF BUFFER WITH MODULE NAME
         LI        R5,39B
         BL        XPRNT           PRINT MODULE NAME
         LW        R4,=C'OVER'     2ND LINE
         LW        R5,=C'LAY '
         LW        R6,1W,R1
         BNE       B41             BR IF NOT MAIN SEGMENT
         LW        R4,=C'MAIN'
         LW        R5,=C'    '
         STD       R4,MPBUF+1D
         LW        R4,=C', LE'
         LW        R5,=C'VEL '
         STD       R4,MPBUF+2D
         LB        R5,MPRIO        PRIORITY
         BL        M0210           CONV TO DEC
         STH       R7,MPBUF+3D
         BU        B42
B41      STD       R4,MPBUF+1D
B42      LI        R5,39B
         LA        R6,MPBUF        BUFFER ADDR
         BL        XPRNT
         LW        R5,1W,R1
         BEQ       B43             BR IF MAIN SEGMENT
         LW        R4,=C'ORIG'
         LW        R5,=C'IN  '
         STD       R4,MPBUF+1D
         LW        R3,5W,R1        MODULE ORIGIN
         BU        B45
B43      TBM       MTYPE,MFLGS     3RD LINE
         BS        B43.5           BR IF PRIVILEGED
         LW        R4,=C'UNPR'
         LW        R5,=C'IVIL'
         STD       R4,MPBUF+1D
         LW        R4,=C'EGED'
         STW       R4,MPBUF+2D
         BU        B44
B43.5    LW        R4,=C'PRIV'
         LW        R5,=C'ILEG'
         STD       R4,MPBUF+1D
         LW        R4,=C'ED  '
         STW       R4,MPBUF+2D
B44      LI        R5,21B
         LA        R6,MPBUF        BUFFER ADDRESS
         BL        XPRNT
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BNS       B44.1           BR IF NOT ABSOULTE
         LW        R4,=C'ABSO'     GET CHAR STRING 'ABSOLUTE'
         LW        R5,=C'LUTE'
         STD       R4,MPBUF+1D     STORE IN OUTPUT BUFFER
         LW        R4,=C' BAS'
         LW        R5,=C'E'
         STD       R4,MPBUF+2D     STORE ' BASE   ' IN OUTPUT BUFFER
         LW        R3,MPABS        GET ABSOLUTE BASE
         BU        B45             BR TO OUTPUT ABSOLUTE BASE
*
B44.1    LW        R4,=C'TRAN'     4TH LINE
         LW        R5,=C'SIEN'
         STD       R4,MPBUF+1D
         LW        R4,=C'T AR'
         LW        R5,=C'EA  '
         STD       R4,MPBUF+2D
         LW        R3,MTRNS        SIZE OF TRANSIENT AREA
B45      BL        M0216           CONVERT TO HEX
         STB       R4,MPBUF+23B
         STW       R5,MPBUF+3D
         LI        R5,28B
         LA        R6,MPBUF        BUFFER ADDR
         BL        XPRNT
         LW        R4,=C'TRAN'
         LW        R5,=C'SFER'
         STD       R4,MPBUF+1D
         LW        R4,=C' ADD'
         LW        R5,=C'R   '
         STD       R4,MPBUF+2D
         LW        R5,=C'NONE'
         TBM       7,0,R1
         BNS       B46             BR IF MODULE HAS NO TRANS ADDR
         LW        R3,4W,R1        GET TRANSFER ADDRESS
         TBR       R3,7            IS TRANSFER ADDRESS IN CSECT
         BS        B45.1           BR IF TRANSFER TO CSECT
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BNS       B45.1           BR IF NOT ABSOLUTE
         ADMW      R3,MPABS        ADD ABSOLUTE BASE TO TRANSFER ADDR
B45.1    BL        M0216
         TBM       M2.5MB,MFLAG2   GENERATING 2.5 MB TASK?      PR12271
         BNS       B45.2           NO...BRANCH                  PR12271
         TRR       R4,R6           TOP OF ADDRESS TO R6         PR12271
         SRL       R4,8            ISOLATE HIGH BYTE            PR12271
         STB       R4,MPBUF+23B    SAVE IN BUFFER               PR12271
         ANMW      R6,=X'000000FF' ISOLATE SECOND BYTE          PR12271
         STB       R6,MPBUF+24B    SAVE IN BUFFER               PR12271
         LI        R6,4            FOUR MORE BYTES TO MOVE      PR12271
         LI        R2,25B          INDEX INTO BUFFER            PR12271
B45.3    CI        R6,0            ARE WE DONE?                 PR12271
         BEQ       B45.4           YES...BRANCH                 PR12271
         ZR        R4                                           PR12271
         SLLD      R4,8            GET ADDR BYTE INTO R4        PR12271
         STB       R4,MPBUF,X2     SAVE IN BUFFER               PR12271
         ADI       R2,1            INCREMENT POINTERS           PR12271
         SUI       R6,1                                         PR12271
         BU        B45.3           NEXT BYTE                    PR12271
B45.4    LI        R5,29B          LENGTH OF LINE TO PRINT      PR12271
         BU        B46.1           OUTPUT TRANSFER ADDRESS      PR12271
B45.2    STB       R4,MPBUF+23B    TRANSFER ADDRESS             PR12271
B46      STW       R5,MPBUF+6W
         LI        R5,28B
B46.1    LA        R6,MPBUF                                     PR12271
         BL        XPRNT           PRINT TRANSFER ADDRESS LINE
         LI        R5,39           LENGTH OF LINE
         LA        R6,B60
         BL        XPRNT           PRINT DASHES
         LI        R5,G'0'         SET DOUBLE SPACE              1.3#10
         STB       R5,MPCCC+7      INTO CC                       1.3#10
         ZR        R5                                            1.3#10
         BL        XPRNT           AND ISSUE                     1.3#10
*
*------
*
         ZR        R7
         SUI       R1,8W
B47      TBM       2,0,R1
         BS        B52             BR IF COMMON ENTRY
         TBM       3,0,R1
         BS        B56             BR IF SECTION DEF
         TBM       1,0,R1
         BS        B56             BR IF DEFINED ENTRY POINT
         TBM       4,0,R1
         BS        B56             BR IF PGM NAME
         TBM       0,0,R1
         BS        B50             BR IF MODULE ENTRY
         TBM       5,0,R1
         BNS       B49             BR IF NOT CONTROL ENTRY
         TRR       R7,R2
         BEQ       B48             BR IF NO PGM NAME LINE TO OUTPUT
         BL        B66             OUTPUT PGM NAME LINE
B48      LI        R5,0
         BL        BPMCK           IS OUTPUT ACTIVE
         BS        $+2W            SKIP IF NOT
         BL        XPRNT           SINGLE SPACE
B49      SUI       R1,4W           NEXT ENTRY
         CAMW      R1,MSYMN
         BGT       B47             BR IF MORE ENTRIES
B50      TRR       R7,R2
         BEQ       B51             BR IF NO PGM NAME LINE TO OUTPUT
         BL        B66             OUTPUT PGM NAME LINE
B51      BU        B68
*
*        COMMON BLOCK DEFINITION
B52      TBM       3,0,R1
         BNS       B52.1           BR IF NOT GLOBAL ALLOCATION ENTRY
         TBM       7,0,R1          IS COMMON ORIGINED IN THIS PGM
         BS        B54             BR IF GLOBAL COMMON BELONGS TO HERE
         BU        B49             GO GET NEXT ENTRY
B52.1    LW        R4,=X'00FFFFFF' MASK FOR COMMON SIZE
         LMW       R5,0,R1         GET SIZE OF COMMON BLOCK
         BEQ       B49             BR IF COMMON ALLOC'D ELSEWHERE
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE
         BS        B54             BR IF ABSOLUTE
         TBM       6,0,R1          IS COMMON ORIGINED IN THIS MODULE
         BS        B54             BR IF ORIGINED IN THIS MODULE
B53      LW        R5,=C'COM*'     MAP LABEL FOR UN-INITIALIZED COMMON
         BU        B55
B54      LW        R5,=C'COM '     MAP LABEL FOR COMMON
B55      TRR       R1,R2           ENTRY ADDRESS
         LW        R3,0+1W,R1      ADDRESS FOR FIELD 2
         BL        B61             OUTPUT LINE
         BU        B49
B56      TRR       R7,R2
         BEQ       B57             BR IF NO PGM NAME LINE TO OUTPUT
         BL        B66             OUTPUT PGM NAME LINE
B57      TBM       1,0,R1
         BS        B58             BR IF DEF ENTRY
         TBM       3,0,R1          SECTION DEF
         BS        B58.1           YES
         TRR       R1,R7           SAVE FOR OUTPUT OF PGM NAME LINE
         BU        B49
*
*        SECTION DEFINITION
B58.1    LW        R5,=C'SEC '
         TRR       R1,R2
         LW        R3,1W,R1
         BL        B61             OUTPUT LINE
         TRR       R1,R3           SAVE SECTION DEF SYMTAB ENTRY ADDR
DEFLOOP  EQU       $
         LB        R6,1W,R1        FETCH SECTION NUM. FROM ENTRY
         SUI       R3,4W           STEP SECONDARY SYMTAB POINTER
         CAMW      R3,MSYMN        END OF SYMTAB ?
         BLE       B49             YES, ENTER PRIMARY SYMTAB SEARCH
         TBM       5,0,R3          IS THIS A CONTROL ENTRY ?
         BS        B49             YES, ENTER PRIMARY SYMTAB SEARCH
         TBM       1,0,R3          IS THIS A DEFINED ENTRY POINT ?
         BNS       DEFLOOP         NO, ONLY WANT DEFS FOR CURRENT SECTIO
         CAMB      R6,1W,R3        IS THE DEF IN THIS SECTION ?
         BNE       DEFLOOP         NO, CONTINUE SECONDARY SEARCH
         TRR       R3,R7           SAVE THIS ENTRY'S ADDR.
         TRR       R3,R2           ADDRESS OF SYMTAB ENTRY TO PRINT
         LW        R3,1W,R3        MODULE RELATIVE ENTRY POINT ADDRESS
         LW        R5,=C'DEF'
         BL        B61             PRINT THE DEF LINE
         TRR       R7,R3           RESTORE CURRENT SYMTAB ENTRY ADDR.
         ZR        R7              ZERO R7 (IT'S USED ALL OVER THE PLACE
         SBM       6,0,R3          MARK THAT ENTRY HAS PRINTED
         BU        DEFLOOP         CONTINUE SECONDARY SYMTAB SEARCH
*
*        ENTRY POINT DEFINITION
B58      LW        R5,=C'DEF '
         TBM       6,0,R1          HAS ENTRY BEEN PRINTED ?
         BS        B49             YES, SKIP TO NEXT ENTRY
         BU        B55
         BOUND     1D
         RES       1W
B59      DATAW     C'    PROGNAME     LOAD MODULE MAP'
B60      DATA      C'        -------------------------------'
*+
* OUTPUT LINE FOR LOAD MODULE MAP
*
*        R2 = ADDR OF SYMBOL TABLE ENTRY
*        R3 = RELATIVE ADDRESS OF ENTRY
*        R5 = LABEL OF ENTRY
*-
B61      STW       R0,B65          SAVE RETURN ADDRESS
         STW       R5,MPBUF+5W     STORE LABEL IN OUTPUT BUFFER  1.3#05
         TBR       R3,7            IS ADDRESS IN CSECT?
         BS        B61.1           BR IF ADDR IN CSECT
         TBM       2,0,R1          IS IT COMMON                    20009
         BNS       B61.01          BR IF NOT IN COMMON BLOCK       20009
         TBM       3,0,R1          IS IT GLOBAL COMMON             20009
         BS        B61.1           BR IF GLOBAL COMMON             20009
B61.01   TBM       MABS,MFLGS      IS MODULE ABSOLUTE              20009
         BNS       B61.1           BR IF NOT ABSOLUTE
         ADMW      R3,MPABS        ADD ABSOLUTE BASE TO ADDRESS
B61.1    BL        M0216           CONVERT ADDRESS TO HEX
         STB       R4,MPBUF+11B                                  1.3#05
         STW       R5,MPBUF+3W                                   1.3#05
         LD        R2,1D,R2        GET NAME OF ENTRY
         STW       R2,MPBUF+0W     SAVE FIRST HALF               1.3#05
         STW       R3,MPBUF+1W     AND SECOND HALF               1.3#05
         LW        R5,BPM.LLEN                                   1.3#05
         LA        R6,MPBUF
         BL        BPMCK           SEE IF OUTPUT ACTIVE          1.3#10
         BS        $+2W            SKIP IF NOT                   1.3#10
         BL        XPRNT           LINE TO SLO
         LW        R0,B65
         TRSW      R0              RETURN
B65      ACW       0
*  OUTPUT PGM NAME LINE SUBR - R2,ADDR OF PGM NAME ENTRY
B66      STW       R0,B67
         ZR        R7
         TBM       6,4W,R2         DID THIS ENTRY COME FROM LIBRY  21013
         BNS       B66.1           BRANCH IF PGM IS NOT FROM LIBRY 21013
         LB        R3,4B,X2        GET LIB INDEX                 1.3#05
         SRL       R3,1            REMOVE BIT 7 (PART OF TRA)    1.3#05
         SLL       R3,2            CONVERT TO WORD INDEX         1.3#05
         LB        R4,LT.LIBS,X3   GET FILE TABLE TYPE ENTRY     1.3#05
         CI        R4,2            IS IT PRIVATE FCB             1.3#05
         BNE       BPM.1           BR IF NOT                     1.3#05
         LW        R4,=X'00FFFFFF' SET MASK                      1.3#05
         LMW       R3,LT.LIBS,X3   GET ADDR OF FCB               1.3#05
         LW        R4,0W,X3        GET LFC ENTRY                 1.3#05
         BU        BPM.2                                         1.3#05
BPM.1    EQU       $               HERE IF SHARED FCB            1.3#05
         LW        R4,LT.LIBS,X3   GET LFC                       1.3#05
BPM.2    EQU       $               MERGE UP                      1.3#05
         SLL       R4,8            CLEAR UPPER BYTE                21013
         SRL       R4,8            RIGHT JUSTIFY LFC               21013
         SBR       R4,2            MAKE UPPER BYTE A SPACE         21013
         STW       R4,MPBUF+6W     STORE LIBRARY LFC IN BUFFER   1.3#05
         LI        R4,28                                         1.3#05
         STW       R4,BPM.LLEN     SET LINE LEN FOR SOURCE       1.3#05
B66.1    EQU       $
*
*    OUTPUT TO LOAD MODULE MAP FROM OPTION 15 ID,DATE/TIME         11005
*
         TBM       MOPT15,MFLGS    SEE IF OPTION 15 SPECIFIED      11005
         BNS       B66.18          IF NOT SKIP                     11005
         TBM       1,XIDFLGS       IS THERE ANY INFO               11005
         BNS       B66.18          IF NOT SKIP                     11005
         STF       R0,MPSAV        SAVE REGS.                      11005
         LD        R2,1D,X2        GET PROGRAM NAME                11005
         LW        R1,XINFOCNT     GET BUFFER INDEX                11005
         CAMW      R2,XINFOBUF,X1  CCOMPARE NAMES                  11005
         BNE       B66.17          IF NOT EQUAL THEN NO INFO       11005
         CAMW      R3,XINFOBUF+1W,X1                               11005
         BNE       B66.17                                          11005
         ADI       R1,3W           INDEX PAST HEADER               11005
B66.11   EQU       $                                               11005
         LB        R4,XINFOBUF+1B,X1  GET SUB-RECORD FLAG          11005
         CI        R4,0            SEE IF DATE/TIME RECORD         11005
         BNE       B66.12          IF NOT SKIP                     11005
         LA        R3,MPBUF+7W+1B   START OF DATE TIME STUFF     1.3#05
         LW        R7,XINFOBUF+1W,X1                             1.3#05
         BL        XSTB            STORE 1ST HALF IN LINE        1.3#05
         LW        R7,XINFOBUF+2W,X1                             1.3#05
         BL        XSTB            STORE SECOND HALF             1.3#05
         ADI       R3,1            LEAVE A SPACE                 1.3#05
         LW        R7,XINFOBUF+3W,X1   GET 1ST HALF OF DATE      1.3#05
         BL        XSTB            AND STORE                     1.3#05
         LW        R7,XINFOBUF+4W,X1                             1.3#05
         BL        XSTB            STORE 2ND HALF                1.3#05
         LI        R7,28+18
         STW       R7,BPM.LLEN     SET LINE LENGTH FOR DATE TIME 1.3#05
         TBM       0,XINFOBUF,X1   IS THIS LAST SUB-RECORD         11005
         BS        B66.14          IF SO, NO MORE FOR THIS RECORD  11005
         ADI       R1,5W           INCREMENT INDEX TO NEXT SUB-REC.11005
         BU        B66.11          RETURN                          11005
B66.12   EQU       $                                               11005
         CI        R4,1            SEE IF ID RECORD                11005
         BNE       B66.14          IF NOT SKIP                    11005
         LNH       R4,XINFOBUF+1H,X1  GET NEGITIVE LENGTH          11005
         ADI       R4,1W           OFF SET HEADER                  11005
         ZR        R2                                              11005
         ADI       R1,1W           GET PAST HEADER                 11005
B66.13   LB        R3,XINFOBUF,X1  TRANSFER DATA                   11005
         ABR       R1,31                                           11005
         STB       R3,MPBUF+12W,X2                                 11005
         ABR       R2,31                                           11005
         BIB       R4,B66.13                                       11005
         LI        R4,80                                         1.3#05
         STW       R4,BPM.LLEN     SET LINE LEN FOR ID FIELD     1.3#05
B66.14   EQU       $                                               11005
         LW        R1,XINFOCNT     GET ORIGINAL INDEX              11005
         TBM       1,XINFOBUF+2W,X1 IS THIS LAST ID RECORD ?       11005
         BNS       B66.15          IF NOT SKIP                     11005
         ZBM       1,XIDFLGS       ZERO OUT INFO BIT               11005
         BU        B66.17          AND CONTINUE                    11005
B66.15   EQU       $
         TBM       0,XINFOBUF+2W,X1  IS THIS LAST RECORD IN BLK.?  11005
         BNS       B66.16          IF NOT THEN DON'T READ NEXT BLK 11005
         M.READ    INFOFCB                                         11005
         ZMW       XINFOCNT        ZERO INDEX                      11005
         BU        B66.17          AND CONTINUE                    11005
B66.16   EQU       $                                               11005
         ADMH      R1,XINFOBUF+5H,X1  ELSE INCREMENT INDEX         11005
         STW       R1,XINFOCNT     AND STORE
B66.17   LF        R0,MPSAV        RESTORE REG.                    11005
B66.18   EQU       $                                               11005
         LW        R4,=X'00FFFFFF'
         LMW       R3,0+5W,R2      ELEMENT'S CAT ALLOC'D COMM
         ADMW      R3,0+7W,R2      +ABS BEGINNING ADDR
         LW        R5,=C'PGM '
         BL        B61
         LW        R0,=C'    '     CLEAR LIBRARY LFC FIELD         21013
         STW       R0,MPBUF+6W                                   1.3#05
         LI        R0,24                                         1.3#05
         STW       R0,BPM.LLEN     SET LINE LENGTH TO MINIMUM    1.3#05
         LW        R0,B67
         TRSW      R0              RETURN
B67      ACW       0
B68      LW        R1,MMODW
         LW        R3,7W,R1        OBTAIN END ADDRESS OF MODULE
         BL        M0216           CONV TO HEX
         STB       R4,BPM.M1D1
         STW       R5,BPM.M1D2
         ZR        R5
         BL        XPRNT
         LB        R5,BPM.M1L
         LA        R6,BPM.MSG1
         BL        XPRNT           LINE TO SLO
         ZR        R5
         BL        XPRNT           SINGLE SPACE
         LW        R5,LMFSIZE
         BL        M0210           CONV NO. RECS IN MODULE TO DECIMAL
         STW       R6,BRMMS.D      SAVE THE VALUE
         STW       R7,BRMMS.D+1W                                 1.3#05
         LI        R2,-7B
B74.1    EQU       $               LOOP TO ELIMINATE LEADING ZEROS
         LB        R6,BRMMS.D+7B,X2      GET NEXT DIGIT FROM LEFT
         CI        R6,G'0'
         BNE       B74.2           BR IF NOT ZERO TO OUTPUT MODULE SIZE
         LI        R6,G' '         LOAD A BLANK
         STB       R6,BRMMS.D+7B,X2      UPDATE MESSAGE
         BIB       R2,B74.1
B74.2    EQU       $
         LB        R5,BRMMS.L
         LA        R6,BRMMS
         BL        XPRNT           RECORDS IN MODULE MSG
         ZR        R5
         BL        XPRNT           SINGLE SPACE
         LF        R0,BPM.RSAV                                   1.3#05
         TRSW      R0                                            1.3#05
BPMFLGS  DATAH     0               MAP PRINTER FLAGS             1.3#10
BPMMSG   EQU       0       INDICATES SUPPRESS MESSAGE ISSUED     1.3#10
         BOUND     1F                                            1.3#05
BPM.RSAV RES       1F                                            1.3#05
*
BPM.MSG1 DATAB     C'**END**    '
BPM.M1D1 DATAB     0
BPM.M1D2 DATAB     0,0,0,0                                       1.3#05&
BPM.M1L  DATAB     $-BPM.MSG1
BPM.LLEN DATAW     24              HOLDS LENGTH OF CURRENT LINE  1.3#05
*                                                                1.3#05
BRMMS    DATAB     C' LOAD MODULE SIZE = '                       1.3#05
BRMMS.D  REZ       8B              HOLDS ACD SIZE IN SECTORS     1.3#05&
         DATAB     C'   SECTORS.'                                1.3#05
BRMMS.L  DATAB     $-BRMMS                                       1.3#05
*                                                                1.3#05
BPMCK.MA DATAB     C' CATALOG:  Load Map output to UT'
         DATAB     C' suspended.'
BPMCK.ML DATAB     $-BPMCK.MA
*
         BOUND     1W
BPMCK    EQU       $
         ZBR       R0,1            SHOW OUTPUT ON
         TBM       XSLOEOM,XFLGS   IS IT ACTUALLY ON
         BS        $+2W            CONTINUE IF NOT
BPMCK.1  TRSW      R0              ELSE RETURN
         NOP
         SBR       R0,1            INDICATE OUTPUT IS OFF
         TBM       BPMMSG,BPMFLGS  HAVE WE TOLD THE USER
         BS        BPMCK.1         BR IF WE HAVE
         STF       R0,BPMCK.RS     ELSE SAVE THE REGS
         LB        R5,BPMCK.ML     SET LENGTH
         LA        R6,BPMCK.MA     AND ADDR
         BL        XTYPEF              ISSUE
         SBM       BPMMSG,BPMFLGS  AND INHIBIT
         LF        R0,BPMCK.RS
         TRSW      R0
         BOUND     1F
BPMCK.RS REZ       1F
*
*----------------------------------------------------------------1.3#05
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     BRM/BIACLR ARRAY CLEARING ROUTINES
*                                                                1.3#05
*  BRMCLR                                                        1.3#05
*                                                                1.3#05
*   THIS ROUTINE ZEROS THE AREA STARTING AT THE LOCATION POINTED 1.3#05
*   TO BY MDSTRMAD FOR A LENGTH OF MDSTRMSZ BYTES                1.3#05
*                                                                1.3#05
*   IN   R1 = CONTAINS CSECT OR DSECT DOPE VECTOR BASE ADDR      1.3#05
*                                                                1.3#05
*  OUT   ALL REGS PRESERVED                                      1.3#05
*                                                                1.3#05
*   USES MARCLR TO ACTUALLY DO THE WORK                          1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
BRMCLR   STD       R2,BCLR.RSV                                   1.3#05
         STW       R0,BCLR.RET     SAVE RETURN ADDR AND R1       1.3#05
         LW        R3,MDSTRMAD,X1       GET STARTING ADDR        1.3#05
         TRR       R3,R2           COPY                          1.3#05
         ADMW      R2,MDSTRMSZ,X1       CALCULATE END ADDR+1W    1.3#05
         BL        MARCLR          GO DO IT                      1.3#05
         LD        R2,BCLR.RSV     REVOVER USER REGS             1.3#05
         BU        *BCLR.RET       RETURN                        1.3#05
*                                                                1.3#05
*================================================================1.3#05
*                                                                1.3#05
*    BIACLR                                                      1.3#05
*                                                                1.3#05
*   THIS ROUTINE ZEROS THE IMAGE AREA STARTING AT LOCATION       1.3#05
*   POINTED TO BY MDSTFST  FOR AN AMOUNT CONTAINED IN MDSTSIZ    1.3#05
*                                                                1.3#05
*    IN    R1 = CONTAINS C/D SECT DOPE VECTOR BASE ADDR          1.3#05
*                                                                1.3#05
*  OUT     ALL REGS PRESERVED                                    1.3#05
*  ROUTINE MARCLR IS USED TO DO THE WORK                         1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
BIACLR   STD       R2,BCLR.RSV                                   1.3#05
         STW       R0,BCLR.RET                                   1.3#05
         LW        R3,MDSTFST,X1       GET STARTING ADDR         1.3#05
         TRR       R3,R2                                         1.3#05
         ADMW      R2,MDSTSIZ,X1       CALCULATE END + 1W        1.3#05
         BL        MARCLR          GO DO IT                      1.3#05
         LD        R2,BCLR.RSV                                   1.3#05
         BU        *BCLR.RET       RETURN                        1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
BCLR.RSV DATAD     0               HOLDS R2,R3                   1.3#05
BCLR.RET DATAW     0               HOLDS RETURN ADDR             1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
         TITLE     BBLDPRE - BUILD PREAMBLE RECORD               1.3#05
*                                                                1.3#05
*   BBLDPRE                                                      1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
BBLDPRE  STF       R0,BBP.RSAV                                   1.3#05
*                                                                1.3#05
         LA        R3,BPREAMB      GET ADDR OF BUFFER            1.3#05
         LI        R2,-96D         INIT COUNTER                  1.3#05
         ZMD       0D,X3           ZAP IT                        1.3#05
         ABR       R3,28           BUMP                          1.3#05
         NOP                       PAD                           1.3#05
         BID       R2,$-2W         AND LOOP                      1.3#05
         LA        R3,BPREAMB      REINIT POINTER                1.3#05
*                                                                1.3#05
*   DO FILE POSITION RELATED ELEMENTS                            1.3#05
*                                                                1.3#05
         LW        R1,MMODW        GET ADDR OF THIS SEG ENTRY    1.3#05
         LW        R2,LMFSIZE      INIT POSITION INDICATOR       1.3#05
         STW       R2,PR.SFAC,X3   SET PRE CSECT DATA ADDR       1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPRESSED           1.3#05
         BS        $+2W            SKIP IF IT IS                 1.3#05
         ADMW      R2,BSP.CSCT     ADD CSECT SIZE                1.3#05
         STW       R2,PR.SFACR,X3  SET PRE CSECT RELOM ADDR      1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPRESSED           1.3#05
         BS        $+2W            SKIP IF IT IS                 1.3#05
         ADMW      R2,BSP.CRMS     ADD CSECT RELOM SIZE          1.3#05
         STW       R2,PR.SFAD,X3   SET PRE DSECT DATA ADDR       1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPRESSED           1.3#05
         BS        $+2W            SKIP IF IT IS                 1.3#05
         ADMW      R2,BSP.DSCT     ADD DSECT DATA SIZE           1.3#05
         STW       R2,PR.SFADR,X3  SET PRE DSECT RELOM ADDR      1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPRESSED           1.3#05
         BS        $+2W            SKIP IF IT IS                 1.3#05
         ADMW      R2,BSP.DRMS     ADD DSECT RELOM SIZE          1.3#05
*                                                                1.3#05
*                                                                1.3#05
         TBM       MOPT19,MFLGS    IS OPTION ON?                 1.3#05
         BNS       BBP.1           SKIP CALCULATIONS IF OFF      1.3#05
         TBM       BFSEG,BFLGS    IS THIS THE FIRST SEGMENT     EAID-32
         BNS       BBP.01         NO, SKIP GLOBALS              EAID-32
         STW       R2,PR.SYMG,X3   SET PRE GLOBAL SYMBOLS        1.3#05
         ADMW      R2,BSP.DGS      ADD GLOBALS TO POINTER        1.3#05
         STW       R2,PR.SYMP,X3   SET PRE LOCAL SYMBOLS         1.3#05
         SUMW      R2,BSP.DGS      BACK GLOBALS OUT              1.3#05
         BU        BBP.02                                       EAID-32
BBP.01   EQU       $                                            EAID-32
         STW       R2,PR.SYMP,X3  STORE LOCAL SYMBOLS POINTER   EAID-32
         STW       R2,XDS.SCNT    TELL I/O ROUTINES ABOUT IT    EAID-32
BBP.02   EQU       $                                            EAID-32
         ADMW      R2,BDBGSIZE     ADD IN GLOBALS + LOCALS       1.3#05
BBP.1    EQU       $               RESUME AFTER COND. SYMBOLS    1.3#05
*                                                                1.3#05
         TBM       MOPT15,MFLGS    IS OPTION ON?                 1.3#05
         BNS       BBP.2           SKIP INFO  IF NOT             1.3#05
         LW        R4,XINFOENT     GET SIZE OF INFO TABLE        |1.3Q39
         BZ        BBP.2           SKIP IF NULL                  |1.3Q39
         STW       R2,PR_SFAID,X3   SET PRE INFO ADDR            1.3#05
         ADMW      R2,XINFOENT     ADD SIZE OF INFO RECORDS      1.3#05
BBP.2    EQU       $               RESUME AFTER COND INFO        1.3#05
         STW       R2,LMFSIZE      AND UPDATE POINTER            1.3#05
         LW        R4,LMTABB       INDEX BLOCK FOR NEW FORMAT    1.3#05
         TBM       MOPT2,MFLGS     IS IT OLD FORMAT              1.3#05
         BS        $+2W            SKIP IS OLD                   1.3#05
         STW       R4,PR.INDEX,X3   LOAD MODULE'S (ZERO IF OLD)  1.3#05
         TBM       MOPT4,MFLAG2    SAVE DIRECTIVES?             ETCM-32
         BS        $+3W            SKIP IF NOT                  ETCM-32
         ADI       R4,1                                         ETCM-32
         STW       R4,PR_CATD,X3   STORE DIRECTIVE SECTOR NUM   ETCM-32
         LW        R7,CATREV       GET CURRENT REVISION LEVEL   EOBJ-30
         STW       R7,PR_CATRV,X3  STORE REV LEVEL IN PREAMBLE  EOBJ-30
*                                                                1.3#05
*     SET MPX-32 ADDRESS,TASK GROUP,BLOCKING BUF,SPACE & KEEP    1.3#05
*                                                                1.3#05
         LW        R7,1W,X1        GET OVERLAY LEVEL             1.3#11
         BNZ       BBP.21          SKIP IF NOT ROOT              1.3#11
*                                                                1.3#11
         LW        R7,EXTDVAL      GET VALUE OF EXTDMPX          1.3#05
         STW       R7,PR_MPXBR,X3     SET PRE WITH MPX   EBRM-33 1.3#05
*                                                                1.3#11
         LB        R7,MTGID        GET TASK GROUP ID             1.3#11
         STB       R7,PR_GID,X3    INTO PREAMBLE                 1.3#11
*                                                                1.3#11
         TBM       MTSBB,MFLGS     IS TASK SUPPLIED BLK BUF     C008-30
         BNS       $+2W            SKIP IF NOT                  C008-30
         SBM       PR_TSBB,PR_FLAG3,X3   SET IN PREAMBLE        C008-30
*                                                                1.3#11
         LH        R7,MLAS         GET SPACE VALUE               1.3#11
         STH       R7,PR_LAS,X3    SET INTO PREAMBLE             1.3#11
*                                                                1.3#11
         TBM       MRCMN,MFLGS     IS REATAIN NAME SET          C008-30
         BNS       $+2W            SKIP                         C008-30
         SBM       PR_RCMN,PR_FLAG3,X3    SET IN PREAMBLE       C008-30
*
         LW        R7,DBNAME       GET DEBUGGER NAME            EDBG-34
         STW       R7,PR_NAMDB,X3  STORE IN PREAMBLE            EDBG-34
         LW        R7,DBNAME+1W    2ND WORD                     EDBG-34
         STW       R7,PR_NAMDB+1W,X3                            EDBG-34
         LW        R7,DBNAME+2W    3RD WORD                     EDBG-34
         STW       R7,PR_NAMDB+2W,X3                            EDBG-34
         LW        R7,DBNAME+3W    4TH WORD                     EDBG-34
         STW       R7,PR_NAMDB+3W,X3                            EDBG-34
*
         TBM       MTSA,MFLGS      EXTENDED TSA SPECIFIED?      ETSA-32
         BNS       BPRE.1          CONTINUE IF NOT              ETSA-32
         ZBM       PR3_ETSA,PR_FLAG3,X3  CLEAR ENABLE BIT       ETSA-32
         SBM       PR3_TSA,PR_FLAG3,X3  SET MOVE TSA BIT        ETSA-32
         BU        BPRE.3          CONTINUE                     ETSA-32
BPRE.1   TBM       MNTSA,MFLGS     NON-EXTENDED TSA SPECIFIED   ETSA-32
         BNS       BPRE.2          CONTINUE IF NOT              ETSA-32
         ZBM       PR3_ETSA,PR_FLAG3,X3   CLEAR ENABLE BIT      ETSA-32
         ZBM       PR3_TSA,PR_FLAG3,X3   CLEAR MOVE TSA BIT     ETSA-32
         BU        BPRE.3          CONTINUE                     ETSA-32
BPRE.2   TBM       MSYST,MFLAG3    WAS SYSTSA SPECIFIED         ETSA-32C
         BNS       BPRE.3          CONTINUE                     ETSA-32C
         SBM       PR3_ETSA,PR_FLAG3,X3  SET ENABLE BIT         ETSA-32C
         ZBM       PR3_TSA,PR_FLAG3,X3   CLEAR MOVE TSA BIT     ETSA-32C
BPRE.3   TBM       MMOUT,MFLGS     MAPOUT MPX SPECIFIED         EOUT-32
         BNS       BPRE.4          CONTINUE IF NOT              EOUT-32
         ZBM       PR4_MAPO,PR_FLAG4,X3  CLEAR ENABLE BIT       EOUT-32
         SBM       PR4_MOFL,PR_FLAG4,X3  SET MAPPED OUT BIT     EOUT-32
         BU        BPRE.6          CONTINUE                     EOUT-32
BPRE.4   TBM       MMIN,MFLGS      NOMAPOUT SPECIFIED           EOUT-32
         BNS       BPRE.5          SKIP IF NOT                  EOUT-32
         ZBM       PR4_MAPO,PR_FLAG4,X3  CLEAR MAPPED OUT BIT   EOUT-32
         ZBM       PR4_MOFL,PR_FLAG4,X3  CLEAR MAPPED OUT BIT   EOUT-32
         BU        BPRE.6          CONTINUE                     EOUT-32
BPRE.5   TBM       MSYSM,MFLAG3    WAS SYSMAP SPECIFIED         EOUT-32B
         BNS       BPRE.6          CONTINUE IF NOT              EOUT-32B
         SBM       PR4_MAPO,PR_FLAG4,X3  SET ENABLE BIT         EOUT-32B
         ZBM       PR4_MOFL,PR_FLAG4,X3  CLEAR MAPPED OUT BIT   EOUT-32B
BPRE.6   TBM       M2.5MB,MFLAG2         2.5 MB TASK GENERATED  ELST-32D
         BNS       $+2W                  CONTINUE IF NOT        ELST-32D
         SBM       PR4_SEGT,PR_FLAG4,X3  SET PREAMBLE FLAG BIT  ELST-32D
         TBM       MDMPG,MFLAG3    WAS DEMAND PAGE SPECIFIED    EDMP-32
         BNS       BPRE.7          CONTINUE IF NOT              EDMP-32
         SBM       PR4_DPG,PR_FLAG4,X3  SET PREAMBLE FLAG BIT   EDMP-32
         LW        R7,AGEVAL       GET DEMAND PAGE AGE VALUE    EAGE-33
         STW       R7,PR_AGE,X3    SAVE IN PREAMBLE             EAGE-33
         BU        BPRE.8          CONTINUE                     EDMP-32
BPRE.7   TBM       MNDMPG,MFLAG3   NODEMAND SPECIFIED           EDMP-32
         BNS       BPRE.8          CONTINUE IF NOT              EDMP-32
         SBM       PR4_NDPG,PR_FLAG4,X3  SET PREAMBLE FLAG BIT  EDMP-32
BPRE.8   EQU       $                                            EDMP-32
         TBM       MONRA,MFLGS     REALTIME ACCOUNTING ON?      ECSW-30
         BNS       BBP.20          CONTINUE IF NOT              ECSW-30
         LB        R7,MPRIO        GET LOAD MODULE PRIORITY     ECSW-30
         CI        R7,54           COMPARE WITH 54              ECSW-30
         BGT       BBP.201         NON-REALTIME WARNING         ECSW-30
         TBM       MOFRA,MFLGS     ARE BOTH ONRA AND OFRA SET?  ECSW-30
         BS        BBP.202         WARNING MESSAGE IF BOTH SET  ECSW-30
         SBM       PR_ONRA,PR_FLAG3,X3  SET BIT IN PREAMBLE     ECSW-30
         BU        BBP.21          CONTINUE                     ECSW-30
BBP.20   TBM       MOFRA,MFLGS     REALTIME ACCOUNTING OFF?     ECSW-30
         BNS       BBP.21          CONTINUE IF NOT              ECSW-30
         LB        R7,MPRIO        GET LOAD MODULE PRIORITY     ECSW-30
         CI        R7,54           COMPARE WITH 54              ECSW-30
         BGT       BBP.201         NON-REALTIME WARNING         ECSW-30
         SBM       PR_OFRA,PR_FLAG3,X3  SET BIT IN PREAMBLE     ECSW-30
         BU        BBP.21          CONTINUE                     ECSW-30
BBP.201  LA        R6,BBP.MSG5     NON REALTIME WARNING MESS.   ECSW-30
         LNB       R5,BBP.ML5      MESSAGE LENGTH               ECSW-30
         BL        XTYPEF          OUTPUT MESSAGE TO USER       ECSW-30
         LA        R6,BBP.MS5B     REST OF MESSAGE              ECSW-30
         LNB       R5,BBP.ML5B                                  ECSW-30
         BL        XTYPEF                                       ECSW-30
         BU        BBP.21          CONTINUE                     ECSW-30
BBP.202  LA        R6,BBP.MSG4     BOTH ONRA AND OFRA SET MESS  ECSW-30
         LNB       R5,BBP.ML4      MESSAGE LENGTH               ECSW-30
         BL        XTYPEF          OUTPUT MESSAGE TO USER       ECSW-30
         LA        R6,BBP.MS4B     REST OF MESSAGE              ECSW-30
         LNB       R5,BBP.ML4B                                  ECSW-30
         BL        XTYPEF                                       ECSW-30
BBP.21   EQU       $                                             1.3#11
         TBM       MDIVM,MFLAG3    COMPATIBLE DIVIDE SPECIFIED  EFLM-33
         BNS       $+2W            NO...SKIP SET BIT            EFLM-33
         SBM       2,PR_FLTC,X3    SET BIT IN CONTEXT WORD      EFLM-33
         TBM       MIEOBJ,MFLAG3   ANY IEEE OBJECT READ         EIEE-33
         BNS       BBP.22          NO...SETUP EXCESS 64 CONTEXT EIEE-33
         SBM       24,PR_FLTC,X3   SET SUDDEN UNDERFLOW FLAG    EIEE-34B
         SBM       26,PR_FLTC,X3   SET AFFINE SENSE FLAG        EIEE-34B
         SBM       28,PR_FLTC,X3   SET UP IEEE CONTEXT          EIEE-33
         SBM       29,PR_FLTC,X3                                EIEE-33
         BU        BBP.23          CONTINUE                     EIEE-33
BBP.22   SBM       30,PR_FLTC,X3   SET UP EXCESS 64 CONTEXT     EIEE-33
         SBM       31,PR_FLTC,X3                                EIEE-33
         SBM       27,PR_FLTC,X3   SET SATURATE FLAG            EIEE-33
BBP.23   EQU       $                                            EIEE-33
*                                                                1.3#05
*    SET UP MODULE NAME                                          1.3#05
*
         LW        R1,MMODW        GET SEGMENT ENTRY ADDR        1.3#05
         LD        R4,2W,R1                                      1.3#05
         STD       R4,PR.NAME,X3       MODULE NAME               1.3#05
         TRR       R1,R5           SET FOR SEARCH                1.3#05
         LW        R4,=X'04000000'   CONTROL ENTRY               1.3#05
         ZR        R7              ANY NAME                      1.3#05
         BL        MSSCH           S E A R C H                   1.3#05
         TRR       R5,R2                                         1.3#05
         STW       R5,BBP.SYMC     SAVE ADDR OF FIRST CONTROL    1.3#05
         TBM       4,1B,X1         IS OUTPUT SUPPRESSED          1.3#05
         BS        BBP.42          SKIP SIZE ELEMENTS IF SET     1.3#05
*                                                                1.3#05
* DO CSECT RELATED ELEMENTS                                      1.3#05
*                                                                1.3#05
         LW        R7,BSP.CSSB     GET BYTE SIZE OF CSECT        1.3#05
         BZ        BBP.3           SKIP IF NULL                  1.3#05
         STW       R7,PR.BYTEC,X3  SET CSECT SIZE                1.3#05
         LW        R7,BSP.CORG     GET CSECT ORIGIN              1.3#05
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       ELST-32
         BNS       $+2W            SKIP IF NOT                  ELST-32
         ADMW      R7,DEBIAS       BIAS CSECT ORIGIN IF 2.5MB   ELST-32
         STW       R7,PR.ORGC,X3   SET CSECT ORIGIN              1.3#05
         ADMW      R7,BSP.CSSB     ADD CSECT SIZE                1.3#05
         STW       R7,PR.ENDC,X3   SET CSECT END                 1.3#05
         LW        R7,BSP.CRMB     GET SIZE OF CSECT RELOM       1.3#05
         STW       R7,PR.BYTCR,X3      SET SIZE OF RELOM         1.3#05
*                                                                1.3#05
         LW        R7,1W,X1        GET OVERLAY LEVEL/SEQ         1.3#05
         BNZ       BBP.3           SKIP PAGE REQ IF AN OVERLAY   1.3#05
         TRR       R2,R7           SAVE R2                       1.3#05
*!!!!!!!!LW!!!!!!!!R2,PR.BYTEC,X3!!!!!!#!BYTES!OF!CSECT!!!!!!!!!PR10874
         LW        R2,MTOTALC      GET CSECT MEM REQUIREMENT    PR10874
         LI        R4,512W                                       1.3#05
         BL        MXBOUND                                       1.3#05
         SRL       R2,11           CONVERT TO PAGES              1.3#05
         STH       R2,PR_PRTGC,X3  SAVE PAGE REQ. IN HALFWORD   EOUT-32
         STB       R2,PR.PAGEC,X3                                1.3#05
         TRR       R7,R2           RECOVER R2                    1.3#05
BBP.3    EQU       $                                             1.3#05
*                                                                1.3#05
*    SET UP DSECT SIZES                                          1.3#05
*
         LW        R5,5W,R1        MODULE ORIGIN                 1.3#05
         ADMW      R5,BSP.BIAS     PLUS NON-INIT'D PART          1.3#07
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE            1.3#05
         BNS       BBP.4           BR IF NOT ABSOLUTE            1.3#05
         ADMW      R5,MPABS        ADD IN ABSOLUTE BASE          1.3#05
         SBR       R5,7            ORIGIN IS ABSOLUTE            1.3#05
BBP.4    STW       R5,PR.ORGD,X3     STORE DSECT ORIGIN          1.3#05
         LW        R5,7W,X1        GET MODULE ENDING ADDR        1.3#05
         TBM       MABS,MFLGS      ARE WE ABSOLUTE               1.3#05
         BNS       BBP.41          SKIP IF NOT                   1.3#05
         ADMW      R5,MPABS        ELSE ADD IN BIAS              1.3#05
         SBR       R5,7            SHOW END ADDR AS ABSOLUTE     1.3#05
BBP.41   EQU       $                                             1.3#05
         STW       R5,PR.ENDD,X3      SET DSECT END              1.3#05
         SUMW      R5,PR.ORGD,X3       SUB OUT START             1.3#05
         STW       R5,PR.BYTED,X3     SET DSECT SIZE             1.3#05
         LW        R7,BSP.DRMB     GET SIZE OF DSECT RELOM       1.3#05
         STW       R7,PR.BYTDR,X3      SET SIZE OF RELOM         1.3#05
*                                                                1.3#05
         LW        R5,1W,R1        CHECK TO SEE IF THIS IS AN OV 1.3#05
         BNE       BBP.42          BRANCH IF OVERLAY             1.3#05
         LW        R2,MTOTALL      GET ALLOC. REQ. FOR LOAD MODU 1.3#05
         ADMW      R2,MALTD        PLUS ALLOCATE INCREMENT       1.3#05
         LI        R4,512W         BOUND TO A PAGE               1.3#05
         BL        MXBOUND                                       1.3#05
         SRL       R2,11           CONVERT TO PAGES              1.3#05
         STH       R2,PR_PRTGD,X3  SAVE PAGE REQ. IN HALFWORD   EOUT-32
         STB       R2,PR.PAGED,X3      # PAGES OF DSECT          1.3#05
BBP.42   EQU       $                                             1.3#05
*                                                                1.3#05
*    DO TIME AND DATE ELEMENTS                                   1.3#05
*
         SBM       BBP.FSTT,BBP.FLGS     SET FIRST TIME FLAG     1.3#05
         BS        BBP.5            SKIP TIME DATE ACQUI. IF SET 1.3#05
         STW       R1,R1SAVE       SAVE REGISTER 1               1.3#05
         M.QATIM   DATETIME             GET THE TIME             1.3#05
         LH        R1,DATETIME+4H     GET THE HOURS IN ASCII     1.3#05
         STH       R1,DATETIME     AND STORE                     1.3#05
         LI        R5,G':'                                       1.3#05
         STB       R5,DATETIME+2B                                1.3#05
         LH        R1,DATETIME+5H  GET MINUTES IN ASCII          1.3#05
         STB       R1,DATETIME+4B  AND STORE                     1.3#05
         SRL       R1,8                                          1.3#05
         STB       R1,DATETIME+3B                                1.3#05
         STB       R5,DATETIME+5B                                1.3#05
         LH        R1,DATETIME+6H  GET SECONDS IN ASCII          1.3#05
         STH       R1,DATETIME+3H  AND STORE                     1.3#05
         LD        R4,DATETIME     GET FORMATED TIME             1.3#05
         STD       R4,DATETIME+1D  AND PUT BACK INTO TIME SLOT   1.3#05
         LD        R4,C.DATE            GET TODAY'S DATE         1.3#05
         STD       R4,DATETIME     AND PUT INTO DATE SLOT        1.3#05
         LW        R1,R1SAVE       RESTORE R1                    1.3#05
BBP.5    EQU       $                                             1.3#05
         LD        R4,DATETIME     GET ASSEMBLED DATE INFO       1.3#05
         STD       R4,PR.DATE,X3       STORE DATE IN PREAMBLE    1.3#05
         LD        R4,DATETIME+1D  GET TIME INFO                 1.3#05
         STD       R4,PR_TIME,X3    STORE INTO PREAMBLE          1.3#05
*                                                                1.3#05
*  DO PAGE SIZE INDICATOR (FROM ENVIRONMENT INFO)                1.3#05
*                                                                1.3#05
         LW        R5,MPAGESZ      SET PAGE SIZE                 1.3#05
         SRL       R5,11           CONV TO # 512W BLOCKS         1.3#05
         STB       R5,PR.PGSIZ,X3                                1.3#05
*                                                                1.3#05
*   DO FILE REQUIREMENTS ELEMENT                                 1.3#05
*                                                                1.3#05
         LB        R7,MFILE        GET FILE COUNT                1.3#05
         STB       R7,PR.FILE,X3       STORE IN PREAMBLE         1.3#05
         TBM       MSEGF,MFLGS     SEE IF SEGFILE DIRECTIVE USED 1.3#05
         BNS       B20.9           ..... BRANCH IF NOT TO USE FI 1.3#05
         LB        R7,MSEGFILE     ..... ELSE USE SEGFILES VALUE 1.3#05
B20.9    STB       R7,PR.SEGS,X3       ..... AND STORE IN PREAMB 1.3#05
*                                                                1.3#05
*  DO BUFFER COUNT REQUIREMENS                                   1.3#05
*
         LB        R7,MBUFR        GET BUFFER COUNT              1.3#05
         STB       R7,PR.BUFR,X3       STORE IN PREAMBLE         1.3#05
*                                                                1.3#05
*  DO FLAG ELEMENT                                               1.3#05
*
         SBM       PR.MPX20,MFLAG  INDICATE A 2.0 LOAD MODULE    1.3#05
         LB        R7,MFLAG          PICK UP FLAGS SET BY ENVIRO 1.3#05
         STB       R7,PR.FLAG,X3    USE ENVIRON FLAGS TO INIT PR 1.3#05
         SBM       PR.ABSC,PR.FLAG,X3     SET ABSOLUTE CSECT FLA 1.3#05
         TBM       MABS,MFLGS          IS DESECT ABSOLUTE        1.3#05
         BNS       $+2W                SKIP IF NOT               1.3#05
         SBM       PR.ABSD,PR.FLAG,X3     SET ABSOLUTE DSECT FLA 1.3#05
*                                                                1.3#05
*  DO VOLUMES ELEMENT                                            1.3#05
*                                                                1.3#05
         LB        R7,MVOLUMES     GET VAT COUNT                 1.3#05
         STB       R7,PR.MOUNT,X3      STORE IN PREAMBLE         1.3#05
*                                                                1.3#05
*   DO CONTROL BYTE ELEMENT                                      1.3#05
*                                                                1.3#05
         TBM       MSAM,MFLGS      CHECK IF SA OPTION SPECIFIED  1.3#05
         BNS       B21.1           BRANCH IF NOT SPECIFIED       1.3#05
         SBM       PR.SAM,PR.CNTL,X3        SET INTO PREAMBLE    1.3#05
B21.1    TBM       MTYPE,MFLGS                                   1.3#05
         BNS       B21.2           BR IF NOT PRIVILEGED          1.3#05
         SBM       PR.PRIV,PR.CNTL,X3     SET PRIVILEGE FLAG     1.3#05
B21.2    TBM       MOPT2,MFLGS     DOES USER WANT 1.X LOAD MODUL 1.3#05
         BNS       B21.3           BRANCH IF OPTION 2 NOT SPEC'D 1.3#05
         SBM       PR.OVLS,PR.CNTL,X3     SET OVERLAYS SEPAR. FL 1.3#05
B21.3    LW        R5,BNSEG        LOAD NUMBER OF SEGMENTS       1.3#05
         CI        R5,1            MORE THAN ONE                 1.3#05
         BGT       B21.4           SKIP IF MORE                  1.3#05
         TBM       MOPT2,MFLGS     IS THIS SEPARATE LM'S         1.3#05
         BS        B21.4           THEN DON'T SET PR.NOVL        1.3#05
         SBM       PR.NOVL,PR.CNTL,X3   TELL LOADER              1.3#05
B21.4    LW        R1,MMODW        ADDR OF WORKING MODULE        1.3#05
**?      LW        R5,1W,X1        GET OV.L/SEQ                  1.3#05
**?      BZ        B21.5           SKIP IF THE MAIN              1.3#05
**?      TBM       MOPT2,MFLGS     IS OPTION 2 ON                1.3#05
**?      BNS       B21.5           SKIP IF NOT                   1.3#05
**?      SBM       PR.OVER,PR.CNTL,X3   TELL LOADER              1.3#05
**? PR.OVER WAS NEVER SET IN PREVIOUS VERSIONS                   1.3#05
B21.5    EQU       $                                             1.3#05
*                                                                1.3#05
*  USE OF FOLLOWING NOT KNOWN,    H.TAMM DOES NOT PROCESS        1.3#05
         SBM       PR.GLOB,PR.CNTL,X3     SET GLOBAL ALL FLAG    1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
*  DO RRS COUNT                                                  1.3#05
*                                                                1.3#05
         LB        R5,MRRSN        GET NUMBER OF RRS ENTRIES     1.3#05
         STB       R5,PR.NRRS,X3     STORE NUMBER OF RRS ENTRIES 1.3#05
         ZMB       MRRSN           NO RRS ENTRIES FOR OVERLAYS   1.3#05
*                                                                1.3#05
*  DO MEMORY TYPE ELEMENT                                        1.3#05
*                                                                1.3#05
         LW        R5,PRMEMS       GET MEMORY TYPE               1.3#05
         STB       R5,PR.MEMS,X3       PUT IN PREAMBLE           1.3#05
*                                                                1.3#05
*  DO GLOBAL COMMON PAGE COUNT ELEMENT                           1.3#05
*                                                                1.3#05
         LI        R5,256          GET # OF PAGES IN 128KW       1.3#05
         SUMW      R5,CLGC         LOWEST GC PAGE USED           1.3#05
         STH       R5,PR_PRTGG,X3  SAVE IN HALFWORD PAGE COUNT  EOUT-32
         STB       R5,PR.PAGEG,X3      SAVE IN PREAMBLE          1.3#05
*                                                                1.3#05
* DO PRIORITY LEVEL ELEMENT                                      1.3#05
*                                                                1.3#05
         LB        R5,MPRIO                                      1.3#05
         STB       R5,PR.PRIOR,X3      PRIORITY LEVEL            1.3#05
*                                                                1.3#05
*   DO PROGRAM OPTION WORD ELEMENT                               1.3#05
*                                                                1.3#05
         LW        R2,MOPTD                                      1.3#05
         STW       R2,PR.OPTN,X3       SET OPTIONS IN PREAMBLE   1.3#05
         LW        R2,MOPTD2       DO SECOND OPTION WORD        EOPT-32
         STW       R2,PR.PGO2,X3   PUT INTO PREAMBLE            EOPT-32
*                                                                1.3#05
*  WHY IS THIS HERE                                              1.3#05
*                                                                1.3#05
         LW        R1,MMODW        GET ADDRESS OF MODULE ENTRY   1.3#05
         LB        R5,1B,R1        GET OPTION BYTE FROM MODULE E 1.3#05
         STB       R5,MOPTS        SET MODULE'S OPTIONS          1.3#05
*                                                                1.3#05
*   DO TRANSFER ADDR ELEMENT                                     1.3#05
*                                                                1.3#05
BBP.8    EQU       $                                             1.3#05
         LW        R5,4W,R1        GET TRANSFER ADDRESS FROM MOD 1.3#05
         TBM       7,0,R1          ANY TRANSFER ADDR             1.3#05
         BS        BBP.91          BR IF TRANSFER ADDRESS        1.3#05
         LW        R5,1W,R1        GET SEQ. NO. AND OVERLAY LEVE 1.3#05
         BNE       BBP.XIT         BR IF NOT MAIN                1.3#05
*                                                                1.3#05
         SBM       XABORTFL,XFLGS  SET ABORT FLAG                1.3#10
         LD        R4,2W,R1        GET MODULE'S NAME             1.3#05
         STW       R4,BBP.MD1                                    1.3#05
         STW       R5,BBP.MD1+1W                                 1.3#05
         LNB       R5,BBP.ML1      SET FOR SLO & UT              1.3#05
         LA        R6,BBP.MSG1                                   1.3#05
         BL        XTYPEF          AND FORCE LOG                 1.3#05
         LW        R5,BBP.SYMC     GET ADDR OF FIRST CONTROL     1.3#05
         SUI       R5,4W           BACK IT DOWN                  1.3#05+
         LW        R4,=X'44000000' SET FOR CONTROL/DEF ENTRY     1.3#05
         ZR        R7              ANY                           1.3#05
         BL        MSSCH           S E A R C H                   1.3#05
         TRR       R5,R2           ANY FOUND                     1.3#05
         BZ        BBP.9           TRY OTHER WAY IF NOT          1.3#05
         TBM       5,0,X2          IS IT A CONTROL ENTRY         1.3#05
         BS        BBP.9           TRY OTHER WAY IF FOUND        1.3#05
         LD        R4,1D,X2        GET SYMBOL NAME               1.3#05
         STW       R4,BBP.MD2                                    1.3#05
         STW       R5,BBP.MD2+1W                                 1.3#05
         LNB       R5,BBP.ML2      SET FOR SLO & UT              1.3#05
         LA        R6,BBP.MSG2                                   1.3#05
         BL        XTYPEF          FORCE LOG                     1.3#05
         LW        R4,=X'00FFFFFF'                               1.3#05
         LMW       R5,1W,X2        GET MODULE RELATIVE ADR       1.3#05
         LB        R7,4B,X2        GET SECTION NUMBER            1.3#05
         BZ        $+2W            SKIP IF ZERO                  1.3#05
         SBR       R5,7            INDICATE IN CSECT             1.3#05
         NOP                       BOUND UP                      1.3#05
         BU        BBP.91          GO TO MERGE POINT             1.3#05
BBP.9    EQU       $                                             1.3#05
         LW        R2,BBP.SYMC     ADDR OF FIRST CONTROL         1.3#05
         LW        R4,=X'00FFFFFF'                               1.3#05
         LMW       R5,3W,X2        GET MODULE ORIGIN             1.3#05
         LMW       R6,1W,X2        GET CAT ALLOCATED AMOUNT      1.3#05
         ADR       R6,R5           ADD TO CONTROL BASE           1.3#05
         TRR       R5,R4           SAVE VALUE                    1.3#05
         M.CONBAH                  CONVERT TO HEX                1.3#05
         ANMW     R6,=X'000000FF'   SAVE 5 DIGITS                1.3#05
         SLLD      R6,8            POSITION                      1.3#05
         ORMW      R6,BBP.TOP      PUT X' IN TOP                 1.3#05
         ORMW      R7,BBP.BOT      PUT ' IN BOTTOM               1.3#05
         STW       R6,BBP.MD3                                    1.3#05
         STW       R7,BBP.MD3+1W                                 1.3#05
         LNB       R5,BBP.ML3                                    1.3#05
         LA        R6,BBP.MSG3                                   1.3#05
         BL        XTYPEF          FORCE LOG                     1.3#05
         TRR       R4,R5           RECOVER VALUE                 1.3#05
BBP.91   EQU       $               MERGE POINT                   1.3#05
         TBR       R5,7            IS TRANSFER ADDRESS IN CSECT  1.3#05
         BS        BBP.92          BR IF TRANSFER ADDRESS IN CSE 1.3#05
         TBM       MABS,MFLGS      IS MODULE ABSOLUTE            1.3#05
         BNS       BBP.92          BR IF NOT ABSOLUTE            1.3#05
         ADMW      R5,MPABS        ADD ABSOLUTE BASE TO TRANSFER 1.3#05
         SBR       R5,7            MARK TRANSFER ADDRESS ABSOLUT 1.3#05
BBP.92   STW       R5,PR.TRAN,X3       PUT TRANSFER ADDR. IN PRE 1.3#05
*                                                                1.3#05
BBP.XIT  EQU       $                                             1.3#05
         LF        R0,BBP.RSAV     RECOVER USER                  1.3#05
         TRSW      R0              RETURN                        1.3#05
BBP.FLGS DATAH     0               BBP FLAGS                     1.3#05
BBP.FSTT EQU       0               FIRST TIME FLAG               1.3#05
BBP.TOP  DATAW     X'58270000'                                   1.3#05
BBP.BOT  DATAW     X'00000027'                                   1.3#05
BBP.SYMC DATAW     0           HOLDS STAB ADDR OF FIRST CONTROL  1.3#05
*                                                                1.3#05
         BOUND     1F                                            1.3#05
BBP.RSAV RES       1F                                            1.3#05
BBP.MSG1 DATAB     C' CATALOG(WARNING) NO TRANSFER ADDRESS'      1.3#05&
         DATAB     C' FOR ROOT LOAD MODULE: '                    1.3#05
BBP.MD1  REZ       8B              HOLDS MODULE NAME             1.3#05&
BBP.ML1  DATAB     $-BBP.MSG1                                    1.3#05
         BOUND     1W
*                                                                1.3#05
BBP.MSG2 DATAB     C'                  GLOBAL SYMBOL     '       1.3#05
BBP.MD2  REZ       8B              HOLDS SYMBOL NAME             1.3#05&
         DATAB     C'    ASSUMED.'                               1.3#05&
BBP.ML2  DATAB     $-BBP.MSG2                                    1.3#05
         BOUND     1W
*
BBP.MSG3 DATAB     C'                  LOCATION  '               1.3#05
BBP.MD3  REZ       8B              HOLDS ACH OF ADDRESS          1.3#05&
         DATAB     C'  ASSUMED.'                                 1.3#05&
BBP.ML3  DATAB     $-BBP.MSG3                                    1.3#05
         BOUND     1W
*                                                                1.3#05
BBP.MSG4 DATAB     C' CATALOG(WARNING) USE OF BOTH ONRA AND'    ECSW-30
         DATAB     C' OFRA ENVIRONMENT OPTIONS IN THE SAME'     ECSW-30
         DATAB     C' LOAD'                                     ECSW-30
BBP.ML4  DATAB     $-BBP.MSG4                                   ECSW-30
BBP.MS4B DATAB     C'                  MODULE IS NOT ALLOWED.'  ECSW-30
         DATAB     C' SYSTEM DEFAULT WILL BE USED.'             ECSW-30
BBP.ML4B DATAB     $-BBP.MS4B                                   ECSW-30
         BOUND     1W
*
BBP.MSG5 DATAB     C' CATALOG(WARNING) ONRA & OFRA ENVIRONMENT' ECSW-30
         DATAB     C' OPTIONS HAVE NO EFFECT ON TIME'           ECSW-30
BBP.ML5  DATAB     $-BBP.MSG5                                   ECSW-30
BBP.MS5B DATAB     C'                  DISTRIBUTION TASKS.'     ECSW-30
BBP.ML5B DATAB     $-BBP.MS5B                                   ECSW-30
         BOUND     1D
*
*----------------------------------------------------------------1.3#05
         TITLE     BSEGPRMS - CALCULATE SEGMENT PARAMETERS       1.3#05
*                                                                1.3#05
*   BSEGPRMS                                                     1.3#05
*                                                                1.3#05
*  THIS ROUTINE LOOPS THROUGH ALL SYMTAB ENTRIES ASSOCIATED      1.3#05
*  WITH THE SEGMENT ENTRY POINTED TO BY R1 AND FINDS:            1.3#05
*                                                                1.3#05
*    1)THE SEGMENT DSECT SIZE IN BYTES                           1.3#05
*                                                                1.3#05
*    2)THE SEGMENT CSECT SIZE IN BYTES (IF ANY)                  1.3#05
*                                                                1.3#05
*    3)THE LARGEST SINGLE(PROGRAM) DSECT IN BYTES                1.3#05
*                                                                1.3#05
*    4)THE LARGEST SINGLE CSECT IN BYTES (IF ANY)                1.3#05
*                                                                1.3#05
*    5)THE SEGMENT SIZE IN SECTORS (BOUNDED FOR CSECT/DSECT)     1.3#05
*      AND INCLUDING SPACE FOR RELOCATION MATRIX(ES)             1.3#05
*                                                                1.3#05
*    6)FILE SIZE REQUIREMENTS FOR GLOBAL SYMBOLS IN SECTORS      1.3#05
*                                                                1.3#05
*                                                                1.3#05
*   IN    R1 = ADDR OF CURRENT SEGMENT ENTRY                     1.3#05
*                                                                1.3#05
*  OUT    R1 = ADDR OF LAST ENTRY PROCESSED                      1.3#05
*         R2 = SEGMENT DSECT SIZE IN BYTES                       1.3#05
*         R3 = SEGMENT CSECT SIZE IN BYTES                       1.3#05
*         R4 = LARGEST SINGLE DSECT SIZE                         1.3#05
*         R5 = LARGEST SINGLE CSECT SIZE                         1.3#05
*         R6 = SIZE IN SECTORS OF FILE REQ. THIS SEGMENT         1.3#05
*         R7 = SIZE IN SECTORS OF FILE REQ. FOR GLOB SYMS        1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
         BOUND 1F                                                1.3#05
*                                                                1.3#05
*    THE FOLLOWING GLOBAL SIZES ARE CALCULATED AND RETURNED      1.3#05
*    IN THE DESIGNATED REGISTER                                  1.3#05
*
BSP.RSAV DATAW     0               RETUN ADDR              R0    1.3#05
BSP.LENT DATAW     0               LAST ENTRY              R1    1.3#05
*                                                                1.3#05
BSP.DSSB DATAW     0   HOLDS SEGMENT DSECT SIZE IN BYTES   R2    1.3#05
BSP.CSSB DATAW     0   HOLDS SEGMENT CSECT SIZE IN BYTES   R3    1.3#05
BSP.LDST DATAW     0   HOLDS SIZE OF LARGEST SINGLE DSECT  R4    1.3#05
BSP.LCST DATAW     0   HOLDS SIZE OF LARGEST SINGLE CSECT  R5    1.3#05
*                                                                1.3#05
BSP.SSS  DATAW     0    SEGMENT SIZE IN SECTORS            R6    1.3#05
BSP.DGS  DATAW     0    DEBUG GLOBAL SYMBOL SECTOR REQUIR. R7    1.3#05
*                                                                1.3#05
*    THE FOLLOWING MODULE RELATED SIZES ARE CALCULATED           1.3#05
*    AND LEFT IN THESE VARIABLES FOR LATER USE                   1.3#05
*
*                                                                1.3#05
BSP.DRMB DATAW     0   DSECT RELOMAT SIZE IN BYTES               1.3#05
BSP.CRMB DATAW     0   CSECT RELOMAT SIZE IN BYTES               1.3#05
*                                                                1.3#05
BSP.DSCT DATAW     0   DSECT SIZE IN SECTORS                     1.3#05
BSP.CSCT DATAW     0   CSECT SIZE IN SECTORS                     1.3#05
*                                                                1.3#05
BSP.DRMS DATAW     0   DSECT RELOMAT SIZE IN SECTORS             1.3#05
BSP.CRMS DATAW     0   CSECT RELOMAT SIZE IN SECTORS             1.3#05
*                                                                1.3#05
BSP.CMAX DATAW     0    HOLDS MAXIMUM CSECT ADDR                 1.3#05
BSP.CORG DATAW     0   CSECT ORIGIN  (MINIMUN ORG FOUND)         1.3#05
*                                                                1.3#05
BSP.BIAS DATAW     0     HOLDS UNINITED CATALOG ALLOCATION       1.3#05
*                                                                1.3#07
BSEGPRMS EQU       $                                             1.3#05
         STF       R0,BSP.RSAV                                   1.3#05
         ZBM       BSP.LSTP,BSP.FLGS    RESET LAST PROGRAM FLAG  1.3#05
         SBM       BSP.FSTP,BSP.FLGS      SET FIRST PROGRAM FLAG 1.3#05
         ZBM       BSP.SCTN,BSP.FLGS      RESET SECTIONED FLAG   1.3#05
         ZMW       BSP.LDST          ZERO LARGEST DSECT          1.3#05
         ZMW       BSP.LCST          ZERO LARGEST CSECT          1.3#05
         ZMW       BSP.DGS           ZERO SYMBOL COUNTER         1.3#05
         ZMW       BSP.CMAX        INIT MAXIMUM CSECT ADDR       1.3#05
         ZMW       BSP.BIAS        INIT FRONT END BIAS           1.3#05
         ZBM       BSP.ORGC,BSP.FLGS   RESET ORG'D COMMON FLAG   1.3#07
         TRR       R1,R2           SAVE SEGMENT ENTRY ADDR       1.3#05
*                                                                1.3#05
         SUI       R1,4W           BACK IT DOWN TO CONTROL       1.3#05
         TBM       5,0W,X1         IS IT REALLY A CONTROL        1.3#05
         BNS       $-2W            LOOP IF LINKBACK              1.3#05
*                                                                1.3#05
         LW        R4,=X'00FFFFFF'  SET UP MASK FOR ENTRY MANIP  1.3#05
         STW       R4,BSP.CORG     INIT MINIMUM CSECT ORIGIN     1.3#05
*                                                                1.3#05
BSP.1    EQU       $               TOP OF CONTROL ENT LOOP       1.3#05
         ZMW       BSP.CSSB        INIT CSECT SIZE OF THIS PE    1.3#05
         TBM       7,0,X1          IS THIS LAST PROG ELEMENT     1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         SBM       BSP.LSTP,BSP.FLGS    SET LAST PROGRAM FLAG    1.3#05
         TRR       R1,R3           USE R3 AS SYMTAB INDEX        1.3#05
         SUI       R1,4W           BACK R1 DOWN TO PROG ENTRY    1.3#05
*                                                                1.3#05
*        R0 = WORKING REGISTER                                   1.3#05
*        R1 = PROGRAM ENTRY (CONSTANT) >4W FOR ACCESS TO CONTROL 1.3#05
*        R2 = SEGMENT ENTRY (CONSTANT)                           1.3#05
*        R3 = INIT AT CONTROL ENTRY LOOP TO PROCESS PROG DATA    1.3#05
*        R4 = ENTRY MASK                                         1.3#05
*        R5 = HOLDS LOOP CONTROL FOR PROGRAM ELEMENT DATA        1.3#05
*        R6 = WORKING REGISTER                                   1.3#05
*        R7 = WORKING REGISTER                                   1.3#05
*                                                                1.3#05
*   NOW LOOP THROUGH ALL ENTRIES UNDER THIS CONTROL              1.3#05
*                                                                1.3#05
         LNH       R5,1H,X3        NEG NUMBER OF ENTRIES         1.3#05
         ADI       R5,1            ACCOUNT FOR THIS CONTROL ENT. 1.3#05
BSP.2    EQU       $               LOOP TOP     WAS B2.1         1.3#05
         SUI       R3,4W           BACK IT DOWN TO NEXT ENTRY    1.3#05
         LW        R0,0W,X3        GET FIRST WRD                 1.3#05
         TBR       R0,2            IS IT A COMMON ENTRY          1.3#05
         BS        BSP.COMM        GO PROCESS                    1.3#05
         TBR       R0,3            IS IT A SECTION ENTRY         1.3#05
         BS        BSP.SECT        GO PROCESS                    1.3#05
         TBR       R0,1            IS IT A DEF ENTRY             1.3#05
         BS        BSP.DEFS        GO PROCESS                    1.3#05
         TBR       R0,4            IS IT A PROGRAM ENTRY         1.3#05
         BS        BSP.PROG        GO PROCESS                    1.3#05
BSP.3    EQU       $                 WAS B2.2                    1.3#05
         BIB       R5,BSP.2        LOOP FOR NEXT ENTRY           1.3#05
*                                                                1.3#05
*    NOW AT END OF ENTRIES UNDER CURRENT CONTROL                 1.3#05
*                                                                1.3#05
*   IF NOT LAST PROGRAM ELEMENT, UPDATE CONTROL ENTRY POINTER    1.3#05
*   AND LOOP. ELSE CALCULATE SEGMENT SIZES AND RETURN            1.3#05
*                                                                1.3#05
BSP.4    EQU       $                                             1.3#05
         LW        R0,BSP.CSSB     GET CSECT SIZE THIS CONTROL   1.3#05
         CAMW      R0,BSP.LCST     COMPARE TO LARGEST SO FAR     1.3#05
         BLE       $+2W            SKIP IF NOT LARGEST           1.3#05
         STW       R0,BSP.LCST     ELSE SAVE AS LARGEST          1.3#05
*                                                                1.3#05
         TBM       BSP.FSTP,BSP.FLGS   IS THIS THE FIRST MODULE  1.3#07
         BNS       BSP.41              SKIP IF NOT               1.3#07
         TBM       BSP.ORGC,BSP.FLGS  IS THERE ORG'D COMMON      1.3#07
         BS        BSP.41          SKIP IF THERE IS              1.3#07
         TBM       MOPT9,MFLAG3    OPTION 9 SET (SET NOZERO)?   EUIC-32
         BS        BSP.40          BRANCH IF SO                 EUIC-32
         LW        R7,AID.NCAT     GET NUMBER OF SEGMENTS       EUIC-32
         CI        R7,1            ARE THERE OVERLAYS           EUIC-32
         BLE       BSP.41          NO...INITIALIZE THE COMMON   EUIC-32
BSP.40   EQU       $                                             1.3#19
         LMW       R7,4W+1W,X1     ELSE  USE COMMON/BND AS       1.3#07
         STW       R7,BSP.BIAS     AS MODULE BIAS                1.3#07
BSP.41   EQU       $                                             1.3#07
*                                                                1.3#07
         LMW       R7,5W,X1     GET COMMON&BOUND COUNT FROM CNTL 1.3#05
         ADMW      R7,6W,X1     ADD OBJECT SIZE FROM CNTRL       1.3#05
         ZBM       BSP.FSTP,BSP.FLGS     FIRST PROGRAM           1.3#05
         BNS       $+2W            SKIP IF NOT                   1.3#05
         SUMW      R7,BSP.BIAS     REMOVE UNINIT'D SIZE          1.3#05
         CAMW      R7,BSP.LDST     IS THIS ONE LARGEST SO FAR    1.3#05
         BLE       $+2W            SKIP IF NOT                   1.3#05
         STW       R7,BSP.LDST                                   1.3#05
*                                                                1.3#05
         TBM       BSP.LSTP,BSP.FLGS  IS THIS LAST PROG ELEMENT  1.3#05
         BS        BSP.5           COMPLETE SEGMENT CALCS IF SET 1.3#05
         SUI       R3,4W           BACK IT DOWN TO NEXT          1.3#05
         TRR       R3,R1           SET UP AS CONTROL ENTRY INDEX 1.3#05
         BU        BSP.1           AND LOOP THROUGH NEXT GUY     1.3#05
*                                                                1.3#05
BSP.5    EQU       $                                             1.3#05
         STW       R3,BSP.LENT     SAVE R3 AS ADDR OF NEXT ENT   1.3#05
*                                                                1.3#05
*    CALCULATE CSECT,DSECT AND TOTAL SIZES IN BYTES              1.3#05
*
         LW        R6,7W,X2        GET SEGMENT END ADDR          1.3#05
         SUMW      R6,5W,X2        REMOVE SEGMENT ORIGIN         1.3#05
         SUMW      R6,BSP.BIAS     REMOVE FRONT END OFFSET       1.3#05
         STW       R6,BSP.DSSB     SAVE IN DSECT SIZE            1.3#05
         ZR        R7              PRESET R7                     1.3#05
         TBM       BSP.SCTN,BSP.FLGS   ANY SECTIONS              1.3#05
         BNS       BSP.6           SKIP IF ALL DSECT             1.3#05
         LW        R7,BSP.CMAX     GET CSECT TOP                 1.3#05
         SUMW      R7,BSP.CORG     REMOVE CSECT ORIGIN           1.3#05
BSP.6    EQU       $                                             1.3#05
         STW       R7,BSP.CSSB     AND SAVE IN CSECT SIZE        1.3#05
*                                                                1.3#05
*  CALCULATE SECTOR REQUIREMENTS FOR CSECT/DSECT                 1.3#05
*                                                                1.3#05
         LW        R7,BSP.DSSB     GET SIZE OF DSECT             1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768          CALCULATE NUMBER OD SECTORS   1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP SECTOR COUNT        1.3#05
         TRR       R7,R0           INIT ACCUMULATOR              1.3#05
         STW       R7,BSP.DSCT     SAVE IN DSECT SECTOR SIZE     1.3#05
*                                                                1.3#05
         ZMW       BSP.CSCT        PRESET CSECT SIZE IN SECTORS  1.3#05
         TBM       BSP.SCTN,BSP.FLGS  IS CSECT PRESENT           1.3#05
         BNS       BSP.7           SKIP IF NOT                   1.3#05
         LW        R7,BSP.CSSB     GET SIZE OF CSECT             1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768          CONVERT TO SECTORS            1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP COUNT               1.3#05
         STW       R7,BSP.CSCT     SAVE IN CSECT SIZE            1.3#05
         ADR       R7,R0           AND ADD TO ACCUMULATOR        1.3#05
BSP.7    EQU       $                                             1.3#05
*                                                                1.3#05
*NOW DO RELOCATION MATRIX FOR THIS CSECT/DSECT                   1.3#05
*                                                                1.3#05
         LW        R7,BSP.DSSB     GET SIZE OF DSECT             1.3#05
         ADI       R7,3            ROUND UP BY ADDING MAX RESID  1.3#05
         SRL       R7,2            AND CONVERT TO WORDS          1.3#05
         ES        R6                                            1.3#05
         DVI       R6,32           CONV TO SIZE OF RELOMAT       1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP RELO MATRIX SIZE    1.3#05
         SLL       R7,2            AND CONVERT TO BYTES          1.3#05
         STW       R7,BSP.DRMB     SAVE AS DSECT MATRIX SIZE     1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768          CONVERT TO SECTORS            1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP SECTOR COUNT        1.3#05
         STW       R7,BSP.DRMS     SAVE IN DSECT MATRIX SECTS    1.3#05
         ADR       R7,R0           AND ACCUMULATE                1.3#05
*                                                                1.3#05
         ZMW       BSP.CRMB       PRESET CSECT RELOMAT SIZE
         ZMW       BSP.CRMB       BYTES AND SECTORS
         TBM       BSP.SCTN,BSP.FLGS  IS IT SECTIONED            1.3#05
         BNS       BSP.8           SKIP IF NOT                   1.3#05
         LW        R7,BSP.CSSB     GET SIZE OF CSECT             1.3#05
         ADI       R7,3            ROUND UP BY ADDING MAX RESID  1.3#05
         SRL       R7,2            AND CONVERT TO WORDS          1.3#05
         ES        R6                                            1.3#05
         DVI       R6,32           CONV TO SIZE OF RELOMAT       1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP RELO MATRIX SIZE    1.3#05
         SLL       R7,2            AND CONVERT TO BYTES          1.3#05
         STW       R7,BSP.CRMB     SAVE AS DSECT MATRIX SIZE     1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768          CONVERT TO SECTORS            1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP SECTOR COUNT        1.3#05
         STW       R7,BSP.CRMS     SAVE IN DSECT MATRIX SECTS    1.3#05
         ADR       R7,R0           AND ACCUMULATE                1.3#05
BSP.8    EQU       $                                             1.3#05
         STW       R0,BSP.SSS      STORE ACCUMULATED TOTAL       1.3#05
*  NOW DO GLOBAL SYMBOLS                                         1.3#05
         TBM       MOPT19,MFLGS                                 S8700640
         BNS       BSP.XIT         SKIP IF NO SYMBOLS           S8700640
         LW        R7,BSP.DGS      GET GLOBAL COUNT              1.3#05
         ADI       R7,1            ACCOUNT FINAL ENTRY          S8700640
         SLL       R7,4            16B PER ENTRY                 1.3#05
         ES        R6                                            1.3#05
         DVI       R6,768          CONVERT TO SECTORS            1.3#05
         TRR       R6,R6           ANY REMAINDER                 1.3#05
         BZ        $+2W            SKIP IF NONE                  1.3#05
         ADI       R7,1            ELSE BUMP SECTOR COUNT        1.3#05
         STW       R7,BSP.DGS      AND UPDATE IN MEMORY          1.3#05
BSP.XIT  EQU       $                                             1.3#05
         LF        R0,BSP.RSAV     RECOVER CALLER CONTEXT        1.3#05
         TRSW      R0              RETURN                        1.3#05
BSP.FLGS DATAH     0               BSEGPRMS FLAGS                1.3#05
BSP.FSTP EQU       0     FIRST PROGRAM ELEMENT                   1.3#05
BSP.LSTP EQU       1     LAST  PROGRAM ELEMENT                   1.3#05
BSP.SCTN EQU       2     SEGMENT SECTIONED                       1.3#05
BSP.ORGC EQU       3     SET ON 1ST ORG'D COMM IN 1ST PROG       1.3#05
*
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
BSP.PROG EQU       $               HERE FOR PROGRAM ENTRY        1.3#05
         BU        BSP.3           AND LOOP                      1.3#05
*                                                                1.3#05
BSP.DEFS EQU       $               HERE TO PROCESS DEF ENTRIES   1.3#05
         TBM       MOPT19,MFLGS    DEBUG SYMBOLS ON ?            1.3#05
         BNS       BSP.3           BACK TO LOOP IF NOT           1.3#05
         ABM       31,BSP.DGS      COUNT NUMBER OF DEFS          1.3#05
         BU        BSP.3           RETURN                        1.3#05
*                                                                1.3#05
BSP.COMM EQU       $               HERE TO PROCESS COMMON ENTRY  1.3#05
         TBM       BSP.FSTP,BSP.FLGS   IS THIS FIRST PROG        1.3#07
         BNS       BSP.3           RETURN TO LOOP IF NOT         1.3#07
         TBM       MOPT9,MFLAG3    OPTION 9 SET (SET NOZERO)    EUIC-32
         BS        BSP.COM1        BRANCH IF SO                 EUIC-32
         LW        R0,AID.NCAT     GET NUMBER OF SEGMENTS       EUIC-32
         CI        R0,1            ARE THERE OVERLAYS           EUIC-32
         BLE       BSP.3           NO...INITIALIZE COMMON       EUIC-32
BSP.COM1 TBM       BSP.ORGC,BSP.FLGS    DID WE FIND AN ORG ONE  EUIC-32
         BS        BSP.3             RETURN TO LOOP IF WE DID    1.3#07
         TBM       6,0,X3          IS BLOCK ORG'D THIS ELEMENT   1.3#07
         BNS       $+3W            CONTINUE IF NOT ORG'D         1.3#19
         SBM       BSP.ORGC,BSP.FLGS    ELSE  SET ORG'D FLAG     1.3#19
         BU        BSP.3           AND CONTINUE ENTRY LOOP       1.3#19
         TBM       7,0,X3          IS THIS ONE ALLOCATED HERE    1.3#19
         BNS       BSP.3           CONTINUE ENTRY LOOP IF NOT    1.3#19
         LMW       R6,0W,X3        ELSE GET SIZE                 1.3#19
         LI        R7,32           SET REQ'D BOUND               1.3#19
         XCR       R6,R2                                         1.3#19
         XCR       R7,R4                                         1.3#19
         BL        MXBOUND         ROUND UP                      1.3#19
         XCR       R6,R2                                         1.3#19
         XCR       R7,R4                                         1.3#19
         ARMW      R6,BSP.BIAS     AND ADD TO MODULE BIAS        1.3#19
         BU        BSP.3           NOW CONTINUE ENTRY LOOP       1.3#19
*                                                                1.3#05
BSP.SECT EQU       $               HERE TO PROCESS SECTION ENT.  1.3#05
         LB        R0,4B,X3        GET SECTION NUMBER            1.3#05
         CI        R0,1            IS IT SECTION 1               1.3#05
         BNE       BSP.3           BACK TO LOOP IF NOT           1.3#05
* ADD UP SECTION 1 STUFF                                         1.3#05
         LMW       R6,1W,X3        GET SECTION ORIGIN            1.3#05
         CAMW      R6,BSP.CORG     TEST TO CURRENT LOW           1.3#05
         BGE       $+2W            SKIP IF GREATER               1.3#05
         STW       R6,BSP.CORG     ELSE UPDATE LOW               1.3#05
         LMW       R7,0W,X3        GET SECTION SIZE              1.3#05
         ARMW      R7,BSP.CSSB     UPDATE CSECT SIZE             1.3#05
         ADR       R7,R6           ADD TO ORIGIN                 1.3#05
         CAMW      R6,BSP.CMAX     TEST TO CURRENT HI            1.3#05
         BLE       $+2W            SKIP IF LOWER                 1.3#05
         STW       R6,BSP.CMAX     ELSE SAVE AS HI               1.3#05
         SBM       BSP.SCTN,BSP.FLGS  INDICATE CSECT  PRESENT    1.3#05
         BU        BSP.3           NOW BACK TO THE LOOP          1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
         TITLE     BGSYMS  - GENERATE DEBUG GLOBAL SYMBOLS
*                                                                1.3#05
*  BGSYMS                                                        1.3#05
*                                                                1.3#05
*    THIS ROUTINE LOOPS THROUGH SYMBOL TABLE ENTRIES STARTING    1.3#05
*    AT MMODW UNTIL NEXT SEGMENT ENTRY AND WRITES ALL THE        1.3#05
*    "DEF" ENTRIES TO THE TEMP LOAD MODULE FILE STARTING AT      1.3#05
*    PR.GSYMS.                                                   1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*                                                                1.3#05
BGSYMS   EQU       $                                             1.3#05
         TBM       BFSEG,BFLGS     IS THIS THE ROOT              1.3#05
         BS        $+2W            SKIP IF SET                   1.3#05
         TRSW      R0              ELSE RETURN                   1.3#05
         NOP                                                     1.3#05
         TBM       MOPT19,MFLGS    ARE SYMBOLS ON                1.3#05
         BS        $+2W            ENTER CODE IF SET             1.3#05
         TRSW      R0              ELSE RETURN                   1.3#05
         NOP                                                     1.3#05
*                                                                1.3#05
         STF       R0,BGS.RET                                    1.3#05
         LW        R1,BPREAMB+PR.SYMG  GET PLACE TO WRITE SYMS   1.3#05
         STW       R1,XDS.SCNT         AND UPDATE SYMBOL WRITER  1.3#05
         LW        R5,MMODW        GET ADDR OF CURRENT SEGMENT   1.3#05
         LW        R4,=X'C0000000' MASK FOR SEG + DEF ENTRIES    1.3#05
         ZR        R2              INIT SYMBOL COUNTER           1.3#05
BGS.1    EQU       $               LOOP TOP                      1.3#05
         ZR        R6                                            1.3#05
         ZR        R7              ANY VALUE WILL DO THANKYOU    1.3#05
         SUI       R5,4W           BACK IT DOWN TO NEXT ENTRY    1.3#05
         BL        MSSCH                                         1.3#05
         TRR       R5,R3           ANYTHING OUT THERE            1.3#05
         BZ        BGS.XIT         QUIT IF NOT                   1.3#05
         TBM       0,0,X3          IS THIS A SEGMENT ENTRY       1.3#05
         BS        BGS.XIT         QUIT IF IT IS                 1.3#05
*                                                                1.3#05
*    LOG THIS DEF SYMBOL                                         1.3#05
*                                                                1.3#05
         ABR       R2,31           BUMP COUNTER                  1.3#05
         LD        R0,2W,X3        LOAD DEF NAME                 1.3#05
         STD       R0,XSYMBUF      STORE IN BUFFER               1.3#05
         LW        R1,1W,X3        GET ADDRESS OF GLOBAL SYMBOL  1.3#05
         SLL       R1,12           STRIP OFF UPPER 12 BITS       1.3#05
         SRL       R1,12           ONLY 19-BIT ADDRESS DESIRED   1.3#05
         TBM       M2.5MB,MFLAG2   GENERATING 2.5MB TASK?       PR12226
         BNS       BGS.6           NO...BRANCH                  PR12226
         TBM       7,1W,X3         IS GLOBAL IN CSECT?          PR12226
         BNS       BGS.6           BRANCH IF NOT                PR12226
         LW        R6,DEBIAS       GET CSECT ORIGIN ADDRESS     PR12226
         ADR       R6,R1           ADD TO SYMBOL ADDRESS        PR12226
         BU        BGS.2           CONTINUE                     PR12226
BGS.6    TBM       MABS,MFLGS      IS MODULE ABSOLUTE            1.3#05
         BNS       BGS.2           BR IF NOT ABSOLUTE            1.3#05
         TBM       7,1W,X3         IS GLOBAL IN CSECT ?          1.3#05
         BS        BGS.2           BR IF CSECT                   1.3#05
         ADMW      R1,MPABS        ADD ABSOLUTE BASE             1.3#05
BGS.2    STW       R1,XSYMBUF+2W   STORE ADDRESS                 1.3#05
         LI        R1,4            LOAD ITEM LENGTH              1.3#05
         SLL       R1,16           PUT IN LEFT HALFWORD          1.3#05
         TBM       3,XSYMFLGS      IS THIS AN ABSOLUTE MODULE    1.3#05
         BS        BGS.3           BRANCH IF ABSOLUTE.           1.3#05
         TBM       7,1W,X3         IS GLOBAL IN CSECT            1.3#05
         BNS       BGS.4           BRANCH IF NOT                 1.3#05
BGS.3    SBR       R1,31           SET ABSOLUTE BIT              1.3#05
BGS.4    STW       R1,XSYMBUF+3W   STORE LAST WORD OF ENTRY      1.3#05
         BL        XDBGSYM         AND ADD TO FILE               1.3#05
         BU        BGS.1           LOOP FOR NEXT                 1.3#05
BGS.XIT  EQU       $                                             1.3#05
*!!!!!!!!TRR!!!!!!!R2,R2!!!!!!!!!!!ANY!SYMBOLS!DONE!!!!!!!!!!!!!S8700640
*!!!!!!!!BZ!!!!!!!!BGS.5!!!!!!!!!!!SKIP!IF!NONE!!!!!!!!!!!!!!!!!S8700640
         ZMD       XSYMBUF         ZAP FIRST HALF                1.3#05
         ZMD       XSYMBUF+1D      AND SECOND HALF               1.3#05
         SBM       13,XSYMBUF+3W   SHOW LENGTH 4                 1.3#05
         BL        XDBGSYM         ADD NULL LAST ENTRY           1.3#05
         BL        XDBGBND         ELSE BOUND THE GLOBAL SECTION 1.3#05
BGS.5    EQU       $                                             1.3#05
         LF        R0,BGS.RET                                    1.3#05
         TRSW      R0                                            1.3#05
         BOUND     1F                                            1.3#05
BGS.RET  RES       1F                                            1.3#05
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
LMERR4   M.BORT    =C'CT10'        CANNOT USE RECATALOG ON OLD
LMERR5   M.BORT    =C'CT11'        ONLY 76 OVERLAYS ARE ALLOWE
         TITLE     LMTAB    - UPDATE OVERLAY TABLE IN LOAD MODULE
LMTAB    STF       R0,MOBSCREG
*
*
*    IN   R1 = POINTER TO SEGMENT ENTRY                          1.3#05
*
* THE BLOCK NUMBER FOR THE NEW MODULE IS IN LMBASE.
* IF THE CURRENT MODULE IS THE ROOT THEN SAVE LMBASE
* IN LMSAVE AND RESET LMBASE TO ZERO,BECAUSE THE ROOT
* MUST GO AT THE FRONT OF THE FILE.
*
* ALWAYS ADD THE NEW MODULE NAME TO THE INDEX IF THE NOP
* OPTION IS OFF.
*
         LW        R7,1W,R1
         BNE       LMTAB0
         ZMW       LMBASE
         ABM       31,LMINDEX      ALWAYS A ROOT ENTRY
         LD        R6,2W,R1        NAME
         STD       R6,LMDWTROT     INTO FIRST ENTRY IN INDEX
         BU        LMTAB1
*
* AN OVERLAY MODULE SO COPY THE NAME AND START BLOCK TO THE TABLE
* BUFFER. IF IT IS FULL, SCREECH TO A HALT FOR NOW.
*
* ONLY ADD AN OVERLAY ENTRY TO THE INDEX IF THE NOP OPTION
* IS OFF.
LMTAB0   TBM       12,0W,R1
         BS        LMTAB1
         LW        R7,LMINDEX      GET CURR. NO. OF ENTRIES IN TBL.22004
         CI        R7,76           COMPARE WITH ENTRY LIMIT        22004
*                                  1 FOR ROOT AND 75 OVERLAYS      22004
         BGE       LMERR5          BR IF ATTEMPTING > 75 O'LAYS    22004
*
* THERE IS ROOM IN THE TABLE
*
LMTAB2   ABM       31,LMINDEX      BUMP COUNT
         LD        R6,2W,R1        NAME
         STD       R6,*LMDWT       ADD TO TABLE
         LW        R7,LMDWT
         SUI       R7,1D
         STW       R7,LMDWT        UPDATE TABLE POINTER
         LW        R7,LMBASE       START BLOCK FOR THIS FILE
         STH       R7,*LMHWT
         LW        R7,LMHWT
         SUI       R7,1H
         STW       R7,LMHWT        UPDATE TABLE POINTER
*
* AND EXIT
*
LMTAB1   LF       R0,MOBSCREG
         TRSW      R0
*
* DECLARE THE DATA
*
         BOUND     1D
LMRRS    DATAW     G'OLD'          RRS TO ALLOCATE RENAMED LM FILE
         DATAB     RR.RID,RR.6.SIZ,0,0
         DATAW     X'80000000'     READ MODE IMPLICIT SHARE      1.3#05
         DATAW     X'04000000'     EXPLICIT UNBLOCKED            1.3#05
LMRID    REZ       4D
*
LMCNP    DATAW     0
         DATAW     0
         DATAH     0
LMSTAT   DATAH     0
         DATAW     0
         DATAW     0
         DATAW     0
         BOUND     1D
LMINDEX  REZ       192W            TABLE BUFFER
LMOLDIND EQU       BPREAMB         OLD INDEX                     1.3#05
LMRECATB RES       92D             NAMES OF RECATALOG MODULES    1.3#05
LMENT    DATAW     0               TOTAL MODULES
LMTABB   DATAW     0               START BLOCK FOR INDEX TABLE
LMBASE   DATAW     0               BASE FOR CURRENT MODULE IN FILE
LMFSIZE  DATAW     0               RUNNING FILE SIZE BY SEGMENT  1.3#05
*
* DATA USED FOR RECATALOGING
*
LMFCBIN  DATAW     G'OLD'          OLD LOAD MODULE FCB
         DATAW     0
         DATAW     X'02000000'     EXPANDED FCB
         DATAW     0,0,0,0,0
         DATAW     LMOLDIND
         DATAW     768B
         DATAW     0,0,0,0,0,0
*
LMREGS   RES       1F              SAVE OF REGISTERS
LMDWT1   EQU       LMOLDIND+76D    DWT ADDRESS IN OLD INDEX      1.3#05
LMHWT1   EQU       LMOLDIND+383H   HWT ADDRESS IN OLD INDEX      1.3#05
LMRECATP ACD       LMRECATB        POINTER INTO NAME BUFFER
LMDINIT  EQU       LMINDEX+75D     DOUBLE WORD NAME TABLE
LMHINIT  EQU       LMINDEX+382H    HALF WORD BLOCK TABLE
LMDWT    ACD       LMDINIT
LMHWT    ACH       LMHINIT
LMDWTROT EQU       LMINDEX+76D     ROOT POSITION IS FIRST
         BOUND     1D                                            1.3#05
LMCPYMOD RES       76D             HOLDS LIST OF MODULES TO COPY 1.3#05
LMCPYSTR RES       76H             HOLDS THEIR STARTING SECTOR   1.3#05
LMCPYSIZ RES       76H             HOLDS THEIR SIZE              1.3#05
LMCOPY   DATAW     0               HOLDS NUMBER OF MODS TO COPY  1.3#05
*                                                                1.3#05
         BOUND     1W
         TITLE     LMCLOSE  - CLOSE LOAD MODULE FILE
LMCLOSE  STF       R0,MOBSCREG
*
* OUTPUT THE INDEX BLOCK TO FILE.
* THE BLOCK NUMBER TO WRITE TO IS IN LMTABB AND THE BUFFER
* TO WRITE IS LMINDEX.
*
* THEN CALL XCLOS TO MAKE THE TEMPORARY FILE PERMANENT
*
         ZBM       4,MOPTS         FORCE FLAG FOR RITE/XCLOS
         LW        R7,LMTABB
         STW       R7,LMINDEX+1W   SAVE IN THE BUFFER
         LI        R2,768          GET SIZE OF INDEX BLOCK       1.3#05
         LA        R3,LMINDEX      GET BUFFER ADDR               1.3#05
         LW        R4,LMTABB       GET SECTOR NUMBER             1.3#05
         ZMW       LMBASE          LMTABB VALUE IS ABSOLUTE      1.3#05
         ZR        R1              USE XWRTMOD ERROR HANDLING    1.3#05
         BL        XWRTMOD         AND WRITE IT                  1.3#05
         TBM       MOPT4,MFLAG2    SAVE DIRECTIVES?             ETCM-32
         BS        LMCLS.C         DON'T WRITE DIRECTIVES IN LM ETCM-32
         M.RWND    XDIRTMP         REWIND TEMP DIRECTIVES FILE  ETCM-32
         LW        R3,TDADDR       GET DIRECTIVE BUFFER ADDR    ETCM-32
         STW       R3,XDIRTMP+8W   SAVE IN FCB                  ETCM-32
         LI        R2,768          TRANSFER 1 SECTOR            ETCM-32
         STW       R2,XDIRTMP+9W   SAVE IN FCB                  ETCM-32
         LW        R5,DIRSECTS     NUMBER OF DIRECTIVE SECTORS  ETCM-32
LMCLS.A  CI        R5,0            DONE WRITING DIRECTIVES?     ETCM-32
         BEQ       LMCLS.C         CLOSE LM FILE IF SO          ETCM-32
         M.READ    XDIRTMP         READ A SECTOR OF DIRECTIVES  ETCM-32
         ADI       R4,1                                         ETCM-32
         BL        XWRTMOD         WRITE IT IN LOAD MODULE      ETCM-32
         SUI       R5,1            ONE SECTOR PROCESSED         ETCM-32
         BU        LMCLS.A         NEXT SECTOR                  ETCM-32
*                                                                  20008
*
LMCLS.C  BL        XCLOS           CLOSE THE FILE
LMCLOSE1 LF        R0,MOBSCREG
         TRSW      R0
         NOP                                                     1.3#05
*                                                                1.3#05
LMCLS.B  EQU       $                                             1.3#05
         LNB       R5,LMCLS.ML                                   1.3#05
         LA        R6,LMCLS.MS                                   1.3#05
         BL        XTYPEF                                        1.3#05
         BL        XABORT                                        1.3#05
LMCLS.MS DATAB     C' CATALOG<<FATAL>> NO ROOT MODULE CATALOGED' 1.3#05
LMCLS.ML DATAB     $-LMCLS.MS                                    1.3#05
         BOUND     1W
*                                                                1.3#05
*----------------------------------------------------------------1.3#05
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         TITLE     LMRECAT  - ADD NEW OVERLAY TO OLD LOAD MODULE
* THIS ROUTINE IS CALLED WHEN ALL SYMTAB ENTRIES FOR MODULES
* BEING RECATALOGED HAVE BEEN PROCESSED.
* THE FOLLOWING VARIABLES HAVE BEEN SET UP:-
*
* LMFSIZE - BLOCKS REQUIRED FOR MODULES BEING RECATALOGED.
*
* LMMODW - ZERO IF THE ROOT IS NOT BEING RECATALOGED, ELSE THE
*          SYMTAB ADDRESS OF THE ROOT ENTRY.
*          ALSO ZERO IT IF THE NOP OPTION IS ON THE ROOT.
*
* LMBASE - SIZE OF ROOT IF IT IS BEING RECATALOGED.
*
* LMRECATB - 192W BUFFER CONTAINING THE 8 CHARACTER NAMES OF THE
*            MODULES BEING RECATALOGED. NOTE A IMPLICIT MAXIMUM
*            OF 96 ENTRIES.
*
* LMENT - NUMBER OF MODULES BEING RECATALOGED.
*
* THE SEQUENCE OF EVENTS IS APPROXIMATELY AS FOLLOWS:-
*
* (1)  LOCATE OLD LOAD MODULE FILE TO GET THE RD
* (2)  OPEN THE OLD FILE FOR EXCLUSIVE READ
* (3)  READ THE PREAMBLE AND ENSURE THE LOAD MODULE IS A NEW
*      FORMAT LOAD MODULE (PR.INDEX > 0)
* (4)  EVALUATE THE FILE SIZE FOR THE NEW LOAD MODULE TO BE CREATED
*      (OLD MODULES + RECATALOG MODULES + INDEX BLOCK)
* (5)  CALL XCREATE TO CREATE THE NEW LOAD MODULE, A TEMPORARY FILE
* (6)  ELIMINATE MODULES BEING RECATALOGED FROM THE INDEX
* (7)  COPY MODULES NOT BEING RECATALOGED FROM THE OLD LOAD MODULE
*      FILE TO THE NEW LOAD MODULE FILE
* (8)  RECREATE THE NEW LOAD MODULE INDEX AS WE GO
* (9)  ENTER THE MAIN CATALOGING PROCESS TO ADD THE NEW (OR
*      RECATALOGED) MODULES AS IN THE NORMAL CATALOG CASE
*
LMRECAT  EQU       $
         STF       R0,LMREGS
*
* COPY THE RID FROM THE RD TO THE RRS READY FOR THE ALLOCATE AND
* OPEN BY RID
*
LMRECA11 LI        R7,-4           FOUR DOUBLE WORDS TO COPY
         LI        R1,RD.IDNAM     START OF RID IN RD
         ZR        R2              START OF RID IN RRS
         LI        R5,1            SET NOT FOUND STATUS          1.3#13
         LW        R4,XRD+RD.IDNAM  GET FIRST WORD               1.3#13
         BZ        LMRECA13         BR IF NOT FOUND              1.3#13
LMRECA12 LD        R4,XRD,R1
         STD       R4,LMRID,R2
         ABR       R1,28           NEXT ENTRY
         ABR       R2,28           NEXT ENTRY
         BIB       R7,LMRECA12     AND LOOP
*
* ALLOCATE AND OPEN THE OLD LOAD MODULE FOR EXCLUSIVE READ.
*
LMRETRY  EQU       $                                            EAID-32
         M.ASSN    LMRRS           ASSIGN OLD LOAD MODULE FILE   1.3#05
         BNS       LMRECAT2        BRANCH IF SUCCESSFUL
         ABM       31,TRYCOUNT                                  EAID-32
         LW        R1,TRYCOUNT                                  EAID-32
         BNZ       LMRETRY                                      EAID-32
         TRR       R7,R5                                         1.3#05
LMRECA13 M.CONBAD                  CONVERT STATUS TO DECIMAL     1.3#05
         ANMW      R7,=X'0000FFFF' KEEP BOTTOM TWO DIGITS        1.3#05
         ORMW      R7,XMDID.RM     INDICATE H.REMM ERROR         1.3#05
         STW       R7,LMR.MD1      STORE IN MESSAGE              1.3#05
         LA        R6,LMR.MSG                                    1.3#05
         LNB       R5,LMR.ML       SET FOR UT AND SLO            1.3#05
         BL        XTYPEF          LOG ERROR                     1.3#05
         BL        XABORT                                        1.3#05
*                                                                1.3#05
LMR.MSG  DATAB     C' CATALOG<<FATAL>>  ERROR TYPE:  '           1.3#05
LMR.MD1  REZ       4B              HOLDS XXNN STATUS             1.3#05&
         DATAB     C'   ALLOCATING ORIGINAL LOAD MODULE FILE.'   1.3#05
LMR.ML   DATAB     $-LMR.MSG                                     1.3#05
         BOUND     1W
*
* MAKE SURE THE LOAD MODULE IS IN NEW FORMAT ELSE WE CANNOT
* RECATALOG.
* TO DO THIS READ THE PREAMBLE AND MAKE SURE PR.INDEX IS > 0
*
LMRECAT2 EQU       $
         LA        R1,LMFCBIN                                    1.3#05
         LA        R7,LMCNP                                      1.3#05
         ZR        R3                                            1.3#05
         BL        XOPENR                                        1.3#05
         M.READ    LMFCBIN         READ FIRST BLOCK (PREAMBLE)
         LW        R7,LMOLDIND+PR.INDEX
         BZ        LMERR4          BRANCH IF OLD FORMAT
*
*
* IN ORDER TO ASCERTAIN THE NUMBER OF BLOCKS IN THE ORIGINAL
* LOAD MODULE THAT MUST BE RETAINED WE SCAN THE INDEX BLOCK
* ELIMINATING THE NAME ENTRIES OF THE MODULES THAT ARE TO
* BE RECATALOGED. THESE EXIST IN THE BUFFER LMRECATB, THE
* NUMBER OF ENTRIES BENG IN LMENT.
* READ THE INDEX BLOCK INTO LMOLDIND (REMEMBER TO ACCESS THE
* OLD LOAD MODULE FILE RANDOMLY NOW).
*
         SBM       4,LMFCBIN+2W    RANDOM ACCESS
         STW       R7,LMFCBIN+10W  INTO FCB
         M.READ    LMFCBIN         AND READ IT
*
* THE INDEX IS NOW IN LMOLDIND, SO GO PLAY WITH IT.
*
* EXECUTE A LOOP LOOKING FOR MODULES THAT NEED TO BE RECATALOGED
* AND DELETE THE NAME ENTRY FROM THE CURRENT INDEX (LMOLDIND).
* LEAVE THE MODULE START BLOCK ENTRY OF THESE DELETED MODULES
* SO THAT THE SIZES OF THE MODULES REMAINING CAN BE EVALUATED
* BY SUBTRACTION OF START BLOCK NUMBERS.
* ALSO WRITE THE BLOCK NUMBER OF THE INDEX BLOCK INTO THE NEXT
* ENTRY IN THE BLOCK START HALFWORD TABLE SO THAT THE SIZE OF THE
* FINAL MODULE CAN BE EVALUATED IN THE SAME WAY AS MENTIONED
* ABOVE.
* ACCESS IS MADE TO THE DOUBLE WORD NAME TABLE AND THE HALF WORD
* BLOCK START TABLE IN THE SAME WAY AS OUR MODIFIED M:LOAD.
*
LMRECAT3 EQU       $
         LW        R2,LMENT        TOTAL MODULES TO BE RECATALOGED
         SUI       R2,1            0 TO N-1
         SLA       R2,3            BYTE STEPPING OF DOUBLE WORDS
*
LMRECAT4 EQU       $
         LNW       R3,LMOLDIND     TOTAL ENTRIES IN CURRENT INDEX
         SLA       R3,3            BYTE INDEXING AGAIN
         LD        R6,LMRECATB,R2  NEXT RECATALOG ENTRY
*
LMRECAT5 EQU       $
         CAMD      R6,LMDWT1+1D,X3 CHECK AGAINST NEXT CURR ENTRY 1.3#05
         BNE       LMRECAT6        NOT THE SAME
         ZMD       LMDWT1+1D,X3    ZAP THE NAME ENTRY            1.3#05
         BU        LMRECAT7        NEXT
*
LMRECAT6 BID       R3,LMRECAT5     CHECK AGAINST NEXT ENTRY
*
* WE GET HERE EITHER WHEN AN ENTRY WAS FOUND, AND ZAPPED,
* OR IF THE MODULE IS A NEW ONE ALTOGETHER AND DID NOT EXIST
* IN THE ORIGINAL LOAD MODULE FILE.
* IN EITHER CASE MOVETO THE NEXT ENTRY IF ANY IN LMRECATB
*
LMRECAT7 EQU       $
         SUI       R2,1D
         BGE       LMRECAT4
*
* GET HERE WHEN ALL INDEX MANIPULATION HAS BEEN DONE, AND
* ALL OF THE MODULES TO BE RECATALOGED HAVE BEEN ELIMINATED
* FROM THE ORIGINAL INDEX.
* THE ORIGINAL INDEX CAN NOW BE SCANNED AND THE SIZES OF THE
* REMAINING BLOCKS EVALUATED BY SUBTRACTING THE START BLOCK
* NUMBER OF THE CURRENT BLOCK FROM THE START BLOCK NUMBER OF
* THE NEXT BLOCK.
* FIRSTLY WRITE THE INDEX BLOCK NUMBER INTO THE NEXT FREE
* ENTRY IN THE START BLOCK TABLE, FOR COMMON PROCESSING.
*
         LW        R2,LMOLDIND+1W  GET BLOCK NUMBER OF INDEX
         LNW       R3,LMOLDIND     TOTAL ENTRIES
         SLA       R3,1            HALF WORD INDEX
         STH       R2,LMHWT1,X3                                  1.3#05
*
*
         LNW       R0,LMOLDIND     NEGATIVE NUMBER OF ENTRIES    1.3#05
         ZR        R2              INIT DOUBLE WORD INDEX        1.3#05
         ZR        R3              INIT HALF WORD INDEX          1.3#05
         ZR        R1              INIT R1 TO INDEX COPY TABLES  1.3#05
LMRECAT9 LD        R6,LMDWT1,R2    NAME ENTRY
         BEQ       LMRECAT8        IGNORE IF ZAPPED
*
* CALCULATE THE SIZE.
*
         LH        R5,LMHWT1-1H,R3 NEXT BLOCK START
         SUMH      R5,LMHWT1,R3    THIS ENTRY START BLOCK
         LH        R4,LMHWT1,X3    GET THIS ENTRY START BLOCK    1.3#05
         STD       R6,LMCPYMOD,X1  SAVE NAME                     1.3#05
         SRL       R1,2            CONVERT TO HALFWORD INDEX     1.3#05
         STH       R4,LMCPYSTR,X1  SAVE START ADDR               1.3#05
         STH       R5,LMCPYSIZ,X1  AND COPY SIZE                 1.3#05
         SLL       R1,2            BACK TO DOUBLE WORD INDEX     1.3#05
         ABR       R1,28           BUMP BY DOUBLE WORD           1.3#05
         ARMW      R5,LMFSIZE      ADD INTO TOTAL FILE SIZE
*
LMRECAT8 SUI       R3,1H           NEXT HALF WORD ENTRY          1.3#05
         SUI       R2,1D           NEXT DW ENTRY                 1.3#05
         BIB       R0,LMRECAT9     LOOP IF MORE ENTRIES          1.3#05
         SRL       R1,3            CONVERT TO COUNT              1.3#05
         STW       R1,LMCOPY       AND SET COPY COUNT            1.3#05
         STW       R1,BNSEG        INDICATE NUMBER OF SEGMENTS   1.3#05
*
* THE TOTAL FILE SIZE REQUIREMENTS OF ALL MODULES TO BE COPIED   1.3#05
* IS NOW IN LMFSIZE. THE COPY TABLE CONTAINS THE DOPE ON EACH.   1.3#05
*
* (C) COPYRIGHT 1983 ENCORE COMPUTER CORPORATION
*     ALL RIGHTS RESERVED
*
         LF        R0,LMREGS
         TRSW      R0
         BOUND     1D
*
         TITLE     AIDMOD
*
SELF     REZ       1D                                           EAID-32
ONEUNIT  DATAW     -1              1 TIMER UNIT                 EAID-32
TRYCOUNT DATAW     -5             TRY TO M.ASSN LM FILE 5 TIMES EAID-32
         PAGE                                                   EAID-32
AID.REGS RES       1F                                           EAID-32
AID.SV   RES       1F                                           EAID-32
AID.BLEN EQU       -768                                         EAID-32
AID.SSCT DATAW     0               SOURCE Sector FOR 'S.' SYMS  EAID-32
AID.OFST DATAW     0               CURR OFFSET INTO SOURCE BUFF EAID-32
AID.FLGS DATAW     0               FLAGS                        EAID-32
IW.FIRST EQU       0               First time thru?             EAID-32
IW.CARET EQU       1               Are we processing a caret?   EAID-32
IW.FLUSH EQU       3               Need to flush an entry       EAID-32
AID.SBEG DATAW     0               SECTOR # FOR SOURCE IN LM    EAID-32
AID.SLEN DATAW     0               NUMBER OF SOURCE CHARS IN LM EAID-32
AID.NCAT DATAW     0               NUMBER OF CATALOG DIRECTIVES EAID-32
AID.OCAT DATAW     0             BIT 30 SET IF SEP CATLD OLAYS  EAID-32
AID.BPOS DATAW     -768            NEG BYTE LENGTH OF BUFFER    EAID-32
AID.SSB  DATAW     0               THE CURR SOURCE SECTOR BASE  EAID-32
CRT.SO   DATAW     0               The caret structure.  Do NOT EAID-32
*                                  separate these six bytes.    EAID-32
CRT.CRT  EQU       CRT.SO          The caret                    EAID-32
CRT.BO   DATAH     0               The byte offset              EAID-32
AID.BOFS DATAH     0               Source byte offset           EAID-32
AID.LTYP DATAB     0               Last source type sent        EAID-32
AID.RECR RES       1W              Return word                  EAID-32
AID_SREC EQU       $                                            EAID-32
         STW       R0,AID.RECR      SAVE RETURN ADDRESS         EAID-32
         ZR        R6                                           EAID-32
         STF       R0,AID.SV        SAVE REGISTERS              EAID-32
         LB        R7,1B,X1         GET OBJECT SUBTYPE          EAID-32
         CI        R7,X'0E'         NEW TYPE?                   EAID-32
         BEQ       AID.O0E                                      EAID-32
         LB        R4,8B,X1        AID SUB TYPE, OBJ TYPE D00B  EAID-32
         LB        R5,9B,X1         CARET  VALUE                EAID-32
         LI        R7,18            LENGTH OF OLD TYPE          EAID-32
         BU        AID.OMG                                      EAID-32
AID.O0E  LB        R4,20B,X1        AID SUB TYPE, OBJ TYPE D00E EAID-32
         LB        R5,21B,X1        CARET  VALUE                EAID-32
         LI        R7,22            LENGTH OF THIS ENTRY        EAID-32
AID.OMG  TRR       R4,R4                                        EAID-32
         BZ        AID.NSRC        BRANCH IF SOURCE NOT PRESENT EAID-32
         SLL       R4,5             POSITION TO BITS 24-26      EAID-32
         ORMW      R4,AID.SV+4W     Get original type in        EAID-32
         STW       R4,AID.SV+4W     Return value                EAID-32
         LNB       R4,2B,X1         DATA BLOCK LENGTH           EAID-32
         ADR       R7,R4            SOURCE PRESENT?             EAID-32
         BLT       AID.DSRC         BRANCH IF SOURCE PRESENT    EAID-32
*  When here, we want source, but we are passed just the caret  EAID-32
*  pointer.  We have already seen the source, and it is pointed EAID-32
*  to by the six bytes at CRT.CRT. We send these 6 bytes out as EAID-32
*  our source; they point to the real source.                   EAID-32
         SBM       IW.CARET,AID.FLGS  Show we had a caret       EAID-32
         STB       R5,CRT.CRT      Store the caret value        EAID-32
         SBM       8,CRT.SO        Tell the debugger we have an EAID-32
*                                  indirect source pointer      EAID-32
         LI        R4,-6B          The length of this "source"  EAID-32
         ZR        R7              Point to source              EAID-32
         LA        R1,CRT.CRT      Ditto                        EAID-32
AID.DSRC ADR       R7,R1            POINT TO SOURCE             EAID-32
*                                                               EAID-32
*  HERE MOVE SOURCE TO OUTPUT BUFFER                            EAID-32
*                                                               EAID-32
         LW        R5,AID.BPOS      BUFFER LENGTH               EAID-32
         LW        R2,AID.OFST      FETCH OFFSET                EAID-32
AID.NB   LB        R3,,X1           FETCH A BYTE OF SOURCE      EAID-32
         STB       R3,AID.BUF,X2    STUFF IN OUTPUT BUFFER      EAID-32
         BIB       R5,AID.NFL       BRANCH IF BUFFER NOT FULL   EAID-32
*                                                               EAID-32
*  HERE BUFFER FULL; FLUSH BUFFER, RESET COUNTERS AND CONTINUE. EAID-32
*                                                               EAID-32
         BL        AID.FLSH         FLUSH BUFFER                EAID-32
         NOP                        TO WORK AROUND 87 CACHE BUG EAID-32
         NOP                        DITTO                       EAID-32
         NOP                        TO WORK AROUND 87 CACHE BUG EAID-32
         NOP                        DITTO                       EAID-32
         LI        R5,AID.BLEN                                  EAID-32
         LI        R2,-1                                        EAID-32
*                                                               EAID-32
*  BUMP ADDRESSES AND GO MOVE NEXT BYTE                         EAID-32
*                                                               EAID-32
AID.NFL  ADI       R1,1B                                        EAID-32
         ADI       R2,1B                                        EAID-32
         BIB       R4,AID.NB                                    EAID-32
         STW       R2,AID.OFST      SAVE CURRENT OFFSET         EAID-32
         STW       R5,AID.BPOS                                  EAID-32
*                                                               EAID-32
*  COMPUTE NEW ADDRESS FOR NEXT SOURCE STATEMENT                EAID-32
*                                                               EAID-32
         LH        R6,AID.BOFS     OFFSET                       EAID-32
         ABR       R6,31           COUNT BY 1                   EAID-32
*  Now save this pointer, if we're not handling a caret         EAID-32
         TBM       IW.CARET,AID.FLGS Is this a caret record?    EAID-32
         BS        $+2W            Go if so                     EAID-32
         STH       R6,CRT.BO       Else save the offset         EAID-32
         SLL       R6,11           Byte OFFSET IN BITS 11-20    EAID-32
         LNW       R5,AID.SSB      Get current SourceSectorBase EAID-32
         ADMW      R5,AID.SSCT     Add in sector addr. The net  EAID-32
*  effect of these three instructions is to subtract the base   EAID-32
*  (AID.SSB) from the sector address, resulting in the Source-  EAID-32
*  SectorOffset (SSO), which is stored in the symbol entry.     EAID-32
         TBM       IW.CARET,AID.FLGS Is this caret processing?  EAID-32
         BS        $+2W            Go if so                     EAID-32
         STW       R5,CRT.SO       Else save SSO                EAID-32
         SLL       R5,21           Position appropriately (0-10)EAID-32
         ORR       R5,R6           MERGE WITH OFFSET            EAID-32
         STW       R6,AID.SV+6W    RETURN R6 TO CALLER          EAID-32
         ZBM       IW.CARET,AID.FLGS Caret processing?          EAID-32
         BNS       AID.S1           Go if not                   EAID-32
         LB        R4,AID.LTYP      Else use last type passed inEAID-32
         STB       R4,AID.SV+4W+3B                              EAID-32
         BU        AID.S2                                       EAID-32
*------------------------------------------------------------   EAID-32
AID.S1   EQU       $                                            EAID-32
         LW        R4,AID.SV+4W    ADD SYM TYPE TO HIGH 3 BITS  EAID-32
         LW        R1,AID.SV+1W     RESTORE CALLERS R1          EAID-32
         LB        R7,1B,X1         GET SYBTYPE                 EAID-32
         CI        R7,X'0E'         NEW SOURCE FORMAT?          EAID-32
         BEQ       $+3W                                         EAID-32
         LB        R7,8B,X1         NO, GET AID SUBTYPE         EAID-32
         BU        $+2W                                         EAID-32
         LB        R7,20B,X1        YES, GET AID SUBTYPE        EAID-32
         TBR       R7,24            IS SOURCE UNCOMPRESSED?     EAID-32
         BNS       $+3W             NO                         EAID-32
         SBR       R4,27            TELL DEBUG SOURCE IS UNCOMP EAID-32
         SBR       R4,31            TELL DEBUG SOURCE IS UNCOMP EAID-32
         STW       R4,AID.SV+4W     RETURN TO USER              EAID-32
         STB       R4,AID.LTYP      For caret processing        EAID-32
AID.S2   EQU       $                                            EAID-32
         LW        R6,AID.FCB+10W   CURRENT SECTOR ADDRESS      EAID-32
         STW       R6,AID.SSCT      Save                        EAID-32
         LW        R6,AID.OFST                                  EAID-32
         STH       R6,AID.BOFS      STORE AS CURRENT Offset     EAID-32
*                                                               EAID-32
AID.NSRC LF        R0,AID.SV                                    EAID-32
         BU        *AID.RECR                                    EAID-32
*                                                               EAID-32
*  ROUTINE TO FLUSH SOURCE OUTPUT BUFFER TO DISC                EAID-32
*                                                               EAID-32
         RES       1W                                           EAID-32
AID.FLSH EQU       $                                            EAID-32
         STW       R0,$-1W          SAVE RETURN                 EAID-32
         STF       R0,AID.REGS     SAVE REGISTERS               EAID-32
         SBM       IW.FIRST,AID.FLGS       1ST TIME THRU?       EAID-32
         BS        AID.OPEN         BRANCH IF NOT               EAID-32
*                                                               EAID-32
*  HERE WE MUST OPEN LFC 'AID'                                  EAID-32
*                                                               EAID-32
         M.LOC     AID.FCB         NEED TO MODIFY EXTENSIONS    EAID-32
         M.MOD     RID.VECT,AID.RD                              EAID-32
         LA        R1,AID.RD           ADDRESS OF READ RD       EAID-32
         LI        R7,256              MIN INCREMENT = 256      EAID-32
         STW       R7,66W,X1           PUT IN RD                EAID-32
         SLL       R7,2                MAX INCREMENT = 1024     EAID-32
         STW       R7,65W,X1           PUT IN RD                EAID-32
         SLL       R7,7                Max size = 128k          EAID-32
         STW       R7,67W,X1           PUT IN RD                EAID-32
         M.REWRIT  RDADDR              UPDATE RD ON DISK        EAID-32
         LA        R1,AID.FCB                                   EAID-32
         SBR       R1,1             R/W ACCESS                  EAID-32
         SVC       1,X'30'                                      EAID-32
*                                                               EAID-32
*  WRITE BUFFER AND BUMP RANDOM ACCESS ADDRESS                  EAID-32
*                                                               EAID-32
AID.OPEN EQU       $                                            EAID-32
         LA        R1,AID.FCB                                   EAID-32
         SVC       1,X'32'                                      EAID-32
         ABM       31,AID.FCB+10W                               EAID-32
*                                                               EAID-32
         LF        R0,AID.REGS     RESTORE REGISTERS            EAID-32
         BU        *AID.FLSH-1W                                 EAID-32
*                                                               EAID-32
AID.BUF  RES       192W                                         EAID-32
AID.RD   RES       192W                                         EAID-32
RID.VECT GEN       8/32,24/W(AID.RD)                            EAID-32
AID.FCB  DATAB     0                                            EAID-32
         DATAB     C'AID'                                       EAID-32
         REZ       1W                                           EAID-32
         DATAW     X'0A000000'                                  EAID-32
         REZ       5W                                           EAID-32
         ACW       AID.BUF                                      EAID-32
         DATAW     768                                          EAID-32
         REZ       6W                                           EAID-32
         BOUND     1D              BOUND UP TO A DOUBLEWORD     EAID-32
         SPACE 3
************************************************************************
*                                                               ENCD-32
*        OBJECT TEMP FILE BLOCKING BUFFER ROUTINES              ENCD-32
*                                                               ENCD-32
************************************************************************
*                                                               ENCD-32
*                                                               ENCD-32
*------------------- 32 WORD EXPANDED FCB                       ENCD-32
*                                                               ENCD-32
*           FIRST 16W SYSTEM STANDARD FCB                       ENCD-32
*            NEXT 16W CONTROL AREA FOR BIG BLOCKS               ENCD-32
*                                                               ENCD-32
FCB.OPTS EQU       2W              OPTION FLAGS,SUPER FCB INDEX ENCD-32
*---------------- OPTION FLAGS DEFINED                          ENCD-32
NWT      EQU       0                                            ENCD-32
EXP      EQU       6                                            ENCD-32
*-----------------------------------------------------------------------
FCB.STAT EQU       3W              STATUS                       ENCD-32
*----------------- STATUS FLAGS DEFINED                         ENCD-32
ERR      EQU       1                                            ENCD-32
EOF      EQU       6                                            ENCD-32
EOM      EQU       7                                            ENCD-32
*-----------------------------------------------------------------------
FCB.ARL  EQU       4W        ACTUAL RECORD LEN FOR SHORT FCB'S  ENCD-32
FCB.5    EQU       5W              I/O QUEUE ADR                ENCD-32
FCB.6    EQU       6W              WAIT I/O ERROR RETURN ADR    ENCD-32
FCB.FAT  EQU       7W              FAT ADDRESS                  ENCD-32
FCB.BADR EQU       8W              DATA BUFF ADDR (EXPANDED FCB)ENCD-32
FCB.BSZ  EQU       9W              COUNT REQUEST (EXPANDED FCB) ENCD-32
FCB.RAN  EQU       10W             RANDOM ADDR (EXPANDED FCB)   ENCD-32
FCB.STW1 EQU       11W             STATUS WORD 1                ENCD-32
FCB.STW2 EQU       12W             STATUS WORD 2                ENCD-32
FCB.13   EQU       13W             NO WAIT I/O NORML END ACTION ENCD-32
FCB.14   EQU       14W             NO WAIT I/O ERROR END ACTION ENCD-32
FCB.15   EQU       15W           USER SUPPLIED DEBLOCKING BUFF  ENCD-32
FCB.BAS  EQU       16W           BLK START ADDR FOR ACTIVE BLK  ENCD-32
FCB.BAE  EQU       17W           BLOCK END ADDR FOR ACTIVE BLK  ENCD-32
FCB.BAP  EQU       18W           CURR POSITION IN ACTIVE BLOCK  ENCD-32
*>>>>>>>>>>>>>>>>>>>>>>>>>>>>SECT BOUNDED FOR WRIT ACTIVE FILES ENCD-32
FCB.BANS EQU       19W          BLOCK REL ADDR OF END OF SECTOR ENCD-32
FCB.BAF  EQU       20W             FLAG WORD FOR ACTIVE BLOCK   ENCD-32
*----------------BLOCK CONTROL FLAGS DEFINED                    ENCD-32
ACTIVE   EQU       0               BUFFER INITIALIZED WHEN SET  ENCD-32
IOCOMP   EQU       1               BUFFER CONTAINS VALID DATA   ENCD-32
SECTOR   EQU       2               INDICATES START OF SECTOR    ENCD-32
LAST     EQU       3               INDICATES THIS IS LAST BLOCK ENCD-32
EMPTY    EQU       4               INDICATES BLOCK IS EMPTY     ENCD-32
*-----------------------------------------------------------------------
FCB.GLF  EQU       21W             FLAG WORD FOR THIS FILE      ENCD-32
*--------------------- FILE CONTROL FLAGS DEFINED               ENCD-32
FORMAT   EQU       0               0=> COMPRESSED ; 1=> NORMAL  ENCD-32
CURBLK   EQU       1           0=> BLOCK 1 ACTIVE; 1=> BLOCK 2  ENCD-32
LASTOP    EQU       2      1=> LAST OP WRITE; 0=> LAST OP READ  ENCD-32
IOACT    EQU       3          INDICATES I/O ACTIVE ON THIS FILE ENCD-32
BLKINIT  EQU       4          INDICATES BLK HAS BEEN INITIALIZD ENCD-32
PIOERR   EQU       5         INDICATES I/O ERR ON LAST PHYS I/O ENCD-32
*-----------------------------------------------------------------------
FCB.B1S  EQU       22W             STARTING ADR OF FIRST BLOCK  ENCD-32
FCB.B1E  EQU       23W             ENDING ADR OF FIRST BLOCK    ENCD-32
FCB.B1F  EQU       24W             CONTROL FLAGS FOR FIRST BLK  ENCD-32
FCB.B2S  EQU       25W             STARTING ADR OF SECOND BLOCK ENCD-32
FCB.B2E  EQU       26W             ENDING ADR OF SECOND BLOCK   ENCD-32
FCB.B2F  EQU       27W             CONTROL FLAGS FOR SECOND BLK ENCD-32
FCB.OCNT EQU       28W             CUMULATIVE WAIT COUNT        ENCD-32
FCB.WCNT EQU       29W             *                            ENCD-32
FCB.SPR2 EQU       30W             *                            ENCD-32
FCB.SPR1 EQU       31W             LAST WORD OF SPARES          ENCD-32
*                                                               ENCD-32
OPTSMSK  DATAW     X'FFF00000'                                  ENCD-32
*=======================================================================
*                                                               ENCD-32
*-------------------- CONTROL TABLE DEFINITION                  ENCD-32
*                                                               ENCD-32
* A VARIABLE LENGTH TABLE (CTAB.LEN) USED TO ASSOCIATE A SUPER FCB
* WITH A USER FCB. THE SPACE FOR THIS TABLE IS ALLOCATED FROM THE
* BUFFER SPACE ACQUIRED BY THE INITIALIZATION ROUTINE. EACH ENTRY IS
* TWO WORDS LONG (1=LFC,T2=SUPER3FCBLADR).     ENTRIES ARE ALLOCATED AS
* NEEDED THROUGH THE VARIABLE TAB.NDX. THE ONE BYTE INDEX TO A CTABLE
* ENTRY IS STORED IN WORD 1 OF THE USERS FCB.
*                                                               ENCD-32
*                                                               ENCD-32
CTAB.LEN EQU       16D                                          ENCD-32
CTAB.BEG DATAW     0            BASE ADDR OF CTABLE SET BY INIT ENCD-32
CTAB.END DATAW     CTAB.LEN        CTABLE LIMIT                 ENCD-32
*                                                               ENCD-32
*-----------------------------------------------------------------------
*                                                               ENCD-32
*---------------- BUFFER CONTROL                                ENCD-32
*                                                               ENCD-32
* BLOCKING BUFFER SPACE IS ALLOCATED TO EACH LFC AS IT IS OPENED.
* FROM A POOL OF MEMORY IN THE EXTENDED SPACE OF THE USER'S TASK.
*  THE INITIALIZATION ROUTINE ACQUIRES THE FIRST MAP BLOCK OF MEMORY
* AND CONSTRUCTS THE CTABLE AT THE FRONT OF IT. THE BALANCE OF THE BLOCK
* WILL BE ALLOCATED AS NEEDED TO EACH LFC. IF MORE MEMORY IS NEEDED IT
* WILL BE ACQUIRED. THE FOLLOWING VARIABLES CONTROL THE ALLOCATION OF
* MEMORY
*                                                               ENCD-32
SCTR.CNT EQU       10                                           ENCD-32
BLK.SIZE EQU       768*SCTR.CNT    10 SECTS PER DEBLOCKING BUFF ENCD-32
*                                                               ENCD-32
*-----------------------------------------------------------------------
*
*-------------- GLOBAL CONTROL FLAG DEFINITIONS                 ENCD-32
FLAGS    DATAW     0               GLOBAL FLAG WORD             ENCD-32
*                                                               ENCD-32
SETUP    EQU       0             INDICATES SETUP DONE WHEN SET  ENCD-32
*                                                               ENCD-32
*-----------------------------------------------------------------------
*                                                               ENCD-32
*---------------- DATA STRUCTURE FOR FILE OPEN SEQUENCE         ENCD-32
*                                                               ENCD-32
         BOUND     1D                                           ENCD-32
CNPOPN   EQU       $                                            ENCD-32
         DATAW     0               WAIT FOREVER                 ENCD-32
         DATAW     0               NO ALTERNATE RETURN          ENCD-32
         DATAH     X'0028'         OPEN UNBLOCKED, SHOW BLOCKED ENCD-32
CNP.STAT DATAH     0               STATUS                       ENCD-32
         DATAW     0,0             N/A (RESERVED)               ENCD-32
         DATAW     0               NO PARM LINK                 ENCD-32
*                                                               ENCD-32
*-----------------------------------------------------------------------
*                                                               ENCD-32
*------------- REGISTER STORAGE                                 ENCD-32
*                                                               ENCD-32
         BOUND     1F                                           ENCD-32
FILE     REZ       1F                                           ENCD-32
SB1.FILE REZ       1F                                           ENCD-32
LFC.MSK  DATAW     X'00FFFFFF'                                  ENCD-32
BLNKS    DATAW     C'    '                                      ENCD-32
*                                                               ENCD-32
*                                                               ENCD-32
         PAGE                                                   ENCD-32
         TITLE     BB.OPNR
************************************************************************
*                                                               ENCD-32
*        BB.OPNR - ALLOCATE A 32 WORD EXPANDED FCB WITH TW0     ENCD-32
*                  10 SECTOR BLOCKING BUFFERS. THE USER FCB     ENCD-32
*                  (ADDRESS IN R1) IS CONNECTED TO THIS         ENCD-32
*                  EXPANDED FCB AND THE FILE OPENED.            ENCD-32
*                                                               ENCD-32
************************************************************************
         BOUND     1W                                           ENCD-32
BB.OPNR  EQU       $                                            ENCD-32
         STF       R0,FILE                                      ENCD-32
         TBM       SETUP,FLAGS     HAVE WE BEEN HERE BEFORE     ENCD-32
         BS        GO.ON           YES WE HAVE, BRANCH          ENCD-32
*                                                               ENCD-32
         LI        R1,CTAB.LEN     CONTROL TABLE SIZE           ENCD-32
         BL        GETMEM                                       ENCD-32
         SBM       SETUP,FLAGS     DONT TRY THIS AGAIN!         ENCD-32
         STW       R4,CTAB.BEG     USE BEGINING AS CONTROL TAB  ENCD-32
         TRN       R1,R1                                        ENCD-32
         TRR       R4,R2                                        ENCD-32
         ZR        R4                                           ENCD-32
         SBR       R4,0                                         ENCD-32
SETUP.1  EQU       $                                            ENCD-32
         STW       R4,0W,X2                                     ENCD-32
         ABR       R2,29           BUMP TO NEXT TABLE ENTRY     ENCD-32
         BIW       R1,SETUP.1      FOR ENTIRE TABLE             ENCD-32
*-----------------------------------------------------------------------
*                                                               ENCD-32
GO.ON    EQU       $                                            ENCD-32
         LW        R4,LFC.MSK      SET UP TO ISOLATE LFC        ENCD-32
         LMW       R2,FILE+1W      GET USER FCB ADR             ENCD-32
         LMW       R5,FCB.LFC,X2   GET USER LFC                 ENCD-32
         TRR       R5,R4           LFC TO R4                    PR10988
         LA        R1,PNTERS       ADDR TO M.INQUIRY DATA AREA  PR10988
         ZR        R5                                           PR10988
         ZR        R7                                           PR10988
         SVC       2,X'48'         M.INQUIRY                    PR10988
         LW        R4,LFC.MSK      SET MASK AGAIN               PR10988
         LMW       R5,FCB.LFC,X2   RESTORE LFC TO R5            PR10988
         LI        R1,-CTAB.LEN    SET UP TO TEST ALL CTABS     ENCD-32
         LW        R3,CTAB.BEG     POINTS TO START OF CTAB      ENCD-32
LOOK.1   EQU       $               --------LOOP TOP------------ ENCD-32
         TBM       0,0W,X3         IS THIS ENTRY FREE           ENCD-32
         BS        FND.FREE   END SEARCH ON 1ST FREE CTAB ENTRY ENCD-32
         CMMW      R5,0W,X3        DOES USED ONE MATCH CURR FCB ENCD-32
         BEQ       FND.USED        BRANCH IF YES                ENCD-32
         ABR       R3,28           BUMP TO NEXT CTAB ENTRY      ENCD-32
         BID       R1,LOOK.1       KEEP TRYING                  ENCD-32
         BU        NOCTAB          BR IF NO MATCH AND NO FREE   ENCD-32
*----------                                                     ENCD-32
FND.FREE EQU       $           FREE ONE MEANS ESTAB NEW ENTRY   ENCD-32
         STW       R5,0W,X3    PUT URRENT LFC INTO CTAB ENTRY   ENCD-32
         ABR       R3,29           BUMP TO PART 2 OF THIS ENTRY ENCD-32
         LI        R1,32W          SET UP TO MAKE SUPER FCB     ENCD-32
         BL        GETMEM          GET MEMORY FOR IT            ENCD-32
         STW       R4,0W,X3        PUT ADR OF EXP FCB IN CTAB   ENCD-32
         SUI       R3,1W           RESTORE LFC ADDRESS          PR12352
         LW        R5,FCB.LFC,X3   GET LFC FROM FCB             PR10988
         TRR       R4,R3           HOLD SUPER FCB ADR FOR LATER ENCD-32
         CAMW      R5,SGOLFC       IS IT DI/SGO?                PR10988
         BNE       FREE.1          SET UP 10 SECTOR BUFF IF NOT PR10988
         LW        R1,PNTERS+1W    GET FAT ADDRESS FOR FILE     PR10988
         TBM       5,DFT.STB,X1    IS IT A VOLUME RESOURCE      PR10988
         BS        FREE.1          YES...SET UP BLOCKING BUFFS  PR10988
         LI        R1,768          ELSE MAKE BBUFF 1 SECTOR     PR10988
         BU        FREE.2          CONTINUE                     PR10988
FREE.1   LI        R1,BLK.SIZE     GET MEMORY FOR FIRST BUFFER  ENCD-32
FREE.2   BL        GETMEM                                       ENCD-32
         STW       R4,FCB.B1S,X3   AND SAVE START ADDR          ENCD-32
         STW       R5,FCB.B1E,X3       END ADDR                 ENCD-32
         BL        GETMEM          GET MEMORY FOR SECOND BLOCK  ENCD-32
         STW       R4,FCB.B2S,X3   AND SAVE START ADDR          ENCD-32
         STW       R5,FCB.B2E,X3            END ADDR            ENCD-32
         TRR       R3,R1                                        ENCD-32
*----------------                                               ENCD-32
*--------------- R1= ADDR OF SUPER FCB                          ENCD-32
*--------------- R2= ADDR OF USER  FCB                          ENCD-32
*----------------                                               ENCD-32
         STW       R1,FCB.FAT,X2   EXP FCB FAT ADR INTO USR FCB ENCD-32
         ZMW       FCB.WCNT,X1     ZERO OUT WAIT COUNT          ENCD-32
         ZMW       FCB.OCNT,X1     AND OP COUNT                 ENCD-32
*                                  USER & EXPANDED FCB'S LINKED ENCD-32
         BU        BUILDFCB                                     ENCD-32
*--------                                                       ENCD-32
FND.USED EQU       $        USED MEANS WE ARE RE-OPENING AN LFC
         ABR       R3,29           BUMP TO SECOND WORD OF ENTRY ENCD-32
         LW        R5,0W,X3        GET ADDR OF SUPER FCB        ENCD-32
         STW       R5,FCB.FAT,X2   PUT EXP FCB ADR IN USERS FCB ENCD-32
*                                  USER & EXP FCB'S LINKED      ENCD-32
         TRR       R5,R1                                        ENCD-32
         NOP                                                    ENCD-32
*--------                                                       ENCD-32
*-------- R1= ADDR OF SUPER FCB                                 ENCD-32
*-------- R2= ADDR OF USER FCB                                  ENCD-32
*--------                                                       ENCD-32
*---------------------- NOW BUILD SUPER FCB                     ENCD-32
BUILDFCB EQU       $                                            ENCD-32
         LW        R5,FCB.LFC,X1   GET LFC FROM FCB             PR10988
         CAMW      R5,SGOLFC       IS IT DI/SGO?                PR10988
         BNE       OPN.0           NO...BRANCH                  PR10988
         LW        R3,PNTERS+1W    GET FILE FAT ADDRESS         PR10988
         TBM       5,DFT.STB,X3    IS FILE A VOLUME RESOURCE    PR10988
         BS        OPN.0           YES...BRANCH                 PR10988
         LI        R6,5            SET APPEND ACCESS IF NOT     PR10988
         BU        OPN.1           CONTINUE                     PR10988
OPN.0    LW        R5,FILE+1W      GET USER FCB ADR INTO R5     ENCD-32
         LI        R6,1            SET READ MODE                PR10705
         ZBR       R5,1            IS THIS A R/W OPEN           ENCD-32
         BNS       OPN.1           BRANCH IF NOT                ENCD-32
         LI        R6,2            SET WRITE MODE               ENCD-32
OPN.1    EQU       $               CONTINUE                     ENCD-32
         STB       R6,CNPOPN+8B    AND STORE IN CNP             ENCD-32
         LW        R6,FCB.LFC,X2     GET LFC FROM USER          ENCD-32
         STW       R6,FCB.LFC,X1     INTO LOCAL FCB             ENCD-32
         ZMW       FCB.OPTS,X1     RESET ALL OPTIONS            ENCD-32
         SBM       EXP,FCB.OPTS,X1   SET EXP BIT IN LOCAL FCB   ENCD-32
         ZMW       FCB.STAT,X2        ZERO USER FCB STATUS      ENCD-32
         ZMW       FCB.STAT,X1                                  ENCD-32
         ZMW       FCB.ARL,X1                                   ENCD-32
         ZMW       FCB.5,X1                                     ENCD-32
         ZMW       FCB.6,X1                                     ENCD-32
         LI        R6,BLK.SIZE                                  ENCD-32
         STW       R6,FCB.BSZ,X1   SAVE BUFFER SIZE             ENCD-32
         ZMW       FCB.RAN,X1                                   ENCD-32
         ZMW       FCB.STW1,X1                                  ENCD-32
         ZMW       FCB.STW2,X1                                  ENCD-32
         LA        R6,NWTNRM                                    ENCD-32
         STW       R6,FCB.13,X1    SAVE END ACTION ADDRESS      ENCD-32
         LA        R6,NWTERR                                    ENCD-32
         STW       R6,FCB.14,X1    SAVE ERROR END ACTION ADDR   ENCD-32
         ZMW       FCB.15,X1                                    ENCD-32
         ZMW       FCB.B1F,X1       SHOW NO FLAGS               ENCD-32
         SBM       EMPTY,FCB.B1F,X1   SHOW THIS BLOCK EMPTY     ENCD-32
         ZMW       FCB.B2F,X1       SHOW NO FLAGS               ENCD-32
         SBM       EMPTY,FCB.B2F,X1   SHOW THIS BLOCK AS EMPTY  ENCD-32
         LW        R5,FCB.LFC,X1   GET LFC                      ETCM-32
         CAMW      R5,SGOLFC       IS IT SGO?                   ETCM-32
         BEQ       OPN.2           DON'T OPEN FILE IF SO        ETCM-32
         CAMW      R5,OBJLFC       IS IT OBJ?                   ETCM-32
         BEQ       OPN.2           DON'T OPEN FILE IF SO        ETCM-32
         LA        R7,CNPOPN                                    ENCD-32
         SVC       2,X'42'         M.OPENR  OPEN RESOURCE       ENCD-32
         BCT       ERR,NOOPN                                    ENCD-32
OPN.2    ZMW       FCB.GLF,X1      INIT FILE CONTROL FLAGS      ENCD-32
         LF        R0,FILE                                      ENCD-32
         TRSW      R0   RETURN TO USER                          ENCD-32
         NOP                       OUT OF EXECUTION LOOP        ENCD-32
*=======================================================================
         PAGE                                                   ENCD-32
         TITLE     BB.READ
************************************************************************
*
*        BB.READ - READS DATA FROM THE FILE ASSIGNED TO THE     ENCD-32
*                  FCB ADDRESS IN R1. THE AMOUNT REQUESTED IN   ENCD-32
*                  THE USER FCB IS RETURNED FROM THE CURRENTLY  ENCD-32
*                  ACTIVE BLOCKING BUFFER. WHEN A BUFFER IS     ENCD-32
*                  EMPTIED, IT IS FILLED AGAIN USING THE        ENCD-32
*                  EXPANDED FCB ATTACHED TO THE USER FCB.       ENCD-32
*                  WHEN AN EOF IS ENCOUNTERED ON THE CURRENT    ENCD-32
*                  OBJECT CODE TEMP FILE, THE USER AND EXPANDED ENCD-32
*                  FCB'S ARE CONNECTED TO THE NEXT OBJ CODE     ENCD-32
*                  TEMP FILE,IF THERE IS ONE, AND READING THEN  ENCD-32
*                  CONTINUES. EOF WILL NO BE REPORTED UNTILL    ENCD-32
*                  THE END OF THE LAST TEMP OBJ CODE FILE.      ENCD-32
*                                                               ENCD-32
************************************************************************
*
BB.READ  EQU       $                                            ENCD-32
         STF       R0,FILE         SAVE USER CONTEXT            ENCD-32
         LW        R2,FCB.FAT,X1      GET ADDR OF EXP FCB IN R2 ENCD-32
         XCR       R1,R2                                        ENCD-32
*                                                               ENCD-32
*-------------------- R1= ADR OF LOCAL FCB                      ENCD-32
*-------------------- R2= ADR OF USER  FCB                      ENCD-32
*                                                               ENCD-32
         ZBM       LASTOP,FCB.GLF,X1   SHOW LAST OP WAS A READ  ENCD-32
         TBM       BLKINIT,FCB.GLF,X1   IS A BLOCK ACTIVE       ENCD-32
         BS        R.USEIT              BRANCH IF YES           ENCD-32
*---------------------- MUST BE FIRST CALL SO INITIALIZE        ENCD-32
         LW        R4,FCB.B1S,X1                                ENCD-32
         STW       R4,FCB.BADR,X1     SET BUFFER STARTING ADR   ENCD-32
         SVC       1,X'31'         READ IN BLOCK                ENCD-32
         LB        R6,FCB.SFLG,X1  ANY STATUS BACK?             ENCD-32
         BZ        $+2W            NOPE                         ENCD-32
         BL        IOSTAT          CHECK IT OUT                 ENCD-32
         ZBM       IOACT,FCB.GLF,X1   SHOW NO I/O ACTIVE        ENCD-32
         SBM       NWT,FCB.OPTS,X1    ALL FUTURE READS NO=WAIT  ENCD-32
         SBM       IOCOMP,FCB.B1F,X1  SHOW I/O DONE ON BUFFER 1 ENCD-32
         SBM       CURBLK,FCB.GLF,X1   SHOW BLOCK 2 AS CURRENT  ENCD-32
         SBM       FORMAT,FCB.GLF,X1  SET FORMAT FLAG FOR FILE  ENCD-32
         SBM       BLKINIT,FCB.GLF,X1  SHOW BLOCK INIT DONE     ENCD-32
         ZBM       EMPTY,FCB.B1F,X1   SHOW BLOCK CONTAINS DATA  ENCD-32
         LW        R6,FCB.B2F,X1   BLK 2 FLAGS TO ACTIVE BLK    ENCD-32
         STW       R6,FCB.BAF,X1   EMPTY FLAG FORCES TOGGLE     ENCD-32
         ABM       31,FCB.OCNT,X1  BUMP OP COUNT                ENCD-32
         BU        R.USEIT         BLOCK IS SET UP, GO USE IT   ENCD-32
*=======================================================================
         PAGE                                                   ENCD-32
R.USEIT  EQU       $                                            ENCD-32
         TBM       EMPTY,FCB.BAF,X1   IS THIS BLOCK EMPTY       ENCD-32
         BS        R.TOGGLE        YES                          ENCD-32
         LW        R3,FCB.BAP,X1   GET CURRENT POSITION         ENCD-32
         BL        PASSLINE                                     ENCD-32
         ZBM       SECTOR,FCB.BAF,X1  DID WE EMPTY THIS SECTOR  ENCD-32
         BNS       BA.XIT                                       ENCD-32
         LW        R3,FCB.BANS,X1  GET BLOCK NEXT SECT BOUNDARY ENCD-32
         ADI       R3,768          BUMP TO NEXT ONE             ENCD-32
         CAMW      R3,FCB.BAE,X1   IS IT PAST END               ENCD-32
         BLE       R.ADVNCE       CONTINUE IF ROOM              ENCD-32
         SBM       EMPTY,FCB.BAF,X1   SHOW CURRENT BLOCK EMPTY  ENCD-32
         BU        BA.XIT          RETURN                       ENCD-32
R.ADVNCE EQU       $                                            ENCD-32
         LW        R4,FCB.BANS,X1  GET OLD SECTOR END           ENCD-32
         STW       R3,FCB.BANS,X1  REPALCE WITH NEW SECTOR END  ENCD-32
         ABR       R4,29           BUMP PAST SECTOR CONTROL     ENCD-32
         TRR       R4,R3           AND SET UP TO MAKE IT CURR   ENCD-32
BA.XIT   EQU       $                                            ENCD-32
         STW       R3,FCB.BAP,X1   SAVE POSITION IN BLOCK       ENCD-32
         LF        R0,FILE                                      ENCD-32
         TRSW      R0              RETURN TO CALLER             ENCD-32
         NOP                       OUT OF PATH                  ENCD-32
*-----------------------------------------------------------------------
R.TOGGLE EQU       $                                            ENCD-32
         TBM       CURBLK,FCB.GLF,X1   WHICH BLK WERE WE USING  ENCD-32
         BS        RTG21           BLK 2 IF SET TOGGLE 2 ->G1   ENCD-32
RTG12    EQU       $               ELSE ITS TOGGLE 1-> 2        ENCD-32
         TBM       0,FCB.SFLG,X1   FCB STATUS                   ENCD-32
         BNS       RTG12.1         YES, OK TO CONTINUE          ENCD-32
*                                                               ENCD-32
*------ WAIT FOR OUTSTANDING I/O TO COMPLETE                    ENCD-32
*                                                               ENCD-32
         ABM       31,FCB.WCNT,X1  BUMP WAIT COUNT              ENCD-32
         SVC       1,X'3C'         M.WAIT                       ENCD-32
RTG12.1  EQU       $                                            ENCD-32
         SBM       EMPTY,FCB.B1F,X1   MAKE BLOCK 1 EMPTY        ENCD-32
         ZBM       IOCOMP,FCB.B1F,X1  MAKE BLOCK 1 I/O ACTIVE   ENCD-32
         LW        R6,FCB.B1S,X1   GET BLOCK 1 START            ENCD-32
         STW       R6,FCB.BADR,X1  INTO FCB                     ENCD-32
         TBM       LAST,FCB.BAF,X1  DO WE HAVE PHYSICAL EOF?    ENCD-32
         BS        RTG12.2          SKIP READ                   ENCD-32
         SBM       IOACT,FCB.GLF,X1  SHOW I/O ACTIVE THIS FILE  ENCD-32
         SVC       1,X'31'         INITIATE A READ              ENCD-32
         LB        R6,FCB.SFLG,X1  ANY STATUS BACK?             ENCD-32
         CI        R6,X'80'                                     ENCD-32
         BEQ       $+2W            NOPE                         ENCD-32
         BL        IOSTAT          CHECK IT OUT                 ENCD-32
*--------                                                       ENCD-32
RTG12.2  EQU       $                                            ENCD-32
         ABM       31,FCB.OCNT,X1  BUMP OPCOUNT                 ENCD-32
         LW        R6,FCB.B2S,X1   GET BLOCK 2 START            ENCD-32
         STW       R6,FCB.BAS,X1 AS ACTIVE BLOCK START          ENCD-32
         ABR       R6,29           BUMP PAST SECTOR CONTROL     ENCD-32
         STW       R6,FCB.BAP,X1   AND ACTIVE BLOCK CURR POSITN ENCD-32
*                                                               ENCD-32
         LW        R6,FCB.BAS,X1   GET ACTIVE BLOCK START       ENCD-32
         ADI       R6,768          BUMP BY ONE SECTOR           ENCD-32
         STW       R6,FCB.BANS,X1  TO SET UP NEXT SECT BOUNDARY ENCD-32
*                                                               ENCD-32
         LW        R6,FCB.B2E,X1   GET BLOCK 2 END              ENCD-32
         STW       R6,FCB.BAE,X1   AS ACTIVE BLOCK END          ENCD-32
*                                                               ENCD-32
         LW        R6,FCB.B2F,X1   GET BLOCK 2 FLAGS            ENCD-32
         STW       R6,FCB.BAF,X1   AS ACTIVE BLOCK FLAGS        ENCD-32
         SBM       CURBLK,FCB.GLF,X1 SHOW BLOCK 2 AS ACTIVE     ENCD-32
*                                                               ENCD-32
         ZBM       EMPTY,FCB.B1F,X1   SHOW SOME DATA IN BLOCK 1 ENCD-32
*--------                                                       ENCD-32
         BU        R.USEIT                                      ENCD-32
*-----------------------------------------------------------------------
RTG21    EQU       $               ELSE ITS TOGGLE 2->1         ENCD-32
         TBM       0,FCB.SFLG,X1   FCB STATUS                   ENCD-32
         BNS       RTG21.1         NO,  OK TO CONTINUE          ENCD-32
*                                                               ENCD-32
*------ CODE TO WAIT FOR I/O COMPLETE                           ENCD-32
*                                                               ENCD-32
         ABM       31,FCB.WCNT,X1  BUMP WAIT COUNT              ENCD-32
         SVC       1,X'3C'         M.WAIT                       ENCD-32
RTG21.1  EQU       $                                            ENCD-32
         SBM       EMPTY,FCB.B2F,X1   MAKE BLOCK 2 EMPTY        ENCD-32
         ZBM       IOCOMP,FCB.B2F,X1  MAKE BLOCK 2 I/O ACTIVE   ENCD-32
         LW        R6,FCB.B2S,X1   GET BLOCK 2 START            ENCD-32
         STW       R6,FCB.BADR,X1  INTO FCB                     ENCD-32
         TBM       LAST,FCB.BAF,X1 DO WE HAVE PHYSICAL EOF?     ENCD-32
         BS        RTG21.2         SKIP READ                    ENCD-32
         SBM       IOACT,FCB.GLF,X1   SHOW I/O ACTIVE THIS FILE ENCD-32
RTG21.0  SVC       1,X'31'         INITATE A READ               ENCD-32
         LB        R6,FCB.SFLG,X1  ANY STATUS BACK?             ENCD-32
         CI        R6,X'80'                                     ENCD-32
         BEQ       $+2W            NOPE                         ENCD-32
         BL        IOSTAT          CHECK IT OUT                 ENCD-32
*--------                                                       ENCD-32
RTG21.2  EQU       $                                            ENCD-32
         ABM       31,FCB.OCNT,X1  BUMP OP COUNT                ENCD-32
         LW        R6,FCB.B1S,X1   GET BLOCK 1 START            ENCD-32
         STW       R6,FCB.BAS,X1   AS ACTIVE BLOCK START        ENCD-32
         ABR       R6,29           BUMP PAST SECTOR CONTROL     ENCD-32
         STW       R6,FCB.BAP,X1   AND ACTIVE BLOCK CURR POSITN ENCD-32
*                                                               ENCD-32
         LW        R6,FCB.BAS,X1   GET ACTIVE BLOCK START       ENCD-32
         ADI       R6,768          BUMP TO NEXT SECTOR BOUNDRY  ENCD-32
         STW       R6,FCB.BANS,X1  AND STORE AS SECTOR BOUNDRY  ENCD-32
*                                                               ENCD-32
         LW        R6,FCB.B1E,X1   GET BLOCK 1 END              ENCD-32
         STW       R6,FCB.BAE,X1   AS ACTIVE BLOCK END          ENCD-32
*                                                               ENCD-32
         LW        R6,FCB.B1F,X1   GET BLOCK 1 FLAGS            ENCD-32
         STW       R6,FCB.BAF,X1   AS ACTIVE BLOCK FLAGS        ENCD-32
         ZBM       CURBLK,FCB.GLF,X1 SHOW BLOCK 1 AS ACTIVE     ENCD-32
*                                                               ENCD-32
         ZBM       EMPTY,FCB.B2F,X1   SHOW SOME DATA IN BLOCK 2 ENCD-32
*--------                                                       ENCD-32
         BU        R.USEIT                                      ENCD-32
*=======================================================================
         PAGE                                                   ENCD-32
*                                                               ENCD-32
PASSLINE EQU       $                                            ENCD-32
         STF       R0,SB1.FILE                                  ENCD-32
         BL        SET.USER                                     ENCD-32
         ABR       R3,31           BUMP TO BYTE CNT PREV RECORD ENCD-32
         ABR       R3,31           BUMP TO STATUS THIS RECORD   ENCD-32
         LB        R4,0B,X3        AND GET IT                   ENCD-32
         TBR       R4,24           IS IT AN END OF FILE         ENCD-32
         BS        PS.EOF          YES                          ENCD-32
*-------------------- NOTHING SPECIAL HERE EITHER               ENCD-32
         ABR       R3,31           BUMP TO BYTE CNT THIS RECORD ENCD-32
         LB        R4,0B,X3        GET IT                       ENCD-32
         TRR       R4,R7           SAVE FOR LATER               ENCD-32
         ABR       R3,31           BUMP TO START OF DATA        ENCD-32
         TRR       R3,R6           SAVE FOR LATER               ENCD-32
         CAMW      R4,USER.REQ       WHAT DID USER ASK FOR      ENCD-32
         BLE       PS.USERL                                     ENCD-32
         LW        R4,USER.REQ       SO USE USER REQUEST        ENCD-32
PS.USERL EQU       $                                            ENCD-32
         TRN       R4,R4                                        ENCD-32
         TRR       R1,R0           SAVE POINTER TO LOCAL FCB    ENCD-32
         LW        R1,USER.ADR        GET USER BUFFER ADR       ENCD-32
PS.LOOP  EQU       $                                            ENCD-32
         LB        R5,0B,X3        GET BYTE                     ENCD-32
         STB       R5,0B,X1        PUT BYTE                     ENCD-32
         ABR       R1,31           BUMP OUT                     ENCD-32
         ABR       R3,31           BUMP IN                      ENCD-32
         BIB       R4,PS.LOOP                                   ENCD-32
*                                                               ENCD-32
         TRR       R0,R1           RECOVER LOCAL FCB            ENCD-32
         TRR       R6,R3           RECOVER POINTER              ENCD-32
         ADR       R7,R3           ADD RECORD LENGTH            ENCD-32
         STW       R3,SB1.FILE+3W  PUT IN USERS CONTEXT         ENCD-32
*                                                               ENCD-32
         LB        R4,0B,X3    GET NEXT BYTE(STAT PREV RECORD)  ENCD-32
         TBR       R4,24           IS IT AN END OF FILE         ENCD-32
         BS        PS.EOF          YES                          ENCD-32
         TBR       R4,26           IS IT AN END OF SECTOR       ENCD-32
         BNS       PS.EOS          YES                          ENCD-32
         SBM       SECTOR,FCB.BAF,X1  FLAG TO ADVANCE SECTOR    ENCD-32
PS.EOS   EQU       $                                            ENCD-32
         ABR       R3,31           BUMP TO PREV RECORD LEN.     ENCD-32
         LB        R4,0B,X3        GET IT                       ENCD-32
         CAR       R4,R7           DOES IT MATCH CURRENT        ENCD-32
         BNE       BCCERR                                       ENCD-32
         LF        R0,SB1.FILE                                  ENCD-32
         TRSW      R0              RETURN TO CALLER             ENCD-32
         NOP                       OUT OF PATH                  ENCD-32
*-----------------------------------------------------------------------
PS.EOF   EQU       $                                            ENCD-32
         SBM       EOF,FCB.STAT,X2    SET EOF TO USER           ENCD-32
         ZMW       FCB.B1F,X1      CLEAR B1 FLAGS               ENCD-32
         ZMW       FCB.B2F,X1      CLEAR B2 FLAGS               ENCD-32
         LF        R0,FILE                                      ENCD-32
         TRSW      R0              RETURN TO CALLER             ENCD-32
         NOP                       OUT OF PATH                  ENCD-32
*=======================================================================
         PAGE                                                   ENCD-32
SET.USER EQU       $           SET UP USER REQUEST SIZE & ADDR  ENCD-32
         TBM       EXP,FCB.OPTS,X2  TEST USER FCB FORMAT        ENCD-32
         BS        EXPFMT                                       ENCD-32
         LW        R4,FCB.TCW,X2                                ENCD-32
         SRLD      R4,20           EXTRACT USER REQ             ENCD-32
         SRL       R5,12           ALIGN USER ADDR              ENCD-32
         ZBR       R5,12                                        ENCD-32
         BU        COMFMT                                       ENCD-32
EXPFMT   EQU       $                                            ENCD-32
         LW        R4,FCB.BSZ,X2   GET USER REQUEST             ENCD-32
         LW        R5,FCB.BADR,X2  GET USER BUFFER ADR          ENCD-32
COMFMT   EQU       $                                            ENCD-32
         STD       R4,USER.REQ     SAVE FOR LATER               ENCD-32
         TRSW      R0              RETURN                       ENCD-32
*-----------------------------------------------------------------------
         BOUND 1D                                               ENCD-32
USER.REQ DATAW     0            SET UP WITH USER XFER REQUEST   ENCD-32
USER.ADR DATAW     0               SET UP WITH USER BUFFER ADDR ENCD-32
*                                                               ENCD-32
         PAGE                                                   ENCD-32
IOSTAT   TBR       R6,24+1         ANY ERRORS?                  ENCD-32
         BS        READ.ERR        YES REPORT IT                ENCD-32
         TBR       R6,24+6         EOF POSTED?                  ENCD-32
         BNS       $+2W            CONTINUE TESTING             ENCD-32
         BU        IOS.EOF         PROCESS EOF CASE             ENCD-32
         TBR       R6,24+7         EOM POSTED?                  ENCD-32
         BS        IOS.EOF                                      ENCD-32
         TRSW      R0              ELSE RETURN                  ENCD-32
IOS.EOF  LW        R3,FCB.ERWA,X1  GET START ADDR OF BUFFER     ENCD-32
         LI        R6,4            NEXT AVAIL CHAR LOCATION     ENCD-32
         STW       R6,0,X3         SAVE IN BUFFER               ENCD-32
         LW        R6,=X'8000'     EOF INDICATOR                ENCD-32
         STH       R6,2H,X3        STORE INTO BUFFER            ENCD-32
         SBM       LAST,FCB.BAF,X1  SHOW EOF IN FCB             ENCD-32
         LW        R4,=X'00FFFFFF'                              ENCD-32
         LMW       R6,0,X1         GET LFC                      ENCD-32
         CAMW      R6,TMPLFC       IS THIS I/O TO TEMP OBJ FILE ENCD-32
         BNE       NOTEMP          SKIP IF NOT                  ENCD-32
         LW        R6,TCNT         GET CURR PASS B TEMP COUNT   ENCD-32
         ADI       R6,1            INCREMENT IT                 ENCD-32
         CAMW      R6,TMPCNT       PASS B COUNT > PASS A COUNT  ENCD-32
         BGT       NOTEMP          ACTUAL TEMP EOF IF SO        ENCD-32
         STW       R6,TCNT         SAVE NEW COUNT               ENCD-32
         M.CONBAD  TCNT            CONVERT TO ASCII             ENCD-32
         SLL       R7,16           POSITION TO MAKE LFC         ENCD-32
         SRL       R7,16                                        ENCD-32
         LW        R4,=X'FFFF0000'                              ENMCD-32
         LMW       R6,TMPLFC       GET TEMP OBJ LFC             ENCD-32
         ORR       R6,R7           MAKE NEW TEMP LFC            ENCD-32
         STW       R7,TMPLFC       SAVE IT                      ENCD-32
         STW       R7,XTEMP        IN FCB                       ENCD-32
         STW       R7,0W,X1        AND EXPANDED FCB             ENCD-32
         ZMW       FCB.FAT,X1      AERO FAT ADDR IN EXP. FCB    ENCD-32
         ZBM       LAST,FCB.BAF,X1  CLEAR PHYSICAL EOF FLAG
         SVC       1,X'31'         DO THE READ AGAIN            ENCD-32
NOTEMP   TRSW      R0                                           ENCD-32
*                                                               ENCD-32
*------------------ VARIOUS ERRORS                              ENCD-32
*                                                               ENCD-32
NOCTAB   EQU       $                                            ENCD-32
         LW        R4,=X'00FFFFFF'   LFC MASK                   ENCD-32
         LMW       R7,0,X2         GET USER LFC                 ENCD-32
         LA        R3,EM1.LFC      WHERE TO PUT IT              ENCD-32
         BL        XSTB            PUT IT IN MESSAGE            ENCD-32
         LNB       R5,EMSG.1L      MESSAGE LENGTH               ENCD-32
         LA        R6,EMSG.1A      MESSAGE ADDRESS              ENCD-32
         BL        XTYPEF          PUT OUT MESSAGE              ENCD-32
         BL        XABORT          AND ABORT                    ENCD-32
NOOPN    EQU       $                                            ENCD-32
         LW        R4,=X'00FFFFFF'                              ENCD-32
         LMW       R7,0,X2         GET USER LFC                 ENCD-32
         LA        R3,EM2.LFC      WHERE TO PUT IT              ENCD-32
         BL        XSTB            PUT LFC IN MESSAGE           ENCD-32
         LNB       R5,EMSG.2L      MESSAGE LENGTH               ENCD-32
         LA        R6,EMSG.2A      MESSAGE ADDRESS              ENCD-32
         BL        XTYPEF          PUT OUT MESSAGE              ENCD-32
         BL        XABORT          AND ABORT                    ENCD-32
BCCERR   EQU       $                                            ENCD-32
         LW        R5,0,X1         GET LFC                      ENCD-32
         SLL       R5,8            CLEAR TOP BYTE               ENCD-32
         SRL       R5,8                                         ENCD-32
         SBR       R5,2            MAKE 1ST BYTE A BLANK        ENCD-32
         STW       R5,XLR.MD2      SAVE IN MESSAGE              ENCD-32
         LW        R5,FCB.STAT,X1  GET STATUS                   ENCD-32
         M.CONBAH                  CONVERT TO HEX               ENCD-32
         STW       R6,XLR.MD1      SAVE IN MESSAGE              ENCD-32
         STW       R7,XLR.MD1+1W                                ENCD-32
         LNB       R5,XLR.ML       MESSAGE LENGTH               ENCD-32
         LA        R6,XLR.MSG      MESSAGE ADDRESS              ENCD-32
         BL        XTYPEF          PUT OUT MESSAGE              ENCD-32
         BL        XABORT          AND ABORT                    ENCD-32
READ.ERR EQU       $                                            ENCD-32
         LW        R4,=X'00FFFFFF'                              ENCD-32
         LMW       R7,0,X2         GET USE LFC                  ENCD-32
         LA        R3,EM4.LFC      PLACE TO PUT IT              ENCD-32
         BL        XSTB                                         ENCD-32
         LNB       R5,EMSG.4L      MESSAGE LENGTH               ENCD-32
         LA        R6,EMSG.4A      MESSAGE ADDRESS              ENCD-32
         BL        XTYPEF          PUT OUT MESSAGE              ENCD-32
         BL        XABORT          AND ABORT                    ENCD-32
TMPERR   EQU       $                                            ENCD-32
         LNB       R5,EMSG.5L      MESSAGE LENGTH               ENCD-32
         LA        R6,EMSG.5A      MESSAGE ADDRESS              ENCD-32
         BL        XTYPEF          PUT OUT MESSAGE              ENCD-32
         BL        XABORT          AND ABORT                    ENCD-32
*-----------------------------------------------------------------------
EMSG.1A  DATAB     C' CATALOG<<FATAL>> NO FCB CONTROL TABLE '   ENCD-32
         DATAB     C' ENTRY TO ALLOCATE FOR LFC : '             ENCD-32
EM1.LFC  DATAB     C'    '                                      ENCD-32
EMSG.1L  DATAB     $-EMSG.1A                                    ENCD-32
*
EMSG.2A  DATAB     C' CATALOG<<FATAL>> CANNOT OPEN FILE '       ENCD-32
         DATAB     C' ASSIGNED TO LFC : '                       ENCD-32
EM2.LFC  DATAB     C'    '                                      ENCD-32
EMSG.2L  DATAB     $-EMSG.2A                                    ENCD-32
*
EMSG.4A  DATAB     C' CATALOG<<FATAL>> ERROR READING FILE '     ENCD-32
         DATAB     C' ASSIGNED TO LFC : '                       ENCD-32
EM4.LFC  DATAB     C'    '                                      ENCD-32
EMSG.4L  DATAB     $-EMSG.4A                                    ENCD-32
*
EMSG.5A  DATAB     C' CATALOG<<FATAL>> NO MORE TEMPORARY '      ENCD-32
         DATAB     C' OBJECT FILES TO ALLOCATE. '               ENCD-32
EMSG.5L  DATAB     $-EMSG.5A                                    ENCD-32
*-----------------------------------------------------------------------
         PAGE                                                   ENCD-32
         BOUND     1W                                           ENCD-32
NWTERR   EQU       $                                            ENCD-32
         SEA                                                    ENCD-32
         TBM       EOM,FCB.STAT,X1   CHECK FOR EOM              ENCD-32
         BNS       NWTERR1         REPORT ERROR IF NOT EOM      ENCD-32
         M.XIEA                    ELSE RETURN TO CONTEXT       ENCD-32
NWTERR1  BU        BCCERR          REPORT ERROR                 ENCD-32
*-----------------------------------------------------------------------
NWTNRM   EQU       $                                            ENCD-32
         SEA                                                    ENCD-32
         ZBM       IOACT,FCB.GLF,X1                             ENCD-32
         TBM       ERR,FCB.STAT,X1                              ENCD-32
         BNS       $+2W            SKIP IF NO ERROR             ENCD-32
         SBM       PIOERR,FCB.GLF,X1                            ENCD-32
         TBM       CURBLK,FCB.GLF,X1                            ENCD-32
         BS        BLK1END                                      ENCD-32
*-------                                                        ENCD-32
BLK2END  EQU       $                                            ENCD-32
         SBM       IOCOMP,FCB.B2F,X1    SHOW I/O COMPLETE       ENCD-32
         BU        IOEND.X                                      ENCD-32
BLK1END  EQU       $                                            ENCD-32
         SBM       IOCOMP,FCB.B1F,X1    SHOW I/O COMPLETE       ENCD-32
IOEND.X  EQU       $                                            ENCD-32
         M.XIEA    RETURN TO INTERRUPTED CONTEXT                ENCD-32
*-----------------------------------------------------------------------
         PAGE                                                   ENCD-32
         TITLE     GETMEM
************************************************************************
*                                                                      *
*     GETMEM ROUTINE                                                   *
*                                                                      *
*     SUPPLIES REQUESTED AMOUNT OF MEMORY TO CALLER                    *
*                                                                      *
*     MANAGES BLOCK CONTROL POINTERS                                   *
*                                                                      *
*     ENTRY CONDITIONS:   R1= AMOUNT OF REQUEST (IN BYTES)             *
*                                                                      *
*     EXIT  CONDITIONS    R4= STARTING ADR OF ALLOCATED BLOCK          *
*                         R5= ENDING   ADR OF ALLOCATED BLOCK          *
*                                                                      *
*        FATAL ERROR IF NO MEMORY AVAILABLE                            *
*                                                                      *
************************************************************************
GETMEM   EQU       $
         STF       R0,SB1.FILE     SAVE CALLERS CONTEXT
         BL        XGETEA          GET EXTENDED MEMORY          ENCD-32
         TRR       R2,R2           DID WE GET IT?               ENCD-32
         BNZ       GETM.1          CONTINUE IF S0               ENCD-32
         LNB       R5,C50.MAL      LENGTH OF MESSAGE            ENCD-32
         LA        R6,C50.MAA      MESSAGE ADDRESS              ENCD-32
         BL        XTYPEF          PUT OUT MESSAGE              ENCD-32
         LNB       R5,C50.MBL      SECOND HALF OF MESSAGE       ENCD-32
         LA        R6,C50.MBA                                   ENCD-32
         BL        XTYPEF                                       ENCD-32
         BL        XABORT          AND ABORT                    ENCD-32
GETM.1   STW       R2,SB1.FILE+4W  SAVE START ADDRESS           ENCD-32
         ADR       R2,R3                                        ENCD-32
         STW       R3,SB1.FILE+5W  SAVE END ADDRESS             ENCD-32
         LF        R0,SB1.FILE
         TRSW      R0              RETURN TO CALLER
         NOP                       OUT OF PATH
*=======================================================================
         PAGE
         BOUND     1W
         TITLE     BB.WRIT
************************************************************************
*
*        BB.WRIT - WRITES THE AMOUNT REQUESTED IN THE USER FCB  ENCD-32
*                  (ADDRESS IN  R1) TO THE CURRENT ACTIVE       ENCD-32
*                  BLOCKING BUFFER FOR THE FILE. ONCE A BUFFER  ENCD-32
*                  IS FILLED, IT IS WRITTEN TO THE CURRENT OBJ  ENCD-32
*                  CODE TEMP FILE USING THE EXPANDED FCB. IF    ENCD-32
*                  THE TRANSFER WILL NOT FIT IN THE CURRENT     ENCD-32
*                  OBJ TEMP FILE, A NEW OBJ TEMP FILE IS        ENCD-32
*                  CREATED, THE TEMP FILE LFC IS INCREMENTED,   ENCD-32
*                  THE FCB WITH THE NEW LFC IS ASSIGNED TO      ENCD-32
*                  THE NEW TEMP FILE, AND THE WRITE IS          ENCD-32
*                  RE-ISSUED.                                   ENCD-32
*                                                               ENCD-32
************************************************************************
BB.WRIT  EQU       $                                            ENCD-32
         STF       R0,FILE         SAVE USER CONTEXT            ENCD-32
         LW        R2,FCB.FAT,X1   GET EXPANDED FCB ADR INTO R2 ENCD-32
         XCR       R1,R2           AND EXCHANGE                 ENCD-32
*                                                               ENCD-32
*        R1=ADR OF SUPER (LOCAL) FCB                            ENCD-32
*        R2=ADR OF USER'S FCB                                   ENCD-32
*                                                               ENCD-32
         SBM       LASTOP,FCB.GLF,X1  SHOW LAST OP WAS A WRITE  ENCD-32
         TBM       BLKINIT,FCB.GLF,X1  IS ANY BLOCK ACTIVE      ENCD-32
         BS        W.USEIT         THEN USE IT                  ENCD-32
*                                                               ENCD-32
*------------------- MUST BE FIRST TIME SO SET IT UP            ENCD-32
*                                                               ENCD-32
         LW        R4,FCB.B1S,X1   GET START ADR OF BLOCK 1     ENCD-32
         STW       R4,FCB.BAS,X1                                ENCD-32
         STW       R4,FCB.BANS,X1  STORE AS END OF SECT BOUNDRY ENCD-32
         SUI       R4,768          DECREMENT BY 1 SECTOR        ENCD-32
         STW       R4,FCB.BAP,X1   STORE AS STRT SECT BOUNDRY   ENCD-32
         LW        R4,FCB.B1E,X1 GET BLOCK 1 END                ENCD-32
         STW       R4,FCB.BAE,X1   AS ACTIVE BLOCK END          ENCD-32
         SBM       BLKINIT,FCB.GLF,X1   SHOW BLOCK INIT DONE    ENCD-32
         SBM       SECTOR,FCB.BAF,X1    BLK 1 ON A SECT BOUNDRY ENCD-32
         ZBM       IOACT,FCB.GLF,X1     NO ACTIVE I/O ON FILE   ENCD-32
         SBM       FORMAT,FCB.GLF,X1   WRITE AS UNCOMPRESD FILE ENCD-32
         SBM       NWT,FCB.OPTS,X1 ENABLE NOWAIT I/O            ENCD-32
         BU        W.USEIT                                      ENCD-32
         PAGE                                                   ENCD-32
W.USEIT  EQU       $                                            ENCD-32
         BL        SET.USER        SET UP REQUEST               ENCD-32
         ZBM       SECTOR,FCB.BAF,X1  ARE WE ON A SECT BOUNDRY  ENCD-32
         BNS       WBA.1           BRANCH IF NOT                ENCD-32
*--------                                                       ENCD-32
         LW        R3,FCB.BANS,X1  GET CURRENT SECTOR END       ENCD-32
         ADI       R3,768          BUMP BY 1 SECTOR             ENCD-32
         CAMW      R3,FCB.BAE,X1   IS THERE ROOM IN THIS BLOCK  ENCD-32
         BGT       W.TOGGLE        BRANCH IF NOT                ENCD-32
*--------                                                       ENCD-32
         STW       R3,FCB.BANS,X1  ADVANCE THE END OF SECT PNTR ENCD-32
         LW        R3,FCB.BAP,X1                                ENCD-32
         ADI       R3,768        ADVANCE THE STRT OF SECT PNTR  ENCD-32
         STW       R3,FCB.BAP,X1   AND SAVE IT                  ENCD-32
         LI        R4,6            PNTS TO STATUS THIS REC BYTE ENCD-32
         STW       R4,0W,X3        AND STORE IN SECT CONTROL WD ENCD-32
         ABR       R3,29           ADVANCE POINTER              ENCD-32
         LI        R4,X'4000'                                   ENCD-32
         STH       R4,0H,X3        SHOW FIRST SECTOR RECORD     ENCD-32
*--------                                                       ENCD-32
WBA.1    EQU       $                                            ENCD-32
         LW        R3,FCB.BAP,X1   GET CURRENT SECT START PNTR  ENCD-32
         TRR       R3,R6           SAVE IT FOR LATER            ENCD-32
         LW        R4,0W,X3        GET CURR WRITE ADR THIS SECT ENCD-32
         TRR       R4,R7           SAVE IT FOR LATER            ENCD-32
         ADR       R3,R4           MAKE IT A BLOCK REL VALUE    ENCD-32
         ABR       R4,29           INCR BY 4 FOR CONTROL BYTES  ENCD-32
         ADMW      R4,USER.REQ       ADD USERS REQUEST          ENCD-32
         CAMW      R4,FCB.BANS,X1    WILL IT FIT IN THIS SECTOR ENCD-32
         BLE       WBA.2           BRANCH IF IT WILL            ENCD-32
*--------                                                       ENCD-32
         TRR       R7,R4      RECOVER CURR WRITE ADR THIS SECT  ENCD-32
         ADMW      R4,FCB.BAP,X1   ADD BASE OF CURRENT SECTOR   ENCD-32
         TRR       R4,R3           AND PUT IN R3 FOR LATER      ENCD-32
         SUMW      R4,FCB.BANS,X1  SUBTRACT END OF SECTOR       ENCD-32
         ZR        R5                                           ENCD-32
WBA.11   EQU       $                                            ENCD-32
         STB       R5,0B,X3                                     ENCD-32
         ABR       R3,31                                        ENCD-32
         BIB       R4,WBA.11       ZERO OUT BALENCE OF SECTOR   ENCD-32
*-------                                                        ENCD-32
         TRR       R7,R3           RECOVER CURRENT WRITE ADR    ENCD-32
         SUI       R3,2        BACK UP TO LAST REC STATUS BYTE  ENCD-32
         TRR       R3,R7           AND SAVE FOR LATER           ENCD-32
         ADMW      R3,FCB.BAP,X1   ADD IN SECTOR BASE           ENCD-32
         LB        R4,0B,X3        GET STATUS BYTE PREV RECORD  ENCD-32
         SBR       R4,26           SHOW IT AS LAST RECORD       ENCD-32
         STB       R4,0B,X3        AND PUT BACK                 ENCD-32
         TRR       R6,R3           GET BACK START OF SECT PNTR  ENCD-32
         STW       R7,0W,X3        UPDATE SECTOR WRITE ADR      ENCD-32
         SBM       SECTOR,FCB.BAF,X1 SHOW A SECTOR BOUNDRY      ENCD-32
         BU        W.USEIT         AND GO BUMP THE SECTOR       ENCD-32
*-----------------------------------------------------------------------
WBA.2    EQU       $               ADD USER RECORD TO BLOCK     ENCD-32
*                                                               ENCD-32
*        R1= ADR OF LOCAL FCB                                   ENCD-32
*        R2= ADR OF USER'S FCB                                  ENCD-32
*        R6= BLOCK RELATIVE ADR OF START OF THIS SECTOR         ENCD-32
*        R7= SECTOR RELATIVE ADR OF NEXT WRITE POSITION         ENCD-32
*                                                               ENCD-32
         TRR       R6,R3           RECOVER BLOCK ADR            ENCD-32
         ADR       R7,R3           ADD IN CURRENT SECTOR OFFSET ENCD-32
         ZMB       0B,X3           STORE STAT BYTE FOR THIS REC ENCD-32
         ABR       R3,31           AND BUMP POINTER             ENCD-32
         LW        R5,USER.REQ       GET USER'S XFER REQUEST    ENCD-32
         STB       R5,0B,X3        STORE LEN BYTE FOR THIS REC  ENCD-32
         ABR       R3,31           BUMP POINTER                 ENCD-32
         ABR       R7,30           BUMP SECTOR REL POSITION     ENCD-32
         ADR       R5,R7           AND ADD IN LEN OF THIS REC   ENCD-32
*--------                                                       ENCD-32
         TRR       R1,R0           SAVE LOCAL FCB ADR           ENCD-32
         LW        R1,USER.ADR        GET USER'S RECORD ADR     ENCD-32
         TRN       R5,R4                                        ENCD-32
WBA.21   EQU       $                                            ENCD-32
         LB        R5,0B,X1                                     ENCD-32
         STB       R5,0B,X3                                     ENCD-32
         ABR       R1,31                                        ENCD-32
         ABR       R3,31                                        ENCD-32
         BIB       R4,WBA.21       MOVE RECORD                  ENCD-32
*-------                                                        ENCD-32
         TRR       R0,R1           RESTORE LOCAL FCB POINTER    ENCD-32
         ZMB       0B,X3           SET STATUS PREVIOUS RECORD   ENCD-32
         ABR       R3,31           BUMP POINTER                 ENCD-32
         LW        R5,USER.REQ       GET USER LENGTH AGAIN      ENCD-32
         STB       R5,0B,X3        AND SET LENGTH PREV RECORD   ENCD-32
         ABR       R7,30           BUMP SECT REL POSITION PAST  ENCD-32
         TRR       R6,R3           RECOVER BLK REL SECTOR START ENCD-32
         STW       R7,0W,X3        AND STORE CURR SECT POSITION ENCD-32
         LF        R0,FILE                                      ENCD-32
         TRSW      R0              RETURN TO USER               ENCD-32
         NOP                       OUT OF PATH                  ENCD-32
*-----------------------------------------------------------------------
W.TOGGLE EQU       $         TOGGLE TO OTHER BLK AFTER WRITING  ENCD-32
         TBM       CURBLK,FCB.GLF,X1   WHICH BLOCK ARE WE USING ENCD-32
         BS        W.TG21          GO TOGGLE 2 -> 1             ENCD-32
W.TG12   EQU       $               TOGGLE 1 -> 2                ENCD-32
*!!!!!!!!!!TBM!!!!!!!IOACT,FCB.GLF,X1!!!IS!I/O!ACTIVE!THIS!FILE!C020-32
         TBM       0,FCB.SFLG,X1   IS I/O ACTIVE                C020-32
         BNS       W.TG12.1        CONTINUE IF NOT              ENCD-32
*                                                               ENCD-32
*----- CODE TO WAIT FOR I/O COMPLETE                            ENCD-32
*                                                               ENCD-32
         ABM       31,FCB.WCNT,X1  BUMP WAIT COUNT              ENCD-32
         SVC       1,X'3C'         M.WAIT                       ENCD-32
W.TG12.1 EQU       $                                            ENCD-32
         SBM       IOACT,FCB.GLF,X1   SHOW I/O ACTIVE THIS FILE ENCD-32
         LW        R5,FCB.BAS,X1   GET CURRENT BLOCK START      ENCD-32
         STW       R5,FCB.BADR,X1 INTO FCB BUFFER ADR WORD      ENCD-32
W.TG12.0 SVC       1,X'32'         WRITE OUT THIS BLOCK         ENCD-32
         TBM       7,FCB.STAT,X1   DID WE GET EOM               ENCD-32
         BNS       W.TG12.2                                     ENCD-32
         BL        TMPLINK         CHAIN TO NEW TEMP FILE       ENCD-32
         BU        W.TG12.0        REISSUE WRITE                ENCD-32
W.TG12.2 EQU       $                                            ENCD-32
         ABM       31,FCB.OCNT,X1  BUMP OP COUNT                ENCD-32
         LW        R4,FCB.B2S,X1   GET START ADR OF BLOCK 1     ENCD-32
         STW       R4,FCB.BAS,X1                                ENCD-32
         STW       R4,FCB.BANS,X1  STORE AS END OF SECT BOUNDRY ENCD-32
         SUI       R4,768          DECREMENT BY 1 SECTOR        ENCD-32
         STW       R4,FCB.BAP,X1   STORE AS START SECT BOUNDRY  ENCD-32
         LW        R4,FCB.B2E,X1 GET BLOCK 1 END                ENCD-32
         STW       R4,FCB.BAE,X1   AS ACTIVE BLOCK END          ENCD-32
         SBM       SECTOR,FCB.BAF,X1  SHOW CUR.BLK ON SECT BOUNDENCD-32
         SBM       CURBLK,FCB.GLF,X1   SHOW BLOCK 2 AS CURRENT  ENCD-32
         BU        W.USEIT                                      ENCD-32
*-----------------------------------------------------------------------
W.TG21   EQU       $               TOGGLE 2 -> 1                ENCD-32
*!!!!!!!!!!TBM!!!!!!!IOACT,FCB.GLF,X1!!!IS!I/O!ACTIVE!THIS!FILE!C020-32
         TBM       0,FCB.SFLG,X1   IS I/O ACTIVE                C020-32
         BNS       W.TG21.1        CONTINUE IF NOT              ENCD-32
*                                                               ENCD-32
*----- CODE TO WAIT FOR I/O COMPLETE                            ENCD-32
*                                                               ENCD-32
         ABM       31,FCB.WCNT,X1  BUMP WAIT COUNT              ENCD-32
         SVC       1,X'3C'         M.WAIT                       ENCD-32
W.TG21.1 EQU       $                                            ENCD-32
         SBM       IOACT,FCB.GLF,X1   SHOW I/O ACTIVE THIS FILE ENCD-32
         LW        R5,FCB.BAS,X1   GET CURRENT BLOCK START      ENCD-32
         STW       R5,FCB.BADR,X1 INTO FCB BUFFER ADR WORD      ENCD-32
W.TG21.0 SVC       1,X'32'         WRITE OUT THIS BLOCK         ENCD-32
         TBM       7,FCB.STAT,X1   DID WE GET EOM               ENCD-32
         BNS       W.TG21.2                                     ENCD-32
         BL        TMPLINK         CHAIN TO NEW TEMP FILE       ENCD-32
         BU        W.TG21.0        REISSUE WRITE                ENCD-32
W.TG21.2 EQU       $                                            ENCD-32
         ABM       31,FCB.OCNT,X1  BUMP OP COUNT                ENCD-32
         LW        R4,FCB.B1S,X1   GET START ADR OF BLOCK 1     ENCD-32
         STW       R4,FCB.BAS,X1                                ENCD-32
         STW       R4,FCB.BANS,X1  STORE AS END OF SECT BOUNDRY ENCD-32
         SUI       R4,768          DECREMENT BY 1 SECTOR        ENCD-32
         STW       R4,FCB.BAP,X1   STORE AS START SECT BOUNDRY  ENCD-32
         LW        R4,FCB.B1E,X1   GET BLOCK 1 END              ENCD-32
         STW       R4,FCB.BAE,X1   AS ACTIVE BLOCK END          ENCD-32
         SBM       SECTOR,FCB.BAF,X1  SHOW CUR.BLK ON SECT BOUNDENCD-32
         ZBM       CURBLK,FCB.GLF,X1   SHOW BLOCK 1 AS CURRENT  ENCD-32
         BU        W.USEIT                                      ENCD-32
*-----------------------------------------------------------------------
W.REPORT EQU       $                                            ENCD-32
         LW        R5,FCB.STAT,X1 GET I/O STATUS                ENCD-32
         STW       R5,FCB.STAT,X2  PUT IN USER FCB              ENCD-32
         LF        R0,FILE                                      ENCD-32
         TRSW      R0              RETURN TO USER               ENCD-32
         NOP                                                    ENCD-32
*-----------------------------------------------------------------------
*                                                               ENCD-32
*        TMPLINK                                                ENCD-32
*                                                               ENCD-32
*        THIS ROUTINE CHECKS FOR THE AVAILABILITY OF ANOTHER    ENCD-32
*        TEMP FILE AND, IF THERE IS ONE FREE, SETS IT UP TO     ENCD-32
*        RECEIVE ALL SUBSEQUENT WRITES TO THE TEMP OBJECT FILE  ENCD-32
*                                                               ENCD-32
***********************************************************************
*                                                               ENCD-32
TMPLINK  STF       R0,LINKSAV      SAVE REGISTERS               ENCD-32
         SVC       1,X'37'         REWIND CURRENT TEMP FILE     ENCD-32
         LW        R4,TMPCNT       GET TEMP COUNT               ENCD-32
         CAMW      R4,MAXTEMP      COMPARE TO MAX ALLOWABLE     ENCD-32
         BGE       TMPERR          NO MORE                      ENCD-32
         ADI       R4,1            BUMP TEMP COUNT              ENCD-32
         STW       R4,TMPCNT       SAVE IT                      ENCD-32
         M.CONBAD  TMPCNT          CONVERT TO ASCII             ENCD-32
         SLL       R7,16           SET UP TO MAKE LFC           ENCD-32
         SRL       R7,16                                        ENCD-32
         LW        R4,=X'FFFF0000'                              ENCD-32
         LMW       R6,TMPLFC       GET TEMP LFC                 ENCD-32
         ORR       R7,R6           MAKE NEW LFC                 ENCD-32
         STW       R6,TMPLFC       SAVE IT                      ENCD-32
         STW       R6,XTEMP        IN TEMP FCB                  ENCD-32
         LW        R3,XTEMP+FCB.FAT  GET ADDR OF EXPANDED FCB   ENCD-32
         STW       R6,0,R3         STORE LFC THERE              ENCD-32
         ZMW       FCB.FAT,X3      ZERO FAT ADDR                ENCD-32
         LA        R1,XTEMP        ADDR OF TEMP FCB             ENCD-32
         LW        R5,TMPSIZE      GET CREATE SIZE              ENCD-32
         SBR       R5,0            SIGNAL TEMP CREATE           ENCD-32
         LI        R6,16           ALLOW 16 SEGMENTS            ENCD-32
         BL        XCRETMP         CREATE TEMP FILE             ENCD-32
         LF        R0,LINKSAV      RESTORE REGISTERS            ENCD-32
         TRSW      R0                                           ENCD-32
*                                                               ENCD-32
LINKSAV  REZ       1F                                           ENCD-32
*-------                                                        ENCD-32
         PAGE                                                   ENCD-32
         TITLE     BB.RWND
************************************************************************
*
*        BB.RWND - THE FILE ASSIGNED TO THE FCB ADDRESS         ENCD-32
*                  SUPPLIED IN R1 IS REWOUND                    ENCD-32
*
************************************************************************
*                                                               ENCD-32
BB.RWND  EQU       $                                            ENCD-32
         STF       R0,FILE         SAVE USER CONTEXT            ENCD-32
         LW        R2,FCB.FAT,X1   GET ADDR OF EXP FCB IN R2    ENCD-32
         XCR       R1,R2           AND EXCHANGE                 ENCD-32
*                                                               ENCD-32
*        R1=ADR OF SUPER (LOCAL) FCB                            ENCD-32
*        R2=ADR OF USER'S FCB                                   ENCD-32
*                                                               ENCD-32
         TBM       0,FCB.SFLG,X1   IS FCB STILL BUSY            C018-32
         BNS       $+2W            SKIP WAIT IF NOT             C018-32
         SVC       1,X'3C'         WAIT FOR I/O COMPLETE        C018-32
         TBM       LASTOP,FCB.GLF,X1 WAS LAST OP A READ OR WRIT ENCD-32
         BNS       RWND.XIT                                     ENCD-32
         BL        PURGE           WRITE OUT LAST BLOCK         ENCD-32
*--------                                                       ENCD-32
RWND.XIT EQU       $                                            ENCD-32
         SVC       1,X'37'         REWIND PHYSICAL FILE         ENCD-32
         BL        RESET                                        ENCD-32
         LF        R0,FILE                                      ENCD-32
         TRSW      R0              RETURN TO USER               ENCD-32
         NOP                                                    ENCD-32
*=======================================================================
         PAGE                                                   ENCD-32
PURGE    EQU       $                                            ENCD-32
         STF       R0,SB1.FILE                                  ENCD-32
         LW        R3,FCB.BAP,X1   GET CURRENT SECT START PNTR  ENCD-32
         TRR       R3,R6           SAVE FOR LATER               ENCD-32
         LW        R4,0W,X3        GET WRITE POS IN CURR SECTOR ENCD-32
         TRR       R4,R7           SAVE FOR LATER               ENCD-32
         ADR       R3,R4           MAKE IT BLOCK RELATIVE       ENCD-32
         TRR       R4,R3           MAKE R3 THE SAME             ENCD-32
         SUMW      R4,FCB.BANS,X1  SUBTRACT END OF SECTOR ADDR  ENCD-32
         ZR        R5                                           ENCD-32
PRG.1    EQU       $                                            ENCD-32
         STB       R5,0B,X3                                     ENCD-32
         ABR       R3,31                                        ENCD-32
         BIB       R4,PRG.1        ZERO OUT BALANCE OF SECTOR   ENCD-32
         TRR       R7,R3           RECOVER CURRENT WRITE ADR    ENCD-32
         ADR       R6,R3           MAKE IT BLOCK RELATIVE       ENCD-32
         LI        R5,X'80'                                     ENCD-32
         STB       R5,0B,X3        PUT LOGICAL EOF IN BLOCK     ENCD-32
         LI        R5,X'A0'                                     ENCD-32
         STB       R5,2B,X3        AND AGAIN JUST IN CASE       ENCD-32
         TRR       R6,R3           RECOVER SECTOR START POINTER ENCD-32
         LW        R5,0W,X3        PICK UP PIONTER              ENCD-32
         ADI       R5,2            BUMP PAST EOF MARK           ENCD-32
         STW       R5,0W,X3        PUT BACK                     ENCD-32
*                                                               ENCD-32
         LW        R5,FCB.BANS,X1  GET END OF SECTOR ADR        ENCD-32
         SUMW      R5,FCB.BAS,X1   SUBTRACT STRART OF BLOCK     ENCD-32
         STW       R5,FCB.BSZ,X1   PUT XFER COUNT INTO FCB      ENCD-32
         LW        R5,FCB.BAS,X1   GET START OF BLOCK           ENCD-32
         STW       R5,FCB.BADR,X1  INTO FCB                     ENCD-32
         ZBM       NWT,FCB.OPTS,X1 INHIBIT NO WAIT              ENCD-32
PRG.2    SVC       1,X'32'         WRITE OUT LAST BLOCK         PR10705
         TBM       7,FCB.STAT,X1   DID WE GET EOM?              PR10705
         BNS       PRG.3           CONTINUE IF NOT              PR10705
         BL        TMPLINK         GET NEW TEMP FILE            PR10705
         BU        PRG.2           RE-ISSUE WRITE               PR10705
PRG.3    SVC       1,X'38'                                      PR10705
         LF        R0,SB1.FILE                                  ENCD-32
         TRSW      R0              RETURN TO CALLER             ENCD-32
         NOP                       OUT OF PATH                  ENCD-32
*=======================================================================
RESET    EQU       $                                            ENCD-32
         ZBM       NWT,FCB.OPTS,X1 RESET NO-WAIT I/O MODE       ENCD-32
         ZMW       FCB.STAT,X1     CLEAR I/O STATUS             ENCD-32
         ZMW       FCB.GLF,X1      CLEAR ALL FILE CONTROL FLAGS ENCD-32
         ZMW       FCB.B1F,X1      ZERO BLOCK 1 FLAGS           ENCD-32
         SBM       EMPTY,FCB.B1F,X1 AND SHOW EMPTY              ENCD-32
         ZMW       FCB.B2F,X1      ZERO BLOCK 2 FLAGS           ENCD-32
         SBM       EMPTY,FCB.B2F,X1 AND SHOW EMPTY              ENCD-32
         ZMW       FCB.STAT,X2     CLEAR USER FCB STATUS        ENCD-32
         LI        R4,BLK.SIZE                                  ENCD-32
         STW       R4,FCB.BSZ,X1   MAKE SURE BLOCK SIZE IS OK   ENCD-32
         TRSW      R0                                           ENCD-32
         NOP                                                    ENCD-32
*=======================================================================
         LPOOL                     DUMP LITERAL POOL
         BOUND     1D
MPFSTTAG END       CATSTART
@
