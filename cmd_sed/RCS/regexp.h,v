head	1.4;
access;
symbols;
locks; strict;
comment	@ * @;


1.4
date	2021.09.13.21.48.53;	author jbev;	state Exp;
branches;
next	1.3;

1.3
date	2021.07.05.23.30.42;	author jbev;	state Exp;
branches;
next	1.2;

1.2
date	95.03.14.04.07.23;	author jbev;	state Exp;
branches;
next	1.1;

1.1
date	95.03.14.01.55.01;	author jbev;	state Exp;
branches;
next	;


desc
@Initial file checkin.
@


1.4
log
@Correct warning errors.
@
text
@/*~!regexp.h*/
/* Name:  regexp.h Part No.: _______-____r
 *
 * Copyright 1995 - J B Systems, Morrison, CO
 *
 * The recipient of this product specifically agrees not to distribute,
 * disclose, or disseminate in any way, to any one, nor use for its own
 * benefit, or the benefit of others, any information contained  herein
 * without the expressed written consent of J B Systems.
 *
 *                     RESTRICTED RIGHTS LEGEND
 *
 * Use, duplication, or disclosure by the Government is  subject  to
 * restriction  as  set forth in paragraph (b) (3) (B) of the Rights
 * in Technical Data and Computer Software  Clause  in  DAR  7-104.9
 * (a).
 */

#ident	"Makef4MPX $Id: regexp.h,v 1.3 2021/07/05 23:30:42 jbev Exp jbev $"

/*
 * $Log: regexp.h,v $
 * Revision 1.3  2021/07/05 23:30:42  jbev
 * Correct warnings.
 *
 * Revision 1.2  1995/03/14 04:07:23  jbev
 * Correct static definitions.
 *
 * Revision 1.1  1995/03/14  01:55:01  jbev
 * Initial revision
 *
 */

#ifndef	REGEXP_H
#define	REGEXP_H

#include <string.h>

#define	CBRA	2
#define	CCHR	4
#define	CDOT	8
#define	CCL	12
#define	CDOL	20
#define	CCEOF	22
#define	CKET	24
#define	CBACK	36

#define	STAR	01
#define RNGE	03

#define	NBRA	9

#define PLACE(c)	ep[c >> 3] |= bittab[c & 07]
#define ISTHERE(c)	(ep[c >> 3] & bittab[c & 07])
#define ecmp(s1, s2, n)	(!strncmp(s1, s2, n))

int step();
int advance();
static void getrnge();

static char *braslist[NBRA];
static char *braelist[NBRA];
static int ebra;
int sed, nbra;
char *loc1, *loc2, *locs;
static int nodelim;

int circf;
static int low;
static int size;

static char bittab[] = { 
    1, 2, 4, 8, 16, 32, 64, 128 };


char *
compile(instring, ep, endbuf, seof)
register char *ep;
char *instring, *endbuf;
int seof;
{
    INIT	/* Dependent declarations and initializations */
    register int c;
    register int eof = seof;
    char *lastep = instring;
    int cclcnt;
    char bracket[NBRA], *bracketp;
    int closed;
    int neg;
    int lc;
    int i, cflg;

    lastep = 0;
    if ((c = GETC()) == eof || c == '\n') {
    	if (c == '\n') {
    	    UNGETC(c);
    	    nodelim = 1;
    	}
    	if (*ep == 0 && !sed)
    	    ERROR(41);
    	RETURN(ep);
    }
    bracketp = bracket;
    circf = closed = nbra = ebra = 0;
    if (c == '^')
    	circf++;
    else
    	UNGETC(c);
    while (1) {
    	if (ep >= endbuf)
    	    ERROR(50);
    	c = GETC();
    	if (c != '*' && ((c != '\\') || (PEEKC() != '{')))
    	    lastep = ep;
    	if (c == eof) {
    	    *ep++ = CCEOF;
    	    RETURN(ep);
    	}
    	switch (c) {

    	case '.':
    	    *ep++ = CDOT;
    	    continue;

    	case '\n':
    	    if (!sed) {
    	    	UNGETC(c);
    	    	*ep++ = CCEOF;
    	    	nodelim = 1;
    	    	RETURN(ep);
    	    } else 
    	    	ERROR(36);
    	case '*':
    	    if (lastep == 0 || *lastep == CBRA || *lastep == CKET)
    	    	goto defchar;
    	    *lastep |= STAR;
    	    continue;

    	case '$':
    	    if (PEEKC() != eof && PEEKC() != '\n')
    	    	goto defchar;
    	    *ep++ = CDOL;
    	    continue;

    	case '[':
    	    if (&ep[17] >= endbuf)
    	    	ERROR(50);

    	    *ep++ = CCL;
    	    lc = 0;
    	    for (i = 0; i < 16; i++)
    	    	ep[i] = 0;

    	    neg = 0;
    	    if ((c = GETC()) == '^') {
    	    	neg = 1;
    	    	c = GETC();
    	    }

    	    do {
    	    	if (c == '\0' || c == '\n')
    	    	    ERROR(49);
    	    	if (c == '-' && lc != 0) {
    	    	    if ((c = GETC()) == ']') {
    	    	    	PLACE('-');
    	    	    	break;
    	    	    }
    	    	    while (lc < c) {
    	    	    	PLACE(lc);
    	    	    	lc++;
    	    	    }
    	    	}
    	    	lc = c;
    	    	PLACE(c);
    	    } while ((c = GETC()) != ']');
    	    if (neg) {
    	    	for (cclcnt = 0; cclcnt < 16; cclcnt++)
    	    	    ep[cclcnt] ^= -1;
    	    	ep[0] &= 0376;
    	    }

    	    ep += 16;

    	    continue;

    	case '\\':
    	    switch (c = GETC()) {

    	    case '(':
    	    	if (nbra >= NBRA)
    	    	    ERROR(43);
    	    	*bracketp++ = nbra;
    	    	*ep++ = CBRA;
    	    	*ep++ = nbra++;
    	    	continue;

    	    case ')':
    	    	if (bracketp <= bracket || ++ebra != nbra)
    	    	    ERROR(42);
    	    	*ep++ = CKET;
    	    	*ep++ = *--bracketp;
    	    	closed++;
    	    	continue;

    	    case '{':
    	    	if (lastep == (char *) 0)
    	    	    goto defchar;
    	    	*lastep |= RNGE;
    	    	cflg = 0;
nlim:
    	    	c = GETC();
    	    	i = 0;
    	    	do {
    	    	    if ('0' <= c && c <= '9')
    	    	    	i = 10 * i + c - '0';
    	    	    else
    	    	    	ERROR(16);
    	    	} while (((c = GETC()) != '\\') && (c != ','));
    	    	if (i > 255)
    	    	    ERROR(11);
    	    	*ep++ = i;
    	    	if (c == ',') {
    	    	    if (cflg++)
    	    	    	ERROR(44);
    	    	    if ((c = GETC()) == '\\')
    	    	    	*ep++ = 255;
    	    	    else {
    	    	    	UNGETC(c);
    	    	    	goto nlim;
    	    	    	/* get 2'nd number */
    	    	    }
    	    	}
    	    	if (GETC() != '}')
    	    	    ERROR(45);
    	    	if (!cflg)	/* one number */
    	    	    *ep++ = i;
    	    	else if ((ep[-1] & 0377) < (ep[-2] & 0377))
    	    	    ERROR(46);
    	    	continue;

    	    case '\n':
    	    	ERROR(36);

    	    case 'n':
    	    	c = '\n';
    	    	goto defchar;

    	    default:
    	    	if (c >= '1' && c <= '9') {
    	    	    if ((c -= '1') >= closed)
    	    	    	ERROR(25);
    	    	    *ep++ = CBACK;
    	    	    *ep++ = c;
    	    	    continue;
    	    	}
    	    }
    	    /* Drop through to default to use \ to turn off special chars */

defchar:
    	default:
    	    lastep = ep;
    	    *ep++ = CCHR;
    	    *ep++ = c;
    	}
    }
    /*NOTREACHED*/
}


int step(p1, p2)
register char *p1, *p2;
{
    register int c;

    if (circf) {
    	loc1 = p1;
    	return(advance(p1, p2));
    }
    /* fast check for first character */
    if (*p2 == CCHR) {
    	c = p2[1];
    	do {
    	    if (*p1 != c)
    	    	continue;
    	    if (advance(p1, p2)) {
    	    	loc1 = p1;
    	    	return(1);
    	    }
    	} while (*p1++);
    	return(0);
    }
    /* regular algorithm */
    do {
    	if (advance(p1, p2)) {
    	    loc1 = p1;
    	    return(1);
    	}
    } while (*p1++);
    return(0);
}


int advance(lp, ep)
register char *lp, *ep;
{
    register char *curlp;
    int c;
    char *bbeg;
    int ct;

    while (1) {
    	switch (*ep++) {

    	case CCHR:
    	    if (*ep++ == *lp++)
    	    	continue;
    	    return(0);

    	case CDOT:
    	    if (*lp++)
    	    	continue;
    	    return(0);

    	case CDOL:
    	    if (*lp == 0)
    	    	continue;
    	    return(0);

    	case CCEOF:
    	    loc2 = lp;
    	    return(1);

    	case CCL:
    	    c = *lp++ & 0177;
    	    if (ISTHERE(c)) {
    	    	ep += 16;
    	    	continue;
    	    }
    	    return(0);
    	case CBRA:
    	    braslist[(int)*ep++] = lp;
    	    continue;

    	case CKET:
    	    braelist[(int)*ep++] = lp;
    	    continue;

    	case CCHR | RNGE:
    	    c = *ep++;
    	    getrnge(ep);
    	    while (low--)
    	    	if (*lp++ != c)
    	    	    return(0);
    	    curlp = lp;
    	    while (size--)
    	    	if (*lp++ != c)
    	    	    break;
    	    if (size < 0)
    	    	lp++;
    	    ep += 2;
    	    goto star;

    	case CDOT | RNGE:
    	    getrnge(ep);
    	    while (low--)
    	    	if (*lp++ == '\0')
    	    	    return(0);
    	    curlp = lp;
    	    while (size--)
    	    	if (*lp++ == '\0')
    	    	    break;
    	    if (size < 0)
    	    	lp++;
    	    ep += 2;
    	    goto star;

    	case CCL | RNGE:
    	    getrnge(ep + 16);
    	    while (low--) {
    	    	c = *lp++ & 0177;
    	    	if (!ISTHERE(c))
    	    	    return(0);
    	    }
    	    curlp = lp;
    	    while (size--) {
    	    	c = *lp++ & 0177;
    	    	if (!ISTHERE(c))
    	    	    break;
    	    }
    	    if (size < 0)
    	    	lp++;
    	    ep += 18;		/* 16 + 2 */
    	    goto star;

    	case CBACK:
    	    bbeg = braslist[(int)*ep];
    	    ct = braelist[(int)*ep++] - bbeg;

    	    if (ecmp(bbeg, lp, ct)) {
    	    	lp += ct;
    	    	continue;
    	    }
    	    return(0);

    	case CBACK | STAR:
    	    bbeg = braslist[(int)*ep];
    	    ct = braelist[(int)*ep++] - bbeg;
    	    curlp = lp;
    	    while (ecmp(bbeg, lp, ct))
    	    	lp += ct;

    	    while (lp >= curlp) {
    	    	if (advance(lp, ep))	
    	    	    return(1);
    	    	lp -= ct;
    	    }
    	    return(0);


    	case CDOT | STAR:
    	    curlp = lp;
    	    while (*lp++)
    	    	;
    	    goto star;

    	case CCHR | STAR:
    	    curlp = lp;
    	    while (*lp++ == *ep)
    	    	;
    	    ep++;
    	    goto star;

    	case CCL | STAR:
    	    curlp = lp;
    	    do {
    	    	c = *lp++ & 0177;
    	    } while (ISTHERE(c));
    	    ep += 16;
    	    goto star;

star:
    	    do {
    	    	if (--lp == locs)
    	    	    break;
    	    	if (advance(lp, ep))
    	    	    return(1);
    	    } while (lp > curlp);
    	    return(0);

    	}
    }
    /*NOTREACHED*/
}


static void getrnge(str)
register unsigned char *str;
{
    low = *str++ & 0377;
    size = (*str == 255) ? 20000 : (*str & 0377) - low;
}

#endif	/* REGEXP_H */
@


1.3
log
@Correct warnings.
@
text
@d19 1
a19 1
#ident	"Makef4MPX $Id: regexp.h,v 1.2 1995/03/14 04:07:23 jbev Exp jbev $"
d23 3
d37 2
d57 4
a66 1
static int getrnge();
d80 1
d83 2
a84 2
    register c;
    register eof = seof;
d270 1
a270 1
step(p1, p2)
d273 1
a273 1
    register c;
d303 1
a303 1
advance(lp, ep)
d341 1
a341 1
    	    braslist[*ep++] = lp;
d345 1
a345 1
    	    braelist[*ep++] = lp;
d396 2
a397 2
    	    bbeg = braslist[*ep];
    	    ct = braelist[*ep++] - bbeg;
d406 2
a407 2
    	    bbeg = braslist[*ep];
    	    ct = braelist[*ep++] - bbeg;
d456 1
a456 2
static
getrnge(str)
@


1.2
log
@Correct static definitions.
@
text
@d19 1
a19 1
#ident	"Makef4MPX $Id: regexp.h,v 1.1 1995/03/14 01:55:01 jbev Exp jbev $"
d21 5
a25 1
/* $Log: regexp.h,v $
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
#ident	"Makef4MPX $Id$"
d21 4
a24 1
/* $Log: $
d54 1
d445 1
a445 1
register char *str;
@
